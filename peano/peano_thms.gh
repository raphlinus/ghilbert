# Building up theorems of peano arithmetic.

import (PROP prop.ghi () "")
import (PEANO_MIN peano_min.ghi (PROP) "")

tvar (wff ph ps ch th ta)
tvar (nat A B C D A' B' C' D')
var (nat v w x y z v' w' x' y' z')

# == Logic ==

# A true statement can be removed from a conjunction. Similar to a1bi.
thm (anTrue () (hyp ps) (<-> (/\ ps ph) ph)
  hyp
  ps ph pm3.2
  ax-mp
  ps ph pm3.27
  impbii
  bicomi
)

# == Pure predicate calculus ==

thm (a4i ()
  (hyp (A. x ph))
  ph
  hyp x ph ax-4 ax-mp
)

## <table>
##   (-> (A. x [ (-> ph ps) ] ) ps)
##             [ (-> ph ps) ]
## </table>
thm (mpg ()
  (hyp1 (-> (A. x ph) ps)
   hyp2 ph)
  ps
  hyp2
  ## <d>
    x gen
  ## </d>
  hyp1 ax-mp
)

thm (19.3 ((ph x))
  ()
  (<-> (A. x ph) ph)
  x ph ax-4 ph x alnfi impbii
)

# Reverse the hypothesis and conclusion of con4bii.
## <title> Equivalence over Negation </title>
thm (con4biir ()
  (hyp (<-> ph ps))
  (<-> (-. ph) (-. ps))
  hyp ph ps notbi
  mpbi
)

# Reorder sylbi a bit.
## <title> Syllogism </title>
thm (sylbi2()
  (hyp1 (-> ps ch)
   hyp2 (<-> ps ph))
  (-> ph ch)
  hyp2 bicomi hyp1 sylbi
)

# Commute the conclusion of bitr3i.
## <title> Transitive Property </title>
thm (bitr3icom()
  (hyp1 (<-> ps ph)
   hyp2 (<-> ps ch))
  (<-> ch ph)
  hyp1 hyp2 bitr3i bicomi
)

## <title> Equivalence over Disjunction </title>
## <table>
##   (\/      ph ] ] ps)
##       (<-> ph ] [ ch)
##   (\/         [ [ ch ps)
## </table>
thm (orbi1ii ()
  (hyp1 (\/ ph ps)
   hyp2 (<-> ph ch))
  (\/ ch ps)
  hyp1 hyp2 ps orbi1i mpbi
)

## <title> Equivalence over Disjunction </title>
thm (orbi2ii ()
  (hyp1 (\/ ph ps)
   hyp2 (<-> ps ch))
  (\/ ph ch)
  hyp1 hyp2 ph orbi2i mpbi
)

## <title> Equivalence over Conjunction </title>
thm (anbi1ii ()
  (hyp1 (/\ ph ps)
   hyp2 (<-> ph ch))
  (/\ ch ps)
  hyp1 hyp2 ps anbi1i mpbi
)

## <title> Equivalence over Conjunction </title>
thm (anbi2ii ()
  (hyp1 (/\ ph ps)
   hyp2 (<-> ps ch))
  (/\ ph ch)
  hyp1 hyp2 ph anbi2i mpbi
)

defthm (df-ex wff (E. x ph) () () (<-> (E. x ph) (-. (A. x (-. ph))))
     (-. (A. x (-. ph))) biid)

# aka 19.7
thm (alnex () ()
  (<-> (A. x (-. ph)) (-. (E. x ph)))
  x ph df-ex con2bii
)

thm (19.8a () ()
  (-> ph (E. x ph))
  x (-. ph) ax-4 con2i
  x ph df-ex sylibr
)

thm (19.8ai () (hyp ph) (E. x ph) hyp ph x 19.8a ax-mp )

thm (19.2 () ()
  (-> (A. x ph) (E. x ph))
  x ph ax-4 ph x 19.8a syl
)

thm (19.9 ((ph x))
  ()
  (<-> (E. x ph) ph)

  x (-. ph) 19.3
  x ph alnex bitr3i con4bii bicomi
)

thm (19.9d ((ps x)) (h (-> ph (E. x ps)))
  (-> ph ps)
  h
  x ps 19.9
  sylib
)

thm (19.15 () ()
  (-> (A. x (<-> ph ps)) (<-> (A. x ph) (A. x ps)))

  ph ps bi1 x gen
  x (<-> ph ps) (-> ph ps) ax-alim ax-mp
  x ph ps ax-alim syl

    ph ps bi2 x gen
    x (<-> ph ps) (-> ps ph) ax-alim ax-mp
    x ps ph ax-alim syl
  impbid
)

thm (19.15i ()
  (hyp (A. x (<-> ph ps)))
  (<-> (A. x ph) (A. x ps))
  hyp x ph ps 19.15 ax-mp)

thm (19.15d () (H1 (-> ph (A. x (<-> ps ch))))
      (-> ph (<-> (A. x ps) (A. x ch)))
     H1 x ps ch 19.15 syl)

## <title> Equivalence over Quantification </title>
thm (albii ()
  (hyp (<-> ph ps))
  (<-> (A. x ph) (A. x ps))
  hyp x gen 19.15i)
	
## <title> Equivalence over Quantification </title>
thm (albiii ()
  (hyp1 (A. x ph)
   hyp2 (<-> ph ps))
  (A. x ps)
  hyp1 hyp2 x albii mpbi
)

# aka 19.6
thm (alex () ()
  (<-> (A. x ph) (-. (E. x (-. ph))))
  ph notnot x albii
  x (-. ph) df-ex con2bii bitri
)

thm (19.20i ()
  (hyp (-> ph ps))
  (-> (A. x ph) (A. x ps))
  x ph ps ax-alim hyp mpg
)

thm (19.21 ((ph x))
  ()
  (<-> (A. x (-> ph ps)) (-> ph (A. x ps)))

  x ph ps ax-alim ph x alnfi syl5
    (-> ph (A. x ps)) x alnfi
      x ps ax-4
      ph imim2i
      x 19.20i
    syl
  impbii
)

thm (19.21ai ((ph x))
  (hyp (-> ph ps))
  (-> ph (A. x ps))
  ph x alnfi hyp x 19.20i syl
)

thm (19.5 () ()
  (<-> (A. x (A. y ph)) (A. y (A. x ph)))
  x (A. y ph) ax-4 y ph ax-4 syl x 19.21ai y 19.21ai
    y (A. x ph) ax-4 x ph ax-4 syl y 19.21ai x 19.21ai
  impbii
)

thm (19.22 () ()
  (-> (A. x (-> ph ps)) (-> (E. x ph) (E. x ps)))

  ph ps con34b x albii
    x (-. ps) (-. ph) ax-alim sylbi con3d
    x ph df-ex x ps df-ex imbi12i sylibr
)

## <table>
##   (->       [ ph ]        [ ps ] )
##   (-> (E. x [ ph ]) (E. x [ ps ] ))
## </table>
thm (19.22i ()
  (hyp (-> ph ps))
  (-> (E. x ph) (E. x ps))
  x ph ps 19.22 hyp mpg
)

thm (19.22d ((ph x))
  (hyp (-> ph (-> ps ch)))
  (-> ph (-> (E. x ps) (E. x ch)))
  hyp x 19.21ai x ps ch 19.22 syl
)

thm (19.18 () ()
  (-> (A. x (<-> ph ps)) (<-> (E. x ph) (E. x ps)))
  ph ps bi1 x 19.20i x ph ps 19.22 syl
    ph ps bi2 x 19.20i x ps ph 19.22 syl
  impbid
)

## <title> Equivalence over Quantification </title>
thm (exbii ()
  (hyp (<-> ph ps))
  (<-> (E. x ph) (E. x ps))
  x ph ps 19.18 hyp mpg
)

## <title> Equivalence over Quantification </title>
thm (exbiii ()
  (hyp1 (E. x ph)
   hyp2 (<-> ph ps))
  (E. x ps)
  hyp1 hyp2 x exbii mpbi
)

thm (exbid ((ph x))
  (hyp (-> ph (<-> ps ch)))
  (-> ph (<-> (E. x ps) (E. x ch)))
  hyp x 19.21ai x ps ch 19.18 syl
)

thm (19.26 () ()
  (<-> (A. x (/\ ph ps)) (/\ (A. x ph) (A. x ps)))
  ph ps pm3.26 x 19.20i
    ph ps pm3.27 x 19.20i
  jca
    ph ps pm3.2 x 19.20i x ps  (/\ ph ps) ax-alim syl
    imp
  impbii
)

# 19.26 with reversed
thm (alan12 () () (-> (/\ (A. x ph) (A. x ps)) (A. x (/\ ph ps)))
  x ph ps 19.26 biimpri
)

thm (19.29 () ()
  (-> (/\ (A. x ph) (E. x ps)) (E. x (/\ ph ps)))
  x ph (-. ps) ax-alim
    x ps alnex
  syl6ib
  con3i
    (A. x ph) (E. x ps) df-an
      x (-> ph (-. ps)) alex con2bii
  3imtr4i
    ph ps df-an x exbii
  sylibr
)

thm (19.29r () ()
  (-> (/\ (E. x ph) (A. x ps)) (E. x (/\ ph ps)))
  x ps ph 19.29 ancoms ps ph ancom x exbii sylib
)

thm (19.32 ((ph x))
  ()
  (<-> (A. x (\/ ph ps)) (\/ ph (A. x ps)))

  x (-. ph) ps 19.21
    ph ps df-or x albii
      ph (A. x ps) df-or
  3bitr4i
)

thm (19.31 ((ps x))
  ()
  (<-> (A. x (\/ ph ps)) (\/ (A. x ph) ps))

  x ps ph 19.32
  ph ps orcom x albii
  (A. x ph) ps orcom
  3bitr4i
)

thm (19.23 ((ps x))
  ()
  (<-> (A. x (-> ph ps)) (-> (E. x ph) ps))

  ph ps imor x albii
  x (-. ph) ps 19.31 bitri
  x ph alnex ps orbi1i bitri
  (E. x ph) ps imor bitr4i
)

thm (19.23ai ((ps x))
  (hyp (-> ph ps))
  (-> (E. x ph) ps)
  hyp x 19.22i
  x ps 19.9 sylib
)

thm (19.41 ((ps x)) ()
  (<-> (E. x (/\ ph ps)) (/\ (E. x ph) ps))
  x (/\ ph ps) df-ex
    x (-. ph) (-. ps) 19.31
      ph ps ianor x albii
        (E. x ph) ps ianor x ph alnex (-. ps) orbi1i bitr4i
    3bitr4i con2bii
  bitr4i
)

thm (19.41l ((ph x)) ()
  (<-> (E. x (/\ ph ps)) (/\ ph (E. x ps)))
  ph  ps  ancom    x  exbii
  x  ps  ph  19.41    bitri
  (E. x ps)  ph  ancom    bitri
)

thm (19.41r ((ph x)) ()
  (<-> (E. x (/\ ph ps)) (/\ ph (E. x ps)))
  ph  ps  ancom    x  exbii
  x  ps  ph  19.41    bitri
  (E. x ps)  ph  ancom    bitri
)

thm (albiim () ()
  (<-> (A. x (<-> ph ps)) (/\ (A. x (-> ph ps)) (A. x (-> ps ph))))
  ph ps dfbi2 x albii
  x (-> ph ps) (-> ps ph) 19.26 bitri
)

# 19.28
thm (alan1 ((ph x)) () (<-> (A. x (/\ ph ps)) (/\ ph (A. x ps)))
  x ph ps 19.26
    x ph 19.3 (A. x ps) anbi1i
  bitri
)

# 19.27
thm (alan2 ((ps x)) () (<-> (A. x (/\ ph ps)) (/\ (A. x ph) ps))
  ph  ps  ancom     x  albii    x  ps  ph  alan1  bitri
  ps  (A. x ph)  ancom    bitri
)

thm (exor2 ((ps x)) () (<-> (E. x (\/ ph ps)) (\/ (E. x ph) ps))
x  (\/ ph ps)  df-ex
  ph  ps  ioran    x  albii  notbii
    x (-. ph)  (-. ps)  alan2  notbii
  bitri
  (A. x (-. ph))  ps  pm4.53    bitri
bitri
x  ph  df-ex    ps  orbi1i  bitr4i
)

thm (aaan ((ph y) (ps x)) ()
  (<-> (A. x (A. y (/\ ph ps))) (/\ (A. x ph) (A. y ps)))
  y ph ps alan1 x albii
  x ph (A. y ps) alan2 bitri
)

thm (ex6 () () (-> (E. x ph) (A. x (E. x ph)))
     x ph df-ex
       x (-. ph) ax-6
     sylbi
       x ph df-ex x albii
     sylibr)

thm (axex () () (<-> (A. x (E. x ph)) (E. x ph))
     x (E. x ph) ax-4
     x ph ex6
     impbii)

thm (exax1 () () (-> (E. x (A. x ph)) (A. x ph))
     x (A. x ph) df-ex
       x ph ax-6 con1i
     sylbi)

thm (exax () () (<-> (E. x (A. x ph)) (A. x ph))
     x ph exax1
     (A. x ph) x 19.8a
     impbii)

thm (exax1d () (1 (-> ph (E. x (A. x ps)))) (-> ph (A. x ps))
     1 x ps exax1 syl)

thm (eximp1 () () (-> (E. x (-> ph ps)) (-> (A. x ph) (E. x ps)))
     ph ps pm2.27 x 19.20i
       x (-> ph ps) ps 19.22
     syl com12)

thm (eximp1d () (1 (-> ph (E. x (-> ps ch)))) (-> ph (-> (A. x ps) (E. x ch)))
     1 x ps ch eximp1 syl)

thm (mpexax () () (-> (E. x ph) (-> (A. x (-> ph ps)) (E. x ps)))
     ph ps pm2.27 x 19.22i eximp1d
     )

thm (mpexaxp () () (-> (E. x ph) (-> (A. x (-> ph ps)) (E. x (/\ ph ps))))
     x ph (/\ ph ps) mpexax
       ph ps ancl x 19.20i
     syl5
     )

# Commutativity of existential operators
thm (excom () () (<-> (E. x (E. y ph)) (E. y (E. x ph)))
  y  ph  df-ex  x  exbii
  x  (-. (A. y (-. ph)))  df-ex  bitri
  (A. y (-. ph)) notnot  x  albii  notbii  bitr4i
  x  y  (-. ph)  ax-7  y  x  (-. ph)  ax-7  impbii  notbii  bitri

    x  ph  df-ex  y  exbii
    y  (-. (A. x (-. ph)))  df-ex  bitri
    (A. x (-. ph)) notnot  y  albii  notbii  bitr4i
  bitr4i
)

# A variant of 19.37
thm (imex ((ph x)) () (<-> (-> ph (E. x ps)) (E. x (-> ph ps)))
   ph  (E. x ps)  imor    (-. ph) (E. x ps) orcom  bitri

   x  ps  (-. ph)  exor2   bitr4i
  ph  ps   imor  (-. ph)  ps  orcom  bitri x  exbii  bitr4i
)

# == Predicate calculus with equality ==

thm (tyex ((A x)) ()
  (E. x (= x A))
  x A ax-tyex
  x (= x A) df-ex mpbir
)

thm (vtocle ((A x) (ph x))
  (hyp (-> (= x A) ph))
  ph

  x A tyex hyp x 19.23ai ax-mp
)

## <title> Reflexive Property </title>
thm (eqid () ()
  (= A A)
  x A A ax-eqtr anidms vtocle
)

## <title> Symmetric Property </title>
thm (eqcom () ()
  (<-> (= A B) (= B A))
  A eqid A B A ax-eqtr mpan2
    B eqid B A B ax-eqtr mpan2
  impbii
)

## <title> Symmetric Property </title>
thm (eqcomi ()
  (hyp (= A B))
  (= B A)
  hyp A B eqcom mpbi)
	
## <title> Symmetric Property </title>
thm (eqcomd ()
  (hyp (-> ph (= A B)))
  (-> ph (= B A))
  hyp A B eqcom sylib)

## <title> Symmetric Property </title>
thm (eqcoms ()
  (hyp (-> (= A B) ph))
  (-> (= B A) ph)
  B A eqcom hyp sylbi
)

## <title> Equivalence over Equality </title>
thm (eqeq1 () ()
  (-> (= A B) (<-> (= A C) (= B C)))
  A B C ax-eqtr ex
    B A C ax-eqtr ex eqcoms
  impbid
)

## <title> Equivalence over Equality </title>
thm (eqeq2 () ()
  (-> (= A B) (<-> (= C A) (= C B)))
  A B C eqeq1
    A C eqcom B C eqcom bibi12i
  sylib
)

## <title> Equivalence over Equality </title>
## <table>
##   (=      A ]    ] [    B ] )
##   (<-> (= A ] C) ] [ (= B ] C))
## </table>
thm (eqeq1i ()
  (hyp (= A B))
  (<-> (= A C) (= B C))
  hyp A B C eqeq1 ax-mp)
	
## <title> Equivalence over Equality </title>
## <table>
##   (-> ph (=      A ]    ] [    B ] ))
##   (-> ph (<-> (= A ] C) ] [ (= B ] C)))
## </table>
thm (eqeq1d ()
  (hyp (-> ph (= A B)))
  (-> ph (<-> (= A C) (= B C)))
  hyp A B C eqeq1 syl)
	
## <title> Equivalence over Equality </title>
## <table>
##   (=        [ A  ] [      [ B)
##   (<-> (= C [ A) ] [ (= C [ B))
## </table>
thm (eqeq2i ()
  (hyp (= A B))
  (<-> (= C A) (= C B))
  hyp A B C eqeq2 ax-mp)
	
## <title> Equivalence over Equality </title>
## <table>
##   (-> ph (=        [ A  ] [      [ B))
##   (-> ph (<-> (= C [ A) ] [ (= C [ B)))
## </table>
thm (eqeq2d ()
  (hyp (-> ph (= A B)))
  (-> ph (<-> (= C A) (= C B)))
  hyp A B C eqeq2 syl)
	
## <title> Equivalence over Equality </title>
thm (eqeq12i ()
  (hyp1 (= A B)
   hyp2 (= C D))
  (<-> (= A C) (= B D))
  hyp1 A B C eqeq1 ax-mp hyp2 C D B eqeq2 ax-mp bitri
)

## <title> Transtitive Property </title>
thm (eqeq12d ()
  (hyp1 (-> ph (= A B))
   hyp2 (-> ph (= C D)))
  (-> ph (<-> (= A C) (= B D)))
  hyp1 C eqeq1d
  hyp2 B eqeq2d bitrd
)

## <title> Transtitive Property </title>
## <table>
##   (= A [ B    ] ]  )
##   (= A [      [ [ C)
##        [ (= B ] [ C)
## </table>
thm (eqtr3 ()
  (hyp1 (= A B)
   hyp2 (= A C))
  (= B C)
  hyp1 hyp2 A B C ax-eqtr mp2an
)

## <title> Transtitive Property </title>
## <table>
##   (= A  [    B ] ] )
##         [ (= B ] [ C)
##   (= A  [      [ [ C)
## </table>
thm (eqtr ()
  (hyp1 (= A B)
   hyp2 (= B C))
  (= A C)
  hyp1 eqcomi hyp2 eqtr3
)

## <title> Transtitive Property </title>
## <table>
##   (= A [      [ [ B)
##        [ (= C ] [B )
##   (= A [    C ] ]  )
## </table>
thm (eqtr4 ()
  (hyp1 (= A B)
   hyp2 (= C B))
  (= A C)
  hyp1 hyp2 eqcomi eqtr
)

## <title> Transtitive Property </title>
## <table>
##   (= A [      [ [ B)
##   (= A [    C ] ]  )
##        [ (= C ] [B )
## </table>
thm (eqtr5 ()
  (hyp1 (= A B)
   hyp2 (= A C))
  (= C B)
  hyp1 hyp2 A B C ax-eqtr mp2an eqcomi
)

## <title> Transtitive Property </title>
thm (eqtrd ()
  (hyp1 (-> ph (= A B))
   hyp2 (-> ph (= B C)))
  (-> ph (= A C))
  hyp1 hyp2 A eqeq2d mpbid
)

## <title> Syllogism </title>
thm (syl5eq ()
  (hyp1 (-> ph (= A B))
   hyp2 (= C A))
  (-> ph (= C B))
  hyp2 ph a1i hyp1 eqtrd
)

## <title> Syllogism </title>
thm (syl5eqr ()
  (hyp1 (-> ph (= A B))
   hyp2 (= A C))
  (-> ph (= C B))
  hyp2 eqcomi ph a1i hyp1 eqtrd
)

## <title> Syllogism </title>
## <table>
##   (-> ph (= A [    B ] ]  ))
##               [ (= B ] [ C)
##   (-> ph (= A [      [ [ C))
## </table>
thm (syl6eq ()
  (hyp1 (-> ph (= A B))
   hyp2 (= B C))
  (-> ph (= A C))
  hyp1 hyp2 ph a1i eqtrd
)

## <title> Syllogism </title>
thm (syl6eqr ()
  (hyp1 (-> ph (= A B))
   hyp2 (= C B))
  (-> ph (= A C))
  hyp1 hyp2 eqcomi ph a1i eqtrd
)

## <title> Syllogism </title>
thm (sylan9eq ()
  (hyp1 (-> ph (= A B))
   hyp2 (-> ps (= B C)))
  (-> (/\ ph ps) (= A C))
  hyp1 ps adantr
    hyp2 ph adantl
  eqtrd
)

thm (3eqtr4g ()
  (hyp1 (-> ph (= A B))
   hyp2 (= C A)
   hyp3 (= D B))
  (-> ph (= C D))
  hyp1 hyp2 syl5eq hyp3 syl6eqr
)

thm (vtocl ((A x) (ps x))
  (hyp1 (-> (= x A) (<-> ph ps))
   hyp2 ph)
  ps

  hyp2 hyp1 mpbii vtocle
)

thm (ceqsal ((A x) (ps x))
  (hyp (-> (= x A) (<-> ph ps)))
  (<-> (A. x (-> (= x A) ph)) ps)

  hyp pm5.74i x albii
  x (= x A) ps 19.23 bitri
  x A tyex ps a1bi bitr4i
)

thm (ceqsex ((ps x) (A x))
  (hyp (-> (= x A) (<-> ph ps)))
  (<-> (E. x (/\ (= x A) ph)) ps)

  hyp pm5.32i x exbii
  x (= x A) ps 19.41 bitri
  x A tyex mpbiran
)

thm (substex ((ph x y) (ps y) (ch x) (A y))
  (hyp (-> (/\ ph (/\ (= y A) ps)) ch))
  (-> (/\ ph (E. x ps)) (E. y ch))

  hyp ex y 19.21ai
    y (/\ (= y A) ps) ch 19.22
  y (= y A) ps 19.41 y A tyex mpbiran syl5ibr syl
  x 19.21ai
  x ps (E. y ch) 19.23 sylib imp
)

# Version of ax-11 using E.
#thm (ex11 () () (-> (= x y) (-> (E. x (/\ (= x y) ph)) (E. y ph)))
#     x y (-. ph) ax-11
#       y ph alnex biimpri
#     syl5
#       x (-> (= x y) (-. ph)) alex biimpi
#     syl6 con4d
#       (= x y) ph df-an x exbii biimpi
#     syl5)

thm (sbaxex () () (-> (A. x (-> (= x y) ph)) (E. x (/\ (= x y) ph)))
     x y tyex
       x (= x y) ph mpexaxp
     ax-mp)

thm (sbaxexd () (1 (-> ph (A. x (-> (= x y) ps))))
        (-> ph (E. x (/\ (= x y) ps)))
     1 x y ps sbaxex syl)

thm (exlem1 ((ph x)) () (-> (E. x ph) (E. x (/\ (= x y) ph)))
     ph x alnfi
       ph (= x y) ax-1 x 19.20i
     syl x 19.22i exax1d sbaxexd)

thm (exalpha1 ((ph y) (ps x)) (1 (-> (= x y) (-> ph ps)))
     (-> (E. x ph) (E. y ps))
     1 eqcoms com12 y 19.21ai
       y x tyex
         y (= y x) ps mpexax
       ax-mp
     syl x 19.23ai)

thm (exalpha ((ph y) (ps x)) (1 (-> (= x y) (<-> ph ps)))
     (<-> (E. x ph) (E. y ps))
    1 biimpd exalpha1
    y x eqcom 1 sylbi biimprd exalpha1
    impbii)

thm (alpha1 ((ph y) (ps x)) (1 (-> (= x y) (-> ph ps)))
     (-> (A. x ph) (A. y ps))
  1 eqcoms con3d exalpha1 con3i
    x ph alex y ps alex
  3imtr4i
)

thm (alpha ((ph y) (ps x)) (1 (-> (= x y) (<-> ph ps)))
  (<-> (A. x ph) (A. y ps))
    1  biimpd alpha1
    1  eqcoms biimprd alpha1
  impbii
)

# == Substitution thms ==

thm (df-subst-just ((A z y) (ph z y)) ()
      (<-> (E. y (/\ (= y A) (E. x (/\ (= x y) ph))))
          (E. z (/\ (= z A) (E. x (/\ (= x z) ph)))))
     y z A eqeq1
       y z x eqeq2 ph anbi1d x exbid
     anbi12d exalpha
     )

defthm (df-subst wff ([/] A x ph) ((A z) (ph z)) ()
         (<-> ([/] A x ph) (E. z (/\ (= z A) (E. x (/\ (= x z) ph)))))
         y A x ph z df-subst-just)

defthm (df-rwff wff (rwff x ph) () ()
        (<-> (rwff x ph) (A. x (<-> ph ([/] x x ph))))
      (A. x (<-> ph ([/] x x ph))) biid)

thm (dfsbcq () ()
  (-> (= A B) (<-> ([/] A x ph) ([/] B x ph)))
  A B y eqeq2 (E. x (/\ (= x y) ph)) anbi1d y exbid
  A x ph y df-subst B x ph y df-subst bibi12i sylibr
)

thm (a4sbc () ()
  (-> (A. x ph) ([/] A x ph))

  x y tyex x ph (= x y) 19.29 mpan2
  ph (= x y) ancom x exbii sylib
  y 19.21ai
    y A tyex (A. x ph) a1i
  jca
  y (E. x (/\ (= x y) ph)) (= y A) 19.29 syl
  (E. x (/\ (= x y) ph)) (= y A) ancom y exbii sylib
  A x ph y df-subst sylibr
)

thm (sbc5 ((A x)) ()
  (<-> ([/] A x ph) (E. x (/\ (= x A) ph)))

  A x ph y df-subst
    y A x eqeq2 ph anbi1d
    x exbid
    ceqsex
  bitri
)

thm (sbcco ((ph y) (A y)) ()
  (<-> ([/] A y ([/] y x ph)) ([/] A x ph))

  A y ([/] y x ph) sbc5
    y x ph sbc5
      (= y A) anbi2i y exbii
    bitri
  A x ph y df-subst bitr4i
)

thm (sbcie ((A x) (ps x))
  (hyp (-> (= x A) (<-> ph ps)))
  (<-> ([/] A x ph) ps)

  A x ph sbc5
  hyp ceqsex bitri
)

thm (cla4g ((ps x) (A x))
  (hyp (-> (= x A) (<-> ph ps)))
  (-> (A. x ph) ps)
  x ph A a4sbc hyp sbcie sylib
)

thm (sbcbid ((ph x))
  (hyp (-> ph (<-> ps ch)))
  (-> ph (<-> ([/] A x ps) ([/] A x ch)))

  hyp (= x y) anbi2d x exbid
  (= y A) anbi2d y exbid
    A x ps y df-subst
      A x ch y df-subst
  3bitr4g
)

thm (sbcbii ()
  (hyp (<-> ph ps))
  (<-> ([/] A x ph) ([/] A x ps))
  (0) eqid
    hyp (= (0) (0)) a1i A x sbcbid
  ax-mp
)
thm (sbceq12 () (h (rwff x ph))
  (-> (= x A) (<-> ph ([/] A x ph)))
  x A x ph dfsbcq
    h x ph df-rwff mpbi a4i
  syl5bb
)

thm (sb6rf ((ph y)) (h (rwff x ph))
  (<-> ph (A. y (-> (= y x) ([/] y x ph))))
  h x ph df-rwff mpbi a4i
    y x x ph dfsbcq
    ceqsal
  bitr4i
)

thm (rwffi ((ps x) (ph y))
  (hyp (-> (= x y) (<-> ph ps)))
  (rwff x ph)
  hyp sbcie x y sbcbii
  hyp x y eqcom ph ps bicom imbi12i mpbi sbcie bitri

  x y x ph sbcco
  bitr3i x gen
  x ph df-rwff mpbir
)

# == Existential uniqueness ==

defthm (df-eu wff (E! x ph) ((ph y)) ()
          (<-> (E! x ph) (E. y (A. x (<-> ph (= x y)))))
       z y x eqeq2 ph bibi2d x 19.21ai 19.15d exalpha)

thm (eubid ((ph x))
  (hyp (-> ph (<-> ps ch)))
  (-> ph (<-> (E! x ps) (E! x ch)))
  hyp   (= x z)  bibi1d
  x  19.21ai       19.15d     z  exbid
  x  ps  z  df-eu   syl5bb
  x  ch  z  df-eu      syl6bbr
)

thm (eubii () (h (<-> ph ps)) (<-> (E! x ph) (E! x ps))
  y eqid
    h  (= y y)  a1i   x  eubid
  ax-mp
)

thm (eualpha ((ph y) (ps x)) (h1 (-> (= x y) (<-> ph ps)))
     (<-> (E! x ph) (E! y ps))
    h1
      x  y  z  eqeq1
    bibi12d    alpha
    z  exbii
        x  ph  z  df-eu
          y  ps  z  df-eu
        bibi12i    biimpri
    ax-mp
)

thm (euex () () (-> (E! x ph) (E. x ph))
  x  ph  z  df-eu  biimpi

    x  z  tyex  z  gen    jctil  z  (E. x (= x z))  (A. x (<-> ph (= x z)))  19.29  syl
    x  (<-> ph (= x z))  (= x z)  19.29  ancoms  z  19.22i  syl
      ph  (= x z)  bi2    (= x z)  anim1i
  (= x z)  ph  pm3.35  ancoms  syl  x  19.22i  z  19.22i  syl
  z  (E. x ph)  19.9  sylib
)

thm (eumo0 ((ph y)) ()
  (-> (E! x ph) (E. y (A. x (-> ph (= x y)))))
  x ph y df-eu biimpi
    ph (= x y) bi1 x 19.20i y 19.22i
  syl
)

thm (sb8eu ((ph y)) (h (rwff x ph))
  (<-> (E! x ph) (E! y ([/] y x ph)))
  h x ph df-rwff mpbi a4i x eubii
  x y x ph dfsbcq eualpha bitri
)

thm (mo ((ph y)) (h (rwff x ph))
  (<-> (E. y (A. x (-> ph (= x y)))) (A. x (A. y (-> (/\ ph ([/] y x ph)) (= x y)))))
  z y x eqeq2
  ph imbi2d
  x 19.21ai 19.15d # albidv
  exalpha
    h y sbceq12 biimprd
      x y z eqeq1 biimpd
    imim12d alpha1
    ancli
      x y (-> ph (= x z)) (-> ([/] y x ph) (= y z)) aaan
    sylibr
      ph (= x z) ([/] y x ph) (= y z) prth
        y z x eqeq2 biimprd impcom
      syl6
      y 19.20i x 19.20i
    syl z 19.23ai
  sylbir

    y x (-> ([/] y x ph) (-> ph (= x y))) 19.5
    x ([/] y x ph) (-> ph (= x y)) ax-alim y 19.20i sylbir  # having a7s would shorten slightly
    y (A. x ([/] y x ph)) (A. x (-> ph (= x y))) 19.22 syl
      ([/] y x ph) x alnfi y 19.22i
    syl5com
      ph ([/] y x ph) (= x y) impexp
      ph ([/] y x ph) (= x y) bi2.04 bitri
      y albii x albii
    syl5ib
      y ([/] y x ph) alnex
        h y sbceq12 biimpd eqcoms con3d alpha1
        ph (= x y) pm2.21 x 19.20i syl
        (A. x (-> ph (= x y))) y 19.8a syl
      sylbir
      (A. x (A. y (-> (/\ ph ([/] y x ph)) (= x y)))) a1d
    pm2.61i
  impbii
)

thm (eu1 ((ph y)) (h (rwff x ph))
  (<-> (E! x ph) (E. x (/\ ph (A. y (-> ([/] y x ph) (= x y))))))
  h y sb8eu
  y ([/] y x ph) x df-eu bitri
    x y eqcom ([/] y x ph) imbi2i y albii
      h y sb6rf
    anbi12i
      ph (A. y (-> ([/] y x ph) (= x y))) ancom
        y ([/] y x ph) (= y x) albiim
    3bitr4i x exbii
  bitr4i
)

thm (eu2 ((ph y)) (h (rwff x ph))
  (<-> (E! x ph) (/\ (E. x ph) (A. x (A. y (-> (/\ ph ([/] y x ph)) (= x y))))))
  x ph euex
    x ph y eumo0
    h y mo sylib
  jca
    x ph (A. y (-> (/\ ph ([/] y x ph)) (= x y))) 19.29r
      ph ([/] y x ph) (= x y) impexp y albii
      y ph (-> ([/] y x ph) (= x y)) 19.21 bitri ph anbi2i
      ph (A. y (-> ([/] y x ph) (= x y))) abai bitr4i x exbii
    sylib
    h y eu1 sylibr
  impbii
)

thm (eu3 ((ph y)) (h (rwff x ph))
  (<-> (E! x ph) (/\ (E. x ph) (E. y (A. x (-> ph (= x y))))))
  h y eu2 h y mo (E. x ph) anbi2i bitr4i
)

# There is exactly one number equal to a given number.
thm (tyeu ((A x)) () (E! x (= x A))
  y  A  tyex
    y  A  x  eqeq2  bicomd  x  19.21ai  y  19.22i  ax-mp
    x  (= x A)  y  df-eu  mpbir
)

# Exists at most one

defthm (df-mo wff (E* x ph) () ()
  (<-> (E* x ph) (-> (E. x ph) (E! x ph)))
  (-> (E. x ph) (E! x ph)) biid
)

thm (mo2 ((ph y)) (h (rwff x ph))
  (<-> (E* x ph) (E. y (A. x (-> ph (= x y)))))
  x ph df-mo
    x ph alnex
      ph (= x y) pm2.21 x 19.20i
      (A. x (-> ph (= x y))) y 19.8a syl
    sylbir
    x ph y eumo0 ja
      h y eu3 biimpri expcom
    impbii
  bitri
)

thm (mo4 ((ph y) (ps x))  (h (-> (= x y) (<-> ph ps)))
  (<-> (E* x ph) (A. x (A. y (-> (/\ ph ps) (= x y)))))
  h rwffi y mo2 h rwffi y mo bitri  # same as mo3, but shouldn't need it as a separate thm
    h sbcie ph anbi2i (= x y) imbi1i y albii x albii
  bitri
)

thm (eu5 () (h (rwff x ph))
  (<-> (E! x ph) (/\ (E. x ph) (E* x ph)))
  h y eu3
  h y mo2 (E. x ph) anbi2i bitr4i
)

thm (eu4 ((ph y) (ps x))
  (h (-> (= x y) (<-> ph ps)))
  (<-> (E! x ph) (/\ (E. x ph) (A. x (A. y (-> (/\ ph ps) (= x y))))))
  h rwffi eu5 h mo4 (E. x ph) anbi2i bitri
)

# == Basic Peano arithmetic ==

defthm (df-1 nat (1) () () (= (1) (S (0)))
        (S (0)) eqid)

## <title> Equality over Addition </title>
thm (addeq1 () ()
  (-> (= A B) (= (+ A C) (+ B C)))
  C eqid A B C C addeq12 mpan2)
	
## <title> Equality over Addition </title>
thm (addeq2 () ()
  (-> (= A B) (= (+ C A) (+ C B)))
  C eqid C C A B addeq12 mpan)
	
## <title> Equality over Addition </title>
thm (addeq12i ()
  (hyp1 (= A B)
   hyp2 (= C D))
  (= (+ A C) (+ B D))
  hyp1 hyp2 A B C D addeq12 mp2an
)

## <title> Equality over Addition </title>
thm (addeq1d ()
  (h (-> ph (= A B)))
  (-> ph (= (+ A C) (+ B C)))
  h A B C addeq1 syl
)

## <title> Equality over Addition </title>
thm (addeq2d ()
  (h (-> ph (= A B)))
  (-> ph (= (+ C A) (+ C B)))
  h A B C addeq2 syl
)

## <title> Equality over Addition </title>
thm (addeq12d ()
  (hyp1 (-> ph (= A B))
   hyp2 (-> ph (= C D)))
  (-> ph (= (+ A C) (+ B D)))
  hyp1 hyp2 jca A B C D addeq12 syl
)

## <title> Equality over Addition </title>
thm (addeq1i ()
  (hyp (= A B))
  (= (+ A C) (+ B C))
  hyp A B C addeq1 ax-mp
)

## <title> Equality over Addition </title>
thm (addeq2i ()
  (hyp (= A B))
  (= (+ C A) (+ C B))
  C eqid hyp C C A B addeq12 mp2an
)

## <title> Equality over Multiplication </title>
## <table>
##   (-> (= A B) (= (* A <r> C) (* B <r> C)))
## </table>
thm (muleq1 () ()
  (-> (= A B) (= (* A C) (* B C)))
  C eqid A B C C muleq12 mpan2)
	
## <title> Equality over Multiplication </title>
## <table>
##   (-> (= A B) (= (* <r> C A) (* <r> C B)))
## </table>
thm (muleq2 () ()
  (-> (= A B) (= (* C A) (* C B)))
  C eqid C C A B muleq12 mpan)

## <title> Equality over Multiplication </title>
thm (muleq12i ()
  (hyp1 (= A B)
   hyp2 (= C D))
  (= (* A C) (* B D))
  hyp1 hyp2 A B C D muleq12 mp2an
)

## <title> Equality over Multiplication </title>
thm (muleq1d ()
  (hyp (-> ph (= A B)))
  (-> ph (= (* A C) (* B C)))
  hyp C eqid A B C C muleq12 mpan2 syl
)

## <title> Equality over Multiplication </title>
thm (muleq1i ()
  (hyp (= A B))
  (= (* A C) (* B C))
  hyp A B C muleq1 ax-mp
)

## <title> Equality over Multiplication </title>
thm (muleq2i () (hyp (= A B))
  (= (* C A) (* C B))
  hyp A B C muleq2 ax-mp
)

thm (suceqd ()
  (hyp (-> ph (= A B)))
  (-> ph (= (S A) (S B)))
  hyp A B pa_ax2 sylib)

thm (finds ((A x) (ch x) (th x) (ta x) (ph y))
  (hyp1 (-> (= x (0)) (<-> ph ps))
   hyp2 (-> (= x y) (<-> ph ch))
   hyp3 (-> (= x (S y)) (<-> ph th))
   hyp4 (-> (= x A) (<-> ph ta))
   hyp5 ps
   hyp6 (-> ch th))
  ta

  hyp4
    hyp5 hyp1 mpbiri x gen
      hyp6
        hyp2 ceqsal
          hyp3 ceqsal
      3imtr4i y gen
    x ph y pa_ind mp2an
    a4i
  vtocl
)

thm (pa_ax3r () ()
  (= (+ (0) A) A)

  x (0) (0) addeq2 (= x (0)) id eqeq12d
    x y (0) addeq2 (= x y) id eqeq12d
      x (S y) (0) addeq2 (= x (S y)) id eqeq12d
        x A (0) addeq2 (= x A) id eqeq12d
          (0) pa_ax3
            (+ (0) y) y pa_ax2
              (0) y pa_ax4 (S y) eqeq1i
            bitr4i biimpi
  finds
)

thm (pa_ax4r () ()
  (= (+ (S A) B) (S (+ A B)))

  x (0) (S A) addeq2 x (0) A addeq2 suceqd eqeq12d
    x y (S A) addeq2 x y A addeq2 suceqd eqeq12d
      x (S y) (S A) addeq2 x (S y) A addeq2 suceqd eqeq12d
        x B (S A) addeq2 x B A addeq2 suceqd eqeq12d

          (S A) pa_ax3 A pa_ax3 (+ A (0)) A pa_ax2 mpbi eqtr4

            (+ (S A) y) (S (+ A y)) pa_ax2 biimpi
              A y pa_ax4 (+ A (S y)) (S (+ A y)) pa_ax2 mpbi
            syl6eqr
              (S A) y pa_ax4
             syl5eq

  finds
)

thm (addcom () ()
  (= (+ A B) (+ B A))

  x (0) B addeq1 x (0) B addeq2 eqeq12d
    x y B addeq1 x y B addeq2 eqeq12d
      x (S y) B addeq1 x (S y) B addeq2 eqeq12d
        x A B addeq1 x A B addeq2 eqeq12d

          B pa_ax3r B pa_ax3 eqtr4

            (+ y B) (+ B y) pa_ax2 biimpi
            y B pa_ax4r syl5eq
            B y pa_ax4 syl6eqr

  finds
)

thm (addass () ()
  (= (+ (+ A B) C) (+ A (+ B C)))

  x (0) B addeq1 C addeq1d x (0) (+ B C) addeq1 eqeq12d
    x y B addeq1 C addeq1d x y (+ B C) addeq1 eqeq12d
      x (S y) B addeq1 C addeq1d x (S y) (+ B C) addeq1 eqeq12d
        x A B addeq1 C addeq1d x A (+ B C) addeq1 eqeq12d

          B pa_ax3r C addeq1i (+ B C) pa_ax3r eqtr4

            (+ (+ y B) C) (+ y (+ B C)) pa_ax2 biimpi
              y B pa_ax4r C addeq1i
              (+ y B) C pa_ax4r eqtr
                y (+ B C) pa_ax4r
            3eqtr4g
  finds
)

## <title> Multiply by 0 </title>
thm (pa_ax5r () ()
  (= (* (0) A) (0))

  x (0) (0) muleq2 (0) eqeq1d
    x y (0) muleq2 (0) eqeq1d
      x (S y) (0) muleq2 (0) eqeq1d
        x A (0) muleq2 (0) eqeq1d
          (0) pa_ax5
            (0) y pa_ax6
            (* (0) y) pa_ax3 eqtr (0) eqeq1i biimpri
  finds
)

thm (pa_ax6r () ()
  (= (* (S A) B) (+ (* A B) B))

  x (0) (S A) muleq2 x (0) A muleq2 (= x (0)) id addeq12d eqeq12d
    x y (S A) muleq2 x y A muleq2 (= x y) id addeq12d eqeq12d
      x (S y) (S A) muleq2 x (S y) A muleq2 (= x (S y)) id addeq12d eqeq12d
        x B (S A) muleq2 x B A muleq2 (= x B) id addeq12d eqeq12d
          (S A) pa_ax5 A pa_ax5 (0) addeq1i (0) pa_ax3 eqtr eqtr4

            (* (S A) y) (+ (* A y) y) (S A) addeq1
            (S A) y pa_ax6 syl5eq
            (+ (* A y) y) A pa_ax4 syl6eq
              (* A y) y A addass y A addcom (* A y) addeq2i eqtr
              (* A y) A y addass eqtr4
              (+ (+ (* A y) y) A) (+ (+ (* A y) A) y) pa_ax2 mpbi
            syl6eq
              A y pa_ax6 (S y) addeq1i
              (+ (* A y) A) y pa_ax4 eqtr
            syl6eqr
  finds
)

## <title> Commutative Property </title>
## <table>
##   (= (* <r> A <g> B) (* <g> B <r> A))
## </table>
thm (mulcom () ()
  (= (* A B) (* B A))

  x (0) B muleq1 x (0) B muleq2 eqeq12d
    x y B muleq1 x y B muleq2 eqeq12d
      x (S y) B muleq1 x (S y) B muleq2 eqeq12d
        x A B muleq1 x A B muleq2 eqeq12d

          B pa_ax5r B pa_ax5 eqtr4

            (* y B) (* B y) B addeq1
            y B pa_ax6r syl5eq
            B y pa_ax6 syl6eqr
  finds
)

# One is an identity of multiplication
## <title> Multiplicative Identity </title>
## <table>
##   (= (* A <r> (1)) A)
## </table>
thm (mulid () ()
  (= (* A (1)) A)
    df-1  (1) (S (0)) A muleq2 ax-mp
    A (0) pa_ax6
      A pa_ax5 A addeq1i  eqtr   A (0) addcom eqtr4 A pa_ax3
    eqtr
  eqtr)


thm (add23 () ()
  (= (+ (+ A B) C) (+ (+ A C) B))
  A B C addass
  B C addcom A addeq2i eqtr
  A C B addass eqtr4
)

thm (add4 () ()
  (= (+ (+ A B) (+ C D)) (+ (+ A C) (+ B D)))
  (+ A B) C D addass
  A B C add23 D addeq1i eqtr3
  (+ A C) B D addass eqtr
)

# Distribution of addition through multiplication
thm (distr () ()
  (= (* A (+ B C)) (+ (* A B) (* A C)))

  x (0) (+ B C) muleq1 x (0) B muleq1 x (0) C muleq1 addeq12d eqeq12d
    x y (+ B C) muleq1 x y B muleq1 x y C muleq1 addeq12d eqeq12d
      x (S y) (+ B C) muleq1 x (S y) B muleq1 x (S y) C muleq1 addeq12d eqeq12d
        x A (+ B C) muleq1 x A B muleq1 x A C muleq1 addeq12d eqeq12d

          (+ B C) pa_ax5r B pa_ax5r C pa_ax5r addeq12i (0) pa_ax3 eqtr eqtr4

            (* y (+ B C)) (+ (* y B) (* y C)) (+ B C) addeq1
            y (+ B C) pa_ax6r syl5eq
              y B pa_ax6r y C pa_ax6r addeq12i
              (* y B) B (* y C) C add4 eqtr
            syl6eqr
  finds
)

# Distribution of addition through multiplication, left argument
thm (distl () ()
  (= (* (+ A B) C) (+ (* A C) (* B C)))

   (+ A B) C mulcom C A B distr eqtr
   C A mulcom C B mulcom addeq12i eqtr)

# Distribution of addition through multiplication, both arguments
thm (distrl () ()
  (= (* (+ A B) (+ C D)) (+ (+ (* A C) (* B C)) (+ (* A D) (* B D))))
  (+ A B) C D distr
    A B C distl A B D distl addeq12i eqtr)

# Multiplication is associative
thm (mulass () ()
  (= (* (* A B) C) (* A (* B C)))

  x (0) B muleq1 C muleq1d x (0) (* B C) muleq1 eqeq12d
    x y B muleq1 C muleq1d x y (* B C) muleq1 eqeq12d
      x (S y) B muleq1 C muleq1d x (S y) (* B C) muleq1 eqeq12d
        x A B muleq1 C muleq1d x A (* B C) muleq1 eqeq12d

          B pa_ax5r C muleq1i C pa_ax5r eqtr (* B C) pa_ax5r eqtr4

            (* (* y B) C) (* y (* B C)) (* B C) addeq1
              y B pa_ax6r C muleq1i
              C (+ (* y B) B) mulcom C (* y B) B distr eqtr3 eqtr
              C (* y B) mulcom C B mulcom addeq12i eqtr
            syl5eq
            y (* B C) pa_ax6r syl6eqr
  finds
)

# Cancellation of addition
thm (addcan () ()
  (<-> (= (+ B A) (+ C A)) (= B C))
  x (0) B addeq2 x (0) C addeq2 eqeq12d (= B C) bibi1d
    x y B addeq2 x y C addeq2 eqeq12d (= B C) bibi1d
      x (S y) B addeq2 x (S y) C addeq2 eqeq12d (= B C) bibi1d
        x A B addeq2 x A C addeq2 eqeq12d (= B C) bibi1d

          B pa_ax3 C pa_ax3 eqeq12i

            B y pa_ax4 C y pa_ax4 eqeq12i
            (+ B y) (+ C y) pa_ax2 bitr4i (= B C) bibi1i biimpri
  finds
)

# Cancellation of addition, left argument
thm (addcan2 () ()
  (<-> (= (+ A B) (+ A C)) (= B C))
  A B addcom A C addcom eqeq12i
    B A C addcan bitri
)

# Successor is equivalent to adding one
thm (a1suc () ()
  (= (S A) (+ A (1)))
  df-1 A addeq2i
  A (0) pa_ax4 eqtr
  A pa_ax3 (+ A (0)) A pa_ax2 mpbi eqtr eqcomi
)

# Replace an equal statement in the second part of an AND statement using the first part of the AND.
thm (anReplaceEq () () (<-> (/\ (= A B) (= B C)) (/\ (= A B) (= A C)))
  (= A B) (= B C) pm3.26

  B A C ax-eqtr
  B A eqcom
  (= B C) anbi1i
  sylbi2
  jca

  (= A B) (= A C) pm3.26
  A B C ax-eqtr
  jca

  impbii
)

thm (inlineEq () () (<-> (/\ (= A B) (= A C)) (/\ (= A B) (= B C)))
  (= A B) (= A C) pm3.26
  A B C ax-eqtr
  jca

  (= A B) (= B C) pm3.26
  B A C ax-eqtr

  B A eqcom
  (= B C) anbi1i
  sylbi2
  jca
  impbii
)

thm (inlineNeqLem () ()
  (-> (/\ (= A B) (-. (= B C))) (/\ (= A B) (-. (= A C))))

  A B C ax-eqtr
  con3i
  (= A B) anim2i
  (= A B) (/\ (= A B) (= A C)) pm4.52
  sylib
  (-. (= A B)) (= A B) (= A C)
  ordi
  con4biir
  sylib
  (= A B) exmid

  (= A B) (-. (= A B)) orcom
  mpbi

  (\/ (-. (= A B)) (= A C))
  anTrue
  
  con4biir
  sylib

  (= A B) (= A C) pm4.52
  bicomi
  sylib
)

thm (inlineNeq () () (<-> (/\ (= A B) (-. (= B C))) (/\ (= A B) (-. (= A C)))) 

  A B C inlineNeqLem
  B A C inlineNeqLem

  B A eqcom
  (-. (= A C)) anbi1i
  sylbi2

  B A eqcom
  (-. (= B C)) anbi1i
  sylib
  impbii
)

thm (df-le-just ((A x) (B x) (A y) (B y)) ()
       (<-> (E. x (= (+ A x) B)) (E. y (= (+ A y) B)))
      x y A addeq2 B eqeq1d exalpha)

# Definition of less than or equal to.
defthm (df-le wff (<= A B) ((A x) (B x)) ()
        (<-> (<= A B) (E. x (= (+ A x) B)))
        # WTS (<-> (E. y (= (+ A y) B)) (E. x (= (+ A x) B)))
        y A B x df-le-just)

defthm (df-lt wff (< A B) () () (<-> (< A B) (/\ (<= A B) (-. (= A B))))
        (/\ (<= A B) (-. (= A B))) biid)

thm (ltle ()
  (hyp (<  A B))
       (<= A B)
  hyp
  A B df-lt
  mpbi
  pm3.26i
)

thm (netr ()
  (hyp (=  A B)
   hyp2 (-. (= B C)))
       (-. (= A C))
  hyp2
  hyp
  C eqeq1i
  mtbir
)

thm (ltDiff () (hyp (< A B)) (<-> (< A B) (E. x (/\ (= (+ A x) B) (-. (= x (0)))))) 
  A B df-lt

  A B x df-le
  (-. (= A B))
  anbi1i
  bitri

  x (= (+ A x) B) (-. (= A B)) 19.41
  bicomi
  bitri

  A x (0) addcan2
  bicomi
  A pa_ax3r
  (0) A addcom
  eqtr5
  (+ A x) eqeq2i
  bitri
  notbii
  (= (+ A x) B) anbi2i

  (+ A x) B A inlineNeq 
  B A eqcom
  con4biir
  (= (+ A x) B) anbi2i
  bitr3icom

  bicomi
  bitri
  bicomi

  x exbii
  bitri
)

# Equality deduction for less than or equal relation
## <title> Inequality Equivalence </title>
thm (leeq1d ()
  (hyp (-> ph (= A B)))
  (-> ph (<-> (<= A C) (<= B C)))
  hyp
    A B x addeq1 C eqeq1d x exbid
      A C x df-le B C x df-le bibi12i
    sylibr
  syl
)

# Equality deduction for less than or equal relation
## <title> Inequality Equivalence </title>
## <table>
##   (-> ph (=         [ A ]       [   [ B ] ))
##   (-> ph (<-> (<= C [ A ] ) (<= [ C [ B ] )))
## </table>
thm (leeq2d ()
  (hyp (-> ph (= A B)))
  (-> ph (<-> (<= C A) (<= C B)))
  hyp
    A B (+ C x) eqeq2 x exbid
      C A x df-le C B x df-le bibi12i
    sylibr
  syl
)

# Equality inference for less than or equal relation
## <title> Equivalence over Inequality </title>
## <table>
##   (=       A ]   ]       [ B ]   )
##   (<-> (<= A ] C ] ) (<= [ B ] C))
## </table>
thm (leeq1i ()
  (hyp (= A B))
  (<-> (<= A C) (<= B C))
  hyp (= A B) id C leeq1d ax-mp
)

# Equality inference for less than or equal relation
## <title> Equivalence over Inequality </title>
## <table>
##   (=         [ A ]       [   [ B ] )
##   (<-> (<= C [ A ] ) (<= [ C [ B ] ))
## </table>
thm (leeq2i ()
  (hyp (= A B))
  (<-> (<= C A) (<= C B))
  hyp (= A B) id C leeq2d ax-mp
)

# Equality inference for less than or equal relation
## <title> Equivalence over Inequality </title>
thm (leeq1ii ()
  (hyp1 (<= A C)
   hyp2 (= A B))
  (<= B C)
  hyp1 hyp2 C leeq1i mpbi
)

# Equality inference for less than or equal relation
## <title> Equivalence over Inequality </title>
thm (leeq2ii ()
  (hyp1 (<= C A)
   hyp2 (= A B))
  (<= C B)
  hyp1 hyp2 C leeq2i mpbi
)

# Addition is strictly monotonic in the first addend
## <title> Add Both Sides </title>
thm (leadd1 () ()
  (<-> (<= A B) (<= (+ A C) (+ B C)))
  (+ A x) C B addcan
  A x C add23 (+ B C) eqeq1i bitr3i
  x exbii
    A B x df-le
      (+ A C) (+ B C) x df-le
  3bitr4i
)

# Addition is strictly monotonic in the second addend
## <title> Add Both Sides </title>
## <table>
##   (<-> (<= A B) (<= (+ <g> C A) (+ <g> C B)))
## </table>
thm (leadd2 () ()
  (<-> (<= A B) (<= (+ C A) (+ C B)))
  A B C leadd1
  A C addcom (+ B C) leeq1i bitri
  B C addcom (+ C A) leeq2i bitri
)

# Inequality relation for two equal sums
thm (leadd12 () ()
  (-> (= (+ A B) (+ C D)) (<-> (<= A C) (<= D B)))
  (= (+ A B) (+ C D)) id (+ C B) leeq1d
  D B C leadd2 syl6bbr
  A C B leadd1 syl5bb
)

## <title> Basic Inequality </title>
thm (1nle0 () ()
  (-. (<= (1) (0)))
  x pa_ax1 (0) (S x) eqcom mtbi
  x a1suc x (1) addcom eqtr (0) eqeq1i mtbi
  x gen x (= (+ (1) x) (0)) alnex mpbi
  (1) (0) x df-le mtbir
)

## <title> Equivalence over Inequality </title>
thm (lteq2d ()
  (hyp (-> ph (= A B)))
  (-> ph (<-> (< C A) (< C B)))
  hyp C leeq2d
  hyp C eqeq2d notbid anbi12d
    C A df-lt
      C B df-lt
  3bitr4g
)

## <title> Equivalence over Inequality </title>
thm (lteq2i ()
  (hyp (= A B))
  (<-> (< C A) (< C B))
  hyp (= A B) id C lteq2d ax-mp
)

## <title> Equivalence over Inequality </title>
thm (lteq2ii ()
  (hyp1 (< C A)
   hyp2 (= A B))
  (< C B)
  hyp1 hyp2 C lteq2i mpbi
)

thm (addge01t () ()
  (<= A (+ A B))
  x B tyex x B A addeq2 x 19.22i ax-mp
  A (+ A B) x df-le mpbir
)

thm (addge02t () ()
  (<= A (+ B A))
  A B addge01t A B addcom A leeq2i mpbi
)

# Less than or equal is a reflexive relation
## <title> Reflexive Property </title>
thm (leid () ()
  (<= A A)
  A (0) addge01t
  A pa_ax3 A leeq2i mpbi
)

thm (lenlttlem () ()
  (-. (<= (+ A (1)) A))
  1nle0 (1) (0) A leadd1 mtbi
  (1) A addcom (+ (0) A) leeq1i mtbi
  A pa_ax3r (+ A (1)) leeq2i mtbi
)

thm (letr () ()
  (-> (/\ (<= A B) (<= B C)) (<= A C))

  z (+ x y) A addeq2
  A x y addass syl6eqr (= (+ A x) B) adantr
  (+ A x) B y addeq1 (= z (+ x y)) adantl eqtrd
  C eqeq1d biimprd
  imp ancoms x substex ex y 19.23ai com12 imp
    A B x df-le
    B C y df-le anbi12i
    A C z df-le imbi12i
  mpbir
)

thm (lefoo ((A z)) ()
  (\/ (= A (0)) (E. z (= (+ (1) z) A)))
  x (0) (0) eqeq1 x (0) (+ (1) z) eqeq2 z exbid orbi12d
    x y (0) eqeq1 x y (+ (1) z) eqeq2 z exbid orbi12d
      x (S y) (0) eqeq1 x (S y) (+ (1) z) eqeq2 z exbid orbi12d
        x A (0) eqeq1 x A (+ (1) z) eqeq2 z exbid orbi12d

  # invariant: x = 0 \/ E. z 1 + z = x
  (0) eqid (E. z (= (+ (1) z) (0))) orci

  z y tyex
    z y (1) addeq2
    y a1suc y (1) addcom eqtr syl6eqr
    z 19.22i
  ax-mp (= (S y) (0)) olci
  (\/ (= y (0)) (E. z (= (+ (1) z) y))) a1i
  finds
)

thm (lefoo3 () ()
  (<-> (<= A B) (\/ (= A B) (<= (+ A (1)) B)))
  A B x df-le
    x y lefoo
      x (0) A addeq2
      A pa_ax3 syl6eq B eqeq1d biimpd com12
        (+ (1) y) x A addeq2 A (1) y addass syl5eq
        B eqeq1d biimprd com12
        y 19.22d
        (+ A (1)) B y df-le syl6ibr
      orim12d
    mpi
  x 19.23ai sylbi
    A leid (= A B) id A leeq2d mpbii
      A (1) addge01t A (+ A (1)) B letr mpan
    jaoi
  impbii
)

thm (nnltp1let () ()
  (<-> (< A B) (<= (+ A (1)) B))
  A B df-lt
  A B lefoo3 (-. (= A B)) anbi1i bitri
    A lenlttlem
    (= A B) id (+ A (1)) leeq2d mtbii
    con2i pm4.71i

      (<= (+ A (1)) B) (= A B) pm5.61
      (<= (+ A (1)) B) (= A B) orcom (-. (= A B)) anbi1i bitr3i
    bitri
  bitr4i
)

thm (nn0nlt0 () ()
  (-. (< A (0)))
    1nle0 (1) A addge02t
    (1) (+ A (1)) (0) letr mpan
  mto
  A (0) nnltp1let mtbir
)

thm (lenltt () ()
  (<-> (<= A B) (-. (< B A)))
  (= x (0)) id B leeq1d (= x (0)) id B lteq2d notbid bibi12d
    (= x y) id B leeq1d (= x y) id B lteq2d notbid bibi12d
      (= x (S y)) id B leeq1d (= x (S y)) id B lteq2d notbid bibi12d
        (= x A) id B leeq1d (= x A) id B lteq2d notbid bibi12d

  # base case
  (0) B addge02t
    B pa_ax3 (0) leeq2i
  mpbi
  B nn0nlt0 2th

  # induction step
  (<= y B) (-. (< B y)) (-. (= y B)) anbi1
    y B nnltp1let y B df-lt bitr3i
      B (+ y (1)) nnltp1let
      B y (1) leadd1 bitr4i
      B y lefoo3 bitri
      B y nnltp1let (= B y) orbi2i bitr4i
        B y eqcom (< B y) orbi1i
        (= y B) (< B y) orcom bitri
      bitri notbii
      (< B y) (= y B) ioran bitri
    bibi12i
  sylibr
    y a1suc B leeq1i y a1suc B lteq2i notbii bibi12i
  sylibr
  finds
)

# Equality deduction for less than relation
thm (lteq1d () (hyp (-> ph (= A B)))
  (-> ph (<-> (< A C) (< B C)))
  hyp C leeq2d
  C A lenltt
  C B lenltt
 bibi12i
 sylib
 con4bid
)

# Equality inference for less than relation
thm (lteq1i () (h (= A B))
  (<-> (< A C) (< B C))
  h (= A B) id C lteq1d ax-mp)

# Equality inference for less than relation
thm (lteq1ii ()
  (hyp1 (< A C)
   hyp2 (= A B))
  (< B C)
  hyp1 hyp2 C lteq1i mpbi
)

## <title> Basic Inequality </title>
thm (0ne1 () ()
  (-. (= (0) (1)))
  (0) pa_ax1
  df-1 (0) eqeq2i mtbir
)

# Transitive law
thm (lelttr () ()
  (-> (/\ (<= A B) (< B C)) (< A C))
  A B (1) leadd1
  B C nnltp1let
  anbi12i
  (+ A (1)) (+ B (1)) C letr sylbi
  A C nnltp1let
  sylibr
)

# Transitive law
thm (lelttr2 () ()
  (-> (/\ (< A B) (<= B C)) (< A C))
  A B nnltp1let (<= B C) anbi1i
  (+ A (1)) B C letr sylbi
  A C nnltp1let sylibr
)

thm (axlttri () ()
  (<-> (< A B) (-. (\/ (= A B) (< B A))))
  A B df-lt
  A B lenltt (-. (= A B)) anbi1i bitri
    (< B A) (= A B) ioran
      (< B A) (= A B) orcom notbii
    bitr3i
  bitri
)

# Less than or equal to expressed in terms of less than or equals
thm (leleo () ()
  (<-> (<= A B) (\/ (< A B) (= A B)))
  A B lenltt
    B A axlttri con2bii
  bitr4i
  B A eqcom (< A B) orbi1i bitri
  (= A B) (< A B) orcom bitri
)

thm (nelt0 () (hyp (-. (= x (0)))) (-. (<= x (0)))
  x nn0nlt0
  hyp
  pm3.2ni

  x (0) leleo
  mtbir
)

thm (ltadd1 () ()
  (<-> (< A B) (< (+ A C) (+ B C)))
  A B C leadd1
    A C B addcan bicomi notbii
  anbi12i

    A B df-lt
      (+ A C) (+ B C) df-lt
  3bitr4i
)

# Multiplication is monotonic in its second argument
## <title> Multiply Both Sides </title>
thm (lemul2 () ()
  (-> (<= A B) (<= (* C A) (* C B)))

  A B x df-le
    (0) eqid
      y (* C x) (* C A) addeq2
        (+ A x) B C muleq2
        C A x distr syl5eqr
      sylan9eq
      (= (0) (0)) adantl x substex
    mpan
  sylbi
    (* C A) (* C B) y df-le
  sylibr
)

thm (lemul4 () ()
  (-> (<= (* A (S C)) (* B (S C)))  (<= A B))
  A  B  lenltt    biimpri   con1i
  B  A  df-lt    sylib
  B  A  x  df-le    biimpi    (-. (= B A)) anim1i    syl
  x  (= (+ B x) A)  (-. (= B A))  19.41    biimpri    syl
      x  (0)  B  addeq2    B  pa_ax3    syl6eq    A  eqeq1d    biimpd    com12    con3d
      (= (+ B x) A)  (-. (= B A))  (-. (= x (0)))    pm3.31    ax-mp
        (+ B x)  A  (S C)  muleq1
        (+ B x)  (S C)  mulcom    (S C)  B  x  distr   eqtr
        (S C)  B  mulcom    (* (S C) x)  addeq1i    eqtr    syl5eqr
        (-. (= B A)) adantr
      jca
      x  y  lefoo      ori
          z  (* (1) C)tyex
            z  (* (1) C)  (1) addeq2
            (1)  C  pa_ax6    (1)  (S C)  mulcom    eqtr3    (* (1) C)  (1)  addcom    eqtr3  eqcomi    syl6eq
          z  19.22i    ax-mp
          (1)  (* (S C) (1))  z  df-le    mpbir
          (1)  (* (S C) (1))  (* (S C) y)  leadd1    mpbi
            (+ (1) y)  x  (S C)  muleq2    (S C)  (1)  y  distr    syl5eqr
            (+ (1) (* (S C) y))  leeq2d    biimpd
          mpi
            (1)  (* (S C) y)  addge01t    (1)  (+ (1) (* (S C) y))  (* (S C) x)  letr
            (<= (1) (+ (1) (* (S C) y)))  (<= (+ (1) (* (S C) y)) (* (S C) x))  (<= (1) (* (S C) x))  pm3.3    ax-mp    ax-mp
          syl
      y  19.22i    syl    y  (<= (1) (* (S C) x))  19.9    sylib
      (1)  (* (S C) x)  (* B (S C))  leadd2    sylib
      (= (+ (* B (S C)) (* (S C) x)) (* A (S C)))  id    (+ (* B (S C)) (1))  leeq2d    biimpd    anim12i
     (<= (+ (* B (S C)) (1)) (+ (* B (S C)) (* (S C) x)))  (<= (+ (* B (S C)) (1)) (* A (S C)))  pm3.35    syl
    syl
  x  19.22i    syl    x  (<= (+ (* B (S C)) (1)) (* A (S C)))  19.9    sylib
  (* B (S C))  (* A (S C))  nnltp1let    biimpri    syl
  (* A (S C))  (* B (S C))  lenltt    biimpi    con2i    syl
  con4i
)

# Multiplication is strictly monotonic when the other multiplicand is nonzero
thm (ltmul1 () ()
  (-> (< (0) A) (-> (< B C) (< (* A B) (* A C))))
  (0) A (* A B) ltadd1
  (* A B) pa_ax3r (+ A (* A B)) lteq1i bitri
  A (* A B) addcom (* A B) lteq2i bitri
    A B (1) distr
    A mulid (* A B) addeq2i eqtr
    (* A B) lteq2i
  bitr4i biimpi
    B C nnltp1let
    (+ B (1)) C A lemul2 sylbi
  anim12i
  (* A B) (* A (+ B (1))) (* A C) lelttr2 syl ex
)

# Multiplication is strictly monotonic with nonzero multiplicand
thm (lemul5 () ()
  (<-> (<= (* A (S C)) (* B (S C))) (<= A B))
  A C B lemul4
    A B (S C) lemul2
    (S C) A mulcom (* (S C) B) leeq1i sylib
    (S C) B mulcom (* A (S C)) leeq2i sylib
  impbii
)

# Trichotomy law (may be a poor choice of name)
thm (lesym () ()
  (<-> (= A B) (/\ (<= A B) (<= B A)))
  # A=B -> A<=B
  B leid    (= A B) id B leeq1d    mpbiri
  # A=B -> B<=A
  A leid    (= A B) id A leeq1d    mpbii
  jca

  A B lenltt
  B A df-lt
  notbii   bitri
  (<= B A) (-. (= B A)) ianor
  bitri biimpi

  (<= B A) (-. (-. (= B A))) imor bicomi biimpi syl  imp
  (= B A) notnot2 syl
  eqcomd

  impbii
)

# For naturals, equal to zero is equivalent to less than or equal to zero
thm (eq0le0 () () (<-> (= A (0)) (<= A (0)))
     A (0) lesym
     # 0 <= A
     (0) A addge01t    A pa_ax3r (0) leeq2i     mpbi
   mpbiran2
)

# Less than or equal is a total relationship
thm (letot () () (\/ (<= A B) (<= B A))
(< B A)  id   (< B A)  (< B A)  imor    mpbi
   A  B  lenltt  biimpri
   B  A  df-lt    biimpi  pm3.26d
orim12i

ax-mp
)

# If a product of a nonzero number and some other number is zero, that number is zero
thm (mul0 () () (-> (= (* (S A) B) (0)) (= B (0)))
x  (* A B)  tyex
  x (* A B)  B  addeq1
  A  B  pa_ax6r        syl6eqr
  (0)  eqeq1d    biimprd  com12    x  B  addcom  (0)  eqeq1i   syl6ib
  x  19.22d
mpi
B  (0)  x  df-le  sylibr
B  eq0le0        sylibr
)

# Multiplication cancellation with nonzero multiplicand
thm (mulcan () ()
  (<-> (= (* A (S C)) (* B (S C))) (= A B))
  (* A (S C)) (* B (S C)) lesym
    A C B lemul5
      B C A lemul5
    anbi12i
  bitri
    A B lesym
  bitr4i
)

# Cancellation for multiplication (over nonzero multiplicand)
thm (mulcan2.1 () () (-> (<= A B) (-> (= (* (S C) A) (* (S C) B)) (= A B)))
  A  B  x  df-le  biimpi
    (+ A x)  B  (S C)  muleq2
    (S C)  A  x  distr  (* (S C) B)  eqeq1i  sylib  eqcomd
      (* (S C) A)  pa_ax3
      (* (S C) B)  eqeq1i  biimpri  eqcomd
      anim12i    (* (S C) B)  (+ (* (S C) A) (* (S C) x))  (+ (* (S C) A) (0))  ax-eqtr  syl
      (* (S C) A)  (* (S C) x)  (0)  addcan2  sylib
      C  x  mul0  syl     A   addeq2d
      ex  anc2li    (+ A x)  B  (+ A (0))  ax-eqtr  syl6   A  pa_ax3  B   eqeq2i  biimpi  eqcomd syl6
    x  19.22i  syl
       19.9d
)

# number 127.5
thm (mulcan2 () () (-> (= (* (S A) B) (* (S A) C)) (= B C))
  B  C  letot
    B  C  A  mulcan2.1
      C  B  A  mulcan2.1
      (* (S A) C)  (* (S A) B)  eqcom  (= C B)   imbi1i  sylib
      imp  eqcomd  ex

    jaoi
  ax-mp
)

thm (mulcant () ()
  (-> (< (0) C) (<-> (= (* A C) (* B C)) (= A B)))

  (0) C axlttri C nn0nlt0 (= (0) C) biorfi  (0) C eqcom bitr3i notbii bitri
  C x lefoo ori sylbi
  x a1suc x (1) addcom eqtr C eqeq1i x exbii sylibr

    (S x) C A muleq2 (S x) C B muleq2 eqeq12d
    A x B mulcan syl5rbbr x 19.23ai
  syl
)

thm (mulcant2 () ()
  (-> (< (0) C) (<-> (= (* C A) (* C B)) (= A B)))
  C A B mulcant
  A C mulcom B C mulcom eqeq12i syl5bbr
)

export (PEANO peano_ax.ghi (PROP PEANO_MIN) "")

# == Some naive set theory ==

import (NAIVE_SET naive_set.ghi (PROP PEANO_MIN PEANO) "")

tvar (set S T U V)


thm (eqri ((S x) (T x))
  (hyp (<-> (e. x S) (e. x T)))
  (=_ S T)
  hyp x gen S T x df-seq mpbir
)

# Set equality is reflexive
thm (seqid () () (=_ S S)
  (e. x S)  biid  x gen
  S  S  x  df-seq  biimpri  ax-mp
)

# Commutativity of set equality
thm (seqcom () () (<-> (=_ S T) (=_ T S))
  S  T  x  df-seq
    (e. x T)  (e. x S)  bicom
    x albii
  bitr4i
  T  S  x  df-seq
  bitr4i
)

thm (eleq2 () ()
  (-> (=_ S T) (<-> (e. A S) (e. A T)))
  S T x df-seq
    x A S ax-eleq1 x A T ax-eleq1 bibi12d
  cla4g sylbi
)

thm (eleq2i ()
  (hyp (=_ S T))
  (<-> (e. A S) (e. A T))
  hyp S T A eleq2 ax-mp
)

thm (abid ()
  (hyp (rwff x ph))
  (<-> (e. x ({|} x ph)) ph)
  x x ph ax-elab
    hyp x ph df-rwff mpbi a4i
  bitr4i
)

thm (elab ((A x) (ps x))
  (hyp (-> (= x A) (<-> ph ps)))
  (<-> (e. A ({|} x ph)) ps)
  A x ph ax-elab
  hyp sbcie bitri
)

thm (elab2 ((A x) (ps x))
  (hyp1 (-> (= x A) (<-> ph ps))
   hyp2 (=_ S ({|} x ph)))
  (<-> (e. A S) ps)
  hyp2 A eleq2i hyp1 elab bitri
)

thm (elin () ()
  (<-> (e. A (i^i S T)) (/\ (e. A S) (e. A T)))

  x A S ax-eleq1 x A T ax-eleq1 anbi12d
    S T x df-in
  elab2
)

# Problem: this theorem verified, but is not true, without
# constraints (S x) (T x). Consider S = {x + 1}, T = {x + 2}.
# The problem was that df-seq lacked these constraints, but needs them.
# Fixed.
thm (dfss2 ((S x) (T x)) ()
  (<-> (C_ S T) (A. x (-> (e. x S) (e. x T))))

  S T df-ss
    (e. x S) (e. x T) pm4.71 (e. x S) (/\ (e. x S) (e. x T)) bicom bitri

      x S T elin
      (e. x S) bibi1i
    bitr4i x albii
    (i^i S T) S x df-seq bitr4i

  bitr4i
)

thm (noel () ()
  (-. (e. A ({/})))

  A eqid
    (= x A) id (= x A) id eqeq12d notbid
      x df-emptyset
    elab2
  con2bii mpbi
)

thm (elsnc () ()
  (<-> (e. A ({} B)) (= A B))
  x A B eqeq1
    B x df-sn
  elab2
)

thm (snid () ()
  (e. A ({} A))
  A eqid
    A A elsnc
  mpbir
)

# Alpha conversion for set abstraction
thm (abeq ((ph y) (ps x))
  (h1 (-> (= x y) (<-> ph ps)))
  (=_ ({|} x ph) ({|} y ps))
  z  x  ph  ax-elab
  z  x  ph  y' df-subst    bitri
      z  y  ps  ax-elab
      z  y  ps  y' df-subst    bitri
          x  y  y'  ax-eqtr    ex
          y  x  y'  ax-eqtr    ex    eqcoms  impbid
          h1    anbi12d
          exalpha
          (= y' z)  anbi2i
          y'  exbii
      bitr4i
  bitr4i
  eqri
)

# Equality theorem for set abstraction
thm (abeq2 () ()
    (-> (A. x (<-> ph ps)) (=_ ({|} x ph) ({|} x ps)))
    x  (<-> ph ps)  ax-4
    y  x  sbcbid
    y  x  ph  ax-elab    syl5bb
    y  x  ps  ax-elab    syl6bbr
    y  19.21ai   ({|} x ph)  ({|} x ps)  y  df-seq    biimpri    syl
)

# Equality inference for set abstraction
thm (abeq2i () (h (<-> ph ps))
  (=_ ({|} x ph) ({|} x ps))
  h x gen x ph ps abeq2 ax-mp
)

# Equality deduction for set abstraction
thm (abeq2d ((ph x)) (h (-> ph (<-> ps ch)))
  (-> ph (=_ ({|} x ps) ({|} x ch)))
  h x 19.21ai x ps ch abeq2 syl
)

# Proofs in progress:

# thm (modlt () ()
#   (-> (< 0 B) (< (mod A B) B))
# ?)

# thm (modcyc () ()
#   (-> (< 0 B) (= (mod (+ A (* B C)) B) (mod A B)))
# ?)

# thm (modadd () ()
#   (-> (/\ (< 0 D) (= (mod A D) (mod B D)))
#    (= (mod (+ A C) D) (mod (+ B C) D)))
# ?)

# thm (divcan4 () ()
#   (-> (< 0 B) (= (div (* A B) B) A))
# ?)
#!

# == Ordered pair ==

# number 1.0
thm (opth1 () ()
   (-> (/\ (= A C) (= B D)) (= (<,> A B) (<,> C D)))
  A C B D addeq12 (+ A B) muleq1d
  A C B D addeq12 (+ A B) (+ C D) (+ C D) muleq2 syl eqtrd
  (= A C) (= B D) pm3.27
  addeq12d
  A B df-op C D df-op 3eqtr4g
)

# number 2.5
thm (nalexi () (hyp (-. (A. x (-. ph)))) (E. x ph)
  hyp x ph df-ex mpbir)

# number 4.0
thm (impexpi  () (hyp (-> (/\ ph ps) ch)) (-> ps (-> ph ch))
  hyp ancoms ps ph ch impexp mpbi)

# number 7.0
thm (lemul3lem1 () (hyp (-> ph (= (+ A B) C))) (-> ph (<= A C))
  A B addge01t
   hyp
   A leeq2d
  mpbii
)
# number 8.0
thm (lemul3lem2 () (hyp (-> ph (<= (+ A B) C))) (-> ph (<= A C))
  A B addge01t ph a1i
   hyp
  jca
    A (+ A B) C letr
  syl)
# number 9.0
thm (exani ((ps x)) (hyp (-> ph ps)) (-> (E. x ph) ps)
  hyp
  x 19.22i
  x ps 19.9 sylib)
# number 10.0

## <title> Inequality & Multiplication </title>
thm (lemul3 () ()
  (-> (/\(<= A B) (<= C D)) (<= (* A C) (* B D)))
  A B x df-le C D y df-le anbi12i
  x (= (+ A x) B) (E. y (= (+ C y) D)) 19.41 bitr4i
    y (= (+ A x) B) (= (+ C y) D) 19.29
    y (= (+ A x) B) 19.3
    sylanbr
  x 19.22i  sylbi

  (+ A x) B (+ C y) D muleq12
    A x C y distrl
  syl5eqr
 lemul3lem1 lemul3lem2
 y exani x exani syl)
# number 11.0
thm (lttr () ()
  (-> (/\ (< A B) (< B C)) (< A C))
  A B nnltp1let B C nnltp1let anbi12i biimpi
  B (1) addge01t
  (+ A (1)) B (+ B (1)) letr mpan2 (<= (+ B (1)) C) anim1i syl
  (+ A (1)) (+ B (1)) C letr syl
  A C nnltp1let sylibr)

# number 12.0
thm (addassrli () (h (= A (+ B (+ C D))))
   (= A (+ (+ B C) D))
   h
   B C D addass eqtr4)

thm (ltmul () () (
  -> (/\ (< A B) (< C D)) (< (* A C) (* B D)))
  A B nnltp1let C D nnltp1let anbi12i
  (+ A (1)) B (+ C (1)) D lemul3 sylbi

  (* A C) (+ (* (1) C) (* A (1))) addge01t
    (* A C) (* (1) C) (* A (1)) addass (* A C) leeq2i  mpbir
     (* A C) (+ (+ (* A C) (* (1) C)) (* A (1))) (1) leadd1 mpbi
    A (1) C (1) distrl addassrli
      (1) mulid (+ (+ (* A C) (* (1) C)) (* A (1))) addeq2i eqtr
      (+ (* A C) (1)) leeq2i
  mpbir
  jctil
  (+ (* A C) (1)) (* (+ A (1)) (+ C (1))) (* B D) letr syl
  (* A C) (* B D) nnltp1let sylibr)

# Squaring (of nonnegative numbers) is monotonic
thm (sqle () ()
  (<-> (<= A B) (<= (* A A) (* B B)))
  A B A B lemul3 anidms
  (* A A) (* B B) lenltt
    B A B A ltmul anidms con3i sylbi A B lenltt sylibr
  impbii)

# number 17.0
thm (muleq12d ()
  (hyp1 (-> ph (= A B))
   hyp2 (-> ph (= C D)))
  (-> ph (= (* A C) (* B D)))
  hyp1  hyp2
  jca
  A B C D muleq12
  syl
)
# number 18.0
thm (sqrtlem5 () ()
  (E. x (/\ (<= (* x x) (0)) (< (0) (* (S x) (S x)))))
   x (0) tyex
      (0) leid  (0) pa_ax5 (0) leeq1i  mpbir
   (= x (0)) id (= x (0)) id muleq12d  (0) leeq1d  mpbiri
     1nle0 (1) (0) lenltt mtbi notnotri
        (1) mulid  df-1 df-1  pm3.2i
        (1) (S (0)) (1) (S (0)) muleq12
      ax-mp eqtr3  (0) lteq2i
     mpbi
     (= x (0)) id  suceqd
     (= (S x) (S (0))) id (= (S x) (S (0))) id muleq12d syl (0) lteq2d mpbiri
  jca
  x 19.22i ax-mp
)
# number 19.0
thm (sqrtlem1 ((A x)) ()
  (-> (= y A)
     (<-> (E. x (/\ (<= (* x x) y) (< y (* (S x) (S x)))))
          (E. x (/\ (<= (* x x) A) (< A (* (S x) (S x)))))))
  (= y A) id (* x x) leeq2d
  (= y A) id (* (S x) (S x)) lteq1d
  anbi12d x exbid
)

# Commutation of conjuncts in consequent
thm (ancomd () (h (-> ph (/\ ps ch)))
  (-> ph (/\ ch ps))
  h
  ps ch ancom

 sylib
)

# number 24.0
thm (sqrtlem6 () ()
  (-> (E. x (/\ (<= (* x x) y) (< y (* (S x) (S x)))))
      (E. x (/\ (<= (* x x) (S y)) (< (S y) (* (S x) (S x))))))

  # y < x' * x' <-> case A \/ case B
  y (* (S x) (S x)) nnltp1let    (+ y (1)) (* (S x) (S x)) lefoo3     bitri

  # spruce this up by adding (... and PH) to both sides
  biimpi (<= (* x x) y) anim1i ancoms ancomd

  # For MUCH later, to factor out the common AND
  (<= (* x x) y)
    (= (+ y (1)) (* (S x) (S x)))
      (<= (+ (+ y (1)) (1)) (* (S x) (S x)))
  andi

  # We don't need this AND term, but Case B does, so add it in here
  (<= (* x x) y) (= (+ y (1)) (* (S x) (S x))) pm3.27

  # Tuck this away for "later"...
  z (S x) tyex

  # Case A -> x' * x' = y'
  y a1suc eqcomi    (+ y (1)) (* (S x) (S x)) (S y)  eqeq1     mpbii

  # Case A -> x' * x' <= y'
  (* (S x) (S x)) leid
  (= (* (S x) (S x)) (S y)) id (* (S x) (S x)) leeq2d mpbii
  # Introduce z as x'
  (= z (S x)) id   (= z (S x)) id   muleq12d   (S y) leeq1d     biimprcd  syl


  # x' < x''
  (+ (S x) (1)) leid   (S x) a1suc  (+ (S x) (1)) leeq2i  mpbir   (S x) (S (S x)) nnltp1let    mpbir
  # x' * x' < x'' * x''
  (< (S x) (S (S x))) pm4.24  mpbi (S x) (S (S x)) (S x) (S (S x)) ltmul  ax-mp
  # Case A -> y' < x'' * x''
  (= (* (S x) (S x)) (S y)) id (* (S (S x)) (S (S x))) lteq1d mpbii
  (= z (S x)) id suceqd  (= z (S x)) id suceqd   muleq12d (S y) lteq2d
      biimprcd syl

  # Join it all up for case A
  jcad syl  z 19.21ai
  z (= z (S x)) (/\ (<= (* z z) (S y)) (< (S y) (* (S z) (S z))))  19.22 syl
  # ... and it's finally "later".
  mpi
  # Bring in the extra AND clause
  syl

  # Okay, time to consider Case B
  # Tuck this away for "later"...
  z x tyex

  # y <= y'
  y (1) addge02t y a1suc y (1) addcom eqtr y leeq2i mpbir
  # x*x <=y -> x*x <= y'
  (* x x) y (S y) letr mpan2

  # y + 1 + 1 < x' * x' -> y + 1 < x' * x'
  (+ y (1)) (* (S x) (S x)) nnltp1let  biimpri
  # ... -> y' < x' * x'
  y a1suc  (* (S x) (S x))  lteq1i  sylibr

  # Join up case B
  anim12i
  # Now to add the z
  # z=x -> z*z<=y' <-> x*x<=y'
  z x z x muleq12 anidms (S y) leeq1d
  # z=x -> y'<z'*z'<-> y'<x'*x'
  z x pa_ax2 biimpi   z x pa_ax2 biimpi muleq12d (S y) lteq2d
  # put it all together
  anbi12d biimprcd syl
  z 19.21ai
  z (= z x) (/\ (<= (* z z) (S y)) (< (S y) (* (S z) (S z))))  19.22  syl
  # And it's finally "later" again.
  mpi


  # Unify the cases
  jaoi
  # Now it is MUCH later, time to factor
  sylbi
  # Both cases are handled!
  syl

  # Existential plumbing
  x  19.22i 19.9d
  # alpha switch
  z x z x muleq12 anidms (S y) leeq1d
  z x pa_ax2 biimpi   z x pa_ax2 biimpi muleq12d (S y) lteq2d
  anbi12d exalpha sylib
)

# Square root
thm (sqrt ((A x)) ()
   (E. x (/\ (<= (* x x) A) (< A (* (S x) (S x)))))
  z (0) x sqrtlem1
  z y x sqrtlem1
  z (S y) x sqrtlem1
  z A x sqrtlem1
  x sqrtlem5
  x y sqrtlem6
  finds
)

# Square root is monotonic
thm (sqlt () () (<-> (< A B) (< (* A A) (* B B)))
  B A sqle
  notbii
  (* B B) (* A A) lenltt
  notbii bitri
  (< (* A A) (* B B)) notnot bicomi bitri

  B A lenltt notbii
  bitr3i
  (< A B) notnot bicomi bitri bicomi
)

# number 28.0
thm (lesuc () ()
  (<-> (< A (S B)) (<= A B))
   A (S B) nnltp1let
   B a1suc   (+ A (1)) leeq2i bitri
   A B (1) leadd1 bicomi bitri
)

# Square root is unique
thm (sqrtuniq () ()
   (-> (/\ (/\ (<= (* A A) B) (< B (* (S A) (S A))))
           (/\ (<= (* C C) B) (< B (* (S C) (S C)))))
   (= A C))

   # Diddle with and ordering
   (<= (* C C) B)  (< B (* (S C) (S C)))  ancom
      (/\ (<= (* A A) B)    (< B (* (S A) (S A)))) anbi2i
   (<= (* A A) B) (< B (* (S A) (S A)))
      (< B (* (S C) (S C)))    (<= (* C C) B)    an4
   bitri

   (* A A) B (* (S C) (S C)) lelttr
   (* C C) B (* (S A) (S A)) lelttr ancoms anim12i
   sylbi

   # ... -> A < C' /\ C < A'
   A (S C) sqlt  C (S A) sqlt anbi12i  biimpri syl

   A C lesuc   C A lesuc
   anbi12i
   A C lesym bicomi bitri biimpi syl
)

# number 30.0
thm (opthlem1 () ()
   (/\ (<= (* (+ A B) (+ A B)) (+ (* (+ A B) (+ A B)) B))
       (< (+ (* (+ A B) (+ A B)) B) (* (S (+ A B)) (S (+ A B)))))
 # First part is easy
 (* (+ A B) (+ A B)) B  addge01t

   # A + B <= A + B
   (+ A B) leid
   # A + B <= (A + B)'
   (+ A B)  (1) addge01t  (+ A B) a1suc (+ A B) leeq2i mpbir
 # Now multiply them out
 (+ A B) (+ A B) (+ A B) (S (+ A B)) lemul3 mp2an

 # Throw in a free A on the right side
 (* (+ A B) (S (+ A B))) A addge01t
 (* (+ A B) (+ A B)) (* (+ A B) (S (+ A B))) (+  (* (+ A B) (S (+ A B))) A) letr mp2an
 # And add B to each side
 (* (+ A B) (+ A B)) (+ (* (+ A B) (S (+ A B))) A)  B leadd1 mpbi
 # Convert le to lt using suc
(+ (* (+ A B) (+ A B)) B) (+ (+ (* (+ A B) (S (+ A B))) A)  B) lesuc mpbir


 # Expand left side of (A+B)'**2 and distribute.
 (+ A B) a1suc (S (+ A B)) muleq1i
 (+ A B) (1) (S (+ A B)) distl eqtr
 # Remove 1*
 (S (+ A B)) (1) mulcom   (S (+ A B)) mulid eqtr3     (* (+ A B) (S (+ A B))) addeq2i eqtr
 # Expand (A+B)'
 (+ A B) a1suc (* (+ A B) (S (+ A B))) addeq2i eqtr
 # Pull the 1 out to the right and reassoc
 addassrli
 (* (+ A B) (S (+ A B))) A B addass (1) addeq1i eqtr4
 # Convert the +1 to a suc

 (+ (+ (* (+ A B) (S (+ A B))) A) B)  a1suc eqtr4
 (+ (* (+ A B) (+ A B)) B)  lteq2i mpbir

 pm3.2i
)
# number 31.0
thm (opthlem2 () ()
    (-> (= (<,> A B) (<,> C D)) (= (+ C D) (+ A B)))

    A B opthlem1

    A B df-op (<,> C D) eqeq1i biimpi  C D df-op  syl6eq
    (* (+ A B) (+ A B)) leeq2d
    A B df-op (<,> C D) eqeq1i biimpi  C D df-op  syl6eq
    (* (S (+ A B)) (S (+ A B))) lteq1d
    anbi12d
  mpbii

  C D opthlem1
  (+ C D) (+ (* (+ C D) (+ C D)) D) (+ A B) sqrtuniq
  mpan

  syl
)
# number 32.0
thm (opthlem3 () ()
    (-> (= (<,> A B) (<,> C D)) (= B D))
  A B C D opthlem2

  # Duplicate the conclusion
  (= (<,> A B) (<,> C D)) (= (+ C D) (+ A B)) anidmdbi mpbir
  # Square the conclusion
  (+ C D) (+ A B) (+ C D) (+ A B) muleq12 syl

  eqcomd B addeq1d eqcomd

  A B df-op (<,> C D) eqeq1i biimpi  C D df-op  syl6eq

  eqtrd
  (* (+ C D) (+ C D)) B D addcan2
  sylib
)

# Ordered pair theorem
thm (opth () ()
    (<-> (= (<,> A B) (<,> C D)) (/\ (= A C) (= B D)))
  A B C D opthlem2

    A B C D opthlem3
    A B D addcan2
  sylibr

  eqtrd
  C D A addcan
  sylib
  eqcomd
  A B C D opthlem3
  jca
  A C B D opth1



 impbii
)

# number 78.0
thm (opeq2 () () (-> (= A B) (= (<,> C A) (<,> C B)))
  A  B  C  addeq2
  A  B  C  addeq2  jca
  (+ C A)  (+ C B)  (+ C A)  (+ C B)  muleq12    syl
  ancri
  (* (+ C A) (+ C A))  (* (+ C B) (+ C B))  A  B  addeq12    syl
  C  A  df-op       syl5eq
  C  B  df-op       syl6eqr
)
# number 78.5
thm (opeq1 () () (-> (= A B) (= (<,> A C) (<,> B C)))
    A  B  C  addeq1    A  B  C  addeq1    jca
    (+ A C) (+ B C) (+ A C) (+ B C) muleq12    syl
    C  addeq1d
        A  C  df-op
    syl5eq
    B  C  df-op   syl6eqr
)
# number 79.0
thm (df-tail-just ((A x) (A y') (A y) (A z)) ()
    (= (iota ({|} x (E. y (= (<,> y x) A))))
       (iota ({|} z (E. y' (= (<,> y' z) A)))))
  x  z  y  opeq2  A  eqeq1d    y  exbid
  y  y'  z  opeq1    A  eqeq1d   exalpha   syl6bb    abeq
  ({|} x (E. y (= (<,> y x) A)))  ({|} z (E. y' (= (<,> y' z) A)))    ax-iotaeq    ax-mp
)
defthm  (df-tail nat (tail A) ((A x) (A y')) ()
  (= (tail A)  (iota ({|} x (E. y' (= (<,> y' x) A)))))
  z  y  A  x  y'  df-tail-just)

# number 80.0
thm (tailop () () (= (tail (<,> A B)) B)
  (<,> A B)  x  z  df-tail
    z  x  A  B  opth    z  exbii
    z  (= z A)  (= x B)  19.41   bitri
    z  A  tyex    (E. z (= z A))  (= x B)  ibar    ax-mp    bitr4i
    x  gen    x  (E. z (= (<,> z x) (<,> A B)))  (= x B)  abeq2    ax-mp
    ({|} x (E. z (= (<,> z x) (<,> A B))))  ({|} x (= x B))  ax-iotaeq    ax-mp
  eqtr
  B  x df-sn    ({} B)  ({|} x (= x B))  ax-iotaeq    ax-mp    eqtr4
  B  ax-iota    eqtr
)
# number 81.0
thm (df-head-just ((A x) (A y') (A y) (A z)) ()
    (= (iota ({|} x (E. y (= (<,> x y) A))))
       (iota ({|} z (E. y' (= (<,> z y') A)))))
  x  z  y  opeq1  A  eqeq1d    y  exbid
  y  y'  z  opeq2    A  eqeq1d   exalpha   syl6bb    abeq
  ({|} x (E. y (= (<,> x y) A)))  ({|} z (E. y' (= (<,> z y') A)))   ax-iotaeq    ax-mp
)
defthm  (df-head nat (head A) ((A x) (A y')) ()
  (= (head A)  (iota ({|} x (E. y' (= (<,> x  y') A)))))
  z  y  A  x  y'  df-head-just)

# number 83.0
thm (headop () () (= (head (<,> A B)) A)
  (<,> A B)  x  z  df-head


    x  z  A  B  opth    z  exbii
    z  (= x A)  (= z B)  19.41r   bitri
    z  B  tyex    (E. z (= z B))  (= x A)  iba    ax-mp    bitr4i
    x  gen    x  (E. z (= (<,> x z) (<,> A B)))  (= x A)  abeq2    ax-mp
    ({|} x (E. z (= (<,> x z) (<,> A B))))  ({|} x (= x A))  ax-iotaeq    ax-mp
  eqtr
  A  x df-sn    ({} A)  ({|} x (= x A))  ax-iotaeq    ax-mp    eqtr4
  A  ax-iota    eqtr
)

# Equality theorem for head
thm (headeq () () (-> (= A B) (= (head A) (head B)))
  A  B  (<,> x y)  eqeq2  y  exbid   x  19.21ai
  x  (E. y (= (<,> x y) A))  (E. y (= (<,> x y) B))  abeq2    syl
  ({|} x (E. y (= (<,> x y) A)))  ({|} x (E. y (= (<,> x y) B)))  ax-iotaeq  syl
  A  x  y  df-head  syl5eq
  B  x  y  df-head  syl6eqr
)

# Equality theorem for tail
thm (taileq () () (-> (= A B) (= (tail A) (tail B)))
  A  B  (<,> y x)  eqeq2  y  exbid  x  19.21ai
  x (E. y (= (<,> y x) A))  (E. y (= (<,> y x) B))  abeq2  syl
  ({|} x (E. y (= (<,> y x) A)))  ({|} x (E. y (= (<,> y x) B)))  ax-iotaeq  syl
  A  x  y  df-tail  syl5eq
  B  x  y  df-tail  syl6eqr
)

# == Iota ==

thm (ex-nf ((ph x)) () (-> (E. x ph) ph)
  x ph 19.9 biimpi
)

# Existential uniqueness implies iota is a member
thm (iotacl ((S x)) ()
   (-> (E! x (e. x S)) (e. (iota S) S))
  x (e. x S) y df-eu biimpi


    x y elsnc (e. x S)  bibi2i x gen 19.15i biimpri
    S ({} y) x  df-seq biimpri
  syl
  y 19.22i syl

  S ({} y) ax-iotaeq y ax-iota  syl6eq
  (iota S) y elsnc  sylibr
  S ({} y) (iota S) eleq2

  biimprd mpd y 19.22i
  syl
    y (e. (iota S) S) ex-nf
  syl
)

# Another iota utility theorem.  Asserts that if exactly one x has the property
# ph, then that x can be found using iota.
thm (iotacl2 () ()
   (-> (E! x ph) (e. (iota ({|} x ph)) ({|} x ph)))
x  ph  y  df-eu   biimpi
  x  ph  (= x y)  abeq2
    ({|} x ph)  ({|} x (= x y))  ax-iotaeq
      y  x  df-sn    ({} y)  ({|} x (= x y))  ax-iotaeq  ax-mp
  y  ax-iota       eqtr3     (iota ({|} x ph))  eqeq2i  biimpi    syl  syl
   (iota ({|} x ph))  y  x  ph  dfsbcq   biimprd  syl
   (iota ({|} x ph))  x  ph  ax-elab   syl6ibr
    ph  (= x y)  bi2  x  19.20i
    x  (-> (= x y) ph)  y  a4sbc    syl

    y  x  (-> (= x y) ph)  z  df-subst   sylib
    x  (= z y)  (/\ (= x z) (-> (= x y) ph))  19.41l   biimpri  z  19.22i    #syl
      # ugh.
      (= z y)  (= x z)  (-> (= x y) ph)  anass
        (= z y)  (= x z)  (-> (= x y) ph)  anass
          (= z y)  (= x z)  (-> (= x y) ph)  anass
          z  y  x  ax-eqtr   z  x  eqcom        sylan2br   (-> (= x y) ph)  anim1i     sylbir
          y  x  eqcom    biimpi    (-> (= x y) ph)  anim1i  syl
         (= x y)  ph  pm3.35    syl
        sylbi  (/\ (= z y) (= x z))  (-> (= x y) ph)  ph  pm5.3      mpbi
       sylbir
      (= z y)  (= x z)  ph  anass  sylib
     x  19.22i  z  19.22i  syl
    x  (= z y)  (/\ (= x z)  ph)  19.41l  biimpi  z  19.22i  syl
   syl
   y  x  ph  z  df-subst    sylibr
 jca
 ([/] y x ph)  (e. (iota ({|} x ph)) ({|} x ph))  pm3.35  ancoms  syl
 y  19.22i  syl
 y  (e. (iota ({|} x ph)) ({|} x ph))  ex-nf  syl
)

# Basic identity for iota
thm (iotaeq () ()
  (= (iota ({|} x (= x A))) A)
  A x df-sn
  ({} A) ({|} x (= x A)) ax-iotaeq ax-mp eqcomi
  A ax-iota eqtr
)

# == Ternary conditional for naturals ==

# Ternary expressions for naturals: (ph ? A : B)
thm (df-ifn-just ((ph x y) (A x y) (B x y)) () (=
  (iota ({|} x (\/ (/\ ph (= x A)) (/\ (-. ph) (= x B)))))
  (iota ({|} y (\/ (/\ ph (= y A)) (/\ (-. ph) (= y B))))))

  x  y  A  eqeq1
  ph  anbi2d
    x  y  B  eqeq1
    (-. ph)  anbi2d
  orbi12d
  abeq
  ({|} x (\/ (/\ ph (= x A)) (/\ (-. ph) (= x B))))  ({|} y (\/ (/\ ph (= y A)) (/\ (-. ph) (= y B))))  ax-iotaeq    ax-mp
)

defthm (df-ifn nat (ifn ph A B) ((ph x) (A x) (B x)) ()
  (= (ifn ph A B)   (iota ({|} x (\/ (/\ ph (= x A)) (/\ (-. ph) (= x B))))))
  y  ph  A  B  x  df-ifn-just)

# First branch of ternary expression.
thm (ifn1 () () (-> ph (= (ifn ph A B) A))
     ph  (= x A)  iba
     ph  (= x A)  ancom    syl6bbr
       (-. ph)  (= x B)  pm3.26    con2i
       (/\ (-. ph) (= x B))  (/\ ph (= x A))  biorf    syl
         (/\ (-. ph) (= x B))  (/\ ph (= x A))  orcom
       syl6rbb
     bitr4d
     x  19.21ai
       x  (= x A)  (\/ (/\ ph (= x A)) (/\ (-. ph) (= x B)))  abeq2
     syl
     ({|} x (= x A))  ({|} x (\/ (/\ ph (= x A)) (/\ (-. ph) (= x B))))  ax-iotaeq    syl
         ph  A  B  x  df-ifn
      syl6eqr
      eqcomd
        A  x  df-sn
          ({} A)  ({|} x (= x A))  ax-iotaeq    ax-mp
        syl6eqr
      A  ax-iota    syl6eq
)

# Second branch of ternary expression.
thm (ifn2 () () (-> (-. ph) (= (ifn ph A B) B))
     (-. ph)  (= x B)  iba
     (-. ph)  (= x B)  ancom    syl6bbr
       ph  (= x A)  pm3.26    con3i
       (/\ ph (= x A))  (/\ (-. ph) (= x B))  biorf    syl
       bitr2d
       x  19.21ai
         x  (\/ (/\ ph (= x A)) (/\ (-. ph) (= x B)))  (= x B)  abeq2
       syl
     ({|} x (\/ (/\ ph (= x A)) (/\ (-. ph) (= x B))))  ({|} x (= x B))  ax-iotaeq    syl
     eqcomd
         ph  A  B  x  df-ifn
      syl6eqr
      eqcomd
        B  x  df-sn
          ({} B)  ({|} x (= x B))  ax-iotaeq    ax-mp
        syl6eqr
      B  ax-iota    syl6eq
)

# Equivalence of predicate in ifn
thm (ifnbi () () (-> (<-> ph ps) (= (ifn ph A B) (ifn ps A B)))
  ph ps dfbi3
    ph A B ifn1 ps adantr ps A B ifn1 ph adantl eqcomd eqtrd
      ph A B ifn2 (-. ps) adantr ps A B ifn2 (-. ph) adantl eqcomd eqtrd
    jaoi
  sylbi
)

# Equality of first term for ifn
thm (ifneq1 () () (-> (= A B) (= (ifn ph A C) (ifn ph B C)))
  ph A C ifn1 B eqeq1d biimprd imp
  ph B C ifn1 (= A B) adantr eqcomd eqtrd ex
    ph A C ifn2
    ph B C ifn2 eqcomd eqtrd (= A B) a1d
  pm2.61i
)

# Equality of second term for ifn
thm (ifneq2 () () (-> (= A B) (= (ifn ph C A) (ifn ph C B)))
  ph C A ifn1
  ph C B ifn1 eqcomd eqtrd (= A B) a1d
    ph C A ifn2 B eqeq1d biimprd imp
    ph C B ifn2 (= A B) adantr eqcomd eqtrd ex
  pm2.61i
)

# == Subtraction over natural numbers ==

# Justification for definition of halfminus
thm (df-halfminus-just ((A x y) (B x y)) ()
  (= (ifn (< A B) (0) (iota ({|} x (= A (+ B x)))))
    (ifn (< A B) (0) (iota ({|} y (= A (+ B y))))))
  x y B addeq2 A eqeq2d abeq
  ({|} x (= A (+ B x))) ({|} y (= A (+ B y))) ax-iotaeq ax-mp
  (iota ({|} x (= A (+ B x)))) (iota ({|} y (= A (+ B y)))) (< A B) (0) ifneq2 ax-mp
)

# Definition of "half minus"
defthm (df-halfminus nat (.- A B) ((A x) (B x)) ()
  (= (.- A B) (ifn (< A B) (0) (iota ({|} x (= A (+ B x))))))
  A B y x df-halfminus-just
)

# Minus is the inverse of addition
thm (halfminus () ()
  (-> (<= B A) (= (+ (.- A B) B) A))
  B A lenltt
  (< A B) (0) (iota ({|} x (= A (+ B x)))) ifn2 sylbi
  A B x df-halfminus syl5eq
  B addeq1d
    B A x df-le
    (+ B x) A eqcom x exbii bitri

      A (+ B x) (+ B y) ax-eqtr
      B x y addcan2 sylib
      y gen x gen (E. x (= A (+ B x))) biantru bitri
      x y B addeq2 A eqeq2d eu4
    bitr4i

      x (= A (+ B x)) iotacl2
    sylbi

      x (iota ({|} x (= A (+ B x)))) B addeq2 A eqeq2d elab
    sylib
    B (iota ({|} x (= A (+ B x)))) addcom syl6eq
  eqcomd eqtrd
)

# A number minus zero is itself
thm (halfminuszero () () (= (.- A (0)) A)
  (.- A (0)) pa_ax3 eqcomi
    A nn0nlt0 (0) A lenltt mpbir
    (0) A halfminus ax-mp
  eqtr
)

# A number minus itself is zero
thm (halfminusid () () (= (.- A A) (0))
  A leid A A halfminus ax-mp
  A pa_ax3r eqcomi eqtr
  (.- A A) A (0) addcan mpbi
)

# == Division, primality ==

# number 36.5
thm (df-divides-just ((A x) (B x) (A y) (B y)) ()
       (<-> (E. x (= (* A x) B)) (E. y (= (* A y) B)))
      x y A muleq2 B eqeq1d exalpha)

## <title> Divides Definition </title>
defthm (df-divides wff (| A B) ((A x) (B x)) ()
       (<-> (| A B) (E. x (= (* A x) B)))
        y A B x df-divides-just)

# number 37.0
thm (divideseq1imp () ()
  (-> (= A B) (-> (| A C) (| B C)))

  (= A B) z alnfi

    A B z muleq1    (= (* A z) C) anim1i
    (* A z) C (* B z) ax-eqtr   eqcomd   ancoms
  syl    ex


    z gen  z (= A B) (-> (= (* A z) C) (= (* B z) C)) ax-alim   ax-mp
  syl
    z (= (* A z) C) (= (* B z) C) 19.22
  syl


  A C z df-divides
  syl5ib


  B C z df-divides
  (| A C) imbi2i
  sylibr
)
# number 38.1
thm (divideseq1 () ()
  (-> (= A B) (<-> (| A C) (| B C)))

  A B C divideseq1imp
  B A C divideseq1imp eqcoms
    impbid
)
# Equality inference for the divides relation.
thm (divideseq1i ()
  (hyp (= A B))
  (<-> (| A C) (| B C))
  hyp A B C divideseq1 ax-mp
)
# Equality inference for the divides relation.
thm (divideseq1ii ()
  (hyp1 (| A C)
   hyp2 (= A B))
  (| B C)
  hyp1 hyp2 C divideseq1i mpbi
)
# number 39.0
thm (df-prime-just ((A x) (A y)) ()
    (<-> (A. x (-> (| x A) (\/ (= x (1)) (= x A))))
         (A. y (-> (| y A) (\/ (= y (1)) (= y A)))))
    x y A divideseq1
    x y (1) eqeq1
    x y A eqeq1  orbi12d
  imbi12d
  alpha
)

## <title> Prime Definition </title>
defthm (df-prime wff (prime A) ((A x))  ()
  (<-> (prime A) (A. x (-> (| x A) (\/ (= x (1)) (= x A)))))
y A x df-prime-just)

tvar (wff et zi si)
# number 40.0
## <title> Natural Number </title>
thm (0orpos () () (\/ (= A (0)) (<= (1) A))
  # x = 0 \/ 1<= x
    A z lefoo
    (1) A z df-le    (= A (0)) orbi2i
  mpbir
)

## <title> Definition of 2 </title>
defthm (df-2 nat (2) () () (= (2) (+ (1) (1)))
        (+ (1) (1)) eqid)

## <title> Definition of 3 </title>
defthm (df-3 nat (3) () () (= (3) (+ (2) (1)))
        (+ (2) (1)) eqid)

## <title> Definition of 4 </title>
defthm (df-4 nat (4) () () (= (4) (+ (3) (1)))
        (+ (3) (1)) eqid)
				
## <title> Definition of 5 </title>
defthm (df-5 nat (5) () () (= (5) (+ (4) (1)))
        (+ (4) (1)) eqid)
				
## <title> Definition of 6 </title>
defthm (df-6 nat (6) () () (= (6) (+ (5) (1)))
        (+ (5) (1)) eqid)
				
## <title> Definition of 7 </title>
defthm (df-7 nat (7) () () (= (7) (+ (6) (1)))
        (+ (6) (1)) eqid)
				
## <title> Definition of 8 </title>
defthm (df-8 nat (8) () () (= (8) (+ (7) (1)))
        (+ (7) (1)) eqid)
				
## <title> Definition of 9 </title>
defthm (df-9 nat (9) () () (= (9) (+ (8) (1)))
        (+ (8) (1)) eqid)
				
## <title> Definition of 10 </title>
defthm (df-10 nat (10) () () (= (10) (+ (9) (1)))
        (+ (9) (1)) eqid)

thm (2p2eq4 () () (= (+ (2) (2)) (4))
  df-2
  (2) addeq2i
  ## <d>
    (2) (1) (1) addass
    eqcomi
  ## </d>
  eqtr
  ## <d>
    df-3
    eqcomi
    (1) addeq1i
  ## </d>
  eqtr
  ## <d>
    df-4
    eqcomi
  ## </d>
  eqtr
)

# number 42.0
## <title> Basic Inequality </title>
thm (0ne2 () () (-. (= (0) (+ (1) (1))))
    (1) pa_ax1  (1) a1suc (0) eqeq2i  mtbi #  (= (* x y) (+ (1) (1)))  mt2bi bicomi
)
# number 43.0
#jctil with hyps listed backwards
thm (jctilb () (h1 ch h2 (-> ph ps)) (-> ph (/\ ch ps))
  h2 h1 jctil
)
# number 44.0
## <title> 2 is Prime Lemma </title>
thm (2primelem1 ()
  (h1 (\/ ph ps)
   h2 (\/ ch (\/ th (\/ ta et)))
   h3 (-> (/\ ps et) (-. si))
   h4 (-> ph (-. si))
   h5 (-> ch (-. si)))
   (-> si (\/ th ta))

  h4 con2i
  h1 ph ps df-or mpbi syl
  h3  con2i  ps et ianor sylib    ps et pm4.62 sylibr   mpd
  h5 con2i
  h2  ch (\/ th (\/ ta et)) df-or mpbi syl
  th ta et 3orass sylibr
  th ta et df-3or sylib   (\/ th ta) et df-or sylib con1d   mpd
)
# number 45.0
## <title> 2 is Prime </title>
thm (2prime () () (prime (+ (1) (1)))
  ## <d>
    x (+ (1) (1)) y df-divides
  ## </d>

  # y is 0 or >=1.
  y 0orpos
  # x is 0, 1 2, or >= 3
  x 0orpos
  ## <d>
    (1) x lefoo3    (= x (0)) orbi2i
  ## </d>
  mpbi
  ## <d>
    (+ (1) (1)) x lefoo3   (= (1) x) orbi2i (= x (0)) orbi2i
  ## </d>
  mpbi


  # 1<=y and 3<=x means x * y >= 1*3
  (1) y (+ (+ (1) (1)) (1)) x lemul3
  # replace 1*3  with 3
  ## <d>
    (+ (+ (1) (1)) (1)) mulid
    (+ (+ (1) (1)) (1)) (1) mulcom
    eqtr3
    (* y x) leeq1i
    bicomi
  ## </d>

  sylib
  # but it's not true that 3 <= 2
  ## <d>
    1nle0
    ## <d>
      (1) (0) (+ (1) (1)) leadd2
      ## <d>
        (+ (1) (1)) pa_ax3 (+ (+ (1) (1)) (1)) leeq2i
      ## </d>
      bitri   notbii
    ## </d>
  ## </d>
  mpbi

  # so this line of reasoning means that x * y != 2
  ## <d>
    x y mulcom
    (+ (1) (1)) eqeq1i
    biimpi (+ (+ (1) (1)) (1)) leeq2d
  ## </d>
  mtbiri  con2i  syl

  # y=0 can't give us x*y = 2
  0ne2
  ## <d>
    y (0) x muleq2
    ## <d>
      x pa_ax5
    ## </d>
    syl6eq
    (+ (1) (1)) eqeq1d
    biimpd
  ## </d>
  mtoi

  # x=0 can't give us x*y = 2 either
  0ne2
  ## <d>
    x (0) y muleq1
    ## <d>
      y pa_ax5r
    ## </d>
    syl6eq
    (+ (1) (1)) eqeq1d
    biimpd
  ## </d>
  mtoi

  # That's all the math -- from here on out it's juggling predicates,
  # connectives, and quantifiers. If the verifier autounified I
  # wouldn't have to carry around all the mandhyps baggage. Instead I
  # tried to tuck most of it away in a lemma.
  2primelem1

  ## <d>
    (1) x eqcom   (= (+ (1) (1)) x) orbi1i
  ## </d>
  sylib
  ## <d>
    (+ (1) (1)) x eqcom (= x (1)) orbi2i
  ## </d>
  sylib
  y 19.22i
  ## <d>
    y (\/ (= x (1)) (= x (+ (1) (1)))) 19.9
  ## </d>
  sylib
  sylbi

  x gen
  ## <d>
    (+ (1) (1)) x df-prime
  ## </d>
  mpbir
)
# number 46.0
thm (dividesmul () ()
    (-> (| A B) (| A (* B C)))
  A B x df-divides biimpi

   y (* x C) tyex
   y (* x C) A muleq2   y 19.22i
  ax-mp

  (* A x) B C muleq1
  A x C mulass  syl5eqr
  (* A y) eqeq2d
  biimpd

  y 19.21ai    y (= (* A y) (* A (* x C))) (= (* A y) (* B C)) 19.22 syl

  mpi
  x 19.22i syl
  x (E. y (= (* A y) (* B C))) 19.9   biimpi  syl

  A (* B C) y df-divides   biimpri   syl
)

# number 47.0
# Induction tool for exfactorial
thm (exfactorial.1 ((A x) (A y)) ()
    (-> (= z A)
        (<-> (E. x (A. y (-> (<= (S y) (S z)) (| (S y) (S (S x))))))
             (E. x (A. y (-> (<= (S y) (S A)) (| (S y) (S (S x))))))))

   (= z A) id  suceqd
   (= (S z) (S A)) id (S y) leeq2d syl
   (| (S y) (S (S x))) imbi1d
   y 19.21ai
   19.15d
   x exbid
)

# number 47.0
# Induction tool for exfactorial
thm (exfactoriallem1 ((A x) (A y)) ()
    (-> (= z A)
        (<-> (E. x (A. y (-> (<= (S (S y)) (S (S z))) (| (S (S y)) (S (S x))))))
             (E. x (A. y (-> (<= (S (S y)) (S (S A))) (| (S (S y)) (S (S x))))))))

   (= z A) id  suceqd      (= (S z) (S A)) id  suceqd  syl
   (= (S (S z)) (S (S A))) id (S (S y)) leeq2d syl
   (| (S (S y)) (S (S x))) imbi1d
   y 19.21ai
   19.15d
   x exbid
)

# number 48.0
thm (divideseq2imp () ()
  (-> (= A B) (-> (| C A) (| C B)))


  A B (* C z) eqeq2    biimpd
  z 19.22d
  C B z df-divides biimpri    syl6

  C A z df-divides biimpi

  syl5
)
# number 49.0
thm (divideseq2 () ()
  (-> (= A B) (<-> (| C A) (| C B)))
   A B C divideseq2imp
   B A C divideseq2imp eqcoms
  impbid
)

# number 51.0
thm (dividessym () () (| A A)
    x (1) tyex
    x (1) A muleq2  eqcomd  A mulid  eqcomi syl5eq   eqcomd  x 19.22i
  ax-mp
  A A x df-divides
  mpbir
)
# number 52.0
# Base case for induction in exfactorial
thm (exfactorial.2 () ()
  (E. x (A. y (-> (<= (S y) (S (0))) (| (S y) (S (S x))))))

  x (0) tyex

  # (for later, prove 1 | 2)
  x  (S (S (0))) tyex
   x  (S (S (0)))  (S (0)) muleq2
    df-1   (S (S (0))) muleq1i  (1)  (S (S (0)))  mulcom  eqtr3
    (S (S (0))) mulid   eqtr
   syl6eq
  x  19.22i  ax-mp
  (S (0))  (S (S (0)))  x  df-divides  mpbir

  # Prove y'<= 0' -> y' = 0'
    y (0) (1) leadd1
    y a1suc (+ (0) (1)) leeq1i
  bitr4i
   (0) a1suc
   (S y) leeq2i bitr4i
  biimpri
  y eq0le0 sylibr
  suceqd

  # ... -> y' | 0''  (it's later)
    (S y) (S (0)) (S (S (0))) divideseq1  syl  biimprd
  mpi

  # ... which is the same as y'' | x'' when x=0
     (= x (0)) a1i
     x (0) eqcom biimpi suceqd suceqd    (S (S (0))) (S (S x)) (S y) divideseq2   syl  biimpd
  syld

  y 19.21ai
  x 19.22i ax-mp
)
# number 52.0
# Base case for induction in exfactorial
thm (exfactoriallem2 () ()
  (E. x (A. y (-> (<= (S (S y)) (S (S (0)))) (| (S (S y)) (S (S x))))))

  x (0) tyex

  # (for later)
    (S (S (0))) dividessym
  # Prove y''<= 0'' -> y'' = 0''
    y (0) (1) leadd1
    y a1suc (+ (0) (1)) leeq1i
  bitr4i
  (S y) (+ (0) (1)) (1) leadd1 bitri
  (S y) a1suc (+ (+ (0) (1)) (1)) leeq1i  bitr4i
  (+ (0) (1)) a1suc (S (S y)) leeq2i bitr4i
  (0) a1suc     (S (0)) (+ (0) (1)) pa_ax2  mpbi   (S (S y)) leeq2i bitr4i
  biimpri
  y eq0le0 sylibr
  suceqd suceqd

  # ... -> y'' | 0''  (it's later)
    (S (S y)) (S (S (0))) (S (S (0))) divideseq1  syl  biimprd
  mpi

  # ... which is the same as y'' | x'' when x=0
     (= x (0)) a1i
     x (0) eqcom biimpi suceqd suceqd    (S (S (0))) (S (S x)) (S (S y)) divideseq2   syl  biimpd
  syld

  y 19.21ai
  x 19.22i ax-mp
)
# number 53.0
# Utility to avoid excessive mandhyp baggage in exfactoriallem3
thm (exfactoriallem4 ()
  (h1 (-> ph (\/ ps ch))
   h2 (-> th ps))
  (-> (-> ch th) (-> ph ps))

  h1
  (-> ch th) anim1i
  ps ch (-> ch th) andir  sylib
  ps (-> ch th) pm3.26   (/\ ch (-> ch th)) orim1i  syl
  ch th pm3.35  ps orim2i syl
  h2 ps orim2i syl
  ps oridm sylib
  expcom
)
# number 54.0
# Inductive step for exfactorial
thm (exfactorial.3 () ()
  (-> (E. x (A. y (-> (<= (S y) (S z)) (| (S y) (S (S x))))))
      (E. x (A. y (-> (<= (S y) (S (S z))) (| (S y) (S (S x)))))))

  # Set up the two cases
    (S y) (S (S z)) lefoo3 biimpi

  # first case: y' = z'''.  This becomes y' | z''' * x''
  (S (S z)) dividessym    (S (S z)) (S (S z)) (S (S x)) dividesmul ax-mp
  (S y) (S (S z))  (* (S (S z)) (S (S x))) divideseq1  mpbiri
  (<= (+ (S y) (1)) (S (S z))) orim1i syl

  # Second case: y'' + 1 <= z'''.  This becomes y'' <= z''
  (S y) (S z) (1) leadd1
  (S z) a1suc   (+ (S y) (1)) leeq2i  bitr4i biimpri
  (| (S y) (* (S (S z)) (S (S x)))) orim2i syl
  # Handle second case by adding an assumption
    (S y) (S (S x)) (S (S z))  dividesmul
      (S (S x)) (S (S z)) mulcom
    (* (S (S x)) (S (S z))) (* (S (S z)) (S (S x))) (S y) divideseq2  ax-mp sylib
  exfactoriallem4

  # So (z''' * x'') is our new x''... we need to show it is at least 2
    (S (S z)) (S x) pa_ax6
    (* (S (S z)) (S x)) (S z) pa_ax4 eqtr
      (* (S (S z)) (S x)) z pa_ax4
      (+ (* (S (S z)) (S x)) (S z)) (S (+ (* (S (S z)) (S x)) z)) pa_ax2 mpbi
    eqtr
      (* (S (S z)) (S (S x))) (S (S (+ (* (S (S z)) (S x)) z))) (S y) divideseq2
    ax-mp
  biimpi  (<= (S y) (S (S z))) imim2i syl

  # Bundle up...
  y 19.20i
  x 19.22i

  # for later still
    x' (+ (* (S (S z)) (S x)) z) tyex
  # Need an substitution: x -> (z''' * x' + z')
      x' (+ (* (S (S z)) (S x)) z) pa_ax2 biimpi suceqd
        (S (S x')) (S (S (+ (* (S (S z)) (S x)) z))) (S y) divideseq2  biimprd
        (| (S y) (S (S (+ (* (S (S z)) (S x)) z)))) (| (S y) (S (S x'))) (<= (S y) (S (S z))) imim2 syl
        y 19.21ai
        y (-> (<= (S y) (S (S z))) (| (S y) (S (S (+ (* (S (S z)) (S x)) z))))) (-> (<= (S y) (S (S z))) (| (S y) (S (S x')))) ax-alim syl
      syl
      com12
      x' 19.22d
    mpi
    x 19.22i
  syl
  x (E. x' (A. y (-> (<= (S y) (S (S z))) (| (S y) (S (S x')))))) 19.9 sylib
  # now alpha change x' back to x
    x' x pa_ax2 biimpi suceqd
    (S (S x')) (S (S x)) (S y) divideseq2 biimpd  syl
    (| (S y) (S (S x'))) (| (S y) (S (S x))) (<= (S y) (S (S z))) imim2 syl
    y 19.21ai
    y (-> (<= (S y) (S (S z))) (| (S y) (S (S x')))) (-> (<= (S y) (S (S z))) (| (S y) (S (S x)))) ax-alim syl
    exalpha1
  syl
)
# number 54.0
# Inductive step for exfactorial
thm (exfactoriallem3 () ()
  (-> (E. x (A. y (-> (<= (S (S y)) (S (S z))) (| (S (S y)) (S (S x))))))
      (E. x (A. y (-> (<= (S (S y)) (S (S (S z)))) (| (S (S y)) (S (S x)))))))

  # Set up the two cases
    (S (S y)) (S (S (S z))) lefoo3 biimpi

  # first case: y'' = z'''.  This becomes y'' | z''' * x''
  (S (S (S z))) dividessym    (S (S (S z))) (S (S (S z))) (S (S x)) dividesmul ax-mp
  (S (S y)) (S (S (S z)))  (* (S (S (S z))) (S (S x))) divideseq1  mpbiri
  (<= (+ (S (S y)) (1)) (S (S (S z)))) orim1i syl

  # Second case: y'' + 1 <= z'''.  This becomes y'' <= z''
  (S (S y)) (S (S z)) (1) leadd1
  (S (S z)) a1suc   (+ (S (S y)) (1)) leeq2i  bitr4i biimpri
  (| (S (S y)) (* (S (S (S z))) (S (S x)))) orim2i syl
  # Handle second case by adding an assumption
    (S (S y)) (S (S x)) (S (S (S z)))  dividesmul
      (S (S x)) (S (S (S z))) mulcom
    (* (S (S x)) (S (S (S z)))) (* (S (S (S z))) (S (S x))) (S (S y)) divideseq2  ax-mp sylib
  exfactoriallem4

  # So (z''' * x'') is our new x''... we need to show it is at least 2
    (S (S (S z))) (S x) pa_ax6
    (* (S (S (S z))) (S x)) (S (S z)) pa_ax4 eqtr
      (* (S (S (S z))) (S x)) (S z) pa_ax4
      (+ (* (S (S (S z))) (S x)) (S (S z))) (S (+ (* (S (S (S z))) (S x)) (S z))) pa_ax2 mpbi
    eqtr
      (* (S (S (S z))) (S (S x))) (S (S (+ (* (S (S (S z))) (S x)) (S z)))) (S (S y)) divideseq2
    ax-mp
  biimpi  (<= (S (S y)) (S (S (S z)))) imim2i syl

  # Bundle up...
  y 19.20i
  x 19.22i

  # for later still
    x' (+ (* (S (S (S z))) (S x)) (S z)) tyex
  # Need an substitution: x -> (z''' * x' + z')
      x' (+ (* (S (S (S z))) (S x)) (S z)) pa_ax2 biimpi suceqd
        (S (S x')) (S (S (+ (* (S (S (S z))) (S x)) (S z)))) (S (S y)) divideseq2  biimprd
        (| (S (S y)) (S (S (+ (* (S (S (S z))) (S x)) (S z))))) (| (S (S y)) (S (S x'))) (<= (S (S y)) (S (S (S z)))) imim2 syl
        y 19.21ai
        y (-> (<= (S (S y)) (S (S (S z)))) (| (S (S y)) (S (S (+ (* (S (S (S z))) (S x)) (S z)))))) (-> (<= (S (S y)) (S (S (S z)))) (| (S (S y)) (S (S x')))) ax-alim syl
      syl
      com12
      x' 19.22d
    mpi
    x 19.22i
  syl
  x (E. x' (A. y (-> (<= (S (S y)) (S (S (S z)))) (| (S (S y)) (S (S x')))))) 19.9 sylib
  # now alpha change x' back to x
    x' x pa_ax2 biimpi suceqd
    (S (S x')) (S (S x)) (S (S y)) divideseq2 biimpd  syl
    (| (S (S y)) (S (S x'))) (| (S (S y)) (S (S x))) (<= (S (S y)) (S (S (S z)))) imim2 syl
    y 19.21ai
    y (-> (<= (S (S y)) (S (S (S z)))) (| (S (S y)) (S (S x')))) (-> (<= (S (S y)) (S (S (S z)))) (| (S (S y)) (S (S x)))) ax-alim syl
    exalpha1
  syl
)

# There exists a number that is divided all numbers up to #(S A)#. While factorial is
# certainly one such, it's not the only, so perhaps this is not an ideal name.
thm (exfactorial ((A x) (A y)) ()
    (E. x (A. y (-> (<= (S y) (S A))
                     (| (S y) (S (S x))))))
    z (0) x y exfactorial.1
    z y' x y exfactorial.1
    z (S y') x y exfactorial.1
    z A x y exfactorial.1
    x y exfactorial.2
    x y y' exfactorial.3
    finds
)

# Equality theorem for primeness
thm (primeeq () () (-> (= A B) (<-> (prime A) (prime B)))
    A B x divideseq2
      A B x eqeq2
      (= x (1)) orbi2d
    imbi12d
    x 19.21ai
    19.15d

      A x df-prime
        B x df-prime
    3bitr4g
)
# number 57.0
thm (dividesle () () (-> (| A (S B)) (<= A (S B)))
    A (S B) x df-divides biimpi
        B pa_ax1
            x (0) A muleq2    A pa_ax5  syl6eq
            (* A x) (0) (S B) eqeq1   syl   biimpd   con3d
        mpi
        con2i
            x y lefoo
            (= x (0)) (E. y (= (+ (1) y) x)) df-or   biimpi    ax-mp
        syl
            y a1suc   y (1) addcom     eqtr     x eqeq1i   biimpri
            (S y) x A muleq2    syl
            (* A (S y)) (* A x) (S B) eqeq1    syl  biimprd
                A (* A y) addge01t
                    A y pa_ax6    (* A y) A  addcom eqtr   (S B) eqeq1i   biimpi    A leeq2d  biimpd
                mpi
            syl6
        y 19.22i    syl
        y (-> (= (* A x) (S B)) (<= A (S B))) 19.9  sylib
        pm2.43i
    x 19.22i syl
    x (<= A (S B)) 19.9 sylib
)
# number 58.0
thm (sindlem1 ()
  (h1 (-> ch (-> ps (\/ (-> th ph) ta)))
   h2 (-> si (/\ th (-> ta ph))))
  (-> si (-> ch (-> ps ph)))

  si ch pm3.2
  h2   h1    anim12i    syl6

  (/\ th (-> ta ph))  ps  ax-1    (-> ps (\/ (-> th ph) ta))  anim1i    syl6
  ps  (/\ th (-> ta ph))  (\/ (-> th ph) ta)  pm3.43    syl6

  th  (-> ta ph)  (\/ (-> th ph) ta)  anass    biimpi    syl8


    (-> ta ph)  (-> th ph)  ta  andi    biimpi
    (-> ta ph)  (-> th ph)  pm3.27    (/\ (-> ta ph) ta)  orim1i    syl
    (-> ta ph)  ta  ancom    biimpi   (-> th ph)  orim2i    syl
    th  anim2i
  syl8

  ta  ph  pm3.35    (-> th ph)  orim2i    th  anim2i    syl8

  th  (-> th ph)  ph  andi    biimpi    th  ph  pm3.27    (/\ th (-> th ph)) orim2i    syl    syl8

  th  ph  pm3.35    ph  orim1i    syl8

  ph  pm1.2    syl8
)

# Strong Induction.
thm (sind ((A x) (ta x) (ph y))                    # ph(x) is some term in x; ph(A) is to be proved
  (hyp1 (-> (= x (0))   (<-> ph ps))               # ps is ph(0)
   hyp3 (-> (= x (S y)) (<-> ph th))               # th is ph(y')
   hyp4 (-> (= x A)     (<-> ph ta))               # ta is ph(A)
   hyp5 ps
   hyp6 (-> (A. x (-> (<= x y) ph)) th))           # ph(x) holds for all x<=y  -->  ph(y') holds
  ta

# Tuck this away for later
hyp4
  z  x  tyex    x  leid    (= z x)  id    x  leeq2d    biimprd    mpi    z 19.22i    ax-mp

    # Don't blink, or you'll miss the actual math content of this proof.
    (= z (S y)) id    x leeq2d    biimpd
       x (S y) lefoo3    biimpi
       y a1suc (+ x (1)) leeq2i  biimpi    x y (1) leadd1  sylibr (= x (S y)) orim2i syl
    syl6
    # That was it!  All that's left is a little bit of logic and a lot of juggling.
    hyp3    biimprd  (<= x y) orim1i    syl6
#      x  ph  ps  19.21    biimpri
        z y tyex
          (= z y) id   x leeq2d    biimprd    (<= x y) (<= x z) ph imim1    syl   x  19.21ai
          x  (-> (<= x z) ph)  (-> (<= x y) ph)  ax-alim    syl
          a2i    z 19.20i
          z  (= z y)  (A. x (-> (<= x y) ph))  19.22    syl
        mpi    z  (A. x (-> (<= x y) ph))  ex-nf    syl
#.     syl .
      # Now the logic is all done, and we just need to juggle.
      # We'll need to use the consequent "x<=y -> ph" twice, so duplicate it here
      (A. z (-> (= z y) (A. x (-> (<= x z) ph))))  (A. x (-> (<= x y) ph))  anidmdbi  biimpri  ax-mp
      # Grind the first one into a theta
      hyp6    (A. x (-> (<= x y) ph))  anim1i  syl
      # Pull the quantifier off the second one
      x  (-> (<= x y) ph)  ax-4    th  anim2i    syl
    # Juggling lematized for your convenience
    sindlem1

    x    19.21ai    x  (= z (S y))  (-> (<= x z) ph)  19.21    sylib
    z  19.21ai
    y  gen

        # Base case
        (= z (0)) id    x leeq2d    biimpd   x eq0le0 biimpri    hyp5 hyp1 mpbiri   syl  syl6    x 19.21ai    z gen
            # Instead of calling "x  ph  y pa_ind" as in finds, we call it like this:
            z  (A. x (-> (<= x z) ph))  y  pa_ind
        mpan
    ax-mp

    # Huzzah!  Now just some cleanup.
    a4i    a4i
  z 19.22i    ax-mp    z  ph  ex-nf    ax-mp
vtocl
)

# Zero doesn't divide any positive number
thm (not0divides () () (-. (| (0) (S A)))
  A pa_ax1
    (0)  (S A)  x  df-divides    biimpi
    x  pa_ax5   x  (0)  mulcom    eqtr3    (S A)  eqeq1i    biimpri    x 19.22i    syl
    x  (= (0) (S A))  ex-nf    syl
  mto
)
# number 60.0

# Every multitude has either a proper multitude divisor or a prime multitude divisor
thm (primedivisor.1 ((A x) (A z)) ()
    (\/ (E. z (/\ (< (S (S z)) (S (S A))) (| (S (S z)) (S (S A)))))
        (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S A))))))

# Case 1: A'' is itself prime
x (prime (S (S A))) 19.3  biimpri
  x A tyex
    (= x A) id suceqd suceqd
    (S (S x)) (S (S A)) primeeq biimprd    syl
      (= x A) id suceqd suceqd
      (S (S x)) (S (S A)) (S (S A)) divideseq1   syl  biimprd
    anim12d
      (S (S A)) dividessym   (prime (S (S A))) jctr
    syl5    com12
    x 19.20i
    x (= x A) (/\ (prime (S (S x))) (| (S (S x)) (S (S A)))) 19.22  syl
  mpi
syl

# Case 2: A'' is not prime.
  (S (S A)) x df-prime   notbii  biimpi
  (-> (| x (S (S A))) (\/ (= x (1)) (= x (S (S A))))) notnot  biimpri   x 19.20i    con3i   syl
  x (-. (-> (| x (S (S A))) (\/ (= x (1)) (= x (S (S A)))))) df-ex  sylibr
  (| x (S (S A))) (\/ (= x (1)) (= x (S (S A)))) pm4.61   biimpi  x 19.22i   syl

    x (S A) dividesle
      (= x (1)) (= x (S (S A))) ioran  biimpi
    anim12i  ancomd
    (-. (= x (1))) (-. (= x (S (S A)))) (<= x (S (S A)))  anass sylib
    x (S (S A)) df-lt    biimpri  ancoms  (-. (= x (1))) anim2i   syl
    (| x (S (S A)))  (-. (\/ (= x (1)) (= x (S (S A)))))  (/\ (-. (= x (1))) (< x (S (S A))))  pm5.3    mpbi
    (| x (S (S A))) (-. (= x (1))) (< x (S (S A))) anass    biimpri    syl
        (S A)  not0divides    x  (0)  (S (S A))  divideseq1    biimpd    mtoi    con2i
         x 0orpos    ori    syl
         (1)  x  y  df-le    biimpi    y a1suc    y  (1)  addcom    eqtr    x  eqeq1i    biimpri    y  19.22i    syl    syl
         (-. (= x (1)))  anim1i
         y  (= (S y) x)  (-. (= x (1)))  19.41    sylibr
           (S y)  x  (1)  eqeq1    biimpd    con3d    (= (S y) x)  (-. (= x (1)))  (-. (= (S y) (1)))  pm3.31    ax-mp
           (= y (0))  id   suceqd    df-1    syl6eqr    con3i    y 0orpos    ori    syl    syl
               (1)  y  z  df-le    biimpi    z a1suc    z  (1)  addcom    eqtr    y  eqeq1i    biimpri    (= (S z) y)  id    suceqd   syl    eqcomd
           z  19.22i    syl    syl
        (= (S y) x)  (-. (= x (1)))  (E. z (= (S y) (S (S z))))  pm5.3    mpbi    y  19.22i    syl

        z  (= (S y) (S (S z)))  (= (S y) x)  19.41    biimpri    ancoms     y  19.22i   syl
        (S y)  (S (S z))  x  ax-eqtr     z  19.22i    y  19.22i    syl
        y  (E. z (= (S (S z)) x))  ex-nf    syl
        (| x (S (S A)))  (-. (= x (1)))  (E. z (= (S (S z)) x))  pm5.3    mpbi    ancomd
        z  (= (S (S z)) x)  (| x (S (S A)))  19.41    sylibr
          (S (S z))  x  (S (S A))  divideseq1    biimprd    (= (S (S z)) x)  (| x (S (S A)))  (| (S (S z)) (S (S A)))  pm3.31    ax-mp
          (= (S (S z)) x)  (| x (S (S A)))  (| (S (S z)) (S (S A)))  pm5.3    mpbi
        z  19.22i   syl
     (< x (S (S A)))   anim1i    syl
     z  (/\ (= (S (S z)) x) (| (S (S z)) (S (S A))))  (< x (S (S A)))  19.41    sylibr
       (= (S (S z)) x)  (| (S (S z)) (S (S A)))  (< x (S (S A)))  an23    (= (S (S z))  x)  id    (S (S A))  lteq1d    biimprd
          (= (S (S z)) x)  (< x (S (S A)))  (< (S (S z)) (S (S A)))  pm3.31    ax-mp    (| (S (S z)) (S (S A))) anim1i
       sylbi
     z 19.22i    syl
   x  19.22i    syl
   x  (E. z (/\ (< (S (S z)) (S (S A))) (| (S (S z)) (S (S A)))))  ex-nf    syl
nsyl4    orri
)
# number 61.0
# Induction tool
thm (primedivisor.2 ((A x)) ()
    (-> (= y A) (<-> (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S y)))))
                     (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S A)))))))
    (= y A)  id    suceqd    suceqd
    (S (S y))  (S (S A)) (S (S x))  divideseq2    syl
    (prime (S (S x)))  anbi2d
    x exbid
)

# number 62.0
thm (lesuc1 () ()
  (<-> (<= A B) (<= (S A) (S B)))
  A  B  (1)  leadd1
  A  a1suc    (+ B (1))  leeq1i    bitr4i
  B  a1suc    (S A)  leeq2i    bitr4i
)

# The "divides" relation is transitive
thm (dividestr () ()
  (-> (/\ (| A B) (| B C)) (| A C))
    A  B  x  df-divides    biimpi
        B  C  y  df-divides    biimpi
    anim12i
    x  (= (* A x) B)  (E. y (= (* B y) C))  19.41    sylibr
    y  (= (* B y) C)  (= (* A x) B)  19.41    biimpri    ancoms    x 19.22i    syl
        (* A x)  B  y  muleq1     C  eqeq1d    biimprd
        (= (* A x) B)  (= (* B y) C)  (= (* (* A x) y) C)  pm3.31    ax-mp
        ancoms A  x  y  mulass    syl5eqr    z 19.21ai
            z  (* x y)  tyex
            z  (* x y)  A  muleq2    C  eqeq1d    biimprd    z  19.22i    ax-mp
            z  (= (* A (* x y)) C)  (= (* A z) C)  eximp1    ax-mp
        syl
    y  19.22i    x  19.22i    syl
    19.9d    19.9d
    A  C  z  df-divides    sylibr
)
# number 64.0
thm (primedivisor ((A x)) ()
    (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S A)))))

x' (0)  x  primedivisor.2
  x' (S y)  x  primedivisor.2
    x'  A  x  primedivisor.2

      # Base case
      x  (0)  tyex
        2prime
          df-1    (1)  (S (0))  pa_ax2    mpbi   (1)  a1suc    eqtr3    (S (S (0))) (+ (1) (1)) primeeq    ax-mp
        mpbir
        (= x (0))  id    suceqd    suceqd    (S (S x))  (S (S (0)))  primeeq    syl    biimprd    mpi
          (S (S (0)))  dividessym
          (= x (0))  id    suceqd    suceqd    (S (S x))  (S (S (0)))  (S (S (0))) divideseq1   syl    biimprd    mpi
        jca
      x  19.22i    ax-mp

        # Inductive step
        x' (S y) x primedivisor.1
          (S (S x'))  (S (S y))  lesuc    biimpi
          (S x')  (S y)  lesuc1    sylibr    x'  y  lesuc1    sylibr
          (| (S (S x')) (S (S (S y))))  anim1i
        x'  19.22i    (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S (S y))))))  orim1i    ax-mp
          (<= x' y)  (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S x')))))  (| (S (S x')) (S (S (S y))))  pm3.45
          x'  19.20i  x'  (/\ (<= x' y) (| (S (S x')) (S (S (S y)))))  (/\ (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S x'))))) (| (S (S x')) (S (S (S y))))) 19.22    syl
        (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S (S y))))))   orim1d    mpi
          (S (S x))  (S (S x'))  (S (S (S y)))  dividestr    (prime (S (S x)))  anim2i
          anassrs    x  19.22i
          x  (/\ (prime (S (S x))) (| (S (S x)) (S (S x'))))  (| (S (S x')) (S (S (S y))))  19.41    (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S (S y)))))) imbi1i    mpbi
        x'  19.22i    19.9d
        (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S (S y))))))  orim1i    syl
        (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S (S y))))))  pm1.2  syl
        sind
)

# number 66.0
thm (dividesadd.1 () ()
    (-> (| (S A) (+ (* (S A) B) C)) (| (S A) C))
    (S A)  (+ (* (S A) B) C)  x  df-divides    biimpi
        (* (S A) B)  C  addge01t
        ( = (* (S A) x) (+ (* (S A) B) C))  id  (* (S A) B)  leeq2d    biimprd    mpi
        (S A)  B  mulcom    (* (S A) x)  leeq1i    sylib
        (S A)  x  mulcom    (* B (S A))  leeq2i    sylib
        B  A  x  lemul4    syl
        B  x  y  df-le    sylib
        (+ B y)  x  (S A)  muleq2    eqcomd   y  19.22i    syl
        ancri
        y  (= (* (S A) x) (* (S A) (+ B y)))  (= (* (S A) x) (+ (* (S A) B) C))  19.41    sylibr
          (* (S A) x)  (* (S A) (+ B y))  (+ (* (S A) B) C)  ax-eqtr
          (S A)  B  y  distr    (+ (* (S A) B) C)  eqeq1i    sylib
          (* (S A) B)  (* (S A) y)  C  addcan2    biimpi    syl

        y  19.22i    syl
        (S A)  C  y  df-divides    sylibr

    x  19.22i   syl    x  (| (S A) C) 19.9    sylib
)
# number 67.0
thm (divides1 () ()
     (-. (| (S (S A)) (1)))
  A  pa_ax1    df-1  (S (S A))  leeq2i      (S A)  (0)  lesuc1    bitr4i    (S A)  eq0le0    bitr4i    biimpi   eqcomd  con3i  ax-mp
    (S (S A))  (1)  x  df-divides    biimpi
        x  z  lefoo
          0ne1
            x  (0)  (S (S A))  muleq2    (S (S A)) pa_ax5    syl6eq
            (1) eqeq1d    biimpd    con3d
          mpi    (E. z (= (+ (1) z) x))  orim1i
        ax-mp
        (= (* (S (S A)) x) (1))  (E. z (= (+ (1) z) x))  imor    biimpri    ax-mp
        ancli
        (+ (1) z)  x  (S (S A)) muleq2    (1)  eqeq1d    biimprd    z  19.22i    (= (* (S (S A)) x) (1))  anim2i    syl
        ancomd    z  (-> (= (* (S (S A)) x) (1)) (= (* (S (S A)) (+ (1) z)) (1)))  (= (* (S (S A)) x) (1))  19.41    sylibr
        (= (* (S (S A)) x) (1))  (= (* (S (S A)) (+ (1) z)) (1))  pm3.35    ancoms    z  19.22i    syl
    x  19.22i    syl    x  (E. z (= (* (S (S A)) (+ (1) z)) (1)))  19.9    sylib
      x  (* (S (S A)) z) tyex
       x  (* (S (S A)) z)  (S (S A)) addeq2    (1)  eqeq1d    biimprd
        (S (S A))  (1)  z  distr    (1)  eqeq1i   biimpi
        (S (S A))  mulid    (* (S (S A)) z)  addeq1i      syl5eqr
       syl5com
      x  19.22d    mpi
      (S (S A))  (1)  x  df-le    biimpri    syl
    z  19.22i    syl    z  (<= (S (S A)) (1)) 19.9    sylib
    con3i
  ax-mp
)
# number 67.0

# number 68.0
thm (dividesadd.2 () ()
  (-> (| (S A) B) (-> (| (S A) (+ B C)) (| (S A) C)))
    (S A)  B  x  df-divides    biimpi
        (* (S A) x)  B  C  addeq1
        (+ (* (S A) x) C)  (+ B C)  (S A)  divideseq2    biimprd    syl
         A  x  C  dividesadd.1    syl6
    x  19.22i    syl
    x  (-> (| (S A) (+ B C)) (| (S A) C))  ex-nf    syl
)
# number 69.0
thm (suceqi () (h (= A B))  (= (S A) (S B))
    h    (= A B)  id    suceqd    ax-mp
)
# number 70.0
thm (infprime.1 ((A x)) () (E. x (/\ (< (S (S A)) (S (S x))) (prime (S (S x)))))
    y  v  (S A)  exfactorial
      v  (-> (<= (S v) (S (S A))) (| (S v) (S (S y))))  (S x)  a4sbc  x  19.21ai  y  19.22i  ax-mp
        (= v (S x))  id  suceqd  (S (S A))  leeq1d
        (= v (S x))  id  suceqd  (S v) (S (S x))  (S (S y))  divideseq1  syl  imbi12d
      sbcie  x albii
    y  exbii mpbi

        x  divides1
        (S x) (S (S y)) (1)  dividesadd.2     con3d    mpi
            (<= (S (S x)) (S (S A))) imim2i    con2d   (S (S x))  (S (S A))  lenltt   biimpri
        con1i    syl6
     x  19.20i       y  19.22i    ax-mp
        x  (+ y (1))  primedivisor
            (S y)  (1)  pa_ax4r    y  (1)  pa_ax4r    suceqi    eqtr
            (+ (S (S y)) (1))  (S (S (+ y (1))))  (S (S x))  divideseq2    ax-mp    biimpri
            (prime (S (S x)))  anim2i
        x  19.22i    ax-mp
        y  gen
    pm3.2i
    y  (A. x (-> (| (S (S x)) (+ (S (S y)) (1))) (< (S (S A)) (S (S x)))))  (A. y (E. x (/\ (prime (S (S x))) (| (S (S x)) (+ (S (S y)) (1))))))  19.41    mpbir
    y  (E. x (/\ (prime (S (S x))) (| (S (S x)) (+ (S (S y)) (1)))))  ax-4    (A. x (-> (| (S (S x)) (+ (S (S y)) (1))) (< (S (S A)) (S (S x)))))  anim2i    y  19.22i    ax-mp
    x  (-> (| (S (S x)) (+ (S (S y)) (1))) (< (S (S A)) (S (S x))))  (/\ (prime (S (S x))) (| (S (S x)) (+ (S (S y)) (1))))  19.29    y  19.22i    ax-mp

            (| (S (S x)) (+ (S (S y)) (1)))  (< (S (S A)) (S (S x)))  pm2.27    (prime (S (S x)))  anim2i     (-> (| (S (S x)) (+ (S (S y)) (1))) (< (S (S A)) (S (S x))))  anim2i
                (prime (S (S x)))  (-> (-> (| (S (S x)) (+ (S (S y)) (1))) (< (S (S A)) (S (S x)))) (< (S (S A)) (S (S x))))  ancom    biimpi    (-> (| (S (S x)) (+ (S (S y)) (1))) (< (S (S A)) (S (S x))))  anim2i
            (-> (| (S (S x)) (+ (S (S y)) (1))) (< (S (S A)) (S (S x))))  (-> (-> (| (S (S x)) (+ (S (S y)) (1))) (< (S (S A)) (S (S x)))) (< (S (S A)) (S (S x))))  (prime (S (S x)))    anass    sylibr    syl
            (-> (| (S (S x)) (+ (S (S y)) (1))) (< (S (S A)) (S (S x))))  (< (S (S A)) (S (S x)))  pm3.35    (prime (S (S x)))  anim1i    syl
    x  19.22i    y  19.22i    ax-mp
    y  (E. x (/\ (< (S (S A)) (S (S x))) (prime (S (S x)))))  19.9    mpbi
)

# Primes are infinite
thm (infprime ((A x)) () (E. x (/\ (< A x) (prime x)))

y  A  infprime.1
 (/\ (< (S (S A)) (S (S y))) (prime (S (S y))))  x  alnfi
  x  (S (S y))  tyex
    (= x (S (S y)))  id    (S (S A))  lteq2d    biimprd
    x  (S (S y)) primeeq    biimprd  anim12d
  x  19.22i    ax-mp
  x  (/\ (< (S (S A)) (S (S y))) (prime (S (S y))))  (/\ (< (S (S A)) x) (prime x))  eximp1    ax-mp
 syl
y  19.22i    ax-mp
y  (E. x (/\ (< (S (S A)) x) (prime x)))  19.9  mpbi

    (+ A (1)) (1) addge01t
    A  (+ (+ A (1)) (1))  nnltp1let    mpbir
    A  a1suc    suceqi    (+ A (1))  a1suc    eqtr    A  lteq2i    mpbir
    A  (S (S A))  x  lttr  mpan
    (prime x)  anim1i
x  19.22i    ax-mp
)

# Existential uniqueness of sqrt
thm (sqrteu ((A x)) () (E! x (/\ (<= (* x x) A) (< A (* (S x) (S x)))))
    y  A  sqrt
        y  A  x  sqrtuniq    ex    y  x  eqcom    syl6ib
            y  x  y  x  muleq12    anidms    A  leeq1d   eqcoms
                x  y  eqcom    biimpi   suceqd    x  y  eqcom   biimpi suceqd    muleq12d    A  lteq2d
            anbi12d    biimpd    com12
        impbid    x  19.21ai
        y  19.22i    ax-mp
        x  (/\ (<= (* x x) A) (< A (* (S x) (S x))))  y  df-eu    biimpri
    ax-mp
)

# number 74.0
thm (df-sqrt-just ((A x) (A y)) ()
(= (iota ({|} x (/\ (<= (* x x) A) (< A (* (S x) (S x))))))
   (iota ({|} y (/\ (<= (* y y) A) (< A (* (S y) (S y)))))))
    y  x  y  x  muleq12    anidms    A  leeq1d   eqcoms
    x  y  eqcom    biimpi   suceqd    x  y  eqcom   biimpi suceqd    muleq12d    A  lteq2d
    anbi12d    bicomd    #  rwffi    abid
   abeq    ({|} x (/\ (<= (* x x) A) (< A (* (S x) (S x)))))  ({|} y (/\ (<= (* y y) A) (< A (* (S y) (S y)))))  ax-iotaeq     ax-mp
)

defthm  (df-sqrt nat (sqrt A) ((A x)) ()
  (= (sqrt A)  (iota ({|} x (/\ (<= (* x x) A) (< A (* (S x) (S x)))))))
  y  A  x  df-sqrt-just)



# number 76.0
thm (syl6seqr ()
  (hyp1 (-> ph (=_ S T))
   hyp2 (=_ U T))
  (-> ph (=_ S U))
  hyp1    S  T  x  df-seq    sylib
  x  (<-> (e. x S) (e. x T))  ax-4    syl
      hyp2    U  T  x  df-seq    mpbi    a4i
  syl6bbr
  x  19.21ai
  S  U  x  df-seq       sylibr
)

# number 77.0
thm (sqrteq () () (-> (= A B) (= (sqrt A) (sqrt B)))
  (= A B)  id    (* x x)  leeq2d
  (= A B)  id    (* (S x) (S x))  lteq1d    anbi12d
  x  19.21ai
  x  (/\ (<= (* x x) A) (< A (* (S x) (S x))))  (/\ (<= (* x x) B) (< B (* (S x) (S x))))  abeq2    syl
  ({|} x (/\ (<= (* x x) A) (< A (* (S x) (S x)))))  ({|} x (/\ (<= (* x x) B) (< B (* (S x) (S x)))))  ax-iotaeq    syl

  B  x  df-sqrt  syl6eqr
  A  x  df-sqrt  syl5eq
)

# number 86.0
thm (df-fun-just ((S x y x' y')) ()
  (<-> (/\ (A. x  (E! y  (e. (<,> x  y ) S))) (A. x (-> (e. x S) (E. y (E. z (= x (<,> y z)))))))
       (/\ (A. x' (E! y' (e. (<,> x' y') S))) (A. x' (-> (e. x' S) (E. y' (E. z' (= x' (<,> y' z'))))))))
  x  x'  y'  opeq1    (<,> x y')  (<,> x' y')  S  ax-eleq1  syl    y'  eubid
    y  y'  x  opeq2     (<,> x y)  (<,> x y')  S  ax-eleq1    syl    eualpha
  syl5bb
  alpha

 x  x'  S  ax-eleq1
  x  x'  (<,>  y' z')  eqeq1  z'  exbid  y'  exbid
   y  y'  z  opeq1   x  eqeq2d  z  exbid
     z  z'  y'  opeq2    x  eqeq2d   exalpha
   syl6bb    exalpha
  syl5bb
 imbi12d  alpha
anbi12i
)


defthm (df-fun wff (fun S) ((S x y))  ()  (<-> (fun S) (/\ (A. x  (E! y  (e. (<,> x  y ) S))) (A. x (-> (e. x S) (E. y (E. z (= x (<,> y z))))))))
x' y' S z'  x y z df-fun-just)


# number 87.0
thm (df-min-just ((S x) (S y) (S x') (S y')) ()
  (= (iota ({|} x (/\ (e. x S) (A. y (-> (e. y S) (<= x y))))))
     (iota ({|} x' (/\ (e. x' S) (A. y' (-> (e. y' S) (<= x' y')))))))
x  x'  S  ax-eleq1
  (= x x')  id    y  leeq1d    (e. y S)  imbi2d   y  19.21ai
  y  (-> (e. y S) (<= x y))  (-> (e. y S) (<= x' y))  19.15    syl
    y  y'  S  ax-eleq1
      (= y y')  id    x'  leeq2d
    imbi12d   alpha
  syl6bb
anbi12d
abeq
({|} x (/\ (e. x S) (A. y (-> (e. y S) (<= x y)))))  ({|} x' (/\ (e. x' S) (A. y' (-> (e. y' S) (<= x' y')))))    ax-iotaeq    ax-mp
)


defthm  (df-min nat (min S) ((S x) (S y)) ()
        (= (min S) (iota ({|} x (/\ (e. x S) (A. y (-> (e. y S) (<= x y)))))))
          x' S y' x y df-min-just)

# number 88.0
thm (mineq () () (-> (=_ S T) (= (min S) (min T)))
  S  T  x  df-seq    biimpi    x  (<-> (e. x S) (e. x T))  ax-4    syl
    S  T  y  df-seq    biimpi    y  (<-> (e. y S) (e. y T))  ax-4    syl
    (<= x y)  imbi1d
    y  19.21ai
    19.15d
  anbi12d
  x  19.21ai
  x  (/\ (e. x S) (A. y (-> (e. y S) (<= x y))))  (/\ (e. x T) (A. y (-> (e. y T) (<= x y))))  abeq2    syl
  ({|} x (/\ (e. x S) (A. y (-> (e. y S) (<= x y)))))  ({|} x (/\ (e. x T) (A. y (-> (e. y T) (<= x y)))))  ax-iotaeq    syl

  S  x  y  df-min    syl5eq
  T  x  y  df-min    syl6eqr
)
thm (minex.1 () ()
  (-> (= y A)
    (<->
      (-> (e. y S) (/\ (e. (min S) S)
                                (<= (min S) y)))
      (-> (e. A S) (/\ (e. (min S) S)
                                 (<= (min S) A)))))

y  A  S  ax-eleq1
  (= y A)  id    (min S)  leeq2d    (e. (min S) S) anbi2d
  imbi12d
)

# number 102.0
thm (minex.2.1 ((A w) (S w) (B w)) ()
  (-> (/\ (e. B S) (A. w (-> (e. w S) (<= A w)))) (<= A B))

w  (e. B S)  (-> (e. w S) (<= A w))  alan1    biimpri

w  B  tyex

  B  w  S ax-eleq1
    (= B w) id    A leeq2d
  imbi12d
  eqcoms
  biimprd
  imp3a
  ancomsd
w  19.22i    ax-mp
w  (/\ (e. B S) (-> (e. w S) (<= A w)))  (<= A B)  eximp1    ax-mp

syl
w  (<= A B)  ex-nf   syl
)

# number 103.0
thm (anim3 () () (-> (/\ ph (-> ps ch)) (-> ps (/\ ph ch)))

 ph  ps  ch  pm5.33   biimpi  ph  (-> (/\ ph ps) ch)  pm3.27 syl
 ph  ps  ch  impexp  sylib
  com23
 ph  ps  ch  pm5.33   biimpi  ph  (-> (/\ ph ps) ch) pm3.26  syl
   jctild
  ph  (-> ph ch)  pm3.26
  ph  ch  pm3.35       jca
 syl6
)

thm (minex.2.2 ((S w) (A w)) () (-> (/\ (e. A S) (A. w (-> (e. w S) (<= A w)))) (= A (min S)))
    x  A  S  ax-eleq1
      (= x A)  id    w  leeq1d    (e. w S)  imbi2d   w  19.21ai
      w  (-> (e. w S) (<= x w))  (-> (e. w S) (<= A w))  19.15    syl
    anbi12d    biimprcd
      (e. A S)  (A. w (-> (e. w S) (<= A w)))  ancom  (/\ (e. x S) (A. w (-> (e. w S) (<= x w))))  anbi2i (e. x S)  (A. w (-> (e. w S) (<= x w)))  (A. w (-> (e. w S) (<= A w)))  (e. A S)  an4    bitri       biimpi
      A  S  w x minex.2.1   ancoms    (/\ (e. x S) (A. w (-> (e. w S) (<= A w))))  anim2i   syl
      x  S  w A minex.2.1  (<= x A)  anim1i    syl
      A  x  lesym   sylibr    eqcomd       expcom
    impbid

    x  19.21ai
    x  (= x A)  (/\ (e. x S) (A. w (-> (e. w S) (<= x w))))  abeq2    syl
    ({|} x (= x A))  ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w)))))  ax-iotaeq    syl
    S  x  w  df-min     syl6eqr
    A x  df-sn  ({} A)  ({|} x (= x A))  ax-iotaeq    ax-mp       syl5eq
    A  ax-iota    syl5eqr
)

thm (minex2.2 ((S w)) () (-> (/\ (e. w' S) (A. w (-> (e. w S) (<= w' w)))) (= w' (min S)))
    x  w'  S  ax-eleq1
      (= x w')  id    w  leeq1d    (e. w S)  imbi2d   w  19.21ai
      w  (-> (e. w S) (<= x w))  (-> (e. w S) (<= w' w))  19.15    syl
    anbi12d    biimprcd
      (e. w' S)  (A. w (-> (e. w S) (<= w' w)))  ancom  (/\ (e. x S) (A. w (-> (e. w S) (<= x w))))  anbi2i (e. x S)  (A. w (-> (e. w S) (<= x w)))  (A. w (-> (e. w S) (<= w' w)))  (e. w' S)  an4    bitri       biimpi
      w'  S  w x minex.2.1   ancoms    (/\ (e. x S) (A. w (-> (e. w S) (<= w' w))))  anim2i   syl
      x  S  w w' minex.2.1  (<= x w')  anim1i    syl
      w'  x  lesym   sylibr    eqcomd       expcom
    impbid

    x  19.21ai
    x  (= x w')  (/\ (e. x S) (A. w (-> (e. w S) (<= x w))))  abeq2    syl
    ({|} x (= x w'))  ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w)))))  ax-iotaeq    syl
    S  x  w  df-min     syl6eqr
    w' x  df-sn  ({} w')  ({|} x (= x w'))  ax-iotaeq    ax-mp       syl5eq
    w'  ax-iota    syl5eqr
)

thm (minex.2 ((S w)) ()
    (-> (A. w (-> (<= w z)
      (-> (e. w S) (/\ (e. (min S) S)
                                (<= (min S) w)))))
      (-> (e. (S z) S) (/\ (e. (min S) S)
                                (<= (min S) (S z)))))
### Please excuse this bit of time-travel.
(<= w z) (e. w S)  (/\ (e. (min S) S) (<= (min S) w))  imdistan  biimpi
  (<= w z)  (/\ (e. (min S) S) (<= (min S) w))  ancom  biimpi z  (1)  addge01t    z  a1suc  z  leeq2i   mpbir
w  z  (S z)  letr  ancoms  mpan  (/\ (e. (min S) S) (<= (min S) w))  anim2i  syl  syl6  ancomsd
w 19.20i
###


# Case 1:  z' is in fact  min S.  This one is easy.
#  S  y  z  df-min    (S z)  eqeq2i    biimpi  (e. (S z) S)  a1d
(S z)  (min S)  S  ax-eleq1  biimpd
    (S z)  leid    (= (S z) (min S)) id  (S z)  leeq1d    mpbii    (e. (S z) S)  a1d
jcad
# Tack this on for later
(-> (e. (S z) S) (E. w (/\ (e. w S) (<= w z))))  orcd

# Case 2: z' is in S but NOT the min.
# What follows would be a lot more readable without all the mandhyps!
  S  x  w  df-min  (S z)  eqeq2i  notbii   biimpi
  ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w)))))  ({} (S z))  ax-iotaeq    (S z)  ax-iota   syl6eq   eqcomd   con3i    syl
  ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w)))))  ({} (S z))  w'  df-seq  notbii    biimpi   syl
  (<-> (e. w' ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w)))))) (e. w' ({} (S z))))  notnot    biimpri    w'  19.20i   con3i    syl
  w'  (-. (<-> (e. w' ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w)))))) (e. w' ({} (S z)))))  df-ex    biimpri    syl
  w'  (S z)  elsnc    (e. w' ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w))))))  bibi2i    notbii   w'  exbii    sylib
    x  w'  S   ax-eleq1
      (= x  w')  id    w  leeq1d    (e. w S)  imbi2d     w  19.21ai    w  (-> (e. w S) (<= x w))  (-> (e. w S) (<= w' w)) 19.15   syl
  anbi12d    elab    (= w' (S z))  bibi1i    notbii  w'  exbii  sylib
  (/\ (e. w' S) (A. w (-> (e. w S) (<= w' w))))  (= w' (S z))  xor     w'  exbii    sylib
    # We now have z' != min S -> (case A) \/ (case B).  Let's reduce case B to something we like.
    w'  (S z)  S  ax-eleq1
      (= w' (S z))  id  w  leeq1d   (e. w S)  imbi2d     w  19.21ai    19.15d       anbi12d    notbid  biimpd
      (e. (S z) S)  (A. w (-> (e. w S) (<= (S z) w)))  pm3.13    syl6   imp
      (e. (S z) S)  (-. (A. w (-> (e. w S) (<= (S z) w))))  imor    sylibr
        (-> (e. w S) (<= (S z) w))  notnot2  w  19.20i  con3i  w  (-. (-> (e. w S) (<= (S z) w)))  df-ex      sylibr
        (e. w S)  (<= (S z) w)  pm4.61    biimpi  (S z)  w  lenltt       con2bii    biimpri   w  z  lesuc    sylib  (e. w S)  anim2i    syl   w  19.22i    syl
      syl6
    (/\ (/\ (e. w' S) (A. w (-> (e. w S) (<= w' w)))) (-. (= w' (S z))))  orim2i    w'  19.22i       w'  (/\ (/\ (e. w' S) (A. w (-> (e. w S) (<= w' w)))) (-. (= w' (S z))))  (-> (e. (S z) S) (E. w (/\ (e. w S) (<= w z))))  exor2    sylib  syl
    # Okay, now let's work with case A.  First show that w' is in fact min S.
    w'  S  w  minex.2.2
    # Ok, now work out the consequences of w' = min S
    (/\ (e. w' S) (A. w (-> (e. w S) (<= w' w))))  (= w' (min S))  anidmdbi    mpbir
    (e. w' S)  (A. w (-> (e. w S) (<= w' w)))  (/\ (= w' (min S)) (= w' (min S)))  pm5.3    mpbi
    (e. w' S)  (= w' (min S))  (= w' (min S))  anass    sylibr
    w'  (min S)  S ax-eleq1   biimpac    (= w' (min S))  anim1i    syl
    pm4.71ri  biimpi   (e. w' S)  (A. w (-> (e. w S) (<= w' w)))  pm3.27   (/\ (e. (min S) S) (= w' (min S)))  anim2i      syl
    (e. (min S) S)  (= w' (min S))  (A. w (-> (e. w S) (<= w' w)))  anass  sylib
      (= w' (min S))  id    w leeq1d  (e. w S)  imbi2d    w  19.21ai    19.15d    biimpd   imp
    (S z) S  w  (min S)  minex.2.1     impexpi    syl       (e. (min S) S)  anim2i    syl
    (e. (min S) S)  (e. (S z) S)  (<= (min S) (S z))  anim3  syl
  (-. (= w' (S z))) adantr   w'  exani   (-> (e. (S z) S) (E. w (/\ (e. w S) (<= w z))))  orim1i  syl

# Great, now we can join up the two cases!
pm2.61i
# Pull out the common hypothesis
(e. (S z) S)  (/\ (e. (min S) S) (<= (min S) (S z)))  (E. w (/\ (e. w S) (<= w z)))  pm4.78    mpbi

# Almost there; just need to apply the IHOP to case 2B.

# Introduce the new antecedent and polish up the new conclusion
  w  (/\ (e. w S) (<= w z))  (/\ (/\ (e. (min S) S) (<= (min S) w)) (<= w (S z))) 19.22
    (e. (min S) S)  (<= (min S) w)  (<= w (S z))  anass     (min S)  w  (S z)  letr   (e. (min S) S)  anim2i    sylbi  w 19.22i
    w  (/\ (e. (min S) S) (<= (min S) (S z)))  ex-nf  syl
  syl6
(/\ (e. (min S) S) (<= (min S) (S z)))  orim2d     mpan9
(/\ (e. (min S) S) (<= (min S) (S z)))  pm1.2    syl
impexpi

syl
)

# The minimum of a nonempty set exists
thm (minex () ()     (-> (e. A S) (/\ (e. (min S) S)
                                (<= (min S) A)))
  x  (0)  S  minex.1
    x  (S y)  S  minex.1
      x  A  S  minex.1
        (0)  x  addge01t x  pa_ax3r    (0)  leeq2i    mpbi  (e. x S)  a1i   x  gen
        (0)  S  x  minex.2.2  ancoms  mpan
          (0)  (min S)  S  ax-eleq1  biimpd    com12                a2i
            (0)  leid    (= (0) (min S))  id   (0) leeq1d  mpbii    (e. (0) S) imim2i
        jcad    ax-mp
          x  y  S  minex.2
  sind
)

# The minimum of a (nonempty) set is in the set
thm (mincl ((S x)) ()
  (-> (E. x (e. x S)) (e. (min S) S))
  x S minex pm3.26d x 19.23ai
)

# Equality deduction for set minimum
thm (mineqd () (h (-> ph (=_ S T)))
  (-> ph (= (min S) (min T)))
  h S T mineq syl
)

# If any number satisfies a predicate, the minimum does
thm (minel ((ps x)) (
  h1 (rwff x ph)
  h2 (-> (= x (min ({|} x ph))) (<-> ph ps))
  ) (-> (E. x ph) ps)

  h1 abid x exbii
  x ({|} x ph) mincl sylbir
  h2 elab sylib
)

# Another way of specifying the value of minimum
thm (minval ((ps x) (A x))
  (h1 (rwff x ph)
   h2 (-> (= x A) (<-> ph ps)))
  (-> (/\ ps (A. x (-> ph (<= A x)))) (= A (min ({|} x ph))))

  h2 elab
  A ({|} x ph) minex sylbir
    x (min ({|} x ph)) ({|} x ph) ax-eleq1
    h1 abid syl5bbr
      (= x (min ({|} x ph))) id A leeq2d
    imbi12d
    cla4g
  anim12i
    (e. (min ({|} x ph)) ({|} x ph)) (<= A (min ({|} x ph))) pm3.35
    (<= (min ({|} x ph)) A) anim1i
    an1rs
  syl
  A (min ({|} x ph)) lesym sylibr
)

# number 89.0
thm (df-mod-just ((A x y x' y') (B x y x' y')) ()
  (= (min ({|} x (E. y (= (+ (* B y) x) A))))
     (min ({|} x' (E. y' (= (+ (* B y') x') A)))))
  x  x'  (* B y)  addeq2    A  eqeq1d     y  exbid
    y  y'  B  muleq2    x'  addeq1d    A  eqeq1d    exalpha
  syl6bb
  abeq
  ({|} x (E. y (= (+ (* B y) x) A)))  ({|} x' (E. y' (= (+ (* B y') x') A)))  mineq    ax-mp
)


defthm  (df-mod nat (mod A B) ((A x y) (B x y)) ()
        (= (mod A B) (min ({|} x (E. y (= (+ (* B y) x) A)))))
          x'  y'  B  A  x  y df-mod-just)

thm (modeq1 () () (-> (= A B) (= (mod A C) (mod B C)))
  A B (+ (* C y) x) eqeq2 y exbid
  x abeq2d mineqd
    A C x y df-mod
      B C x y df-mod
  3eqtr4g
)

# number 90.1

# (lincom A B C) means that C is a linear (integer) combination of A and B.
thm (df-lincom-just (
(A v w x y v' w' x' y')
(B v w x y v' w' x' y')
(C v w x y v' w' x' y')
(C' v' w' x' y')) ()
(-> (= C C') (<->
                (E. v (E. w (E. x (E. y (= (+ (* v A) (* w B))
                                            (+ (+ (* x A) (* y B)) C))))))
              (E. v' (E. w' (E. x' (E. y' (= (+ (* v' A) (* w' B))
                                           (+ (+ (* x' A) (* y' B)) C'))))))))
  C  C'  (+ (* x' A) (* y' B))  addeq2    (+ (* v' A) (* w' B))  eqeq2d  y'  exbid  x'  exbid  w'  exbid  v'  exbid
    v  v'  A  muleq1  (* w' B)  addeq1d  (+ (+ (* x' A) (* y' B)) C)  eqeq1d    y'  exbid  x'  exbid  w'  exbid
      w  w'  B  muleq1    (* v A)  addeq2d    (+ (+ (* x' A) (* y' B)) C)  eqeq1d    y'  exbid    x'  exbid
        x  x'  A  muleq1    (* y' B)  addeq1d    C  addeq1d    (+ (* v A) (* w B))  eqeq2d  y'  exbid
            y  y'  B  muleq1    (* x A)  addeq2d    C  addeq1d    (+ (* v A) (* w B))  eqeq2d    exalpha
        syl5bb    exalpha
      syl5bb    exalpha
    syl5bb    exalpha
  syl5bb
)

defthm (df-lincom wff (lincom A B C) (
(A v w x y)
(B v w x y)
(C v w x y)
) ()
(<-> (lincom A B C) (E. v (E. w (E. x (E. y (= (+ (* v A) (* w B))
                                            (+ (+ (* x A) (* y B)) C)))))))
  C  eqid
  C  C  v' w' x' y' A B v w x y df-lincom-just
  ax-mp
)

# number 90.2
thm (exan ((ph y) (ps x))
  (h1 (E. x ph)
   h2 (E. y ps))
  (E. x (E. y (/\ ph ps)))
  h1  h2    pm3.2i
  x  ph  (E. y ps)  19.41   mpbir
  y  ph  ps  19.41l   x  exbii   mpbir
)
# number 90.3
thm (lincomd () (h (-> ph
  (= (+ (* A A') (* B B')) (+ (+ (* C A') (* D B')) C'))))
  (-> ph (lincom A' B' C'))
h
  v  A  tyex   w  B  tyex   x  C  tyex   y  D  tyex
  exan  exan  y  (= w B)  (/\ (= x C) (= y D))  19.41r  x  exbii  w  exbii mpbir
  exan  x  (= v A)  (E. y (/\ (= w B) (/\ (= x C) (= y D))))  19.41r  w  exbii v exbii mpbir
  y  (= v A)  (/\ (= w B) (/\ (= x C) (= y D)))  19.41r  x  exbii w  exbii v  exbii mpbir

# Doing arithmetic
  y D B'  muleq1
  (* x A')  addeq2d
  x  C  A'  muleq1  (* D B')  addeq1d  sylan9eq    ancoms
  C'  addeq1d    (+ (* v A') (* w B'))  eqeq2d
  w  B  B'  muleq1  (* v A')  addeq2d   (+ (+ (* C A') (* D B')) C')  eqeq1d  sylan9bbr
  v  A  A'  muleq1  (* B B')  addeq1d (+ (+ (* C A') (* D B')) C')  eqeq1d   sylan9bbr
  biimprd    com12
  y  19.22d  x  19.22d  w  19.22d  v  19.22d  mpi
  A'  B'  C'  v  w  x  y  df-lincom  sylibr
syl
)
# number 90.4
thm (lincomeq3 () () (-> (= A B) (<-> (lincom C D A) (lincom C D B)))
  A  B   v  w  x  y   C  D  v'  w'  x'  y'  df-lincom-just
  C  D  A  v  w  x  y  df-lincom    syl5bb
  C  D  B  v'  w'  x'  y'  df-lincom    syl6bbr
)
# number 90.5
#!thm (df-gcd-just.1 ((A v w x y v' w' x' y' ) (B v w x y v' w' x' y')) ()
#!(-> (= z z') (<->  (/\ (-. (= z (0)))
#!                (E. v (E. w (E. x (E. y (= (+ (* v A) (* w B))
#!                                            (+ (+ (* x A) (* y B)) z)))))))
#! (/\ (-. (= z' (0)))
#!              (E. v' (E. w' (E. x' (E. y' (= (+ (* v' A) (* w' B))
#!                                           (+ (+ (* x' A) (* y' B)) z')))))))))
#!z  z'  (0)  eqeq1   notbid
#!
#!  z  z'  (+ (* x' A) (* y' B))  addeq2    (+ (* v' A) (* w' B))  eqeq2d  y'  exbid  x'  exbid  w'  exbid  v'  exbid
#!    v  v'  A  muleq1  (* w' B)  addeq1d  (+ (+ (* x' A) (* y' B)) z)  eqeq1d    y'  exbid  x'  exbid  w'  exbid
#!      w  w'  B  muleq1    (* v A)  addeq2d    (+ (+ (* x' A) (* y' B)) z)  eqeq1d    y'  exbid    x'  exbid
#!        x  x'  A  muleq1    (* y' B)  addeq1d    z  addeq1d    (+ (* v A) (* w B))  eqeq2d  y'  exbid
#!            y  y'  B  muleq1    (* x A)  addeq2d    z  addeq1d    (+ (* v A) (* w B))  eqeq2d    exalpha
#!        syl5bb    exalpha
#!      syl5bb    exalpha
#!    syl5bb    exalpha
#!  syl5bb
#!
#!anbi12d
#!)
# number 91.0
thm (df-gcd-just ((A z z') (B z z')) ()
(= (min ({|} z (/\ (-. (= z (0))) (lincom A B z))))
   (min ({|} z' (/\ (-. (= z' (0))) (lincom A B z')))))
  z  z'  (0)  eqeq1 notbid
    z  z'  v w x y A B v' w' x' y' df-lincom-just
    A  B  z  v  w  x  y  df-lincom     syl5bb
    A  B  z'  v'  w' x'  y'  df-lincom     syl6bbr
  anbi12d
  abeq
  ({|} z (/\ (-. (= z (0))) (lincom A B z)))  ({|} z' (/\ (-. (= z' (0))) (lincom A B z')))  mineq  ax-mp
)


defthm  (df-gcd nat (gcd A B) ((A z) (B z)) ()
        (= (gcd A B) (min ({|} z (/\ (-. (= z (0)))
                (lincom A B z)))))
          z'  A B z df-gcd-just)

# number 107.0
thm (modle1 () () (<= (mod A B) A)
    y  (0)  tyex
      y  (0)  B  muleq2
    B  pa_ax5  syl6eq  A  addeq1d    A  pa_ax3r  syl6eq   y  19.22i    ax-mp
    x  A  (* B y)  addeq2  A  eqeq1d   y  exbid
    ({|} x  (E. y (= (+ (* B y) x) A)))  seqid     elab2
  biimpri  ax-mp
  A  ({|} x  (E. y (= (+ (* B y) x) A)))  minex  ax-mp
  pm3.27i
      A  B  x  y  df-mod    A  leeq1i  mpbir
)

# number 108.0
thm (modex ((A y) (B y)) () (E. y (= (+ (* B y) (mod A B)) A))
    y  (0)  tyex
      y  (0)  B  muleq2
    B  pa_ax5  syl6eq  A  addeq1d    A  pa_ax3r  syl6eq   y  19.22i    ax-mp
    x  A  (* B y)  addeq2  A  eqeq1d   y  exbid
    ({|} x  (E. y (= (+ (* B y) x) A)))  seqid     elab2
  biimpri  ax-mp
  A  ({|} x  (E. y (= (+ (* B y) x) A)))  minex  ax-mp
  pm3.26i
  A  B  x  y  df-mod    (mod A B)  (min ({|} x (E. y (= (+ (* B y) x) A))))  ({|} x (E. y (= (+ (* B y) x) A)))  ax-eleq1  ax-mp
mpbir

    x  (mod A B)  (* B y)  addeq2  A  eqeq1d   y  exbid
    ({|} x  (E. y (= (+ (* B y) x) A)))  seqid     elab2
mpbi
)
# number 109.0
thm (modmin ((A x) (B x) (C x)) () (-> (E. x (= (+ (* A x) B) C)) (<= (mod C A) B))

    y B (* A x) addeq2 C eqeq1d x exbid
    ({|} y (E. x (= (+ (* A x) y) C))) seqid elab2   biimpri
    B  ({|} y (E. x (= (+ (* A x) y) C)))  minex  syl  pm3.27d
          C  A  y  x  df-mod    B  leeq1i  biimpri  syl
)

# number 110.0
thm (modlt2 () () (< (mod A (S B)) (S B))
B  pa_ax1
  (S B)  (mod A (S B)) x  df-le   biimpi
    y  (S B)  A modex
      (+ (S B) x)  (mod A (S B))  (* (S B) y)  addeq2   A  eqeq1d  biimprd     y 19.22d
    mpi
      (S B)  y  pa_ax6   x  addeq1i   (* (S B) y)  (S B)  x  addass  (+ (* (S B) (S y)) x)  eqeq2i   mpbi
      A  eqeq1i  biimpri
        (= (+ (* (S B) (S y)) x) A)  z  alnfi
          z  (S y)  tyex
          z  (S y)  (S B)  muleq2  x  addeq1d    A  eqeq1d    biimprd   z  19.22i    ax-mp
          z  (= (+ (* (S B) (S y)) x) A)  (= (+ (* (S B) z) x) A)  eximp1    ax-mp
        syl
      syl
      z  (S B)  x  A  modmin    syl
    y  19.22i  syl     y  (<= (mod A (S B)) x)  ex-nf    syl
      x  (S B)  addge02t      (= (+ (S B) x) (mod A (S B)))  id    x  leeq2d   biimpd  mpi
    jca
    (mod A (S B))  x  lesym    biimpri  syl   eqcoms  ancli    eqcoms
    (mod A (S B))  (+ (S B) x)  x  ax-eqtr    syl
    x  pa_ax3r  syl6eqr
    (S B)  x  (0)  addcan    sylib  eqcomd
  x  19.22i    syl  x  (= (0) (S B))  ex-nf  syl
  con3i
ax-mp
(S B)  (mod A (S B))  lenltt  biimpri  con1i  ax-mp
)
# number 111.0
thm (exey ((ph y) (ps x))
  () (-> (/\ (E. x ph) (E. y ps)) (E. x (E. y (/\ ph ps))))
  x  ph  (E. y ps)  19.41   biimpri
  y  ph  ps  19.41l   x  exbii   sylibr
)
# number 111.5
# A' is in the set minned by (gcd A' B).

thm (gcddiv1.1 ((A z)) ()
  (e. (S A) ({|} z (/\ (-. (= z (0))) (lincom (S A) B z))))
  z  (S A)  tyex
  A  pa_ax1  z  (S A)  (0)  eqeq2  biimpd  con3d  mpi  (0)  z  eqcom biimpri  con3i  syl
# Juggling quantifiers
  v  (1)  tyex   w  (0)  tyex   x  (0)  tyex   y  (0)  tyex
  exan  exan  y  (= w (0))  (/\ (= x (0)) (= y (0)))  19.41r  x  exbii  w  exbii mpbir
  exan  x  (= v (1))  (E. y (/\ (= w (0)) (/\ (= x (0)) (= y (0)))))  19.41r  w  exbii v exbii mpbir
  y  (= v (1))  (/\ (= w (0)) (/\ (= x (0)) (= y (0))))  19.41r  x  exbii w  exbii v  exbii mpbir

# Doing arithmetic
  y (0) B  muleq1  B  pa_ax5r  syl6eq
  (* x (S A))  addeq2d  (* x (S A))  pa_ax3  syl6eq
  x  (0)  (S A)  muleq1  (S A)  pa_ax5r  syl6eq  sylan9eq    ancoms
  z  addeq1d  z  pa_ax3r  syl6eq  (+ (* v (S A)) (* w B))  eqeq2d
  w  (0)  B  muleq1  B  pa_ax5r  syl6eq  (* v (S A))  addeq2d  (* v (S A))  pa_ax3  syl6eq  z  eqeq1d  sylan9bbr
  v  (1)  (S A)  muleq1  (S A)  (1)  mulcom  (S A)  mulid  eqtr3  syl6eq  z  eqeq1d   sylan9bbr
  biimprd    com12    eqcoms
  y  19.22d  x  19.22d  w  19.22d  v  19.22d  mpi
  (S A)  B  z  v  w  x  y  df-lincom  sylibr
  jca
  ancli
  z  19.22i  ax-mp
  (S A)  z  (/\ (-. (= z (0))) (lincom (S A) B z))  sbc5    mpbir
  (S A)  z  (/\ (-. (= z (0))) (lincom (S A) B z))  ax-elab    mpbir
)
# number 111.6
thm (gcddiv1.2 ((A z) (B z)) () (-> (= (gcd (S A) B) z) (/\ (-. (= z (0))) (lincom (S A) B z)))
 A z B  gcddiv1.1
  (S A)  ({|} z (/\ (-. (= z (0))) (lincom (S A) B z))) minex  ax-mp  pm3.26i

    (S A) B z  df-gcd
    (gcd (S A) B)  (min ({|} z (/\ (-. (= z (0))) (lincom (S A) B z))))  ({|} z (/\ (-. (= z (0))) (lincom (S A) B z)))  ax-eleq1  ax-mp
  mpbir
  (gcd (S A) B)  z  ({|} z (/\ (-. (= z (0))) (lincom (S A) B z)))  ax-eleq1  mpbii
    z z' (0) eqeq1 notbid
      z  z'  (S A) B  lincomeq3
  anbi12d  rwffi  abid    sylib
)

# Equality theorem for mod
thm (modeq2 () () (-> (= A B) (= (mod C A) (mod C B)))
  A  B  y  muleq1  x  addeq1d   C  eqeq1d   y  exbid x  19.21ai
  x  (E. y (= (+ (* A y) x) C))  (E. y (= (+ (* B y) x) C))  abeq2  syl
  ({|} x (E. y (= (+ (* A y) x) C)))  ({|} x (E. y (= (+ (* B y) x) C)))  mineq  syl
  C  A  x  y  df-mod  syl5eq
  C  B  x  y  df-mod  syl6eqr
)

# Divides relation is equivalent to zero remainder
thm (dividesmod () () (<-> (| A B) (= (mod B A) (0)))
  A  B  x  df-divides
    (* A x)  pa_ax3  B  eqeq1i  x  exbii  bitr4i
  x  A  (0)  B  modmin  sylbi     (mod B A)  eq0le0      sylibr

    x  A  B   modex
    (mod B A)  (0)  (* A x)  addeq2  B  eqeq1d   (* A x)  pa_ax3  B  eqeq1i   syl6bb  x exbid    mpbii
    A  B  x  df-divides  sylibr

    impbii
)
# number 112.0
thm (gcddiv1 () () (| (gcd (S A) B) (S A))
# For later.
z  (gcd (S A) B) tyex
z  leid  (= (gcd (S A) B) z)  id  z  leeq2d   biimprd  mpi   z  (gcd (S A) B)  lenltt    sylib

  A B z gcddiv1.2
  pm3.27d    (S A)  B  z  v  w  x  y  df-lincom  sylib

   v'  z  (S A)  modex

  # Now we show that (mod A' z) is in the set minned by GCD(A',B)
    (+ (* v (S A)) (* w B)) (+ (+ (* x (S A)) (* y B)) z)  v'  muleq2
    v'  (+ (* x (S A)) (* y B))  z  distr  syl6eq
    v'  (* v (S A))  (* w B)  distr  syl5eqr
    v'  v  (S A)  mulass  (* v' (* w B))  addeq1i  syl5eq
    v'  w  B  mulass  (* (* v' v) (S A))  addeq2i  syl5eq
    v'  (* x (S A))  (* y B)  distr  (* v' z)  addeq1i  syl6eq
    v'  x  (S A)  mulass  (* v' (* y B))  addeq1i  (* v' z)  addeq1i  syl6eqr
    v'  y  B  mulass     (* (* v' x) (S A))  addeq2i  (* v' z)  addeq1i  syl6eqr
    (+ (* (* v' v) (S A)) (* (* v' w) B))  (+ (+ (* (* v' x) (S A)) (* (* v' y) B)) (* v' z))  (+ (* z v') (mod (S A) z)) (S A)  addeq12  ex  syl  imp
    # Now, cancel out those z terms
    (* z v')  (mod (S A) z)  addcom   (+ (* (* v' v) (S A)) (* (* v' w) B))  addeq2i  syl5eqr
    (+ (* (* v' v) (S A)) (* (* v' w) B))  (mod (S A) z)  (* z v')  addass  syl5eq
    (+ (* (* v' x) (S A)) (* (* v' y) B))  (* v' z)  (S A)  addass  syl6eq
    (* v' z)  (S A)  addcom  (+ (* (* v' x) (S A)) (* (* v' y) B))  addeq2i    syl6eq
    (+ (* (* v' x) (S A)) (* (* v' y) B))  (S A)  (* v' z)  addass  syl6eqr
    v'  z  mulcom    (+ (+ (* (* v' x) (S A)) (* (* v' y) B)) (S A))  addeq2i    syl6eq
    (+ (+ (* (* v' v) (S A)) (* (* v' w) B)) (mod (S A) z))  (* z v')  (+ (+ (* (* v' x) (S A)) (* (* v' y) B)) (S A))  addcan  sylib
    # Group up the A' terms
    (* (* v' x) (S A))  (* (* v' y) B)  (S A)  addass  syl6eq
    (* (* v' y) B)  (S A)  addcom  (* (* v' x) (S A))  addeq2i  syl6eq
    (* (* v' x) (S A))  (S A)  (* (* v' y) B)  addass  syl6eqr
    (* v' x) (1) (S A)  distl    (1)  (S A)  mulcom  (S A) mulid  eqtr  (* (* v' x) (S A))  addeq2i  eqtr    (* (* v' y) B)  addeq1i  syl6eqr
    eqcomd
    lincomd
 # Bam!  Now time to sweep away all those pesky quantifiers.
  ancoms    ex    v'  19.22i  ax-mp
  v'  (-> (= (+ (* v (S A)) (* w B)) (+ (+ (* x (S A)) (* y B)) z)) (lincom (S A) B (mod (S A) z)))  ex-nf  ax-mp
  y  19.22i  x  19.22i  w  19.22i  v  19.22i  syl
  v  (E. w (E. x (E. y (lincom (S A) B (mod (S A) z)))))  ex-nf  syl
  w  (E. x (E. y (lincom (S A) B (mod (S A) z))))  ex-nf syl
  x  (E. y (lincom (S A) B (mod (S A) z)))  ex-nf syl
  y (lincom (S A) B (mod (S A) z))  ex-nf syl
  # This means that either (mod A' z) is 0, or it's in the set minned by gcd.
    (-. (= (mod (S A) z) (0)))  biantrud   biimpd    imp
      x  (mod (S A) z)  (0)  eqeq1  notbid    x  (mod (S A) z)  (S A)  B  lincomeq3   anbi12d  sbcie  sylibr
    (mod (S A) z)  x  (/\ (-. (= x (0))) (lincom (S A) B x))  ax-elab      sylibr
  (mod (S A) z)  ({|} x (/\ (-. (= x (0))) (lincom (S A) B x)))   minex  syl  pm3.27d
(S A)  B  x  df-gcd  (mod (S A) z)  leeq1i  sylibr
  # But gcd A' B <= mod A' z is impossible:
    A  B  z  gcddiv1.2  pm3.26d
    z  y  lefoo       ori      syl    y  a1suc   (1)  y  addcom  eqtr4 z  eqeq1i  biimpri   y  19.22i  syl
      (S A)  y  modlt2
        (S y)  z  (S A) modeq2    (S y)  lteq1d  mpbii
      (= (S y) z)  id  (mod (S A) z)  lteq2d   biimpd    mpd
    y  19.22i  syl  y  (< (mod (S A) z) z)  ex-nf  syl
  (-. (= (mod (S A) z) (0)))  adantr    jca
  (gcd (S A) B)  (mod (S A) z)  z  lelttr   syl
  ex  con3d
mpd
(= (mod (S A) z) (0))  notnot  sylibr
(gcd (S A) B)  z  (S A)  modeq2  (0)  eqeq1d  biimprd  mpd
(gcd (S A) B)  (S A)  dividesmod  sylibr  eqcoms  z  exani  ax-mp
)

# number 114.0
#!# (sequence-set-just A S) will mean that S is a set of pairs defining an
#!# injection from [0,A] to N.
#!thm (df-sequence-set-just ((A v w) (S v w)) ()
#!(<->
#!    (/\ (A. v (-> (e. v S) (<= (head v) A)))
#!        (A. v (-> (<= v A) (E! w (e. (<,> v w) S)))))
#!    (/\ (A. v' (-> (e. v' S) (<= (head v') A)))
#!        (A. v' (-> (<= v' A) (E! w' (e. (<,> v' w') S))))))
#!
#!  v  v'  S  ax-eleq1
#!  v  v'  headeq  A  leeq1d     imbi12d
#!
#!    (= v v')  id  A  leeq1d
#!      v  v'  w opeq1
#!      (<,> v w)  (<,> v' w)  S  ax-eleq1  syl

# number 115.0
thm (divideseq12 () () (-> (/\ (= A B) (= C D))  (-> (| A C) (| B D)))
   (= A B) z alnfi

  A B z muleq1    (= (* A z) C) anim1i
    (* A z) C (* B z) ax-eqtr   eqcomd   ancoms
    syl    ex

    z gen  z (= A B) (-> (= (* A z) C) (= (* B z) C)) ax-alim   ax-mp
  syl
    z (= (* A z) C) (= (* B z) C) 19.22
  syl

  C  D  (* B z)  eqeq2  z  exbid    biimpd
   anim12i
 (E. z (= (* A z) C))  (E. z (= (* B z) C))  (E. z (= (* B z) D))  pm3.33    syl
A  C  z  df-divides  syl5ib
B  D  z  df-divides  syl6ibr
)

thm (modval.1 () ()
  (-> (/\ (= (+ (* (S B) D) C) A) (= (+ (* (S B) D') C') A))
   (<-> (< D' D) (< C C')))

  (+ (* (S B) D) C) A eqcom (+ (* (S B) D') C') A eqcom anbi12i
  A (+ (* (S B) D) C) (+ (* (S B) D') C') ax-eqtr sylbi

  (* (S B) D) C (* (S B) D') C' leadd12 syl

    (S B) D mulcom (* (S B) D') leeq1i
    (S B) D' mulcom (* D (S B)) leeq2i bitri
    D B D' lemul5 bitri
  syl5bbr

  D D' lenltt C' C lenltt bibi12i sylib
  con4bid
)

thm (modval.2 () ()
  (-> (/\ (= (+ (* (S B) D) C) A) (= (+ (* (S B) D') C') A))
    (-> (< C C') (<= (+ (S B) C) C')))
  B D C A D' C' modval.1
  biimprd
  D' D nnltp1let syl6ib

  (+ D' (1)) D (S B) lemul2 syl6

    (S B) D' (1) distr
    (S B) mulid (* (S B) D') addeq2i eqtr
    (* (S B) D) leeq1i
  syl6ib
  #(* (S B) D) pa_ax3 (+ (* (S B) D') (S B)) leeq2i syl6ibr
  #(S B) (0) (* (S B) D') leadd2 syl6ibr

  (+ (* (S B) D') (S B)) (* (S B) D) C leadd1 syl6ib

    # Note: the next two lines are copied from modval.1, should be refactored
    (+ (* (S B) D) C) A eqcom (+ (* (S B) D') C') A eqcom anbi12i
    A (+ (* (S B) D) C) (+ (* (S B) D') C') ax-eqtr sylbi
    (+ (+ (* (S B) D') (S B)) C) leeq2d
  sylibd

  (* (S B) D') (S B) C addass (+ (* (S B) D') C') leeq1i syl6ib
  (+ (S B) C) C' (* (S B) D') leadd2 syl6ibr
)

thm (modval.3 () ()
  (-> (/\ (= (+ (* B D) C) A) (= (+ (* B D') C') A)) (-> (< C C') (<= (+ B C) C')))
    (0) B C addeq1 C pa_ax3r syl5eqr C' leeq1d
    C C' df-lt pm3.26bi syl5bi
    (/\ (= (+ (* B D) C) A) (= (+ (* B D') C') A)) a1d
  (0) B eqcom B eq0le0 bitri B (0) lenltt bitri con2bii
  (0) B nnltp1let (1) pa_ax3r B leeq1i bitri
  bitr3i

  (.- B (1)) D C A D' C' modval.2

  (1) B halfminus (.- B (1)) a1suc syl5eq D muleq1d C addeq1d A eqeq1d
    (1) B halfminus (.- B (1)) a1suc syl5eq D' muleq1d C' addeq1d A eqeq1d
  anbi12d

  (1) B halfminus (.- B (1)) a1suc syl5eq C addeq1d C' leeq1d
  (< C C') imbi2d
  imbi12d
  mpbii
  sylbi

  pm2.61i
)

# Main theorem giving mod its value
thm (modval ((A y) (B y) (C y)) ()
  (-> (/\ (< C B) (E. y (= (+ (* B y) C) A))) (= C (mod A B)))

  (< C B) (E. y (= (+ (* B y) C) A)) pm3.27
    y y' B muleq2 C addeq1d A eqeq1d exalpha

    B y x A y' C modval.3
      B x addge01t B (+ B x) C letr mpan
    syl6
    con3d
    B C lenltt con2bii syl5ib
    C x lenltt syl6ibr
    ex y 19.23ai com12
    y' 19.23ai
    sylbi com3r
    imp x 19.21ai
  jca

    x z (* B y) addeq2 A eqeq1d y exbid rwffi
      x C (* B y) addeq2 A eqeq1d y exbid
    minval
  syl
  A B x y df-mod C eqeq2i sylibr
)

# Identity law for modulo
thm (modid () ()
  (-> (< A B) (= (mod A B) A))
  x (0) tyex
    x (0) B muleq2 B pa_ax5 syl6eq
    A addeq1d A pa_ax3r syl6eq
    x 19.22i
  ax-mp
  A B x A modval mpan2 eqcomd
)

# Definition of division using set minimum instead of iota
thm (df-div-just ((A x y) (B x y)) ()
  (= (min ({|} x (= (+ (* B x) (mod A B)) A)))
    (min ({|} y (= (+ (* B y) (mod A B)) A))))
  x y B muleq2 (mod A B) addeq1d A eqeq1d abeq
  ({|} x (= (+ (* B x) (mod A B)) A)) ({|} y (= (+ (* B y) (mod A B)) A)) mineq ax-mp
)

defthm (df-div nat (div A B) ((A x) (B x)) ()
  (= (div A B) (min ({|} x (= (+ (* B x) (mod A B)) A))))
  y B A x df-div-just
)

# Main theorem about division
thm (div () () (= (+ (* B (div A B)) (mod A B)) A)
   x B A modex
    x y B muleq2 (mod A B) addeq1d A eqeq1d rwffi
    A B x df-div x eqeq2i biimpri x (div A B) B muleq2 syl (mod A B) addeq1d A eqeq1d
    minel
  ax-mp
)

thm (muldiv () ()
  (-> (< (0) B) (= (div (* B A) B) A))

  (* B (div (* B A) B)) pa_ax3
    B dividessym B B A dividesmul ax-mp
    B (* B A) dividesmod mpbi
    (* B (div (* B A) B)) addeq2i
    B (* B A) div eqtr3
  eqtr3
  B (div (* B A) B) A mulcant2 mpbii
)

# == Godel's Beta Function ==

# A development of Godel's Beta Function, following Shoenfield(1967).
thm (df-beta-just ((A x x') (B x x')) ()
(=  (min ({|} x (| (S (* (S (<,> B x)) (tail A))) (head A))))
    (min ({|} x' (| (S (* (S (<,> B x')) (tail A))) (head A)))))


    x  x'  B  opeq2  suceqd  (tail A)  muleq1d  suceqd
    (S (* (S (<,> B x)) (tail A)))  (S (* (S (<,> B x')) (tail A)))  (head A)  divideseq1  syl
  abeq
  ({|} x (| (S (* (S (<,> B x)) (tail A))) (head A)))  ({|} x' (| (S (* (S (<,> B x')) (tail A))) (head A)))   mineq  ax-mp
)
defthm  (df-beta nat (beta A B) ((A x ) (B x )) ()
        (= (beta A B) (min ({|} x (| (S (* (S (<,> B x)) (tail A))) (head A)))))
          x' B A x df-beta-just)

# number 116.1
thm (maxex.1 ((A x y)) ()
(-> (= x' A)  (<->
    (-> (fun S)
      (E. x (A. y (-> (/\ (< (head y) x') (e. y S)) (<= (tail y) x)))))
    (-> (fun S)
      (E. x (A. y (-> (/\ (< (head y) A) (e. y S)) (<= (tail y) x)))))))
  (= x' A)  id  (head y)  lteq2d
  (e. y S)  anbi1d
  (<= (tail y) x)  imbi1d  y  19.21ai  19.15d
   x exbid
    (fun S)  imbi2d
)
# number 116.15
thm (fun1 ((A x y) (S x y)) () (-> (fun S) (E. x (A. y (-> (/\ (= (head y) A) (e. y S)) (= y x)))))
S  y  v  w   df-fun  biimpi
  y  A  v  opeq1  (<,> y v)  (<,> A v)  S  ax-eleq1  syl  v  eubid  cla4g
v  (e. (<,> A v) S)  v'  df-eu  sylib

  (A. y (-> (e. y S) (E. v (E. w (= y (<,> v w))))))  anim1i  syl
  y  (-> (e. y S) (E. v (E. w (= y (<,> v w)))))  ax-4
    (<,> v w)  y  headeq    v  w  headop   syl5eqr  v (head y)  w  opeq1  syl   ancri
  (<,> v w)  (<,> (head y) w)  y  ax-eqtr  syl  eqcoms   w  19.22i  v  19.22i  syl6
  imp  19.9d  w  v  (head y)  opeq2  y  eqeq1d  exalpha  sylib

    (head y)  A  v  opeq1  y  eqeq1d  v  exbid  biimpd   anim12i
  (E. v (= (<,> (head y) v) y))  (E. v (= (<,> A v) y))   pm3.35  syl  ex  ex  imp3a
   ancrd   (E. v (= (<,> A v) y))  (e. y S)  (= (head y) A)  anass syl6ibr  imp   pm3.26d
   v  (= (<,> A v) y)  (e. y S)  19.41 sylibr
     (<,> A v)  y  S  ax-eleq1  biimprd  imp    ancri
   (e. (<,> A v) S)  (= (<,> A v) y)  (e. y S)  anass  sylibr pm3.26d  v  19.22i  syl
  ex  y  19.21ai
(E. v' (A. v (<-> (e. (<,> A v) S) (= v v'))))  anim2i  syl
v'  (A. v (<-> (e. (<,> A v) S) (= v v')))  (A. y (-> (/\ (e. y S) (= (head y) A)) (E. v (/\ (e. (<,> A v) S) (= (<,> A v) y)))))  19.41  sylibr

y  (A. v (<-> (e. (<,> A v) S) (= v v')))  (-> (/\ (e. y S) (= (head y) A)) (E. v (/\ (e. (<,> A v) S) (= (<,> A v) y))))    alan1
v'  exbii  sylibr

(A. v (<-> (e. (<,> A v) S) (= v v')))  (/\ (e. y S) (= (head y) A))  (E. v (/\ (e. (<,> A v) S) (= (<,> A v) y)))  anim3

v  (<-> (e. (<,> A v) S) (= v v'))  (/\ (e. (<,> A v) S) (= (<,> A v) y))  19.29      syl6

(<-> (e. (<,> A v) S) (= v v'))  (e. (<,> A v) S) (= (<,> A v) y)  anass  biimpri    (e. (<,> A v) S)  (= v v')  bi1   (e. (<,> A v) S)  anim1i  ancomd   (e. (<,> A v) S)  (= v v')  pm3.35    syl  (= (<,> A v) y)  anim1i  syl  v  19.22i  syl6

v  v'  A  opeq2  y  eqeq1d  biimpd  imp  v  19.22i  syl6

v  (= (<,> A v') y)  ex-nf  syl6

y  19.20i  v'  19.22i  syl

# (E. v' (A. y (-> (/\ (e. y S) (= (head y) A)) (= (<,> A v') y))))  x  alnfi
  x  (<,> A v')  tyex
  x  (<,> A v')  y  eqeq1  (/\ (e. y S) (= (head y) A))  imbi2d   y  19.21ai   19.15d  biimprd  x 19.22i  ax-mp
  v'  gen
jctil

v'  (E. x (-> (A. y (-> (/\ (e. y S) (= (head y) A)) (= (<,> A v') y))) (A. y (-> (/\ (e. y S) (= (head y) A)) (= x y)))))  (A. y (-> (/\ (e. y S) (= (head y) A)) (= (<,> A v') y)))  19.29    syl

 x  (-> (A. y (-> (/\ (e. y S) (= (head y) A)) (= (<,> A v') y))) (A. y (-> (/\ (e. y S) (= (head y) A)) (= x y))))  (A. y (-> (/\ (e. y S) (= (head y) A)) (= (<,> A v') y)))  19.41    biimpri  v'  19.22i  syl

 (A. y (-> (/\ (e. y S) (= (head y) A)) (= (<,> A v') y)))  (A. y (-> (/\ (e. y S) (= (head y) A)) (= x y)))  pm3.35    ancoms  x  19.22i  v'  19.22i  syl

v'  (E. x (A. y (-> (/\ (e. y S) (= (head y) A)) (= x y))))  ex-nf  syl

(e. y S)  (= (head y) A)  ancom  x  y  eqcom  imbi12i  y  albii  x  exbii  sylib
)

thm (maxex.2 ((S x y)) ()
(-> (-> (fun S)

      (E. x (A. y (-> (/\ (< (head y) z) (e. y S)) (<= (tail y) x)))))
    (-> (fun S)
      (E. x (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) x))))))

(head y)  z  lesuc    biimpi    (head y)  z  lefoo3      sylib
(head y)  z  nnltp1let    (= (head y) z)  orbi2i  sylibr

(e. y S)  anim1i
(= (head y) z)  (< (head y) z)  (e. y S)  andir    sylib

(fun S)  jctl    ancomd
 (fun S)  (/\ (< (head y) (S z)) (e. y S))  (\/ (/\ (= (head y) z) (e. y S)) (/\ (< (head y) z) (e. y S)))  anim3    syl
(fun S)  (/\ (= (head y) z) (e. y S))  (/\ (< (head y) z) (e. y S))  andi  syl6ib
(fun S)  (/\ (= (head y) z) (e. y S))  pm3.27  (/\ (fun S) (/\ (< (head y) z) (e. y S)))  orim1i  syl6
y  19.21ai  w  19.21ai

S  w  y  z  fun1  jca

 w  (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (\/ (/\ (= (head y) z) (e. y S)) (/\ (fun S) (/\ (< (head y) z) (e. y S))))))  (A. y (-> (/\ (= (head y) z) (e. y S)) (= y w)))  19.29    syl

# Please excuse this illegible mess.  Just pulling an implication in from the end and applying
# it to the first half of the disjunction.

  (/\ (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (\/ (/\ (= (head y) z) (e. y S)) (/\ (fun S) (/\ (< (head y) z) (e. y S)))))) (A. y (-> (/\ (= (head y) z) (e. y S)) (= y w))))  y  alnfi
  y  (-> (/\ (< (head y) (S z)) (e. y S)) (\/ (/\ (= (head y) z) (e. y S)) (/\ (fun S) (/\ (< (head y) z) (e. y S)))))  ax-4  y  (-> (/\ (= (head y) z) (e. y S)) (= y w))  ax-4  anim12i    y  19.20i  syl

 (-> (/\ (= (head y) z) (e. y S)) (= y w)) (/\ (< (head y) (S z)) (e. y S)) (\/ (/\ (= (head y) z) (e. y S)) (/\ (fun S) (/\ (< (head y) z) (e. y S)))) anim3    ancoms
 (-> (/\ (= (head y) z) (e. y S)) (= y w))  (/\ (= (head y) z) (e. y S))  (/\ (fun S) (/\ (< (head y) z) (e. y S)))  andi  syl6ib
 (/\ (= (head y) z) (e. y S))  (= y w)  pm3.35  ancoms  (/\ (-> (/\ (= (head y) z) (e. y S)) (= y w)) (/\ (fun S) (/\ (< (head y) z) (e. y S))))  orim1i
 (-> (/\ (= (head y) z) (e. y S)) (= y w))  (/\ (fun S) (/\ (< (head y) z) (e. y S)))  pm3.27  (= y w)  orim2i  syl  syl6
 y  19.20i  syl
 w  19.22i  syl


   (fun S)  x  (A. y (-> (/\ (< (head y) z) (e. y S)) (<= (tail y) x)))  imex
   y  (fun S)  (-> (/\ (< (head y) z) (e. y S)) (<= (tail y) x))  19.21  x  exbii  bitr4i
    (fun S)  (/\ (< (head y) z) (e. y S))   (<= (tail y) x)  pm3.31  y  19.20i x  19.22i    sylbi
  anim12i    ancoms
  w  (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (\/ (= y w) (/\ (fun S) (/\ (< (head y) z) (e. y S)))))) x  (A. y (-> (/\ (fun S) (/\ (< (head y) z) (e. y S))) (<= (tail y) x)))  exey    syl
  y  (-> (/\ (< (head y) (S z)) (e. y S)) (\/ (= y w) (/\ (fun S) (/\ (< (head y) z) (e. y S)))))  (-> (/\ (fun S) (/\ (< (head y) z) (e. y S))) (<= (tail y) x))  alan12   x  19.22i  w  19.22i  syl

  # Once again, pulling an implication in and applying it to part of the disjunction.
  (-> (/\ (fun S) (/\ (< (head y) z) (e. y S))) (<= (tail y) x))  (/\ (< (head y) (S z)) (e. y S))  (\/ (= y w) (/\ (fun S) (/\ (< (head y) z) (e. y S))))  anim3    ancoms     (-> (/\ (fun S) (/\ (< (head y) z) (e. y S))) (<= (tail y) x))  (= y w)  (/\ (fun S) (/\ (< (head y) z) (e. y S)))  andi   syl6ib  (-> (/\ (fun S) (/\ (< (head y) z) (e. y S))) (<= (tail y) x))  (= y w)  pm3.27  (/\ (-> (/\ (fun S) (/\ (< (head y) z) (e. y S))) (<= (tail y) x)) (/\ (fun S) (/\ (< (head y) z) (e. y S))))  orim1i  syl6  (/\ (fun S) (/\ (< (head y) z) (e. y S)))  (<= (tail y) x)  pm3.35 ancoms  (= y w)  orim2i  syl6
    (tail w)  x  addge01t      y  w  taileq  (+ (tail w) x) leeq1d  mpbiri
      x  (tail w)  addge01t  x  (tail w)  addcom  x  leeq2i  mpbi  (tail y)  x  (+ (tail w) x)  letr  ancoms  ex  ax-mp
    jaoi  (/\ (< (head y) (S z)) (e. y S))  imim2i
  syl
y  19.20i  x  19.22i  w  19.22i  syl

    v  (+ (tail w) x)  tyex
    (= v (+ (tail w) x))  id    (tail y)  leeq2d  biimprd  (/\ (< (head y) (S z)) (e. y S))  imim2d  y  19.21ai  v  19.22i  ax-mp
     x  gen  w  gen

#  w  (A. x (E. v (-> (-> ph (<= (tail y) (+ (tail w) x))) (-> ph (<= (tail y) v)))))  (E. x (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x)))))  19.29    x  (E. v (-> (-> ph (<= (tail y) (+ (tail w) x))) (-> ph (<= (tail y) v))))  (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x))))  19.29  w  19.22i  syl  ex  ax-mp    syl

  w  (A. x (E. v (A. y (-> (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x))) (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) v))))))  (E. x (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x)))))  19.29    x  (E. v (A. y (-> (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x))) (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) v)))))  (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x))))    19.29  w  19.22i  syl  ex  ax-mp    syl

  v  (A. y (-> (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x))) (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) v))))  (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x))))   19.41   biimpri    y (-> (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x))) (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) v)))  (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x)))  alan12  (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x)))  (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) v))  pm3.35  ancoms  y  19.20i  syl  v  19.22i  syl  x  19.22i  w  19.22i  syl


  w  (E. x (E. v (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) v)))))  ex-nf  syl
  x  (E. v (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) v))))  ex-nf  syl
  (= v x)  id    (tail y)  leeq2d  (/\ (< (head y) (S z)) (e. y S))  imbi2d  y  19.21ai    19.15d  exalpha  sylib
ex
)

thm (maxex ((A x y) (S x y)) ()
  (-> (fun S)
      (E. x (A. y (-> (/\ (< (head y) A) (e. y S)) (<= (tail y) x)))))
  x' (0) S  x  y    maxex.1
    x' y' S  x  y    maxex.1
      x' (S y') S  x  y    maxex.1
       x'  A  S  x  y  maxex.1
# Base case is trivial
         (head y)  nn0nlt0     (<= (tail y) x)  pm2.21i  (e. y S)  adantr
         y  gen   x  19.8ai    (fun S) a1i
           S  x  y  y'  maxex.2

  finds
)

thm (df-relprim-just ((A x x') (B x x')) ()
  (<-> (A. x (-> (| B (* A x)) (| B x)))
       (A. x' (-> (| B (* A x')) (| B x'))))
  x  x'  A  muleq2   (* A x)  (* A x')  B  divideseq2  syl
  x  x'  B  divideseq2
  imbi12d
  alpha
)

# Definition of "relatively prime"
defthm  (df-relprim wff (relprim A B) ((A x) (B x)) ()
        (<-> (relprim A B) (A. x (-> (| B (* A x)) (| B x))))
          x' B A x df-relprim-just)

# number 120.0
# Induction tool for relprimex
thm (relprimex.1 ((C y z)) ()
(-> (= x' C)
    (<->
(-> (A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y))))
     (E. z (/\ (A. y (-> (/\ (< (S (S y)) x') (e. (S (S y)) S))     (| (S (S y)) z)))
               (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z)))))))
(-> (A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y))))
     (E. z (/\ (A. y (-> (/\ (< (S (S y)) C) (e. (S (S y)) S))     (| (S (S y)) z)))
               (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z)))))))))
  (= x' C)  id  (S (S y))  lteq2d
  (e. (S (S y)) S)  anbi1d
  (| (S (S y)) z)  imbi1d
  y  19.21ai  19.15d
  (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z))))  anbi1d
  z  exbid
  (A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y))))  imbi2d

)
# number 122.0
# base case for relprimex
thm (relprimex.2 () ()
 (-> (A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y))))
     (E. z (/\ (A. y (-> (/\ (< (S (S y)) (0)) (e. (S (S y)) S))     (| (S (S y)) z)))
               (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z)))))))

z  (1)  tyex
  (S (S y))  nn0nlt0
  (| (S (S y)) z)  pm2.21i
  (e. (S (S y)) S)  adantr
  y  gen
    y  divides1    z  (1)  (S (S y)) divideseq2  notbid  biimprd  mpi
    (e. (S (S y)) T)  a1d  y 19.21ai
  jctilb
  z  19.22i
ax-mp
(A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y))))  a1i
)

# Equality theorem for relative primeness, second argument
thm (relprimeq2 () () (-> (= A B) (<-> (relprim C A) (relprim C B)))
  A  B  (* C x)  divideseq1
  A  B  x  divideseq1
  imbi12d
  x  19.21ai  19.15d
  C  A  x  df-relprim  syl5bb
  C  B  x  df-relprim  syl6bbr
)

# Equality theorem for relative primeness, first argument
thm (relprimeq1 () () (-> (= A B) (<-> (relprim A C) (relprim B C)))
  A  B   x  muleq1  (* A x)  (* B x)  C  divideseq2    syl    (| C x)  imbi1d
  x  19.21ai  19.15d
  A  C  x  df-relprim  syl5bb
  B  C  x  df-relprim  syl6bbr
)

# induction step for relprimex
thm (relprimex.3 ((S x y z) (T x y z) (A x y z)) ()
(->
 (-> (A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y))))
     (E. z (/\ (A. y (-> (/\ (< (S (S y)) A) (e. (S (S y)) S))    (| (S (S y)) z)))
               (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z)))))))
 (-> (A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y))))
     (E. z (/\ (A. y (-> (/\ (< (S (S y)) (S A)) (e. (S (S y)) S)) (| (S (S y)) z)))
               (A. y (-> (e. (S (S y)) T)  (-. (| (S (S y)) z)))))))
)


# Case 1: A is in S.  Now we take z from the IHOP and use z*A as the new z.
  (e. (S (S y)) S)  (< (S (S y)) A)  ancom    biimpi    (| (S (S y)) z)  imim1i
    A  dividessym     A  A  z  dividesmul    ax-mp    (S (S y)) A  (* A z)  divideseq1   mpbiri
    z  A  mulcom    (* z A)  (* A z)  (S (S y))  divideseq2  ax-mp    sylibr
    (e. (S (S y)) S)  adantl  (-> (/\ (e. (S (S y)) S) (< (S (S y)) A)) (| (S (S y)) z))  a1i
      (S (S y))  z  A  dividesmul    (/\ (e. (S (S y)) S) (< (S (S y)) A))  imim2i
    jaod
    (e. (S (S y)) S) (= (S (S y)) A) (< (S (S y)) A)  andi      biimpi   ancoms  syl5
      (S (S y))  A  lesuc    biimpi (S (S y))  A  lefoo3    sylib
      (S (S y))  A  nnltp1let    (= (S (S y)) A)  orbi2i    sylibr
    (e. (S (S y)) S) anim1i    syl5
  syl
  y  19.20i
  (/\ (e. A S) (A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y)))))  a1i
    x  A  S  ax-eleq1  (e. y T)  anbi1d
    x  A  y  relprimeq1    imbi12d     (e. A S)  (e. y T)  (relprim A y)  impexp    (= x A)  a1i    bitrd
    y  19.21ai  19.15d  cla4g y
    (e. A S)  (-> (e. y T) (relprim A y))  19.21    sylib    com12    imp
    y  (S (S z)) T  ax-eleq1    y  (S (S z))  A  relprimeq2  imbi12d    cla4g   z  19.21ai
      (= z y)  id    suceqd    suceqd   (S (S z)) (S (S y))  T  ax-eleq1   syl
      (= z y)  id    suceqd    suceqd   (S (S z)) (S (S y))  A  relprimeq2    syl  imbi12d  cla4g
    syl syl
    A  (S (S y))  z  df-relprim  syl6ib
    z  (-> (| (S (S y)) (* A z)) (| (S (S y)) z))  ax-4    syl6
    imp    A  z  mulcom  (* A z)  (* z A)  (S (S y))  divideseq2  ax-mp  syl5ibr
    con3d     ex     a2d    y 19.21ai
    y  (->  (e. (S (S y)) T) (-. (| (S (S y)) z)))  (-> (e. (S (S y)) T) (-. (| (S (S y)) (* z A))))  ax-alim   syl
  anim12d
  z  19.22d
  ex  a2d
  # Need to alpha-switch z -> z * A
  imp  imp
   (/\ (A. y (-> (/\ (< (S (S y)) (S A)) (e. (S (S y)) S)) (| (S (S y)) (* z A)))) (A. y (->  (e. (S (S y)) T) (-. (| (S (S y)) (* z A))))))  z'  alnfi
    z'  (* z A)  tyex
      z'  (* z A)  (S (S y))  divideseq2    (/\ (< (S (S y)) (S A)) (e. (S (S y)) S))  imbi2d    y  19.21ai  19.15d
        z'  (* z A)  (S (S y))  divideseq2    notbid  (e. (S (S y)) T)  imbi2d    y  19.21ai    19.15d
      anbi12d  biimprd
    z'  19.22i    ax-mp
    z'  (/\ (A. y (-> (/\ (< (S (S y)) (S A)) (e. (S (S y)) S)) (| (S (S y)) (* z A)))) (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) (* z A))))))  (/\ (A. y (-> (/\ (< (S (S y)) (S A)) (e. (S (S y)) S)) (| (S (S y)) z'))) (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z')))))  eximp1  ax-mp
   syl
   z    19.22i
   19.9d
     z'  z  (S (S y))  divideseq2  (/\ (< (S (S y)) (S A)) (e. (S (S y)) S))  imbi2d
     y  19.21ai    19.15d
       z'  z  (S (S y))  divideseq2  notbid    (e. (S (S y)) T)  imbi2d
       y  19.21ai    19.15d
     anbi12d
   exalpha    sylib
  syl
  ex  ex
# Case 2: A is not in S.  This is easy, because the x from the IHOP works again;
# but ugly, because of all the mandhyps.
  (S (S y))  A  S  ax-eleq1  notbid  biimprd     com12    con2d
    (S (S y))  A  lesuc    biimpi (S (S y))  A  lefoo3    sylib
    (S (S y))  A  nnltp1let    (= (S (S y)) A)  orbi2i    sylibr   ord
  syl9
  (e. (S (S y)) S)  (< (S (S y)) A)  ancr     (< (S (S y)) (S A))  imim2i  (-. (e. A S))  imim2i  ax-mp
  imp3a
  (| (S (S y)) z)  imim1d
  y  19.21ai
  y  (-> (/\ (< (S (S y)) A) (e. (S (S y)) S)) (| (S (S y)) z))  (-> (/\ (< (S (S y)) (S A)) (e. (S (S y)) S)) (| (S (S y)) z))  ax-alim      syl
  (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z))))  anim1d
  z  19.21ai
  z  (/\ (A. y (-> (/\ (< (S (S y)) A) (e. (S (S y)) S)) (| (S (S y)) z))) (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z)))))  (/\ (A. y (-> (/\ (< (S (S y)) (S A)) (e. (S (S y)) S)) (| (S (S y)) z))) (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z)))))  19.22    syl
  (A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y))))  imim2d

# Unify cases 1 and 2.
pm2.61i
)
# number 127.0
# A development of Godel's Beta Function, following Shoenfield(1967).
# Suppose everything in S is relatively prime to everything in T.
# Then there's a number x divisible by everything in (1,A) & S and by nothing in (1, B) & T.
# We prove this by induction on A.
thm (relprimex ((S x y z) (T x y z) (A y z)) ()
 (-> (A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y))))
     (E. z (/\ (A. y (-> (/\ (< (S (S y)) A) (e. (S (S y)) S))     (| (S (S y)) z)))
               (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z)))))))
  x' (0)  x  y  S   T   z relprimex.1
    x' y'  x   y  S   T   z relprimex.1
      x' (S y')  x  y  S   T  z  relprimex.1
        x' A  x  y  S   T  z relprimex.1
          x  y  S  T  z  relprimex.2
            x  y  S  T  z  y'     relprimex.3
  finds
)

# number 128.0
thm (relprimcom () () (-> (relprim A (S B)) (relprim (S B) A))
A  (* (S B) y)  x  df-divides
    A  (S B)  x  df-relprim    biimpi    x  (-> (| (S B) (* A x)) (| (S B) x))  ax-4  syl
    (S B)  (* A x)  y  df-divides  syl5ibr
    (= (* (S B) y) (* A x))  y  19.8a    syl5
    (S B)  x  z  df-divides  syl6ib
    ancrd
    z  (= (* (S B) z) x)  (= (* (S B) y) (* A x))  19.41    syl6ibr
    (* (S B) z)  x  A  muleq2  eqcomd
    (* (S B) y)  (* A x)  eqcom   biimpi anim12i
    (* A x)  (* A (* (S B) z))  (* (S B) y)   ax-eqtr    syl
    A  (S B)  z  mulass  syl5eq
    A  (S B)  mulcom    z  muleq1i  syl5eqr
    (S B)  A  z  mulass   (* (S B) y)  eqeq1i        B  (* A z)  y  mulcan2   sylbi  syl  z  19.22i  syl6
  A  y  z  df-divides    syl6ibr    com12    eqcoms
x  19.22i  sylbi  19.9d  com12
y  19.21ai

(S B)  A  y  df-relprim  sylibr
)

# number 128.5
thm (beta.1.1 () () (relprim (S A) (S (* B (S A))))
  (* B (S A))  x  pa_ax6r
  (S A)  B  mulcom  x  muleq1i
  (S A)  B  x  mulass  eqtr3  x  addeq1i  eqtr

  (* (S (* B (S A))) x)  (+ (* (S A) (* B x)) x)  (S A)  divideseq2  ax-mp
  A  (* B x)  x  dividesadd.1  sylbi  x  gen
  (S (* B (S A)))  (S A)  x  df-relprim  mpbir
  (S (* B (S A)))  A  relprimcom  ax-mp
)

# number 128.6
thm (dividesmul12 () () (-> (| A B) (| (* A C) (* B C)))
  A  B  x  df-divides
    (* A x)  B  C  muleq1
      A  x  C  mulass    x  C  mulcom  (* x C)  (* C x)  A  muleq2  ax-mp  eqtr
      A  C  x  mulass  eqtr4 (* B C)  eqeq1i  sylib
    x  19.22i  sylbi
  (* A C)  (* B C)  x  df-divides  sylibr
)
# number 129.0
# A development of Godel's Beta Function, following Shoenfield(1967).
# k=A', z=B', j=C
thm (beta.1 () () (-> (| (S A) (S B)) (relprim (S (* (+ C (S A)) (S B))) (S (* C (S B)))))
    (* (+ C (S A)) (S B))  x  pa_ax6r
    C  (S A)  (S B)  distl  x  muleq1i  x  addeq1i  eqtr
    (* C (S B))  (* (S A) (S B))  x  distl  x  addeq1i  eqtr
    (* (* C (S B)) x)  (* (* (S A) (S B)) x)  x  addass  (* (* (S A) (S B)) x)  x  addcom  (* (* C (S B)) x)  addeq2i    eqtr   (* (* C (S B)) x)  x  (* (* (S A) (S B)) x)  addass  eqtr4  eqtr
    (* C (S B))  x  pa_ax6r  (* (* (S A) (S B)) x)  addeq1i  eqtr4
    (* (S (* (+ C (S A)) (S B))) x)  (+ (* (S (* C (S B))) x) (* (* (S A) (S B)) x))  (S (* C (S B)))  divideseq2  ax-mp
    (* C (S B))  x  (* (* (S A) (S B)) x)  dividesadd.1    sylbi
    (S A)  (S B)  mulcom  x  muleq1i  (S B)  (S A)  x  mulass  eqtr  (* (* (S A) (S B)) x)  (* (S B) (* (S A) x))  (S (* C (S B)))  divideseq2  ax-mp  sylib

      B  C  beta.1.1  (S B)  (S (* C (S B)))  y  df-relprim  mpbi
        y  (* (S A) x)  (S B)  muleq2    (* (S B) y)  (* (S B) (* (S A) x))  (S (* C (S B)))  divideseq2  syl
  y  (* (S A) x)  (S (* C (S B)))  divideseq2    imbi12d    cla4g    ax-mp   syl
  (S A)  (S B)  x  dividesmul12  anim12i
  (S (* C (S B)))  (* (S A) x)  (* (S B) x)  dividestr  syl
  B  C  beta.1.1  (S B)  (S (* C (S B)))  x  df-relprim  mpbi   a4i  syl
  ex  com12   x  19.21ai

  (S (* (+ C (S A)) (S B))) (S (* C (S B)))  x  df-relprim  sylibr
)

# number 131.0
thm (sucsuc ((A x)) () (<-> (E. x (= A (S (S x)))) (< (1) A))
  x  pa_ax1
  (S x)  eq0le0    biimpri   eqcomd  con3i   ax-mp
  (S x)  (0)  lesuc1     notbii  mpbi
  (S (S x))  (S (0))  lenltt   notbii  mpbi     notnotri
  df-1  (S (S x)) lteq1i  mpbir
  (= A (S (S x)))  id   (1)  lteq2d   mpbiri
  x  19.22i  x  (< (1) A)  ex-nf  syl


     (1)  A  axlttri   (= (1) A)  (< A (1))  ioran  bitri
     A  (1)  nnltp1let
       A  eq0le0   A  (0)  (1)  leadd1    bitri    (1)  pa_ax3r  (+ A (1))  leeq2i  bitri  bitr4i
     notbii
     A  z  lefoo     ori    sylbi
   (-. (= (1) A))  anim2i   sylbi
       z  (0)  (1)  addeq2  (1)  pa_ax3  syl6eq  A  eqeq1d  biimpd  com12  imp  con3i
     (= (+ (1) z) A)  (= z (0))  ianor  sylib   z  19.21ai
     (E. z (= (+ (1) z) A))  anim1i   syl
     z  (\/ (-. (= (+ (1) z) A)) (-. (= z (0))))  (= (+ (1) z) A)  19.29      syl
      (= (+ (1) z) A)  pm3.24     (= (+ (1) z) A)  (-. (= (+ (1) z) A))  ancom  notbii  mpbi
       (-. (= (+ (1) z) A))  (-. (= z (0)))  (= (+ (1) z) A)  andir
       (/\ (-. (= (+ (1) z) A)) (= (+ (1) z) A))  (/\ (-. (= z (0))) (= (+ (1) z) A))  df-or  bitri  biimpi
      mpi
      z  x  lefoo    ori  (= (+ (1) z) A)  anim1i  syl
      x  (= (+ (1) x) z)  (= (+ (1) z) A)  19.41      sylibr
    z  19.22i  syl
      x  a1suc    x  (1)  addcom  eqtr  z  eqeq1i  biimpri    suceqd  eqcomd
      z  a1suc    z  (1)  addcom  eqtr  A  eqeq1i  biimpri    anim12i
      (S z)  (S (S x))  A  ax-eqtr  syl  eqcomd
    x  19.22i  z  19.22i  syl  z  (E. x (= A (S (S x))))  ex-nf  syl

   impbii
)
# number 133.0
# Like relprimex, but without the class abstraction
thm (relprimex2 ((A x z) (ps x z) (ph v z)) (h1 (rwff x ph) h2 (rwff v ps))
 (-> (A. x (A. v (-> (/\ ph  ps) (relprim x v))))
     (E. z (/\ (A. x (-> (/\ (< (1) x) (/\ (< x A) ph)) (| x z)))
               (A. v (-> (/\ (< (1) v) ps) (-. (| v z)))))))

h1  abid  h2  abid    anbi12i  (relprim x v) imbi1i  v  albii  x  albii  biimpri
  v  y  ({|} v ps)  ax-eleq1    (e. x ({|} x ph))  anbi2d
  v  y  x  relprimeq2    imbi12d
  alpha
x  albii  sylib

  x  y  ({|} x ph) ({|} v ps)  z  A  relprimex  syl
    y  x   sucsuc  biimpri
      (= x (S (S y)))  id    A  lteq1d
      x  (S (S y))  ({|} x ph)  ax-eleq1    h1  abid     syl5bbr    anbi12d
      x  (S (S y))  z  divideseq1    imbi12d  biimprd
    y  19.22i  syl
    (A. y (-> (/\ (< (S (S y)) A) (e. (S (S y)) ({|} x ph))) (| (S (S y)) z)))  anim2i
    y  (-> (/\ (< (S (S y)) A) (e. (S (S y)) ({|} x ph))) (| (S (S y)) z))  (-> (-> (/\ (< (S (S y)) A) (e. (S (S y)) ({|} x ph))) (| (S (S y)) z)) (-> (/\ (< x A) ph) (| x z)))  19.29    syl
    (-> (/\ (< (S (S y)) A) (e. (S (S y)) ({|} x ph))) (| (S (S y)) z))  (-> (/\ (< x A) ph) (| x z))  pm3.35    y  19.22i  syl
    y  (-> (/\ (< x A) ph) (| x z))  ex-nf  syl
    expimpd
    x  19.21ai

    y  v   sucsuc  biimpri
      v  (S (S y))  ({|} v ps)  ax-eleq1    h2  abid     syl5bbr
      v  (S (S y))  z  divideseq1  notbid   imbi12d  biimprd
    y  19.22i  syl
    (A. y (-> (e. (S (S y)) ({|} v ps)) (-. (| (S (S y)) z))))  anim2i
    y  (-> (e. (S (S y)) ({|} v ps)) (-. (| (S (S y)) z)))  (-> (-> (e. (S (S y)) ({|} v ps)) (-. (| (S (S y)) z))) (-> ps (-. (| v z))))  19.29    syl
    (-> (e. (S (S y)) ({|} v ps)) (-. (| (S (S y)) z)))  (-> ps (-. (| v z)))  pm3.35    y  19.22i  syl
    y  (-> ps (-. (| v z)))  ex-nf  syl
    expimpd
    v  19.21ai

    anim12i
  z  19.22i  syl

)

# number 134.5
thm (beta.2.1 ((A w x y)) ()   (E. w (A. x (A. y (-> (/\ (<= y x) (/\ (-. (= x y)) (/\ (< x A) (< y A))))
                                          (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))))))

  y  x  v df-le
    v  (0)  y  addeq2    y  pa_ax3  syl6eq  x  eqeq1d  biimpd  com12  imp  eqcomd  ex  con3d
    v  z  lefoo   ori    syl6  z  a1suc  (1)  z  addcom eqtr4   v  eqeq1i  z  exbii  syl6ibr
    anc2li  z  (= (+ y v) x)  (= (S z) v)  19.41r  syl6ibr
    (S z) v  y  addeq2  x  eqeq1d  biimprd  com12  imp
    (+ y (S z))  x  (S (S w))  muleq1  suceqd
     (S (* (+ y (S z)) (S (S w))))   (S (* x (S (S w))))  (S (* y (S (S w))))  relprimeq1  syl
      x  A  df-lt  biimpi  pm3.26d     A  y  addge01t   x A  (+ A y)  letr  mpan2    syl
      (= (+ y (S z)) x)  id (+ A y)  leeq1d    biimprd   com12  syl  com12
      y  (S z)  addcom  (+ A y)    leeq1i  syl6ib
      (S z)  A  y  leadd1      syl6ibr
      A  (1)  addge01t  A  a1suc  A  leeq2i  mpbir  (S z)  A  (S A) letr  mpan2   syl6
     jca
    syl
    (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w))))))  (< x A)  (<= (S z) (S A))  anim3    syl
  z  19.22i  syl6    v  19.22i  v  (-> (-. (= x y)) (E. z (-> (< x A) (/\ (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))) (<= (S z) (S A))))))  ex-nf  syl
sylbi
(< x A)  z  (/\ (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))) (<= (S z) (S A)))  imex  syl6ibr
imp imp

(/\ (/\ (<= y x) (-. (= x y))) (< x A))  z  (/\ (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))) (<= (S z) (S A)))  imex  mpbi

y  gen  x  gen  w  gen
  w  z  A  exfactorial
  z (S w)  y  beta.1  (<= (S z) (S A))  imim2i  z  19.20i  y 19.21ai  x  19.21ai    w  19.22i  ax-mp
pm3.2i


w  (A. x (A. y (E. z (-> (/\ (/\ (<= y x) (-. (= x y))) (< x A)) (/\ (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))) (<= (S z) (S A)))))))  (A. x (A. y (A. z (-> (<= (S z) (S A)) (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w)))))))))    19.29     ax-mp

x  (A. y (E. z (-> (/\ (/\ (<= y x) (-. (= x y))) (< x A)) (/\ (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))) (<= (S z) (S A))))))  (A. y (A. z (-> (<= (S z) (S A)) (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))))))  alan12  y  (E. z (-> (/\ (/\ (<= y x) (-. (= x y))) (< x A)) (/\ (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))) (<= (S z) (S A)))))  (A. z (-> (<= (S z) (S A)) (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w)))))))  alan12   x  19.20i  syl  w  19.22i  ax-mp


z  (-> (<= (S z) (S A)) (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))))  (-> (/\ (/\ (<= y x) (-. (= x y))) (< x A)) (/\ (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))) (<= (S z) (S A))))  19.29  ancoms    y  19.20i  x  19.20i  w  19.22i    ax-mp

(-> (<= (S z) (S A)) (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))))  (/\ (/\ (<= y x) (-. (= x y))) (< x A))  (/\ (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))) (<= (S z) (S A)))  anim3

(/\ (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))) (<= (S z) (S A)))  (-> (<= (S z) (S A)) (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))))  ancom  biimpri  (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w))))))  (<= (S z) (S A))  (-> (<= (S z) (S A)) (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))))  anass  sylib  (<= (S z) (S A))  (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w)))))  pm3.35   (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w))))))  anim2i   syl   (/\ (/\ (<= y x) (-. (= x y))) (< x A))  imim2i  syl

(relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w)))))  (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))  bi1  (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w)))))  anim2i   (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w)))))  (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))  pm3.35  syl  ancoms  syl6

z  19.22i

z  (-> (/\ (/\ (<= y x) (-. (= x y))) (< x A)) (relprim (S (* x (S (S w)))) (S (* y (S (S w))))))  ex-nf  syl   y  19.20i  x  19.20i  w  19.22i  ax-mp

(/\ (/\ (<= y x) (-. (= x y))) (< x A))  (< y A)  pm3.26

# To avoid time-travel, we'll use contrapositives...
con3i

(<= y x)  (-. (= x y))  (< x A)  anass  (< y A)  anbi1i  notbii sylib
(<= y x)  (/\ (-. (= x y)) (< x A))  (< y A)  anass  notbii  sylib
(-. (= x y))  (< x A)  (< y A)  anass  (<= y x)  anbi2i  notbii  sylib

con4i

(relprim (S (* x (S (S w)))) (S (* y (S (S w)))))  imim1i  y  19.20i  x  19.20i  w  19.22i  ax-mp
)
# number 135.0
thm (beta.2 ((A w x y)) ()   (E. w (A. x (A. y (->  (/\ (-. (= x y)) (/\ (< x A) (< y A)))
                                          (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))))))


w  x  y  A beta.2.1

(= x z)  id  y  leeq2d    x  z  y  eqeq1  notbid   (= x z)  id   A  lteq1d    (< y A)  anbi1d    anbi12d  anbi12d
x  z  (S (S w)) muleq1   suceqd
(S (* x (S (S w))))  (S (* z (S (S w))))  (S (* y (S (S w))))  relprimeq1 syl  imbi12d
y  19.21ai   y  (-> (/\ (<= y x) (/\ (-. (= x y)) (/\ (< x A) (< y A)))) (relprim (S (* x (S (S w)))) (S (* y (S (S w))))))  (-> (/\ (<= y z) (/\ (-. (= z y)) (/\ (< z A) (< y A)))) (relprim (S (* z (S (S w)))) (S (* y (S (S w))))))  19.15  syl
alpha

(= y x)  id  z  leeq1d   y  x  z  eqeq2  notbid    (= y x)  id  A  lteq1d    (< z A)  anbi2d  anbi12d  anbi12d

y  x  (S (S w)) muleq1   suceqd
(S (* y (S (S w))))  (S (* x (S (S w))))  (S (* z (S (S w))))  relprimeq2 syl  imbi12d
alpha  z  albii  bitri

(= z y)  id  x  leeq2d    z  y  x  eqeq1  notbid   (= z y)  id   A  lteq1d    (< x A)  anbi1d    anbi12d  anbi12d
z  y  (S (S w)) muleq1   suceqd
(S (* z (S (S w))))  (S (* y (S (S w))))  (S (* x (S (S w))))  relprimeq1 syl  imbi12d
x  19.21ai   x  (-> (/\ (<= x z) (/\ (-. (= z x)) (/\ (< z A) (< x A)))) (relprim (S (* z (S (S w)))) (S (* x (S (S w))))))  (-> (/\ (<= x y) (/\ (-. (= y x)) (/\ (< y A) (< x A)))) (relprim (S (* y (S (S w)))) (S (* x (S (S w))))))  19.15  syl
alpha
bitri

y  x  (-> (/\ (<= x y) (/\ (-. (= y x)) (/\ (< y A) (< x A)))) (relprim (S (* y (S (S w)))) (S (* x (S (S w))))))  ax-7  sylbi


(S (* y (S (S w))))  (* x (S (S w)))  relprimcom  (/\ (<= x y) (/\ (-. (= y x)) (/\ (< y A) (< x A))))  imim2i  y  19.20i  x  19.20i  syl

y  x  eqcom  notbii   (< y A)  (< x A)  ancom   anbi12i  (<= x y)  anbi2i  (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))  imbi1i  y  albii  x  albii  sylib

ancri

x  (A. y (-> (/\ (<= x y) (/\ (-. (= x y)) (/\ (< x A) (< y A)))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))))  (A. y (-> (/\ (<= y x) (/\ (-. (= x y)) (/\ (< x A) (< y A)))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))))  alan12  syl

y  (-> (/\ (<= x y) (/\ (-. (= x y)) (/\ (< x A) (< y A)))) (relprim (S (* x (S (S w)))) (S (* y (S (S w))))))  (-> (/\ (<= y x) (/\ (-. (= x y)) (/\ (< x A) (< y A)))) (relprim (S (* x (S (S w)))) (S (* y (S (S w))))))  alan12  x  19.20i  syl



    (<= x y)  (/\ (-. (= x y)) (/\ (< x A) (< y A)))  (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))  impexp    (<= y x)  (/\ (-. (= x y)) (/\ (< x A) (< y A)))  (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))  impexp  anbi12i
      x  y  letot  ori   (-> (/\ (-. (= x y)) (/\ (< x A) (< y A))) (relprim (S (* x (S (S w)))) (S (* y (S (S w))))))  imim1i  (-> (<= x y) (-> (/\ (-. (= x y)) (/\ (< x A) (< y A))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))))  anim2i
      (<= x y)  (-> (/\ (-. (= x y)) (/\ (< x A) (< y A))) (relprim (S (* x (S (S w)))) (S (* y (S (S w))))))  pm4.83   biimpi  syl
    sylbi
    y  19.20i  x  19.20i  syl

w  19.22i  ax-mp
)
# number 135.1
thm (beta.2s ((A w x y)) ()   (E. w (A. x (A. y (->  (/\ (-. (= x y)) (/\ (< x A) (< y A)))
                                          (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w)))))))))

  v  (S x)  tyex  x  gen
    z  (S y)  tyex  y gen

pm3.2i
  y  (A. x (E. v (= v (S x))))  (E. z (= z (S y)))  alan1  biimpri   ax-mp
  x  (E. v (= v (S x)))  (E. z (= z (S y)))  alan2  y  albii mpbir
  v  (= v (S x))  z  (= z (S y))  exey  x  19.20i  y  19.20i  ax-mp
   z  (S y)  v  eqeq2  v  (S x)  (S y)  eqeq1  sylan9bb      notbid  ancoms
    (= v (S x))  id  (S A)  lteq1d
     (= z (S y))  id  (S A)  lteq1d  bi2anan9
       A x  lenltt   con2bii  A  x  lesuc1  notbii   (S A)  (S x)  lenltt   con2bii  bitr4i    bitri
       A y  lenltt   con2bii  A  y  lesuc1  notbii   (S A)  (S y)  lenltt   con2bii  bitr4i    bitri  anbi12i
     syl6bbr
   anbi12d
     v  (S x)  (S (S w)) muleq1  suceqd  (S (* v (S (S w)))) (S (* (S x) (S (S w)))) (S (* z (S (S w)))) relprimeq1  syl
     z  (S y)  (S (S w)) muleq1  suceqd  (S (* z (S (S w)))) (S (* (S y) (S (S w)))) (S (* (S x) (S (S w)))) relprimeq2  syl
   sylan9bb
  imbi12d

  z  19.22i  v  19.22i  x  19.20i  y  19.20i  ax-mp
  w  gen

    w  v  z (S A)  beta.2
  pm3.2i

  w  (A. y (A. x (E. v (E. z (<-> (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w)))))) (-> (/\ (-. (= (S x) (S y))) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w)))))))))))  (A. v (A. z (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w))))))))  19.29  ax-mp

  x  (E. v (E. z (<-> (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w)))))) (-> (/\ (-. (= (S x) (S y))) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w)))))))))  (A. v (A. z (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w))))))))  alan2  y  albii  y  (A. x (E. v (E. z (<-> (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w)))))) (-> (/\ (-. (= (S x) (S y))) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w))))))))))  (A. v (A. z (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w))))))))  alan2   bitri  w  exbii  mpbir

 v  (A. z (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w)))))))  (E. z (<-> (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w)))))) (-> (/\ (-. (= (S x) (S y))) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w))))))))  19.29  ancoms  z  (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w))))))  (<-> (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w)))))) (-> (/\ (-. (= (S x) (S y))) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w)))))))  19.29  v  19.22i  syl  x  19.20i  y  19.20i  w  19.22i  ax-mp

  (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w))))))  (-> (/\ (-. (= (S x) (S y))) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w))))))  bi1    (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w))))))  anim2i  (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w))))))  (-> (/\ (-. (= (S x) (S y))) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w))))))  pm3.35  syl   z 19.22i  v  19.22i  x  19.20i  y  19.20i  w  19.22i  ax-mp

  v  (E. z (-> (/\ (-. (= (S x) (S y))) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w)))))))  ex-nf    z  (-> (/\ (-. (= (S x) (S y))) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w))))))  ex-nf  syl  x  19.20i  y  19.20i  w  19.22i  ax-mp

  x  y  pa_ax2  notbii (/\ (< x A) (< y A))  anbi1i  (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w)))))  imbi1i  biimpri  x  19.20i  y  19.20i  w  19.22i  ax-mp

  y  x  (-> (/\ (-. (= x y)) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w))))))  ax-7  w  19.22i  ax-mp

)
# number 137.5
thm (beta.3.1 () (
h1 (<-> ph (E. x' (/\ ps (= x (S (* (S x') (S A))))))))
(-> ph (< (1) x))
h1

A  pa_ax1  (S A)  0orpos  ori  con1i    eqcomd  con1i  ax-mp
(1)  (S A)  (S x')  lemul2  ax-mp
x'  pa_ax1  (S x')  0orpos  ori  con1i    eqcomd  con1i  ax-mp
(1)  (S x')  (1)  lemul2  ax-mp
(1)  (S x')  mulcom  (* (1) (1))  leeq2i  mpbi
(* (1) (1))  (* (S x') (1))  (* (S x') (S A))  letr  mpan  ax-mp
(1)  mulid  (* (S x') (S A))  leeq1i  mpbi
(1)  (* (S x') (S A))  lesuc  mpbir

(= x (S (* (S x') (S A))))  id  (1) lteq2d  biimprd  mpi  ps  adantl

x'  19.22i  x'  (< (1) x)  ex-nf  syl

sylbi
)

# number 137.6
thm (lesuc12 () () (<-> (<= A B) (<= (S A) (S B)))
A  B   (1)  leadd1  A  a1suc  (+ B (1)) leeq1i  bitr4i  B  a1suc  (S A)  leeq2i  bitr4i
)

# number 138.0
# A development of Godel's Beta Function, following Shoenfield(1967).
thm (beta.3 ((A w x y x' y' z') (B w x y x' y') (ph y z') (ps x z') (S x y x' y')) (
h1 (<-> ph (E. x' (/\ (/\ (<= x' A) (e. x' S))  (= x (S (* (S x') (S (S w))))))))
h2 (<-> ps (E. y' (/\ (/\ (<= y' B) (-. (e. y' S))) (= y (S (* (S y') (S (S w)))))))))
(E. w (E. z' (/\ (A. x (-> ph (| x z'))) (A. y (-> ps (-. (| y z')))))))

  h1  h2  anbi12i  biimpi
  x'  (/\ (/\ (<= x' A) (e. x' S)) (= x (S (* (S x') (S (S w))))))  (E. y' (/\ (/\ (<= y' B) (-. (e. y' S))) (= y (S (* (S y') (S (S w)))))))   19.41  sylibr
  y'  (/\ (/\ (<= y' B) (-. (e. y' S))) (= y (S (* (S y') (S (S w))))))  (/\ (/\ (<= x' A) (e. x' S)) (= x (S (* (S x') (S (S w))))))  19.41  biimpri  ancoms  x'  19.22i  syl

  (/\ (<= y' B) (-. (e. y' S)))  (= y (S (* (S y') (S (S w)))))  (/\ (<= x' A) (e. x' S))  (= x (S (* (S x') (S (S w)))))  an4
  y'  exbii  x'  exbii  sylib


  (<= y' B) (-. (e. y' S)) (<= x' A) (e. x' S)  an4

  B  A  addge01t   (+ B A)  leid  (+ B A)  (+ B A)  lesuc  mpbir    B  (+ B A)  (S (+ B A))  lelttr  mpan2  ax-mp  y'  B  (S (+ B A))  lelttr  mpan2
  A  B addge01t  A  B  addcom  A  leeq2i  mpbi  (+ B A)  leid  (+ B A)  (+ B A)  lesuc  mpbir    A  (+ B A)  (S (+ B A))  lelttr  mpan2  ax-mp  x'  A  (S (+ B A))  lelttr  mpan2  anim12i  ancomd

    (e. x' S)  (e. y' S)  xor    biimpri  orcs
      x'  y'  S  ax-eleq1  con3i   syl       ancoms
    anim12i
  sylbi  ancomd

    y  (S (* (S y') (S (S w))))  x  relprimeq2   x  (S (* (S x') (S (S w))))  (S (* (S y') (S (S w))))  relprimeq1   sylan9bb    biimprd
  anim12i
y'  19.22i  x'  19.22i  syl  y  gen  x  gen  w  gen

###

  w  x'  y'  (S (+ B A))  beta.2s
pm3.2i

w  (A. x (A. y (-> (/\ ph ps) (E. x' (E. y' (/\ (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (-> (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))) (relprim x y)))))))) (A. x' (A. y' (-> (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w)))))))) 19.29    ax-mp

y  (-> (/\ ph ps) (E. x' (E. y' (/\ (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (-> (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))) (relprim x y))))))  (A. x' (A. y' (-> (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))))))  alan2  x  albii  x  (A. y (-> (/\ ph ps) (E. x' (E. y' (/\ (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (-> (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))) (relprim x y)))))))  (A. x' (A. y' (-> (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))))))  alan2    bitri  biimpri  (A. x' (A. y' (-> (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))))))  (/\ ph ps)  (E. x' (E. y' (/\ (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (-> (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))) (relprim x y)))))  anim3  ancoms  y  19.20i  x  19.20i  syl  w  19.22i  ax-mp

x'  (A. y' (-> (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w)))))))  (E. y' (/\ (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (-> (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))) (relprim x y))))  19.29  ancoms  y'  (-> (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))))  (/\ (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (-> (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))) (relprim x y)))  19.29   x'  19.22i  syl ancoms  (/\ ph ps)  imim2i y  19.20i  x  19.20i   w  19.22i  ax-mp

(-> (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))))  (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A)))))  (-> (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))) (relprim x y))  anass  biimpri (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A)))))  (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w)))))  pm3.35  ancoms  (-> (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))) (relprim x y))  anim1i   syl  (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w)))))  (relprim x y)  pm3.35  syl

y'  19.22i  x'  19.22i  (/\ ph ps)  imim2i  y  19.20i  x  19.20i w  19.22i  ax-mp

x'  (E. y' (relprim x y))  ex-nf  y'  (relprim x y)  ex-nf    syl  (/\ ph ps) imim2i  y  19.20i  x 19.20i  w 19.22i  ax-mp


   x  v  (S (* (S x') (S (S w))))  eqeq1  (/\ (<= x' A) (e. x' S))  anbi2d  x'  exbid  h1  syl5bb rwffi
   y  v  (S (* (S y') (S (S w))))  eqeq1  (/\ (<= y' B) (-. (e. y' S)))  anbi2d  y'  exbid  h2  syl5bb rwffi

   z'  (S (S (* (S (S w)) (S A))))  relprimex2  w  19.22i
ax-mp

h1  beta.3.1    ancri  (< x (S (S (* (S (S w)) (S A)))))  anim2i  (< x (S (S (* (S (S w)) (S A)))))  (< (1) x)  ph  anass  (< x (S (S (* (S (S w)) (S A)))))  (< (1) x)  ancom  ph  anbi1i  bitr3i  sylib  (< (1) x)  (< x (S (S (* (S (S w)) (S A)))))  ph  anass  sylib  (| x z')  imim1i  x  19.20i

h2  beta.3.1    ancri  (-. (| y z'))  imim1i  y  19.20i

anim12i  z'  19.22i  w  19.22i  ax-mp

h1  biimpi
(<= x' A)  (e. x' S)  (= x (S (* (S x') (S (S w)))))  an23  biimpi  pm3.26d
x'  A  lesuc12
   (S x')  (S A)  (S (S w))  lemul2  sylbi  (S x') (S (S w))  mulcom  (* (S (S w)) (S A))  leeq1i  sylibr  (* (S x') (S (S w)))  (* (S (S w)) (S A))  lesuc12  sylib
     (= x (S (* (S x') (S (S w)))))  id  (S (* (S (S w)) (S A)))  leeq1d  biimprd
   mpan9
  syl
  x'  19.22i  syl  x'  (<= x (S (* (S (S w)) (S A))))  ex-nf  syl
  x  (S (* (S (S w)) (S A)))  lesuc  sylibr


  ancri  (| x z')  imim1i
  x  19.20i  (A. y (-> ps (-. (| y z'))))  anim1i  z'  19.22i  w  19.22i  ax-mp

)
# number 139.5
thm (beta.4.1 ((ph x) (B x) (A x x')) ()  # ph and B contain x' but not x.
  (-> (A. x (-> (E. x' (/\ ph (= x B))) (| x A)))
      (A. x' (-> ph (| B A))))

  x  B  tyex
    (/\ ph (= x B))  x'  19.8a  (| x A)  imim1i
    ph  (= x B)  (| x A)  impexp  biimpi  (= x B)  (| x A)  ancr  syl6  syl
    x  B  A  divideseq1  biimpd  imp  ancoms  syl8
    com13  com23

  x  19.22i  ax-mp
  (E. x (-> (-> (E. x' (/\ ph (= x B))) (| x A)) (-> ph (| B A))))  (A. x (-> (E. x' (/\ ph (= x B))) (| x A)))   pm3.2  ax-mp

  x  (-> (E. x' (/\ ph (= x B))) (| x A))  (-> (-> (E. x' (/\ ph (= x B))) (| x A)) (-> ph (| B A)))  19.29  ancoms  syl

  (-> (E. x' (/\ ph (= x B))) (| x A))  (-> ph (| B A))  pm3.35  x  19.22i  syl
  x  (-> ph (| B A))  ex-nf  syl
  x'  19.21ai
)
# number 139.6
thm (beta.4.2 ((ph x) (B x) (A x x')) ()  # ph and B contain x' but not x.
  (-> (A. x (-> (E. x' (/\ ph (= x B))) (-. (| x A))))
      (A. x' (-> ph (-. (| B A)))))

  x  B  tyex
    (/\ ph (= x B))  x'  19.8a  (-. (| x A))  imim1i
    ph  (= x B)  (-. (| x A))  impexp  biimpi  (= x B)  (-. (| x A))  ancr  syl6  syl
    x  B  A  divideseq1   notbid  biimpd  imp  ancoms  syl8
    com13  com23

  x  19.22i  ax-mp
  (E. x (-> (-> (E. x' (/\ ph (= x B))) (-. (| x A))) (-> ph (-. (| B A)))))  (A. x (-> (E. x' (/\ ph (= x B))) (-. (| x A))))   pm3.2  ax-mp

  x  (-> (E. x' (/\ ph (= x B))) (-. (| x A)))  (-> (-> (E. x' (/\ ph (= x B))) (-. (| x A))) (-> ph (-. (| B A))))  19.29  ancoms  syl

  (-> (E. x' (/\ ph (= x B))) (-. (| x A)))  (-> ph (-. (| B A)))  pm3.35  x  19.22i  syl
  x  (-> ph (-. (| B A)))  ex-nf  syl
  x'  19.21ai
)
# number 140.0
thm (beta.4 ((A x' z) (S x' z)) ()
    (E. z (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (tail z))) (head z))))))

(E. x' (/\ (/\ (<= x' A) (e. x' S))  (= x (S (* (S x') (S (S w)))))))  biid
  (E. y' (/\ (/\ (<= y' A) (-. (e. y' S))) (= y (S (* (S y') (S (S w)))))))  biid
z' beta.3

# exalpha y' -> x'
  (= y' x')  id  A  leeq1d  y'  x'  S  ax-eleq1  notbid anbi12d
  (= y' x')  id  suceqd  (S (S w))  muleq1d  suceqd  y  eqeq2d  anbi12d  exalpha
  (-. (| y z'))  imbi1i  y  albii  (A. x (-> (E. x' (/\ (/\ (<= x' A) (e. x' S)) (= x (S (* (S x') (S (S w))))))) (| x z')))  anbi2i  z'  exbii  w  exbii
mpbi

# alpha y -> x
  y  x  (S (* (S x') (S (S w))))  eqeq1  (/\ (<= x' A) (-. (e. x' S)))  anbi2d  x'  exbid
  y  x  z'  divideseq1  notbid  imbi12d  alpha
  (A. x (-> (E. x' (/\ (/\ (<= x' A) (e. x' S)) (= x (S (* (S x') (S (S w))))))) (| x z')))  anbi2i  z'  exbii  w  exbii
mpbi

# Eliminate dummies
x  x'  (/\ (<= x' A) (e. x' S))  (S (* (S x') (S (S w))))  z'  beta.4.1
x  x'  (/\ (<= x' A) (-. (e. x' S)))  (S (* (S x') (S (S w))))  z'  beta.4.2  anim12i  z'  19.22i  w  19.22i  ax-mp


# Consolidate  quantifiers
  x'  (-> (/\ (<= x' A) (e. x' S)) (| (S (* (S x') (S (S w)))) z'))  (-> (/\ (<= x' A) (-. (e. x' S))) (-. (| (S (* (S x') (S (S w)))) z')))   alan12  z'  19.22i  w  19.22i
ax-mp

  (<= x' A)  (e. x' S)  (| (S (* (S x') (S (S w)))) z')  impexp  biimpi
  (<= x' A)  (-. (e. x' S))  (-. (| (S (* (S x') (S (S w)))) z'))  impexp  biimpi
  anim12i (<= x' A)  (-> (e. x' S) (| (S (* (S x') (S (S w)))) z'))  (-> (-. (e. x' S)) (-. (| (S (* (S x') (S (S w)))) z')))  pm4.76    sylib
  (e. x' S)  (| (S (* (S x') (S (S w)))) z')  ax-3   (-> (e. x' S) (| (S (* (S x') (S (S w)))) z'))  anim2i  syl6
  (e. x' S)  (| (S (* (S x') (S (S w)))) z')  dfbi2    syl6ibr
x'  19.20i  z'  19.22i  w  19.22i  ax-mp

###  Combine w and z' into z
    z  (<,> z' (S (S w))) tyex
      z  (<,> z' (S (S w)))  headeq  z'  (S (S w))  headop  syl6eq
      (head z)  z'  (S (* (S x') (tail z)))  divideseq2  syl
        z  (<,> z' (S (S w)))  taileq  z'  (S (S w))  tailop  syl6eq
        (tail z)  (S (S w))  (S x')  muleq2  syl  suceqd
        (S (* (S x') (tail z)))  (S (* (S x') (S (S w))))  z'  divideseq1  syl
      bitrd
      (e. x' S)  bibi2d  (<= x' A)  imbi2d  biimprd  x'  19.21ai
      x'  (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (S (S w)))) z')))  (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (tail z))) (head z))))  ax-alim  syl
    z  19.22i  ax-mp  z'  gen  w  gen
  pm3.2i

  w  (A. z' (E. z (-> (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (S (S w)))) z')))) (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (tail z))) (head z))))))))  (E. z' (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (S (S w)))) z')))))  19.29  ancoms  z'  (E. z (-> (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (S (S w)))) z')))) (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (tail z))) (head z)))))))  (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (S (S w)))) z'))))  19.29  w  19.22i  syl  ax-mp

  z  (-> (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (S (S w)))) z')))) (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (tail z))) (head z))))))  (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (S (S w)))) z'))))  19.41  biimpri  z'  19.22i  w  19.22i  ax-mp

  (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (S (S w)))) z'))))  (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (tail z))) (head z)))))  pm3.35 ancoms  z  19.22i  z'  19.22i  w  19.22i  ax-mp

  w  (E. z' (E. z (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (tail z))) (head z)))))))  ex-nf  ax-mp

  z'  (E. z (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (tail z))) (head z))))))  ex-nf  ax-mp
)

# An ordering theorem on ordered pairs. Note that this breaks the abstraction somewhat,
# but if necessary we could define a special ordering rather than reusing <=.
thm (leop12 () () (-> (/\ (<= A C) (<= B D)) (<= (<,> A B) (<,> C D)))
  A  C  B   leadd1
  B  D  C   leadd2  anbi12i  (+ A B)  (+ C B)  (+ C D)  letr  sylbi
  (+ A B) (+ C D)  (+ A B)  (+ C D) lemul3     anidms     syl
  (* (+ A B) (+ A B))  (* (+ C D) (+ C D))  B  leadd1  sylib
  B  D  (* (+ C D) (+ C D)) leadd2  biimpi  (<= A C)   adantl  jca
  (+ (* (+ A B) (+ A B)) B)  (+ (* (+ C D) (+ C D)) B)  (+ (* (+ C D) (+ C D)) D)  letr  syl
  A  B  df-op  (+ (* (+ C D) (+ C D)) D)  leeq1i  sylibr
  C  D  df-op  (<,> A B)  leeq2i  sylibr
)

# number 143.0
thm (maxex2 ((A v w) (S v w)) ()
  (-> (fun S)
      (E. v (A. w (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v))))))

S  v  w  A  maxex
  (/\ (< (head w) A) (e. w S))  (<= (tail w) v)  ancr
  (head w)  A  df-lt  biimpi  pm3.26d  (e. w S)  adantr   (<= (tail w) v)  anim2i  syl6
  (head w)  A  (tail w)  v  leop12  ancoms   syl6

    S  w  x  y  df-fun  biimpi  pm3.27d  w  (-> (e. w S) (E. x (E. y (= w (<,> x y)))))  ax-4  syl
      w  (<,> x y)  headeq  x  y  headop  syl6eq    w  (<,> x y)  taileq  x  y  tailop  syl6eq    jca
      (head w)  x  (tail w)  y  opth1  syl  eqcomd  eqcoms  ancri  (<,> x y)  (<,> (head w) (tail w))  w  ax-eqtr  syl  eqcoms
      y  19.22i  x  19.22i  x  (E. y (= (<,> (head w) (tail w)) w))  ex-nf  syl  y  (= (<,> (head w) (tail w)) w)  ex-nf  syl
    syl6
    imp  (<,> A v)  leeq1d  biimpd  ancoms  ex  com13  com23
  syl6

  (< (head w) A)  (e. w S)  (-> (e. w S) (-> (fun S) (<= w (<,> A v))))  impexp   biimpi  (e. w S)  (-> (fun S) (<= w (<,> A v)))  pm2.43    syl6  syl
  imp3a  com23  com12  w  19.21ai
  w  (-> (/\ (< (head w) A) (e. w S)) (<= (tail w) v))  (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v)))  ax-alim  syl
  v  19.21ai  v  (A. w (-> (/\ (< (head w) A) (e. w S)) (<= (tail w) v)))  (A. w (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v))))  19.22  syl
mpd
)

# number 146.0
# A development of Godel's Beta Function, following Shoenfield(1967).
# If S is a functional set defining a sequence {S(0), S(1), ..., S(A), ...}:
# Then there exists a z such that for all x in [0,A], we have:
# beta(z, x) = S(x).
# This allows us to encode finite sequences in a quantifiable way,
# which is necessary to deal with recursive functions.
thm (beta ((S x z) (A x z)) ()
  (-> (fun S)
      (E. z (A. x (-> (< x A) (e. (<,> x (beta z x)) S)))))
     S  v  w  A  maxex2
       z  w  (<,> A v)  S  beta.4
    v  gen  jctil
     v  (E. z (A. w (-> (<= w (<,> A v)) (<-> (e. w S) (| (S (* (S w) (tail z))) (head z))))))  (A. w (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v))))  19.29  syl
     z  (A. w (-> (<= w (<,> A v)) (<-> (e. w S) (| (S (* (S w) (tail z))) (head z)))))  (A. w (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v))))  19.41  v  exbii sylibr
     w  (-> (<= w (<,> A v)) (<-> (e. w S) (| (S (* (S w) (tail z))) (head z))))  (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v)))  alan12  z  19.22i  v  19.22i  syl


  (/\ (< (head w) A) (e. w S))  (<= w (<,> A v))  (<-> (e. w S) (| (S (* (S w) (tail z))) (head z)))
pm3.33    ancoms
  (e. w S)  (| (S (* (S w) (tail z))) (head z))  bi1  (/\ (< (head w) A) (e. w S))  imim2i     (< (head w) A)  (e. w S)  (-> (e. w S) (| (S (* (S w) (tail z))) (head z)))  impexp  biimpi  syl  (e. w S) (| (S (* (S w) (tail z))) (head z))  pm2.43  syl6   syl
  w  19.20i

    w  (<,> x y)  tyex
      w  (<,> x y)  headeq  x  y  headop  syl6eq  A  lteq1d
        w  (<,> x y)  S  ax-eleq1
          (= w (<,> x y))  id  suceqd  (tail z)  muleq1d  suceqd
          (S (* (S w) (tail z)))  (S (* (S (<,> x y)) (tail z)))  (head z)  divideseq1  syl
        imbi12d
      imbi12d  biimpd
    w  19.22i  ax-mp  y  gen  x  gen
  jctir
  x  (A. w (-> (< (head w) A) (-> (e. w S) (| (S (* (S w) (tail z))) (head z)))))
     (A. y (E. w (-> (-> (< (head w) A) (-> (e. w S) (| (S (* (S w) (tail z))) (head z)))) (-> (< x A) (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z))))))) alan1  sylibr
  y  (A. w (-> (< (head w) A) (-> (e. w S) (| (S (* (S w) (tail z))) (head z)))))  (E. w (-> (-> (< (head w) A) (-> (e. w S) (| (S (* (S w) (tail z))) (head z)))) (-> (< x A) (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z))))))  alan1  biimpri  x  19.20i syl

  w  (-> (< (head w) A) (-> (e. w S) (| (S (* (S w) (tail z))) (head z))))  (-> (-> (< (head w) A) (-> (e. w S) (| (S (* (S w) (tail z))) (head z)))) (-> (< x A) (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z)))))  19.29  y  19.20i  x  19.20i    syl
  (-> (< (head w) A) (-> (e. w S) (| (S (* (S w) (tail z))) (head z))))  (-> (< x A) (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z))))  pm3.35  w  19.22i  y  19.20i  x  19.20i  syl
  w  (-> (< x A) (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z))))  ex-nf  y 19.20i x 19.20i syl
  y  (< x A)  (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z)))  ax-alim  (< x A)  y  alnfi  syl5    x  19.20i  syl

    S  x  y  z  df-fun  biimpi  pm3.26d
      y  (e. (<,> x y) S)  euex  x  19.20i  syl
  anim12i
  x  (-> (< x A) (A. y (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z)))))  (E. y (e. (<,> x y) S))  alan12  syl
     (E. y (e. (<,> x y) S))  (< x A)  (A. y (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z))))  anim3   ancoms    y  (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z)))  (e. (<,> x y) S)  19.29   ancoms syl6
  (e. (<,> x y) S)  pm4.24   biimpi  (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z)))  anim2i  (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z)))  (e. (<,> x y) S)  (e. (<,> x y) S)  anass sylibr

   (e. (<,> x y) S)  (| (S (* (S (<,> x y)) (tail z))) (head z))  pm3.35  ancoms  (e. (<,> x y) S) anim1i  syl

 y  19.22i

syl6  x  19.20i  syl

    w  (<,> x y)  tyex
    (A. w (/\ (-> (<= w (<,> A v)) (<-> (e. w S) (| (S (* (S w) (tail z))) (head z)))) (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v)))
))  (fun S)  pm3.26  (-> (<= w (<,> A v)) (<-> (e. w S) (| (S (* (S w) (tail z))) (head z))))  (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v))) pm3.27  w  19.20i  syl   (E. w (= w (<,> x y)))  biantrurd   biimpd  mpi
    w  (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v)))  (= w (<,> x y))  19.29  syl
      w  (<,> x y)  headeq   x  y  headop  syl6eq  A  lteq1d
      w  (<,> x y)  S  ax-eleq1  anbi12d
      (= w (<,> x y))  id  (<,> A v)  leeq1d    imbi12d  biimpd  com12  imp
    w  19.22i  syl  w  (-> (/\ (< x A) (e. (<,> x y) S)) (<= (<,> x y) (<,> A v)))  ex-nf  syl
    (< x A)  (e. (<,> x y) S) (<= (<,> x y) (<,> A v))  impexp  biimpi  syl
    imp  y  19.21ai  ex  x  19.21ai
  jca
  x  (-> (< x A) (E. y (/\ (| (S (* (S (<,> x y)) (tail z))) (head z)) (e. (<,> x y) S))))  (-> (< x A) (A. y (-> (e. (<,> x y) S) (<= (<,> x y) (<,> A v)))))  alan12  syl
  (< x A)  (E. y (/\ (| (S (* (S (<,> x y)) (tail z))) (head z)) (e. (<,> x y) S)))  (A. y (-> (e. (<,> x y) S) (<= (<,> x y) (<,> A v))))  pm3.43    x  19.20i  syl
    y  (-> (e. (<,> x y) S) (<= (<,> x y) (<,> A v)))  (/\ (| (S (* (S (<,> x y)) (tail z))) (head z)) (e. (<,> x y) S))  19.29  ancoms
    (| (S (* (S (<,> x y)) (tail z))) (head z))  (e. (<,> x y) S)  (-> (e. (<,> x y) S) (<= (<,> x y) (<,> A v)))  anass  (e. (<,> x y) S)  (<= (<,> x y) (<,> A v))  pm3.35  (| (S (* (S (<,> x y)) (tail z))) (head z))  anim2i sylbi  ancoms
  y  19.22i  syl
(< x A)  imim2i  x  19.20i  syl




  y  y'  x  opeq2  suceqd  (tail z)  muleq1d  suceqd   (S (* (S (<,> x y)) (tail z)))  (S (* (S (<,> x y')) (tail z)))  (head z) divideseq1  syl  rwffi  abid  biimpri
  y  ({|} y (| (S (* (S (<,> x y)) (tail z))) (head z)))  minex  syl
    z  x  y df-beta  (beta z x)  (min ({|} y (| (S (* (S (<,> x y)) (tail z))) (head z))))  ({|} y (| (S (* (S (<,> x y)) (tail z))) (head z)))  ax-eleq1  ax-mp
  (<= (min ({|} y (| (S (* (S (<,> x y)) (tail z))) (head z)))) y)  anbi1i  sylibr
  z  x  y df-beta   y  leeq1i  (e. (beta z x) ({|} y (| (S (* (S (<,> x y)) (tail z))) (head z))))  anbi2i  sylibr
    (beta z x)  y (| (S (* (S (<,> x y)) (tail z))) (head z))  ax-elab  (beta z x)  y  (| (S (* (S (<,> x y)) (tail z))) (head z))  sbc5  bitri
    y  (beta z x)  x  opeq2  suceqd  (tail z)  muleq1d  suceqd   (S (* (S (<,> x y)) (tail z)))  (S (* (S (<,> x (beta z x))) (tail z)))  (head z) divideseq1  syl  biimpd  imp  y  19.22i  sylbi  y  (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  ex-nf  syl   (<= (beta z x) y)  anim1i
  syl
  x  leid  x  x  (beta z x)  y  leop12  mpan  (<,> x (beta z x))  (<,> x y)  (<,> A v)  letr  ex  syl  (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  anim2i  syl
  (<= (<,> x y) (<,> A v))  anim1i  (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  (-> (<= (<,> x y) (<,> A v)) (<= (<,> x (beta z x)) (<,> A v)))  (<= (<,> x y) (<,> A v))  anass sylib
  (<= (<,> x y) (<,> A v))  (<= (<,> x (beta z x)) (<,> A v))  pm3.35  ancoms  (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  anim2i  syl
  y  19.22i    y  (/\ (| (S (* (S (<,> x (beta z x))) (tail z))) (head z)) (<= (<,> x (beta z x)) (<,> A v)))  ex-nf syl
(< x A)  imim2i  x  19.20i  syl

  (-> (<= w (<,> A v)) (<-> (e. w S) (| (S (* (S w) (tail z))) (head z))))  (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v)))  pm3.26  w  19.20i
    (= w (<,> x (beta z x)))  id  (<,> A v)  leeq1d
      w  (<,> x (beta z x))  S  ax-eleq1
        (= w (<,> x (beta z x)))  id  suceqd  (tail z)  muleq1d  suceqd
        (S (* (S w) (tail z)))  (S (* (S (<,> x (beta z x))) (tail z)))  (head z)  divideseq1  syl
      bibi12d
    imbi12d
    cla4g   x  19.21ai
  syl
  (fun S)  adantr
jca

x  (-> (< x A) (/\ (| (S (* (S (<,> x (beta z x))) (tail z))) (head z)) (<= (<,> x (beta z x)) (<,> A v))))
   (-> (<= (<,> x (beta z x)) (<,> A v)) (<-> (e. (<,> x (beta z x)) S) (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))))  alan12  syl


     (-> (<= (<,> x (beta z x)) (<,> A v)) (<-> (e. (<,> x (beta z x)) S) (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))))  (< x A)  (/\ (| (S (* (S (<,> x (beta z x))) (tail z))) (head z)) (<= (<,> x (beta z x)) (<,> A v))) anim3  ancoms   (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  (<= (<,> x (beta z x)) (<,> A v))  ancom  (-> (<= (<,> x (beta z x)) (<,> A v)) (<-> (e. (<,> x (beta z x)) S) (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))))  anbi2i  syl6ib  (-> (<= (<,> x (beta z x)) (<,> A v)) (<-> (e. (<,> x (beta z x)) S) (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))))  (<= (<,> x (beta z x)) (<,> A v))  (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  anass  syl6ibr  (<= (<,> x (beta z x)) (<,> A v))  (<-> (e. (<,> x (beta z x)) S) (| (S (* (S (<,> x (beta z x))) (tail z))) (head z)))  pm3.35  ancoms   (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  anim1i  syl6   (e. (<,> x (beta z x)) S)  (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  bi2  (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  anim1i  syl6  (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  (e. (<,> x (beta z x)) S)  pm3.35  ancoms  syl6
   x  19.20i  syl


ex  z  19.22i  v  19.22i  syl

v  (E. z (-> (fun S) (A. x (-> (< x A) (e. (<,> x (beta z x)) S)))))  ex-nf    syl
z  (fun S)  (A. x (-> (< x A) (e. (<,> x (beta z x)) S)))  eximp1  syl
(fun S)  z  alnfi     syl5       pm2.43i


)

# Equality theorem for beta, first argument
thm (betaeq1 () () (-> (= A B) (= (beta A C) (beta B C)))
  A  B  headeq   (head A)  (head B)  (S (* (S (<,> C x)) (tail A)))  divideseq2  syl
   A  B  taileq  (tail A)  (tail B)  (S (<,> C x))  muleq2  syl  suceqd
   (S (* (S (<,> C x)) (tail A)))  (S (* (S (<,> C x)) (tail B)))  (head B)  divideseq1  syl
  bitrd    x  19.21ai
  x (| (S (* (S (<,> C x)) (tail A))) (head A))  (| (S (* (S (<,> C x)) (tail B))) (head B))  abeq2   syl
  ({|} x (| (S (* (S (<,> C x)) (tail A))) (head A)))  ({|} x (| (S (* (S (<,> C x)) (tail B))) (head B)))  mineq    syl


  B  C  x  df-beta    syl6eqr
  A  C  x  df-beta    syl5eq
)

# Equality theorem for beta, second argument
thm (betaeq2 () () (-> (= A B) (= (beta C A) (beta C B)))
  A  B  x  opeq1  suceqd  (tail C)  muleq1d  suceqd
  (S (* (S (<,> A x)) (tail C)))  (S (* (S (<,> B x)) (tail C)))  (head C)  divideseq1  syl
  x  19.21ai
  x  (| (S (* (S (<,> A x)) (tail C))) (head C))  (| (S (* (S (<,> B x)) (tail C))) (head C))  abeq2  syl
  ({|} x (| (S (* (S (<,> A x)) (tail C))) (head C)))  ({|} x (| (S (* (S (<,> B x)) (tail C))) (head C)))  mineq  syl
  C  A  x  df-beta  syl5eq
  C  B  x  df-beta  syl6eqr
)

# number 152.0
thm (recursive.2.1 ((A x)) () (E. x (= (beta x (0)) A))

# The constant map is a function
  w  A  tyeu
   ph  id
    y  (<,> x w)  (<,> z A)  eqeq1  z  exbid  elab
    x  w  z A  opth  z exbii  z  (= x z)  (= w A)  19.41  bitri   bitri
    z  x  tyex   x  z  eqcom  z  exbii  mpbir  mpbiran
    (-> ph ph)  a1i  w  eubid
   ax-mp
  mpbir
  x  gen
    (e. x ({|} y (E. z (= y (<,> z A)))))  v alnfi
    y  x  (<,> z A)  eqeq1  z  exbid  elab  w  z  A  opeq1  x  eqeq2d  exalpha  bitr4i  v  gen  v  (e. x ({|} y (E. z (= y (<,> z A)))))  (E. w (= x (<,> w A)))  19.15  ax-mp  biimpi  syl
    v  A  tyex   v  A  w  opeq2  x  eqeq2d  w  exbid    biimprd   v 19.22i    ax-mp     jctir
    v  (E. w (= x (<,> w A)))  (-> (E. w (= x (<,> w A))) (E. w (= x (<,> w v))))  19.29  syl
    (E. w (= x (<,> w A)))  (E. w (= x (<,> w v)))  pm3.35  v  19.22i  syl
    v  w  (= x (<,> w v))  excom  sylib
    x  gen
  pm3.2i

  ({|} y (E. z (= y (<,> z A))))  x  w  v   df-fun  mpbir

# Apply beta
  ({|} y (E. z (= y (<,> z A))))  x v (S (0)) beta
    v  (0)  tyex
    (0)  leid   (0)  (0)  lesuc   mpbir     (= v (0)) id (S (0)) lteq1d   mpbiri
      v  (0)  x  betaeq2
      (= v (0))  id  jca  ancomd
      v  (beta x v)  (0)  (beta x (0))  opth  sylibr
      (<,> v (beta x v))  (<,> (0) (beta x (0)))  ({|} y (E. z (= y (<,> z A))))  ax-eleq1  syl
      (< v (S (0)))  imbi2d  biimpd
    com23  mpd
    v  19.22i  ax-mp
    x  gen
  jctir
  x  (E. v (-> (-> (< v (S (0))) (e. (<,> v (beta x v)) ({|} y (E. z (= y (<,> z A)))))) (e. (<,> (0) (beta x (0))) ({|} y (E. z (= y (<,> z A)))))))  (A. v (-> (< v (S (0))) (e. (<,> v (beta x v)) ({|} y (E. z (= y (<,> z A)))))))  19.29  ancoms  syl
    v  (-> (< v (S (0))) (e. (<,> v (beta x v)) ({|} y (E. z (= y (<,> z A))))))  (-> (-> (< v (S (0))) (e. (<,> v (beta x v)) ({|} y (E. z (= y (<,> z A)))))) (e. (<,> (0) (beta x (0))) ({|} y (E. z (= y (<,> z A))))))   19.29  ancoms
    (-> (< v (S (0))) (e. (<,> v (beta x v)) ({|} y (E. z (= y (<,> z A))))))  (e. (<,> (0) (beta x (0))) ({|} y (E. z (= y (<,> z A)))))    pm3.35  v  19.22i  syl
  x  19.22i  syl
  v  (e. (<,> (0) (beta x (0))) ({|} y (E. z (= y (<,> z A)))))  ex-nf  x  19.22i  syl

  y  (<,> (0) (beta x (0)))  (<,> z A) eqeq1  (0)  (beta x (0))  z  A  opth    syl6bb  z  exbid    elab  (= (0) z)  (= (beta x (0)) A)  pm3.27  z  19.22i  sylbi  z  (= (beta x (0)) A)  ex-nf  syl  x  19.22i  syl


ax-mp
)

# == Lambda and function application ==

# Definition of the lambda operator, which creates a functional set from an
# expression in one variable.
thm (df-lambda-just ((A x x')) ()
  (=_ ({|} x (E. y (= x (<,> y A)))) ({|} x' (E. y (= x' (<,> y A)))))
  x  x'  (<,> y A) eqeq1  y  exbid
#  y  y'  A  opeq1  x'  eqeq2d % exalpha  syl6bb
  abeq
)

defthm  (df-lambda set (lambda y A) ((A x)) ()
        (=_ (lambda y A) ({|} x (E. y (= x (<,> y A)))))
          x' y A x df-lambda-just)

# number 155.5
#!thm (eusbceq ((A x) (B x)) (h1 (rwff y (= x A))) (E! x ([/] B y (= x A)))
#!   x A tyeu x (= x A) z df-eu mpbi
#!   B  y  y  (= x A)  dfsbcq
#!   h1  y (= x A)  df-rwff  mpbi a4i
#!   syl6bbr (= x z) bibi1d x 19.21ai 19.15d z exbid
#!
#!
#!  x ([/] B y (= x A)) z df-eu
#!  syl5bb
#!  mpbiri
#!  eqcoms vtocle
#!)
# number 156.0

# Asserts that lambda constructs are actually functions.
thm (funlambda ((A y) (B x)) (h1 (-> (= x y) (= A B))) (fun (lambda x A))
#(A. y (E! v (e. (<,> y v) (lambda x A))))
v  B  tyeu  z eqid
 x  A  w  df-lambda    (<,> y v)  eleq2i
 w  (<,> y v)  (<,> x A)  eqeq1    x  exbid  elab   bitri
 y  v  x  A  opth  x  exbii  bitri
  h1  eqcoms eqcomd v  eqeq2d  biimprd  imp  x  19.22i  x  (= v B)  ex-nf  syl
    x  y  tyex
    h1 eqcoms eqcomd v  eqeq2d  biimpd  com12  ancld  com12  eqcoms  com12 x  19.22d  mpi
  impbii
 bitri     (= z z)  a1i  v eubid  ax-mp
mpbir
v  x  y  opeq2  (<,> y v)  (<,> y x)  (lambda x A)  ax-eleq1  syl  eualpha  mpbi
y gen

    x  A  y  df-lambda    y  eleq2i
    y  y'  (<,> x A) eqeq1  x  exbid  rwffi  abid  bitri  biimpi
    w  A  tyex    w  A  x  opeq2  y  eqeq2d   biimprd  w  19.22i  ax-mp  x  gen  jctil
    x  (E. w (-> (= y (<,> x A)) (= y (<,> x w))))  (= y (<,> x A))  19.29   syl
    w  (-> (= y (<,> x A)) (= y (<,> x w)))  (= y (<,> x A))   19.41  x  exbii  sylibr
    (= y (<,> x A))  (= y (<,> x w))  pm3.35  ancoms  w  19.22i  x  19.22i  syl
    y  gen
  pm3.2i

  (lambda x A)  y  x  w  df-fun  mpbir
)

# number 156.5
thm (piecewisefun.1 ((A x) (S x) (T x)) () (<-> (e. A ({|} x (\/ (/\ ([/] (head x) x ph)  (e. x S)) (/\ (-. ([/] (head x) x ph)) (e. x T))))
) (\/ (/\ ([/] (head A) x ph)  (e. A S)) (/\ (-. ([/] (head A) x ph)) (e. A T))))
x  A  S  ax-eleq1  ([/] (head x) x ph)  anbi2d
  x  A  T  ax-eleq1  (-. ([/] (head x) x ph))  anbi2d
orbi12d
  x  A  headeq
  (head x)  (head A)  x  ph  dfsbcq  syl
  (e. A S) anbi1d
    x  A  headeq
    (head x)  (head A)  x  ph  dfsbcq  syl  notbid
    (e. A T) anbi1d
  orbi12d
bitrd
elab
)

# number 157.0
# Given two functions S, T and a discriminator ph, we can assemble a piecewise
# function which mimics S when ph is true and T otherwise.
thm (piecewisefun ((S x') (T x')) () (-> (/\ (fun S) (fun T)) (fun ({|} x' (\/ (/\ ([/] (head x') x' ph)  (e. x' S))
                                                                         (/\ (-. ([/] (head x') x' ph)) (e. x' T))))))

([/] x x' ph)  exmid
  x  y  headop    (head (<,> x y))  x  x' ph  dfsbcq  ax-mp  bicomi
    ([/] (head (<,> x y)) x' ph)   (e. (<,> x y) S)   ibar  (/\ (-. ([/] (head (<,> x y)) x' ph)) (e. (<,> x y) T)) orbi1d
      (-. ([/] (head (<,> x y)) x' ph))  (e. (<,> x y) T)  pm3.26  con2i    (-. (/\ (-. ([/] (head (<,> x y)) x' ph)) (e. (<,> x y) T)))  (e. (<,> x y) S)  pm5.5    syl
        (/\ (-. ([/] (head (<,> x y)) x' ph)) (e. (<,> x y) T))  (e. (<,> x y) S)  df-or  (/\ (-. ([/] (head (<,> x y)) x' ph)) (e. (<,> x y) T))  (e. (<,> x y) S)  orcom  bitr3i
      syl5bbr
    bitr3d
      (<,> x y) x' ph S T piecewisefun.1
    syl5bb
   sylbi  y  eubid
   S  x  y  z  df-fun  biimpi  pm3.26d  x  (E! y (e. (<,> x y) S))  ax-4  syl     syl5bir

     x  y  headop    (head (<,> x y))  x  x' ph  dfsbcq  ax-mp  notbii bicomi
       (-. ([/] (head (<,> x y)) x' ph))   (e. (<,> x y) T)   ibar  (/\ ([/] (head (<,> x y)) x' ph) (e. (<,> x y) S)) orbi1d
         ([/] (head (<,> x y)) x' ph)  (e. (<,> x y) S)  pm3.26  con3i    (-. (/\ ([/] (head (<,> x y)) x' ph) (e. (<,> x y) S)))  (e. (<,> x y) T)  pm5.5    syl
           (/\ ([/] (head (<,> x y)) x' ph) (e. (<,> x y) S))  (e. (<,> x y) T)  df-or  (/\ ([/] (head (<,> x y)) x' ph) (e. (<,> x y) S))  (e. (<,> x y) T)  orcom  bitr3i
         syl5bbr
       bitr3d
       (/\ ([/] (head (<,> x y)) x' ph) (e. (<,> x y) S))  (/\ (-. ([/] (head (<,> x y)) x' ph)) (e. (<,> x y) T))  orcom  syl5bb
         (<,> x y) x' ph S T piecewisefun.1
       syl5bb
      sylbi  y  eubid
    T  x  y  z  df-fun  biimpi  pm3.26d  x  (E! y (e. (<,> x y) T))  ax-4  syl     syl5bir
  jaoa
ax-mp
x  19.21ai


x x' ph S T piecewisefun.1   biimpi
  ([/] (head x) x' ph)  (e. x S)  pm3.27  (-. ([/] (head x) x' ph))  (e. x T)  pm3.27  orim12i  syl
  S  x  y  z  df-fun  biimpi  pm3.27d  x  (-> (e. x S) (E. y (E. z (= x (<,> y z)))))  ax-4  syl
    T  x  y  z  df-fun  biimpi  pm3.27d  x  (-> (e. x T) (E. y (E. z (= x (<,> y z)))))  ax-4  syl
  jaao
mpan9    ancoms  ex   x  19.21ai

  ({|} x' (\/ (/\ ([/] (head x') x' ph)  (e. x' S))  (/\ (-. ([/] (head x') x' ph)) (e. x' T))))  x  y  z  df-fun  biimpri
ex  com12  syl


mpd

)
# number 157.5
# Definition of "apply" to apply a function (reperesented by a set S) to an
# input.
thm (df-apply-just ((A y) (S y) (A z) (S z)) ()
  (= (iota ({|} z (e. (<,> A z) S)))
     (iota ({|} y (e. (<,> A y) S))))
   z  y  A  opeq2     (<,> A z)  (<,> A y)  S  ax-eleq1    syl   abeq     ({|} z (e. (<,> A z) S))  ({|} y (e. (<,> A y) S))  ax-iotaeq    ax-mp)

# Definition of function application
defthm  (df-apply nat (apply S A) ( (A z) (S z)) ()
  (= (apply S A) (iota ({|} z (e. (<,> A z) S))))
  y A S z df-apply-just)

# Equality identity for fun
thm (funeq () () (-> (=_ S T) (<-> (fun S) (fun T)))
  S  T  (<,> x y)  eleq2  y eubid
  x  19.21ai  x  (E! y (e. (<,> x y) S))  (E! y (e. (<,> x y) T)) 19.15  syl
    S  T  x  eleq2  (E. y (E. z (= x (<,> y z))))  imbi1d
    x  19.21ai  x  (-> (e. x S) (E. y (E. z (= x (<,> y z)))))  (-> (e. x T) (E. y (E. z (= x (<,> y z)))))  19.15  syl
  anbi12d
  S  x  y  z  df-fun  syl5bb
  T  x  y  z  df-fun  syl6bbr
)

# Asserts that membership in functional set of a lambda works the way you'd expect.
thm (ellambda ((A y) (B y) (C x)) (h1 (-> (= x y) (= B C)))
     (<-> (e. (<,> x A) (lambda x B)) (= A B))
  x  B  z  df-lambda  (<,> x A) eleq2i
    h1  B  C  x  opeq2  syl  z  eqeq2d
    x  y  C  opeq1  z  eqeq2d  bitrd  exalpha
    z  gen  z  (E. x (= z (<,> x B)))  (E. y (= z (<,> y C)))  abeq2  ax-mp
  (<,> x A)  eleq2i  bitri
  z  (<,> x A)  (<,> y C)  eqeq1  y  exbid  elab  bitri
    x  A  y  C  opth  y  exbii bitri
      h1  (= A C)  anim1i
        C  B  A ax-eqtr  ex  eqcoms  com12  eqcoms  com12  imp  syl  y  19.22i  y  (= B A)  ex-nf  syl
          y  x  tyex  h1     ancli    eqcoms
        B  A  C ax-eqtr  ex  (= x y)  anim2d   mpan9    ancoms  ex  y  19.22d  mpi
      impbii
    bitri
  B  A  eqcom  bitri
)

# number 159.5
# apply actually works (assuming S is a function).
thm (funapply () () (-> (fun S) (e. (<,> A (apply S A)) S))
#      y  x  (e. (<,> A x) S)  ax-elab
  S  w  x  z  df-fun  biimpi     pm3.26d
  w  (E! x (e. (<,> w x) S))  A  a4sbc    syl
  w  A  x  opeq1    (<,> w x)  (<,> A x)  S  ax-eleq1  syl  x  eubid    sbcie   sylib
  x  (e. (<,> A x) S)   iotacl2  syl
  S  A  x  df-apply  (apply S A)  (iota ({|} x (e. (<,> A x) S)))  ({|} x (e. (<,> A x) S))  ax-eleq1  ax-mp  sylibr
  (apply S A)  x  (e. (<,> A x) S)  ax-elab    sylib
    x  (apply S A)  A  opeq2   (<,> A x)  (<,> A (apply S A))  S  ax-eleq1  syl
  sbcie  sylib
)

# First equality identity for lambda.
thm (lambdaeq1 ((A y) (B x)) (h1 (-> (= x y) (= A B)))
  (=_ (lambda x A) (lambda y B))
 x eqid
  x  A  z  df-lambda
  (= x x) a1i
    h1    A  B  x  opeq2    syl
    x  y  B  opeq1    eqtrd
    z  eqeq2d
    exalpha    bicomi
    z  gen
      z  (E. y (= z (<,> y B)))  (E. x (= z (<,> x A)))  abeq2
    ax-mp
  syl6seqr
    y  B  z  df-lambda
  syl6seqr
 ax-mp
)

# Second equality identity for lambda
thm (lambdaeq2 () () (-> (A. x (= A B)) (=_ (lambda x A) (lambda x B)))
    A  B  x  opeq2    y  eqeq2d    x  19.20i
    x  (= y (<,> x A))  (= y (<,> x B))  19.18    syl
    y  19.21ai
    y  (E. x (= y (<,> x A)))  (E. x (= y (<,> x B)))  abeq2    syl
    x  B  y  df-lambda    syl6seqr
    ({|} y (E. x (= y (<,> x A))))  (lambda x B)  seqcom   sylib
    x  A  y  df-lambda    syl6seqr
    (lambda x B)  (lambda x A)  seqcom    sylib
)

# == Recursive functions ==

# Definition of recursion, using a predicate.
# (recursep S A B C) will mean that S^A(B) = C
thm (df-recursep-just ( (A y) (S y) (A x) (S x) (A z) (C z) (B z) (S z) (A w) (C w) (B w) (S w)) ()
  (<-> (E. z (/\ (= (beta z (0)) B) (/\ (= (beta z A) C)
                    (A. y (-> (< y A) (e. (<,> (beta z y) (beta z (S y))) S))))))
       (E. w (/\ (= (beta w (0)) B) (/\ (= (beta w A) C)
                    (A. x (-> (< x A) (e. (<,> (beta w x) (beta w (S x))) S)))))))
  z  w  (0)  betaeq1  B  eqeq1d
    z  w  A  betaeq1  C  eqeq1d
      z  w  y  betaeq1   (beta z y)  (beta w y)  (beta z (S y))  opeq1  syl
      z  w  (S y)  betaeq1  (beta z (S y))  (beta w (S y))  (beta w y)  opeq2  syl   eqtrd
      (<,> (beta z y) (beta z (S y)))  (<,> (beta w y) (beta w (S y)))  S  ax-eleq1  syl
      (< y A)  imbi2d     y  19.21ai    19.15d
       (= y x)  id  A  lteq1d
        y  x  w  betaeq2   (beta w y)  (beta w x)  (beta w (S y))  opeq1  syl
        y  x  pa_ax2  biimpi    (S y)  (S x)  w  betaeq2  syl    (beta w (S y))  (beta w (S x))  (beta w x)  opeq2  syl   eqtrd
        (<,> (beta w y) (beta w (S y)))  (<,> (beta w x) (beta w (S x)))  S  ax-eleq1    syl
       imbi12d  alpha
     syl6bb
   anbi12d
  anbi12d
exalpha)

defthm  (df-recursep wff (recursep S A B C) ((A y) (S y) (A z) (S z) (B z) (C z)) ()
  (<-> (recursep S A B C)  (E. z (/\ (= (beta z (0)) B) (/\ (= (beta z A) C)
                    (A. y (-> (< y A) (e. (<,> (beta z y) (beta z (S y))) S)))))))
  w B A C x S z y df-recursep-just)

# number 157.7
# Fourth equality identity for recursep.
thm (recursepeq4 () () (-> (= A B) (<-> (recursep S C D A) (recursep S C D B)))
  A  B  (beta x C)  eqeq2  (A. y (-> (< y C) (e. (<,> (beta x y) (beta x (S y))) S)))  anbi1d  (= (beta x (0)) D)  anbi2d  x  exbid
    S  C  D  A  x  y  df-recursep
  syl5bb
    S  C  D  B  x  y  df-recursep
  syl6bbr
)

# number 160.0
thm (recursive.3.1 ((A y) (ph y) (S y) (A z) (C z) (B z) (S z) (A v) (S v) (B v) (C v) (C y))
(h2 (<-> ph (/\ (A. y (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))))  (/\ (= (beta v (0)) B) (/\ (= (beta v A) C) (A. y (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S))))))))
(-> (fun S)
  (->  (recursep S  A  B  C)
       (recursep S (S A) B (apply S C))))

S  A  B  C  v  y  df-recursep  biimpi


  y  y'  v  betaeq2  funlambda
    (apply S C)  eqid  (= y y') a1i  funlambda
      (lambda y (beta v y))  (lambda y (apply S C))  x (<= x A) piecewisefun
        ({|} x (\/ (/\ ([/] (head x) x (<= x A)) (e. x (lambda y (beta v y)))) (/\ (-. ([/] (head x) x (<= x A))) (e. x (lambda y (apply S C))))))  seqid
        ({|} x (\/ (/\ ([/] (head x) x (<= x A)) (e. x (lambda y (beta v y)))) (/\ (-. ([/] (head x) x (<= x A))) (e. x (lambda y (apply S C))))))  ({|} x (\/ (/\ ([/] (head x) x (<= x A)) (e. x (lambda y (beta v y)))) (/\ (-. ([/] (head x) x (<= x A))) (e. x (lambda y (apply S C))))))  funeq  ax-mp
      sylibr
    mpan2
  ax-mp
({|} x (\/ (/\ ([/] (head x) x (<= x A)) (e. x (lambda y (beta v y)))) (/\ (-. ([/] (head x) x (<= x A))) (e. x (lambda y (apply S C))))))  z  y  (S (S A))  beta  ax-mp

  (<,> y (beta z y))  x  headeq  (head (<,> y (beta z y))) (head x) x  (<= x A) dfsbcq    syl
  (<,> y (beta z y))  x  (lambda y (beta v y))  ax-eleq1   anbi12d
      (<,> y (beta z y))  x  headeq  (head (<,> y (beta z y))) (head x) x  (<= x A) dfsbcq    syl  notbid
      (<,> y (beta z y))  x  (lambda y (apply S C))  ax-eleq1   anbi12d
  orbi12d
  eqcoms  bicomd
          ({|} x (\/ (/\ ([/] (head x) x (<= x A)) (e. x (lambda y (beta v y)))) (/\ (-. ([/] (head x) x (<= x A))) (e. x (lambda y (apply S C))))))  seqid
  elab2
    y  (beta z y)  headop  (head (<,> y (beta z y)))  y  x (<= x A)  dfsbcq  ax-mp
    (= x y)  id  A  leeq1d  sbcie  bitri
      y  y'  v  betaeq2  (beta z y) ellambda
    anbi12i
      y  (beta z y)  headop  (head (<,> y (beta z y)))  y  x (<= x A)  dfsbcq  ax-mp
      (= x y)  id  A  leeq1d  sbcie  bitri  notbii
        (apply S C)  eqid (= y y')  a1i  (beta z y)  ellambda
      anbi12i
    orbi12i
  bitri
(< y (S (S A)))  imbi2i  y  albii  z  exbii  mpbi

   y  (S A)  lesuc
      y  A lenltt   con2bii     A  y  nnltp1let  bitr3i   A  a1suc  y  leeq1i  bitr4i  (= (beta z y) (apply S C)) anbi1i  (/\ (<= y A) (= (beta z y) (beta v y)))  orbi2i
   imbi12i
  y  (S A)  lesym    biimpri  ex  (= (beta z y) (apply S C))  anim1d  (/\ (<= y A) (= (beta z y) (beta v y)))  orim2d  a2i
  sylbi
 y  19.20i  z  19.22i  ax-mp
 v  gen
jctil

v  (E. z (A. y (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C)))))))  (/\ (= (beta v (0)) B) (/\ (= (beta v A) C) (A. y (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S)))))  19.29    syl

z  (A. y (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))))  (/\ (= (beta v (0)) B) (/\ (= (beta v A) C) (A. y (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S)))))  19.41    biimpri  v  19.22i    syl

# For cleanliness and my own sanity, I'm using h2 to store this big predicate in phi.
h2    z  exbii  v  exbii  sylibr

# Phi has everything we need to assert the viability of z for proving (recursep S A' B (apply S C)).
# To reassemble this assertion, we'll go step by step.
# 1. Prove phi -> beta z 0 = B
# 2. Prove phi -> beta z A' = (apply S C)
# 3. Prove phi -> (A. y y<A' -> <beta z y, beta z y'> e. S)
# 4. Join it all together and clean up the quantifiers.

# Step 1.
h2  biimpi
  (A. y (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))))  (= (beta v (0)) B)  (/\ (= (beta v A) C) (A. y (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S))))  anass  sylibr
  pm3.26d
    (= y (0))  id  (S A)  leeq1d
      (= y (0))  id  A  leeq1d
        y  (0)  z  betaeq2    y  (0)  v  betaeq2  eqeq12d
      anbi12d
        y  (0)  (S A)  eqeq1
          y  (0)  z  betaeq2    (apply S C)  eqeq1d
        anbi12d
      orbi12d
    imbi12d
  cla4g
  (= (beta v (0)) B)  anim1i
syl
  A  pa_ax1    (= (0) (S A))  (= (beta z (0)) (apply S C))  pm3.26    con3i    ax-mp
  (/\ (= (0) (S A)) (= (beta z (0)) (apply S C)))  (/\ (<= (0) A) (= (beta z (0)) (beta v (0))))  orel2   ax-mp
  (<= (0) (S A))  imim2i  (= (beta v (0)) B)  anim1i
syl
  (0)  (S A)  addge01t     (S A)  pa_ax3r    (0) leeq2i  mpbi     (<= (0) (S A))  (/\ (<= (0) A) (= (beta z (0)) (beta v (0))))  pm2.27    ax-mp    (= (beta v (0)) B)   anim1i
syl
(<= (0) A)  (= (beta z (0)) (beta v (0)))  (= (beta v (0)) B)  anass    sylib
pm3.27d
  (beta v (0))  B  (beta z (0))  ax-eqtr  ancoms  (beta v (0))  (beta z (0))  eqcom  (= (beta v (0)) B)  anbi1i    (= B (beta z (0)))  imbi1i   mpbi
syl  eqcomd
(fun S)  adantl


# Step 2: phi -> beta z A' = (apply S C)
h2  biimpi  pm3.26d
    (= y (S A))  id  (S A)  leeq1d
      (= y (S A))  id  A  leeq1d
        y  (S A)  z  betaeq2    y  (S A)  v  betaeq2  eqeq12d
      anbi12d
        y  (S A)  (S A)  eqeq1
          y  (S A)  z  betaeq2    (apply S C)  eqeq1d
        anbi12d
      orbi12d
    imbi12d
  cla4g
syl

(S A)  leid   (<= (S A) (S A))  (\/ (/\ (<= (S A) A) (= (beta z (S A)) (beta v (S A)))) (/\ (= (S A) (S A)) (= (beta z (S A)) (apply S C))))  pm2.27    ax-mp    syl

A  leid    A  A  lesuc  mpbir   (S A)  A  lenltt    biimpi    con2i  ax-mp    (-. (= (beta z (S A)) (beta v (S A))))  orci  (<= (S A) A)  (= (beta z (S A)) (beta v (S A)))  pm3.14   ax-mp    (/\ (<= (S A) A) (= (beta z (S A)) (beta v (S A))))  (/\ (= (S A) (S A)) (= (beta z (S A)) (apply S C)))  orel1  ax-mp    syl

pm3.27d  (fun S)  adantl

# Step 3, the hard one: phi -> (A. y y<A' -> <beta z y, beta z y'> e. S)
# We'll do this in two steps.  Case 3a: y = A, and Case 3b: y < A
h2  biimpi

# scrub unneeded clauses
(= (beta v A) C)  (A. y (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S)))  pm3.26  (= (beta v (0)) B)  adantl   (A. y (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))))  anim2i  syl

# move quantifier up
y  (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C)))))  (= (beta v A) C)  alan2   biimpri   syl
# lemme just stick this here for later
 S  C  funapply

# collapse case clause for y=A to prove (beta z y) = C
  A  (1)  addge01t    A  a1suc    A  leeq2i  mpbir   (= y A)  id   (S A)  leeq1d   biimprd   mpi    (<= y (S A))  (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))   pm2.27  syl
    0ne1  A  (0)  (1)  addcan2  A  pa_ax3  (+ A (1)) eqeq1i   bitr3i   A  a1suc   A  eqeq2i  bitr4i  notbii  mpbi
    y  A  (S A)  eqeq1  biimpd   con3d    mpi
    (-. (= (beta z y) (apply S C)))  orcd  (= y (S A))  (= (beta z y) (apply S C))  pm3.14  syl   (/\ (= y (S A)) (= (beta z y) (apply S C)))  (/\ (<= y A) (= (beta z y) (beta v y)))  orel2  syl
  syld
  (= (beta v A) C)  anim1d
  (<= y A)  (= (beta z y) (beta v y))  pm3.27  (= (beta v A) C)  anim1i  syl6
  y  A  v  betaeq2   (beta z y)   eqeq2d  (beta z y)  (beta v A)  eqcom  syl6bb    (= (beta v A) C)  anbi1d    biimpd  (beta v A)  (beta z y)  C  ax-eqtr  syl6  syld
com12  y  19.20i
y  (-> (= y A) (= (beta z y) C))  ax-4    syl
# Now to prove that y=A also implies (beta z y') = (apply S C).
# Need to up the index by one.  alpha-switch y to x, then substitute (S y) in for x.

  (= y x)  id  (S A)  leeq1d
    (= y x)  id  A  leeq1d
      y  x  z  betaeq2    y  x  v  betaeq2  eqeq12d
    anbi12d
      y  x  (S A)  eqeq1
        y  x  z  betaeq2    (apply S C)  eqeq1d
      anbi12d
    orbi12d
  imbi12d
  (= (beta v A) C)  anbi1d
  alpha  biimpi

    (= x (S y))  id  (S A)  leeq1d
      (= x (S y))  id  A  leeq1d
        x  (S y)  z  betaeq2    x  (S y)  v  betaeq2  eqeq12d
      anbi12d
        x  (S y)  (S A)  eqeq1
          x  (S y)  z  betaeq2    (apply S C)  eqeq1d
        anbi12d
      orbi12d
    imbi12d
    (= (beta v A) C)  anbi1d
    cla4g
  syl
  pm3.26d
# remove bounding guard
  (S A)   leid  y  A  pa_ax2  biimpi    (S A)  leeq1d    mpbiri    (<= (S y) (S A))  (\/ (/\ (<= (S y) A) (= (beta z (S y)) (beta v (S y)))) (/\ (= (S y) (S A)) (= (beta z (S y)) (apply S C))))  pm2.27    syl   com12    syl
# collapse case clause again
    A  leid    A  A  lesuc  mpbir   (S A)  A  lenltt    biimpi    con2i    ax-mp
    y  A  pa_ax2  biimpi    A  leeq1d    notbid    mpbiri
    (-. (= (beta z (S y)) (beta v (S y))))  orcd  (<= (S y) A)  (= (beta z (S y)) (beta v (S y)))  pm3.14   syl  (/\ (<= (S y) A) (= (beta z (S y)) (beta v (S y))))  (/\ (= (S y) (S A)) (= (beta z (S y)) (apply S C)))  orel1  syl
  a2i    syl
  imp    pm3.27d    ex
# Join up the y and the y' case to get the OP
jcad
# too lazy to go prove opeq12
 (beta z y)  C  (beta z (S y))  opeq1    eqcomd    (beta z (S y))  (apply S C)  C  opeq2    anim12i    (<,> C (beta z (S y)))  (<,> (beta z y) (beta z (S y)))  (<,> C (apply S C))    ax-eqtr   syl    syl6
 (<,> (beta z y) (beta z (S y)))  (<,> C (apply S C))  S  ax-eleq1  syl6
# it's later
imp  biimprd   mpan9    ex  exp3a  com12   syl    imp
#### Finally done with case 3a!

# Now, case 3b, y < A.  Proceeds similarly at first.
h2  biimpi

# scrub unneeded clauses
(= (beta v (0)) B)  (/\ (= (beta v A) C) (A. y (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S))))  pm3.27    (= (beta v A) C)  (A. y (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S)))  pm3.27    syl    (A. y (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))))  anim2i    syl

# Join quantifiers
y  (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C)))))  (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S))  alan12   syl

# Drop quantifier for y=y.
y  (/\ (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))) (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S)))  ax-4    syl

# unite common assertion.
  # must be easier way to prove y<A -> y <= A'.... need more coffee?
  A  leid    A  A  lesuc    mpbir
  y  A  df-lt    biimpi    pm3.26d    y  A  (S A)  lelttr    ex    syl   mpi
  y  (S A)  df-lt    sylib    pm3.26d
  # continually sloppy but getting the job done
  (<= y (S A))  (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))  pm2.27    syl   com12    (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S))  anim1i    syl
  (< y A)  (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))  (e. (<,> (beta v y) (beta v (S y))) S)  jcab    sylibr

# collapse case clause
    A  leid    A  A  lesuc    mpbir
    y  A  df-lt    biimpi    pm3.26d    y  A  (S A)  lelttr    ex    syl   mpi
    y  (S A)    df-lt    sylib    pm3.27d
    (-. (= (beta z y) (apply S C)))  orcd    (= y (S A))  (= (beta z y) (apply S C))  pm3.14   syl    (/\ (= y (S A)) (= (beta z y) (apply S C)))  (/\ (<= y A) (= (beta z y) (beta v y)))  orel2  syl
    (e. (<,> (beta v y) (beta v (S y))) S)  anim1d
  a2i    syl
# clean up the result a bit
  (<= y A)  (= (beta z y) (beta v y))  (e. (<,> (beta v y) (beta v (S y))) S)  anass    biimpi    pm3.27d    syl6
  (beta z y)  (beta v y)  (beta v (S y))  opeq1    (<,> (beta z y) (beta v (S y)))  (<,> (beta v y) (beta v (S y)))  S  ax-eleq1    syl    biimprd    imp    syl6
  imp
# Start over to get back the quantifier we dropped, since now we want y=y'
    h2  biimpi

# scrub unneeded clauses(*)
    (= (beta v (0)) B)  (/\ (= (beta v A) C) (A. y (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S))))  pm3.27    (= (beta v A) C)  (A. y (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S)))  pm3.27    syl    (A. y (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))))  anim2i    syl

# Join quantifiers
    y  (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C)))))  (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S))  alan12   syl

# alpha-change y->x, then substitute y' for x.
      (= y x)  id  (S A)  leeq1d
        (= y x)  id  A  leeq1d
          y  x  z  betaeq2    y  x  v  betaeq2  eqeq12d
        anbi12d
          y  x  (S A)  eqeq1
            y  x  z  betaeq2    (apply S C)  eqeq1d
          anbi12d
        orbi12d
      imbi12d
        (= y x)  id    A  lteq1d
        y  x  v  betaeq2    (= y x)  id    suceqd    (S y)  (S x)  v  betaeq2    syl    jca
        # opeq12 again
        (beta v y)  (beta v x)  (beta v (S y))  opeq1    eqcomd    (beta v (S y))  (beta v (S x))  (beta v x)  opeq2    anim12i    (<,> (beta v x) (beta v (S y)))  (<,> (beta v y) (beta v (S y)))  (<,> (beta v x) (beta v (S x)))    ax-eqtr   syl    syl
        (<,> (beta v y) (beta v (S y)))  (<,> (beta v x) (beta v (S x)))  S  ax-eleq1    syl
       imbi12d
      anbi12d    alpha
    sylib

      (= x (S y))  id  (S A)  leeq1d
        (= x (S y))  id  A  leeq1d
          x  (S y)  z  betaeq2    x  (S y)  v  betaeq2  eqeq12d
        anbi12d
          x  (S y)  (S A)  eqeq1
            x  (S y)  z  betaeq2    (apply S C)  eqeq1d
          anbi12d
        orbi12d
      imbi12d
        (= x (S y))  id    A  lteq1d
        x  (S y)  v  betaeq2    (= x (S y))  id    suceqd    (S x)  (S (S y))  v  betaeq2    syl    jca
        # opeq12 again
        (beta v x)  (beta v (S y))  (beta v (S x))  opeq1    eqcomd    (beta v (S x))  (beta v (S (S y)))  (beta v (S y))  opeq2    anim12i    (<,> (beta v (S y)) (beta v (S x)))  (<,> (beta v x) (beta v (S x)))  (<,> (beta v (S y)) (beta v (S (S y))))    ax-eqtr   syl    syl
        (<,> (beta v x) (beta v (S x)))  (<,> (beta v (S y)) (beta v (S (S y))))  S  ax-eleq1    syl
       imbi12d
      anbi12d    cla4g
    syl

    # *aw crap, i just realized that I don't actually need that extra clause and the above could've been MUCH simpler.  But too lazy to redo it now.
    pm3.26d
# normalize bound
    y  A  df-lt    biimpi    pm3.26d    y  A  lesuc12  sylib
    (<= (S y) (S A))  (\/ (/\ (<= (S y) A) (= (beta z (S y)) (beta v (S y)))) (/\ (= (S y) (S A)) (= (beta z (S y)) (apply S C))))  pm2.27    syl   com12    syl
# collapse case yet again
      y  A  df-lt    biimpi    pm3.27d    y  A  pa_ax2    notbii    sylib
      (-. (= (beta z (S y)) (apply S C)))  orcd    (= (S y) (S A))  (= (beta z (S y)) (apply S C))  pm3.14   syl    (/\ (= (S y) (S A)) (= (beta z (S y)) (apply S C)))  (/\ (<= (S y) A) (= (beta z (S y)) (beta v (S y))))  orel2  syl
    a2i    syl
    imp    pm3.27d
# join it up
    (beta z (S y))  (beta v (S y))  (beta z y)  opeq2    syl
    (<,> (beta z y) (beta z (S y)))  (<,> (beta z y) (beta v (S y)))  S  ax-eleq1    syl
  mpbird
  ex    (fun S)  a1d    imp
#### Done with case 3b!
# Now join the two together
jaod
y  A  lefoo3    y  A  nnltp1let    (= y A)  orbi2i    bitr4i    syl5ib
# I honestly can no longer remember *why* I wanted to prove phi -> (A. y y<A' -> <beta z y, beta z y'> e. S) , but now I can:
y  A  lesuc    syl5ib    y  19.21ai    ancoms
#################### END OF STEP 3!! ####################
# Step 4 should be easy by comparison....
jca    jca
(/\ (= (beta z (0)) B) (/\ (= (beta z (S A)) (apply S C)) (A. y (-> (< y (S A)) (e. (<,> (beta z y) (beta z (S y))) S)))))  z  19.8a    syl
S  (S A)  B  (apply S C)  z  y  df-recursep    sylibr
ancoms    ex    z  19.22i    v    19.22i    syl
v  (E. z (-> (fun S) (recursep S (S A) B (apply S C))))  ex-nf    syl
z  (-> (fun S) (recursep S (S A) B (apply S C)))  ex-nf    syl
com12
)
# number 161.0
thm (recursive.3 ((A x) (S x))
  ()
  (->  (-> (fun S) (E. x (recursep S    w  A x)))
       (-> (fun S) (E. x (recursep S (S w) A x))))
  (/\ (A. y (-> (<= y (S w)) (\/ (/\ (<= y w) (= (beta z y) (beta v y))) (/\ (= y (S w)) (= (beta z y) (apply S x)))))) (/\ (= (beta v (0)) A) (/\ (= (beta v w) x) (A. y (-> (< y w) (e. (<,> (beta v y) (beta v (S y))) S))))))  biid  recursive.3.1  x  19.21ai
  x  (recursep S w A x)  (recursep S (S w) A (apply S x))  19.22    syl    a2i
  imp

    v  (apply S x)  tyex
    v  (apply S x)  S  (S w)  A  recursepeq4    v  19.22i    ax-mp
    (recursep S (S w) A v)  (recursep S (S w) A (apply S x))  bi2    v  19.22i    ax-mp
    x  gen
  jctil
  x  (E. v (-> (recursep S (S w) A (apply S x)) (recursep S (S w) A v)))  (recursep S (S w) A (apply S x))  19.29    syl
  v  (-> (recursep S (S w) A (apply S x)) (recursep S (S w) A v))  (recursep S (S w) A (apply S x))  19.41  biimpri    x  19.22i    syl
  (recursep S (S w) A (apply S x))  (recursep S (S w) A v)  pm3.35    ancoms      v  19.22i    x  19.22i    syl
  x  (E. v (recursep S (S w) A v))  ex-nf    syl
  x  v  S  (S w)  A  recursepeq4    exalpha    sylibr
  ex
)

thm (recursive.1 ((B x)) ()
  (-> (= w B)
     (<-> (-> (fun S) (E. x (recursep S w A x)))
          (-> (fun S) (E. x (recursep S B A x)))))

  w  B  z  betaeq2
  x  eqeq1d
    (= w B)  id  y  lteq2d
    (e. (<,> (beta z y) (beta z (S y))) S)  imbi1d
    y  19.21ai     19.15d
  anbi12d
  (= (beta z (0)) A)  anbi2d
  z  exbid
  x  exbid
  (fun S) imbi2d

    S w A x z y df-recursep    x  exbii   (fun S)  imbi2i   syl5rbb
    S B A x z y df-recursep    x  exbii   (fun S)  imbi2i   syl5rbb
)

# Base case
thm (recursive.2 ((A x z)) () (-> (fun S) (E! x (E. z (/\ (= (beta z (0)) A) (/\ (= (beta z (0)) x)
                    (A. y (-> (< y (0)) (e. (<,> (beta x y) (beta x (S y))) S))))))))
x  A  tyeu
  v  eqid
z  A  recursive.2.1
  x  A  (beta z (0)) eqeq2   (= (beta z (0)) A)  anbi2d   (= (beta z (0)) A)  anidm    syl6bb
    y nn0nlt0   (e. (<,> (beta x y) (beta x (S y))) S)  pm2.21i    y gen
   (= (beta z (0)) x)  biantru
   (= (beta z (0)) A)  anbi2i
  syl5bbr
  z  exbid
mpbiri
  (= (beta z (0)) A)  (= (beta z (0)) x)  (A. y (-> (< y (0)) (e. (<,> (beta x y) (beta x (S y))) S)))  anass  bicomi
  (beta z (0))  A  x  ax-eqtr  eqcomd  (A. y (-> (< y (0)) (e. (<,> (beta x y) (beta x (S y))) S)))  adantr  sylbi
  z  19.22i  z  (= x A)  ex-nf  syl
impbii
 (= v v)  a1i  x  eubid  ax-mp  mpbi
(fun S) a1i
)

# Base case
thm (recursive.2a ((A x)) () (-> (fun S) (E. x (recursep S (0) A x)))
x  A  tyex
  v  eqid
z  A  recursive.2.1
  x  A  (beta z (0)) eqeq2   (= (beta z (0)) A)  anbi2d   (= (beta z (0)) A)  anidm    syl6bb
    y nn0nlt0   (e. (<,> (beta z y) (beta z (S y))) S)  pm2.21i    y gen
   (= (beta z (0)) x)  biantru
   (= (beta z (0)) A)  anbi2i
  syl5bbr
  z  exbid
mpbiri
  (= (beta z (0)) A)  (= (beta z (0)) x)  (A. y (-> (< y (0)) (e. (<,> (beta z y) (beta z (S y))) S)))  anass  bicomi
  (beta z (0))  A  x  ax-eqtr  eqcomd  (A. y (-> (< y (0)) (e. (<,> (beta z y) (beta z (S y))) S)))  adantr  sylbi
  z  19.22i  z  (= x A)  ex-nf  syl
impbii
 (= v v)  a1i  x  exbid  ax-mp  mpbi
(fun S) a1i

  S  (0)  A  x  z  y  df-recursep    x  exbii     (fun S)  imbi2i   mpbir
)

# Existence of the result of a recursion operation.
thm (recursive ((A w) (S w) (B w)) () (-> (fun S) (E. w (recursep S A B w)))

   x  (0)    S  w  B  recursive.1
   x  y      S  w  B  recursive.1
   x  (S y)  S  w  B  recursive.1
   x  A      S  w  B  recursive.1
   S  w  B  recursive.2a
   S  w  y  B  recursive.3
finds
)

# number 166.0
thm (recursep-uniq.1 () () (-> (fun S) (<-> (recursep S (0) A B) (= A B)))

#  v  eqid
z  A  recursive.2.1
  B  A  (beta z (0)) eqeq2   (= (beta z (0)) A)  anbi2d   (= (beta z (0)) A)  anidm    syl6bb
    y nn0nlt0   (e. (<,> (beta z y) (beta z (S y))) S)  pm2.21i    y gen
   (= (beta z (0)) B)  biantru
   (= (beta z (0)) A)  anbi2i
  syl5bbr
  z  exbid
mpbiri
  (= (beta z (0)) A)  (= (beta z (0)) B)  (A. y (-> (< y (0)) (e. (<,> (beta z y) (beta z (S y))) S)))  anass  bicomi
  (beta z (0))  A  B  ax-eqtr  eqcomd  (A. y (-> (< y (0)) (e. (<,> (beta z y) (beta z (S y))) S)))  adantr  sylbi
  z  19.22i  z  (= B A)  ex-nf  syl
impbii

  S  (0)  A  B  z  y  df-recursep

bitr4i
bicomi
B  A  eqcom  bitri
(fun S)  a1i
)

# Recursing "one more time" works as expected
thm (recursepsuc ((A x) (B x) (C x) (S x)) ()
 # (-> (fun S)
     (-> (recursep S (S A) B C) (E. x (/\ (recursep S A B x) (e. (<,> x C) S))))
 #)

  x  (beta y A)  tyex    y  gen
    S  (S A)  B  C  y  z  df-recursep    biimpi
      A  leid    A  A  lesuc    mpbir
      z  A  (S A)  lttr    impexpi    ax-mp
      (e. (<,> (beta y z) (beta y (S z))) S)  imim1i    z  19.20i    #y  gen
      (= (beta y (S A)) C)  adantl    (=  (beta y A) x)  anim2i    ex    (= (beta y (0)) B)  anim2d    com12
      imp  (/\ (= (beta y (0)) B) (/\ (= (beta y A) x) (A. z (-> (< z A) (e. (<,> (beta y z) (beta y (S z))) S)))))  y  19.8a    syl
      S  A  B  x  y  z  df-recursep    sylibr

       A  leid    A  A  lesuc    mpbir
        (= z A)  id   (S A)  lteq1d
          z  A  y   betaeq2
          (= z A)  id    suceqd    (S z)  (S A)  y  betaeq2    syl    jca
          (beta y z)  (beta y (S z))  (beta y A)  (beta y (S A))  opth  sylibr
          (<,> (beta y z) (beta y (S z)))  (<,> (beta y A) (beta y (S A)))  S  ax-eleq1    syl
        imbi12d
        cla4g
       mpi
       (= (beta y (S A)) C)  anim2i
         (beta y A)  (beta y (S A))  x  C  opth    biimpri
         (<,> (beta y A) (beta y (S A)))  (<,> x C)  S  ax-eleq1    syl   biimpd
       ex    imp3a    com12
     syl
     (= (beta y (0)) B)  adantl
     imp
   jca
   ex
   com12     eqcoms     com12
   x  19.21ai
 y  19.22i    syl
 jctilb
y  (E. x (= x (beta y A)))  (A. x (-> (= x (beta y A)) (/\ (recursep S A B x) (e. (<,> x C) S))))  19.29  syl
x  (-> (= x (beta y A)) (/\ (recursep S A B x) (e. (<,> x C) S)))  (= x (beta y A)) 19.29    ancoms    y  19.22i    syl
(= x (beta y A))  (/\ (recursep S A B x) (e. (<,> x C) S))  pm3.35  ancoms    x  19.22i   y  19.22i   syl
y  (E. x (/\ (recursep S A B x) (e. (<,> x C) S)))  ex-nf    syl
)
# number 168.0




thm (recursep-uniq.2 ((S z z') (A z z')) ()
  (-> (fun S) (-> (A. z (A. z' (-> (/\ (recursep S y A z) (recursep S y A z')) (= z z'))))
      (A. z (A. z' (-> (/\ (recursep S (S y) A z) (recursep S (S y) A z')) (= z z'))))))

  S  y  A  z  x  recursepsuc
    S  y  A  z'  x'  recursepsuc
  anim12i
  x  (/\ (recursep S y A x) (e. (<,> x z) S))  x'  (/\ (recursep S y A x') (e. (<,> x' z') S))  exey    syl  (recursep S y A x)  (e. (<,> x z) S)  (recursep S y A x')  (e. (<,> x' z') S)  an4    biimpi    x'  19.22i    x  19.22i    syl

    # need to alpha-swap the hypothesis
    z'  x'  S  y  A  recursepeq4
      (recursep S y A z)  anbi2d
      z'  x'  z  eqeq2    imbi12d   alpha
      (= z x) a1i
        z  x  S  y  A  recursepeq4
        (recursep S y A x')  anbi1d
        z  x  x'  eqeq1    imbi12d
        x'  19.21ai
        x'  (-> (/\ (recursep S y A z) (recursep S y A x')) (= z x'))  (-> (/\ (recursep S y A x) (recursep S y A x')) (= x x'))  19.15    syl
      bitrd
      alpha    biimpi
      (/\ (recursep S y A x) (recursep S y A x'))  (= x x')  (/\ (e. (<,> x z) S) (e. (<,> x' z') S))  pm3.45    x'  19.20i    x  19.20i   syl
    anim12i
      x  (A. x' (-> (/\ (/\ (recursep S y A x) (recursep S y A x')) (/\ (e. (<,> x z) S) (e. (<,> x' z') S))) (/\ (= x x') (/\ (e. (<,> x z) S) (e. (<,> x' z') S)))))  (E. x' (/\ (/\ (recursep S y A x) (recursep S y A x')) (/\ (e. (<,> x z) S) (e. (<,> x' z') S))))  19.29    ancoms
      x' (-> (/\ (/\ (recursep S y A x) (recursep S y A x')) (/\ (e. (<,> x z) S) (e. (<,> x' z') S))) (/\ (= x x') (/\ (e. (<,> x z) S) (e. (<,> x' z') S))))  (/\ (/\ (recursep S y A x) (recursep S y A x')) (/\ (e. (<,> x z) S) (e. (<,> x' z') S)))  19.29    x  19.22i    syl
    syl
      (/\ (/\ (recursep S y A x) (recursep S y A x')) (/\ (e. (<,> x z) S) (e. (<,> x' z') S)))  (/\ (= x x') (/\ (e. (<,> x z) S) (e. (<,> x' z') S)))  pm3.35    ancoms
    x'  19.22i    x  19.22i    syl
    ancoms  ex
    x  x'  z  opeq1   (<,> x z)  (<,> x' z)  S   ax-eleq1    syl    biimpd    imp    (e. (<,> x' z') S)  anim1i    anasss  x'  19.22i    x  19.22i      x  (E. x' (/\ (e. (<,> x' z) S) (e. (<,> x' z') S)))  ex-nf   syl   syl6
    imp
      S  x'  z  w  df-fun    biimpi    pm3.26d
      x'  (E! z (e. (<,> x' z) S))  ax-4    syl
      z  (e. (<,> x' z) S)  w  df-eu    sylib
      z z'  x'  opeq2    (<,> x' z)  (<,> x' z')  S  ax-eleq1    syl    z  z'  w  eqeq1  bibi12d   cla4g
      biimpd
      z  (<-> (e. (<,> x' z) S) (= z w))  ax-4    biimpd    jca
      (e. (<,> x' z') S)  (= z' w)  (e. (<,> x' z) S)  (= z w)  prth    syl
      w  z  z'  ax-eqtr    ex    eqcoms    com12  eqcoms    imp    syl6
      w    19.22i    w  (-> (/\ (e. (<,> x' z') S) (e. (<,> x' z) S)) (= z z'))  ex-nf    syl
    syl
    com12    ancoms    com12
    x'  19.22d    x'  (= z z')  ex-nf    syl6
  anim12i
  (E. x' (/\ (e. (<,> x' z) S) (e. (<,> x' z') S)))  (= z z')  pm3.35    syl
  ancoms    anassrs    ex
  z'  19.21ai    z  19.21ai    ex
)

# Second equality identitiy for recursep.
thm (recursepeq2 () () (-> (= A B) (<-> (recursep S A C D) (recursep S B C D)))

    A  B  x  betaeq2    D  eqeq1d
      (= A B)  id y  lteq2d    (e. (<,> (beta x y) (beta x (S y))) S)  imbi1d
      y  19.21ai
      y  (-> (< y A) (e. (<,> (beta x y) (beta x (S y))) S))  (-> (< y B) (e. (<,> (beta x y) (beta x (S y))) S))  19.15    syl
    anbi12d
    (= (beta x (0)) C)  anbi2d
    x  exbid
      S A C D x y df-recursep
    syl5bb
     S B C D x y df-recursep
    syl6bbr
)

# number 170.0
thm (recursep-uniq.3 ((B z z')) () (-> (= x B) (<->
  (-> (fun S) (A. z (A. z' (-> (/\ (recursep S x A z) (recursep S x A z')) (= z z')))))
  (-> (fun S) (A. z (A. z' (-> (/\ (recursep S B A z) (recursep S B A z')) (= z z')))))
))
  x  B  S  A  z  recursepeq2
    x  B  S  A  z'  recursepeq2
  anbi12d
  (= z z')  imbi1d
  z'  19.21ai  19.15d    z  19.21ai    19.15d
  (fun S)  imbi2d
)

# Uniqueness of the result of a recursion operation.
thm (recursep-uniq () () (-> (fun S) (-> (/\ (recursep S A B C)  (recursep S A B D)) (= C D)))

  x  (0)  S  z  z'  B  recursep-uniq.3
    x  y  S  z  z'  B  recursep-uniq.3
  x  (S y)  S  z  z'  B  recursep-uniq.3
    x  A  S  z  z'  B  recursep-uniq.3

  S  B  z   recursep-uniq.1
    S   B  z'  recursep-uniq.1
  anbi12d    biimpd
  B  z  z'  ax-eqtr    syl6
  z'  19.21ai  z  19.21ai

  S  z  z'  y  B  recursep-uniq.2  a2i

finds

  z  C  S  A  B  recursepeq4
  (recursep S A B z')  anbi1d
  (= z C)  id    z'  eqeq1d    imbi12d
  z'  19.21ai  19.15d
  cla4g
syl

   z'  D  S  A  B  recursepeq4
  (recursep S A B C)  anbi2d
  (= z' D)  id    C  eqeq2d    imbi12d
  cla4g
syl
)

# First equality identity of recursep.
thm (recursepeq1 () () (-> (=_ S T) (<-> (recursep S A B C) (recursep T A B C)))
    S  T  (<,> (beta x y) (beta x (S y)))  eleq2
    (< y A)  imbi2d
    y  19.21ai
    19.15d
    (= (beta x A) C)  anbi2d
    (= (beta x (0)) B)  anbi2d
    x  exbid
      S  A  B  C  x  y  df-recursep
    syl5bb
      T  A  B  C  x  y  df-recursep
    syl6bbr
)

# Recursing zero times doesn't go anywhere.
thm (recursep0 () () (recursep S (0) A A)

  A  eqid
z  A  recursive.2.1
  A  A  (beta z (0)) eqeq2   (= (beta z (0)) A)  anbi2d   (= (beta z (0)) A)  anidm    syl6bb
    y nn0nlt0   (e. (<,> (beta z y) (beta z (S y))) S)  pm2.21i    y gen
   (= (beta z (0)) A)  biantru
   (= (beta z (0)) A)  anbi2i
  syl5bbr
  z  exbid
mpbiri
 ax-mp
 S  (0)  A  A  z  y  df-recursep
 mpbir
)

# number 174.0
# There exists a unique answer to recursing the function S exactly B times
# starting at A.
thm (eurecursep ((S x) (A x) (B x)) () (-> (fun S) (E! x (recursep S A B x)))
  S x A B recursive
    S A B x y recursep-uniq y 19.21ai x 19.21ai
  jca
  x y S A B recursepeq4 eu4 sylibr
)

# == Exponentiation ==

# Definition of exponentiation in terms of recursed multiplication.
# NOTE(abliss): this entails 0^0 = 1.  Maybe a bad choice we'll pay for later?
thm (df-exp-just ((A w x y z) (B x z)) () (=
  (iota ({|} x (recursep (lambda y (* y A)) B (1) x)))
  (iota ({|} z (recursep (lambda w (* w A)) B (1) z))))

 x  z  (lambda w (* w A))  B  (1)  recursepeq4
  y  w  A  muleq1
  lambdaeq1
  (lambda y (* y A))  (lambda w (* w A))  B  (1)  x  recursepeq1    ax-mp
 syl5bb
 abeq
 ({|} x (recursep (lambda y (* y A)) B (1) x))  ({|} z (recursep (lambda w (* w A)) B (1) z))  ax-iotaeq    ax-mp
)

defthm (df-exp nat (exp A B) ((A x y) (B x)) ()
  (= (exp A B) (iota ({|} x (recursep (lambda y (* y A)) B (1) x))))
  x'  y'  A  B  x  y  df-exp-just)

# Exponent zero.
#
# Together with expsuc, this provides a "working definition" of exponentiation
# similar to what pa_ax3/pa_ax4 provide for addition and what pa_ax5/pa_ax6
# provide for multiplication.  If you want an interface that includes
# exponentiation, you should be able to import only these two (along with the
# equality identities expeq1 and expeq2); no knowledge of the recursep / beta
# framework should be required.
thm (exp0 () () (= (exp A (0)) (1))

    x  (1)  tyeu
      (lambda y (* y A))  (1)  recursep0
      x  (1)  (lambda y (* y A))  (0)  (1)  recursepeq4  mpbiri

    (lambda y (* y A))  (1)  recursep0
          y  z  A  muleq1    funlambda
          (lambda y (* y A))  (0)  (1)  (1)  x  recursep-uniq    ax-mp
        ex    ax-mp    eqcomd
      impbii
      x  eubii
    mpbi
    x  (recursep (lambda y (* y A)) (0) (1) x)  iotacl2    ax-mp



      A  (0)  x  y  df-exp
      (exp A (0))  (iota ({|} x (recursep (lambda y (* y A)) (0) (1) x)))  ({|} x (recursep (lambda y (* y A)) (0) (1) x))  ax-eleq1  ax-mp
    mpbir

      x  (exp A (0))    (lambda y (* y A))  (0)  (1)  recursepeq4
      elab
    mpbi


        (lambda y (* y A))  (1)  recursep0
          y  z  A  muleq1    funlambda
          (lambda y (* y A))  (0)  (1)  (1)  (exp A (0))  recursep-uniq    ax-mp
        ex    ax-mp    eqcomd
    ax-mp
)

# Successor of exponent.  See [exp0] for more notes.
thm (expsuc () () (= (exp A (S B)) (* A (exp A B)))

y  z  A  muleq1    funlambda
(lambda y (* y A))  x  (S B)  (1)  eurecursep    ax-mp
x  (recursep (lambda y (* y A)) (S B) (1) x)  iotacl2    ax-mp

  A  (S B)  x  y  df-exp
    (exp A (S B))  (iota ({|} x (recursep (lambda y (* y A)) (S B) (1) x)))  ({|} x (recursep (lambda y (* y A)) (S B) (1) x))  ax-eleq1
  ax-mp

mpbir

x  (exp A (S B))  (lambda y (* y A))  (S B)  (1)  recursepeq4  elab    mpbi


  (lambda y (* y A))  B  (1)  (exp A (S B))  x  recursepsuc
ax-mp

  y  x  A  muleq1  lambdaeq1
  (lambda y (* y A))  (lambda x (* x A))  (<,> x (exp A (S B)))  eleq2    ax-mp
  x  z  A  muleq1  (exp A (S B))  ellambda    bitri
  x  A  mulcom    (exp A (S B))  eqeq2i    bitri
  (recursep (lambda y (* y A)) B (1) x)  anbi2i
  x  exbii
mpbi



y  z  A  muleq1    funlambda
(lambda y (* y A))  x  B  (1)  eurecursep    ax-mp
x  (recursep (lambda y (* y A)) B (1) x)  iotacl2    ax-mp
  A  B  x  y  df-exp
    (exp A B)  (iota ({|} x (recursep (lambda y (* y A)) B (1) x)))  ({|} x (recursep (lambda y (* y A)) B (1) x))  ax-eleq1
  ax-mp
mpbir
x  (exp A B)  (lambda y (* y A))  B  (1)  recursepeq4  elab    mpbi


y  z  A  muleq1  funlambda
  (lambda y (* y A))  B  (1)  (exp A B)  x  recursep-uniq    ax-mp
mpan
(= (exp A (S B)) (* A x))  anim1i

  (exp A B)  x  A  muleq2    (= (exp A (S B)) (* A x))  anim1i
    (* A x)  (exp A (S B))  (* A (exp A B))  ax-eqtr  ex    eqcoms    com12    eqcoms   imp    syl
  syl
x  19.22i    ax-mp

x  (= (exp A (S B)) (* A (exp A B)))  ex-nf    ax-mp
)

# First equality identity for exponentiation
thm (expeq1 () () (-> (= A B) (= (exp A C) (exp B C)))
  (= A B)  y  alnfi
    A  B  y  muleq2
    y  19.20i
    y  (* y A)  (* y B)  lambdaeq2   syl
    (lambda y (* y A))  (lambda y (* y B))  C  (1)  x  recursepeq1    syl
    x  19.21ai
    x  (recursep (lambda y (* y A)) C (1) x)  (recursep (lambda y (* y B)) C (1) x)  abeq2    syl
    ({|} x (recursep (lambda y (* y A)) C (1) x))  ({|} x (recursep (lambda y (* y B)) C (1) x))  ax-iotaeq    syl
    B  C  x  y  df-exp    syl6eqr
    A  C  x  y  df-exp    syl5eq
  syl
)

# Second equality identity for exponentiation
thm (expeq2 () () (-> (= A B) (= (exp C A) (exp C B)))
  (= A B)  x  alnfi
    A  B  (lambda y (* y C))  (1)  x  recursepeq2
    x  19.20i
    x  (recursep (lambda y (* y C)) A (1) x)  (recursep (lambda y (* y C)) B (1) x)  abeq2    syl
    ({|} x (recursep (lambda y (* y C)) A (1) x))  ({|} x (recursep (lambda y (* y C)) B (1) x))  ax-iotaeq    syl
    C  B  x  y  df-exp    syl6eqr
    C  A  x  y  df-exp    syl5eq
  syl
)

thm (expmul.1 () () (-> (= x D) (<->
  (= (exp (* A B) x) (* (exp A x) (exp B x)))
  (= (exp (* A B) D) (* (exp A D) (exp B D)))))

  x  D  (* A B)  expeq2
    x  D  A  expeq2
      x  D  B  expeq2
    muleq12d
  eqeq12d
)

# Multiplying of exponents
thm (expmul () () (= (exp (* A B) C) (* (exp A C) (exp B C)))

x  (0)  A  B  expmul.1
x  y  A  B  expmul.1
x  (S y)  A  B  expmul.1
x  C  A  B  expmul.1

# base case
(* A B)  exp0
  A  exp0
    B  exp0
  muleq12i
  (1)  mulid  eqtr
eqtr4

# inductive step
(exp (* A B) y)  (* (exp A y) (exp B y))  (* A B)  muleq2
(* A B)  y  expsuc  syl5eq
  A  y  expsuc
    B  y  expsuc
  muleq12i
  (* A (exp A y))  B  (exp B y)  mulass   eqtr4
    A  (exp A y)  B  mulass  (exp A y)  B  mulcom   (* (exp A y) B)  (* B (exp A y))  A  muleq2  ax-mp  eqtr
    A  B  (exp A y)  mulass  eqtr4
    (exp B y)  muleq1i
  eqtr
  (* A B)  (exp A y)  (exp B y)  mulass  eqtr
  syl6eqr

finds
)

thm (expadd.1 () () (-> (= x B) (<->
  (= (exp A (+ x C)) (* (exp A x) (exp A C)))
  (= (exp A (+ B C)) (* (exp A B) (exp A C)))))

x  B  C  addeq1
(+ x C)  (+ B C)  A  expeq2  syl
  x  B  A  expeq2
  (exp A C)  muleq1d
eqeq12d
)

# Adding of exponents
thm (expadd () () (= (exp A (+ B C)) (* (exp A B) (exp A C)))

x  (0)  A  C  expadd.1
x  y  A  C  expadd.1
x  (S y)  A  C  expadd.1
x  B  A  C  expadd.1

# base case
C  pa_ax3r
(+ (0) C)  C  A  expeq2    ax-mp
  A  exp0
  (exp A C)  muleq1i
  (1)  (exp A C)  mulcom     (exp A C)  mulid  eqtr  eqtr
eqtr4

# inductive step
(exp A (+ y C))  (* (exp A y) (exp A C))  A  muleq2
  y  C  pa_ax4r
    (+ (S y) C)  (S (+ y C))  A  expeq2  ax-mp
  A  (+ y C)  expsuc  eqtr
syl5eq
  A  y  expsuc    (exp A C)  muleq1i
  A  (exp A y)  (exp A C)  mulass    eqtr
syl6eqr

finds
)

thm (expexp.1 () () (-> (= x C) (<->
 (= (exp (exp A B) x) (exp A (* B x)))
 (= (exp (exp A B) C) (exp A (* B C)))))

x  C  (exp A B)  expeq2
  x  C  B  muleq2
  (* B x)  (* B C)  A  expeq2    syl
eqeq12d
)

# Exponentiation over exponentiation yields multiplication.
thm (expexp () () (= (exp (exp A B) C) (exp A (* B C)))

x  (0)    A  B  expexp.1
x  y      A  B  expexp.1
x  (S y)  A  B  expexp.1
x  C      A  B  expexp.1

# base case
(exp A B)  exp0
  B  pa_ax5    (* B (0))  (0)  A  expeq2    ax-mp
  A  exp0    eqtr
eqtr4

# inductive step
(exp (exp A B) y)  (exp A (* B y))  (exp A B)  muleq2
  (exp A B)  y  expsuc
    B  y  pa_ax6    (* B (S y))  (+ (* B y) B)  A  expeq2    ax-mp
    A  (* B y)  B  expadd    eqtr
    (exp A (* B y))  (exp A B)  mulcom   eqtr
  eqeq12i
sylibr

finds
)

thm (explt1 () ()
  (-> (< (0) A) (<= (1) (exp A B)))
  x (0) A expeq2 (1) leeq2d (< (0) A) imbi2d
    x y A expeq2 (1) leeq2d (< (0) A) imbi2d
      x (S y) A expeq2 (1) leeq2d (< (0) A) imbi2d
        x B A expeq2 (1) leeq2d (< (0) A) imbi2d

  # Base case
  (1) leid A exp0 (1) leeq2i mpbir (< (0) A) a1i

  # Induction step
  (0) A nnltp1let (1) pa_ax3r A leeq1i bitri
    (1) A (exp A y) lemul2
    (exp A y) mulid (* (exp A y) A) leeq1i sylib
    A y expsuc A (exp A y) mulcom eqtr (exp A y) leeq2i sylibr
  sylbi
  (1) (exp A y) (exp A (S y)) letr ancoms ex syl a2i

  finds
)

thm (explt2 () ()
  (-> (< (0) A) (-> (<= B C) (<= (exp A B) (exp A C))))
  B C x df-le
    A x explt1 (1) (exp A x) (exp A B) lemul2 syl
    (exp A B) mulid (* (exp A B) (exp A x)) leeq1i sylib
      (+ B x) C A expeq2
      A B x expadd syl5eqr
      (exp A B) leeq2d
      (< (0) A) imbi2d
    mpbii x 19.23ai
  sylbi com12
)

thm (explt.3 () ()
  (-> (< (1) A) (-> (< B C) (< (exp A B) (exp A C))))
  (0) leid (0) (0) lesuc mpbir df-1 (0) lteq2i mpbir
  (0) (1) A lttr mpan
  A (+ B (1)) C explt2
  B C nnltp1let
  syl5ib

    A B expsuc eqcomi
    B a1suc (S B) (+ B (1)) A expeq2 ax-mp eqtr
    (exp A C) leeq1i
  syl6ibr (< (1) A) adantr
  A B explt1 (0) (exp A B) nnltp1let (1) pa_ax3r (exp A B) leeq1i bitri sylibr
  (exp A B) (1) A ltmul1 syl imp
  (exp A B) mulid (* (exp A B) A) lteq1i
  sylib
  (exp A B) A mulcom (exp A B) lteq2i sylib
   (exp A B) (* A (exp A B)) (exp A C) lelttr2 ex syl
  syld ex com12
  mpd
)

# Exponentation is strictly monotonic with base of two or greater
thm (exple () ()
  (-> (< (1) A) (<-> (<= B C) (<= (exp A B) (exp A C))))
  (0) leid (0) (0) lesuc mpbir df-1 (0) lteq2i mpbir (0) (1) A lttr mpan
  A B C explt2 syl
    A C B explt.3
      B C lenltt con2bii
        (exp A B) (exp A C) lenltt con2bii
    3imtr3g
    con4d
  impbid
)

# Exponentation is strictly monotonic with base of two or greater
thm (explt () ()
  (-> (< (1) A) (<-> (< B C) (< (exp A B) (exp A C))))
  A C B exple
    C B lenltt
      (exp A C) (exp A B) lenltt
  3bitr3g con4bid
)

# == Unique factorization ==

# number 0.5
thm (lincomgcd () () (lincom (S A) B (gcd (S A) B))
x  (gcd (S A) B)  tyex
  A  B  x  gcddiv1.2
  pm3.27d
  eqcoms
  x  (gcd (S A) B)  (S A)  B  lincomeq3    mpbid
  x  exani
ax-mp
)
# number 0.9
thm (dividesadd12 () () (-> (/\ (| A B) (| A C)) (| A (+ B C)))
  A  B  x  df-divides    biimpi
    A  C  y  df-divides    biimpi
  anim12i
  x  (= (* A x) B)  y  (= (* A y) C)  exey    syl
   z  (+ x y)  tyex
    (* A x)  B  (* A y)  C  addeq12
    A  x  y  distr    (+ B C)  eqeq1i    sylibr
      z  (+ x y)  A  muleq2
      (+ B C)  eqeq1d
      biimprd
      com12
      z  19.22d
    syl
   mpi
   y  exani
   x  exani
  syl
    A  (+ B C)  z  df-divides
  sylibr
)
# number 0.95
thm (divideslincom () () (-> (/\ (| (S A) B) (| (S A) C)) (-> (lincom B C D) (| (S A) D)))
B  C  D  w  x  y  z  df-lincom
  (S A)  B  w  dividesmul
  B  w  mulcom  (* B w)  (* w B)  (S A)  divideseq2    ax-mp   sylib
    (S A)  C  x  dividesmul
    C  x  mulcom  (* C x)  (* x C)  (S A)  divideseq2    ax-mp   sylib
  anim12i
  (S A)  (* w B)  (* x C)  dividesadd12    syl
    (+ (* w B) (* x C))  (+ (+ (* y B) (* z C)) D)  (S A)  divideseq2    biimpd
  mpan9
  ex    com12

 (S A)  B  y  dividesmul
  B  y  mulcom  (* B y)  (* y B)  (S A)  divideseq2    ax-mp   sylib
    (S A)  C  z  dividesmul
    C  z  mulcom  (* C z)  (* z C)  (S A)  divideseq2    ax-mp   sylib
  anim12i
  (S A)  (* y B)  (* z C)  dividesadd12    syl

  A  (+ (* y B) (* z C))  D  dividesadd.2    syl

  sylcom

  z  exani    y  exani    x  exani    w  exani    sylbi
  com12
)

thm (gcd () () (-> (/\ (| (S A) (S B)) (| (S A) C)) (| (S A) (gcd (S B) C)))
  B  C  lincomgcd
  A  (S B)  C  (gcd (S B) C)  divideslincom
mpi
)

# Linear combination is commutative
thm (lincomcom () () (<-> (lincom A B C) (lincom B A C))
  A  B  C  w  x  y  z  df-lincom
    (* w A)  (* x B)  addcom
      (* y A)  (* z B)  addcom    C  addeq1i
    eqeq12i
    z  exbii
    y  exbii
    y  z  (= (+ (* x B) (* w A)) (+ (+ (* z B) (* y A)) C))  excom    bitri
    x  exbii
    w  exbii
    w  x  (E. z (E. y (= (+ (* x B) (* w A)) (+ (+ (* z B) (* y A)) C))))  excom    bitri
  bitri
    B  A  C  x  w  z  y  df-lincom
  bitr4i
)

# Greatest common denominator is commutative
thm (gcdcom () () (= (gcd A B) (gcd B A))
  A  B  x  df-gcd
    A  B  x  lincomcom
    (-. (= x (0)))  anbi2i
    x  gen
    x  (/\ (-. (= x (0))) (lincom A B x))  (/\ (-. (= x (0))) (lincom B A x))  abeq2    ax-mp
    ({|} x (/\ (-. (= x (0))) (lincom A B x)))  ({|} x (/\ (-. (= x (0))) (lincom B A x)))  mineq    ax-mp
  eqtr
  B  A  x  df-gcd   eqtr4
)

# number 7.0
thm (primegcd () () (-> (prime (S A)) (\/ (| (S A) (S B)) (= (gcd (S A) (S B)) (1))))
A  (S B)  gcddiv1
  (S A)  x  df-prime    biimpi
    x  (gcd (S A) (S B))  (S A)    divideseq1
      x  (gcd (S A) (S B))  (1)  eqeq1
      x  (gcd (S A) (S B))  (S A)  eqeq1  orbi12d
    imbi12d
    cla4g
  syl
mpi

B  (S A)  gcddiv1
  (S A)  (S B)  gcdcom    (S A)  eqeq1i     biimpi
  (gcd (S B) (S A))  (S A)  (S B)  divideseq1    biimpd  syl
mpi

(= (gcd (S A) (S B)) (1)) orim2i    syl

(= (gcd (S A) (S B)) (1))  (| (S A) (S B))  orcom    sylib
)
# number 7.1
thm (divides0 () () (| A (0))
  x  (0)  tyex
    x  (0)  A  muleq2
    A  pa_ax5    syl6eq
  x  19.22i    ax-mp
  A  (0)  x  df-divides  mpbir
)

# number 7.2
thm (0divides () () (<-> (| (0) A) (= (0) A))
  (0)  A  x  df-divides
    x  pa_ax5r    A  eqeq1i
    x  exbii
  bitri
    x  (= (0) A)   19.9
  bitri
)

# number 7.3
thm (0primeideal () () (<-> (= (* A B) (0)) (\/ (= A (0)) (= B (0))))
  A  (0)  B  muleq1
  B  pa_ax5r    syl6eq
    B  (0)  A  muleq2
    A  pa_ax5    syl6eq
  jaoi

    A  x  lefoo
    x  a1suc    x  (1)  addcom  eqtr    A  eqeq1i  biimpri
    B  muleq1d
    (0)  eqeq1d   biimprd
      x  B  mul0
    syl6
    x  exani    (= A (0))    orim2i    ax-mp
    ori    com12    orrd
  impbii
  bicomi
)

# number 7.4
thm (0notprime () () (-. (prime (0)))


x  (S (1))  tyex
  (S (1))  divides0
    x  (S (1))  (0)  divideseq1    biimprd
  mpi
    (1)  pa_ax1    (0)  (S (1))  eqcom    biimpri  con3i   ax-mp
    x  (S (1))  (0)  eqeq1    biimpd    con3d    mpi
      (0)  pa_ax1
        df-1    (0)  eqeq2i    biimpi    con3i    ax-mp
        (0)  (1)  pa_ax2    biimpri   con3i  ax-mp
        df-1    (S (1))  eqeq1i    biimpi   eqcoms  con3i     ax-mp
        x  (S (1))  (1)  eqeq1   biimpd    con3d    mpi
      jca    ancomd
      (= x (1))  (= x (0))  pm4.56    sylib
    jca
    (| x (0))  (\/ (= x (1)) (= x (0)))  annim     sylib
    x  19.22i
    ax-mp


  x  (-. (-> (| x (0)) (\/ (= x (1)) (= x (0)))))  df-ex
  (-> (| x (0)) (\/ (= x (1)) (= x (0))))  notnot    x  albii    notbii    bitr4i
  (0)  x  df-prime  biimpi    con3i  sylbi
ax-mp
)

# Euclid's lemma, assuming A and B are not 0.
thm (euclidlem.1 () () (-> (prime (S A)) (-> (| (S A) (* (S B) C)) (\/ (| (S A) (S B)) (| (S A) C))))
   A  B  primegcd  ord
      A  (S B)  lincomgcd
      (gcd (S A) (S B))  (1)  (S A)  (S B)  lincomeq3    mpbii
   syl6
   (S A)  (S B)  (1)  w  x  y  z  df-lincom    syl6ib


       (S A)  dividessym  (S A)  (S A)  (* w C)  dividesmul    ax-mp
         (S A)  w  mulcom    C  muleq1i   (S A)  w  C  mulass  eqtr3
         (* (* w (S A)) C)  (* (S A) (* w C))  (S A)  divideseq2    ax-mp
       mpbir
         (S A)  (* (S B) C)  x  dividesmul    (* (S B) C)  x  mulcom   x  (S B)  C  mulass    eqtr4   (* (* (S B) C) x)  (* (* x (S B)) C)  (S A)  divideseq2    ax-mp    sylib
      jctilb
      (S A)  (* (* w (S A)) C)  (* (* x (S B)) C)  dividesadd12    syl

     (+ (* w (S A))  (* x (S B)))  (+ (+ (* y (S A))  (* z (S B))) (1))   C  muleq1
     (* w (S A))  (* x (S B))  C  distl    syl5eqr
     (+ (* y (S A)) (* z (S B)))  (1)  C  distl    syl6eq
     (* y (S A))  (* z (S B))  C  distl    (* (1) C)  addeq1i    syl6eq

     (+ (* (* w (S A)) C) (* (* x (S B)) C))  (+ (+ (* (* y (S A)) C) (* (* z (S B)) C)) (* (1) C))  (S A)  divideseq2    syl    biimpd

     mpan9
     ex

       (S A)  dividessym  (S A)  (S A)  (* y C)  dividesmul    ax-mp
         (S A)  y  mulcom    C  muleq1i   (S A)  y  C  mulass  eqtr3
         (* (* y (S A)) C)  (* (S A) (* y C))  (S A)  divideseq2    ax-mp
       mpbir
         (S A)  (* (S B) C)  z  dividesmul    (* (S B) C)  z  mulcom   z  (S B)  C  mulass    eqtr4   (* (* (S B) C) z)  (* (* z (S B)) C)  (S A)  divideseq2    ax-mp    sylib
       jctilb
       (S A)  (* (* y (S A)) C)  (* (* z (S B)) C)  dividesadd12    syl

       A  (+ (* (* y (S A)) C) (* (* z (S B)) C))  (* (1) C)  dividesadd.2    syl

       C  mulid    C  (1)  mulcom    eqtr3    C  (* (1) C)  (S A)  divideseq2    ax-mp
    syl6ibr

    syld
    com12

  z  19.22i    y   19.22i    x  19.22i    w  19.22i    syl6
  z  (-> (| (S A) (* (S B) C)) (| (S A) C))  19.9    biimpi    y  exani    x  exani    w  exani    syl6
  com23
  imp
  orrd
  ex
)

# Removes one of the S marks from [euclidlem.1] by considering the case A=0.
# The other S mark will be removed in [euclidlem] by considering B=0.
thm (euclidlem.2 () () (-> (prime A) (-> (| A (* (S B) C)) (\/ (| A (S B)) (| A C))))
0notprime
(0)  A  primeeq    biimprd    con3d    mpi
con2i
A  (0)  eqcom    notbii  sylibr
A  x  lefoo    ori    syl
  x  a1suc    x  (1)  addcom  eqtr     A  eqeq1i    biimpri
x  19.22i    syl
  (S x)  A  primeeq    biimprd
  (S x)  A  (* (S B) C)  divideseq1   biimprd    anim12d
  x  B  C  euclidlem.1    imp    syl6
    (S x)  A  (S B)  divideseq1
    (S x)  A  C  divideseq1    orbi12d
  sylibd
x  exani    syl
anabsi5
ex
)
# number 8.0
# Euclid's lemma.
thm (euclidlem () () (-> (prime A) (-> (| A (* B C)) (\/ (| A B) (| A C))))
  B  x  lefoo
    A  divides0
    B  (0)  A  divideseq2    biimprd    mpi
    (| A C)  orcd    (| A (* B C))  a1d    (prime A)  a1d

      x a1suc    x  (1)  addcom    (S x)  eqeq2i    mpbi
      B  eqeq1i     biimpri
       A  x  C  euclidlem.2
        (S x)  B  C  muleq1
        (* (S x) C)  (* B C)  A  divideseq2    syl
          (S x)  B  A  divideseq2    (| A C)  orbi1d
        imbi12d  biimpd
       mpan9
      ancoms   ex    syl
      x  exani
    jaoi
  ax-mp
)

# primes(A B) shall mean that the first A elements of the list represented by
# the beta-numeral B are all prime.
thm (df-primes-just ((A x y) (B x y)) () (<->
  (A. x (-> (< x A) (prime (beta B x))))
  (A. y (-> (< y A) (prime (beta B y)))))

  (= x y)  id    A  lteq1d
    x  y  B  betaeq2
    (beta B x)  (beta B y)  primeeq    syl
  imbi12d
  alpha
)

defthm (df-primes wff (primes A B) ((A x) (B x)) ()
    (<-> (primes A B)    (A. x (-> (< x A) (prime (beta B x)))))
  y  A  B  x  df-primes-just)
# number 10.0
# nondecr(A B) shall mean that the first A elements of the list represented by
# the beta-numeral B are nondecreasing.
thm (df-nondecr-just ((A x y) (B x y)) () (<->
  (A. x (-> (< (S x) A) (<= (beta B x) (beta B (S x)))))
  (A. y (-> (< (S y) A) (<= (beta B y) (beta B (S y))))))
  (= x y)  id    suceqd    A  lteq1d

    x  y  B  betaeq2
    (beta B (S x))  leeq1d

      (= x y)  id    suceqd
      (S x)  (S y)  B  betaeq2    syl
      (beta B y)  leeq2d
    bitr2d
    bicomd

  imbi12d
  alpha
)

defthm (df-nondecr wff (nondecr A B) ((A x) (B x)) ()
    (<-> (nondecr A B)   (A. x (-> (< (S x) A) (<= (beta B x) (beta B (S x))))))
  y  A  B  x  df-nondecr-just)


# partprod(A B C) shall mean that the first A elements of the sequence in
# beta-numeral B have their partial products in the beta-numeral C.
# May act funky if A == 0.
thm (df-partprod-just ((A x y) (B x y) (C x y)) () (<->
  (/\ (= (beta B (0)) (beta C (0)))
      (A. x (-> (< (S x) A) (= (beta C (S x)) (* (beta C x) (beta B x))))))
  (/\ (= (beta B (0)) (beta C (0)))
      (A. y (-> (< (S y) A) (= (beta C (S y)) (* (beta C y) (beta B y)))))))

  (= x y)  id    suceqd    A  lteq1d

    (= x y)  id    suceqd
    (S x)  (S y)  C  betaeq2    syl
      x  y  C  betaeq2
        x  y  B  betaeq2
      muleq12d
     eqeq12d
   imbi12d
  alpha
  (= (beta B (0)) (beta C (0)))  anbi2i
)

defthm (df-partprod wff (partprod A B C) ((A x) (B x) (C x)) ()
    (<-> (partprod A B C)
      (/\ (= (beta B (0)) (beta C (0)))
        (A. x (-> (< (S x) A) (= (beta C (S x)) (* (beta C x) (beta B x)))))))
  B  C  y  A  x  df-partprod-just)

# factorization(A, B, C, D) shall mean that D has been factored into A' primes,
# which are listed nondecreasingly in the beta-numeral B.  The beta-numeral C
# shall list the partial products alongside.
defthm (df-factorization  wff (factorization A B C D) () ()
  (<-> (factorization A B C D)
  (/\ (primes (S A) B)
      (/\ (nondecr (S A) B)
          (/\ (partprod (S A) B C)
              (= D (beta C A))))))

  (/\ (primes (S A) B)
      (/\ (nondecr (S A) B)
          (/\ (partprod (S A) B C)
              (= D (beta C A)))))  biid
)


# Any prime number has a trivial length-1 factorization.
thm (exfactorization.0 ((A x)) ()
  (-> (prime A) (E. x (factorization (0) x x A)))

# x will be the beta-numeral of the length-1 list [A].
  x  A  recursive.2.1
# 1. primes [A]
    (beta x (0))  A  primeeq    biimprd
        z  (0)  lesuc    z  eq0le0    bitr4i    z  (0)  x  betaeq2    sylbi
        (beta x z)  (beta x (0))  primeeq    syl    biimprcd
    syl6
    imp
    z  19.21ai
    (S (0))  x  z  df-primes    sylibr
    #ex

# 2. nondecr 0' x  (for any x)
      y  pa_ax1    (S y)  (0)    lesuc    (S y)  eq0le0    bitr4i    biimpi   eqcomd     con3i   ax-mp
      (<= (beta x y) (beta x (S y)))  pm2.21i
      y  gen
        (S (0))  x  y  df-nondecr
      biimpri  ax-mp

# 3. partprod 0' x x  (for any x)
        (beta x (0))  eqid
          y  pa_ax1    (S y)  (0)    lesuc    (S y)  eq0le0    bitr4i    biimpi   eqcomd     con3i   ax-mp
          (= (beta x (S y)) (* (beta x y) (beta x y)))  pm2.21i
          y  gen
        pm3.2i
        (S (0))  x  x  y  df-partprod    mpbir

# assemble
          (beta x (0))  A  eqcom    biimpi    (prime A)  adantr
        jctilb
      jctilb
    jca

    ex
    com12
    x  19.22d
  mpi

    (0)  x  x  A  df-factorization    x  exbii
  sylibr
)

# Third equality identity for factorization
thm (factorizationeq3 () () (-> (= C C') (<-> (factorization A B C D) (factorization A B C' D)))


# just proving partprodeq3 in-place
    C  C'  (0)  betaeq1    (beta B (0))  eqeq2d
      C  C'  (S x)  betaeq1
      C  C'  x  betaeq1    (beta B x)  muleq1d    eqeq12d
      (< (S x) (S A))  imbi2d
      x  19.21ai            19.15d
    anbi12d
    (S A)  B  C  x  df-partprod    syl5bb
    (S A)  B  C'  x  df-partprod    syl6bbr


  C  C'  A  betaeq1
  D  eqeq2d

  anbi12d
  (nondecr (S A) B)  anbi2d
  (primes (S A) B)  anbi2d


  A  B  C  D  df-factorization    syl5bb
  A  B  C'  D  df-factorization    syl6bbr
)
# number 14.0
# Fourth equality identity for factorization
thm (factorizationeq4 () () (-> (= A B) (<-> (factorization D C C' A) (factorization D C C' B)))

  A  B  (beta C' D)  eqeq1
  (partprod (S D) C C')  anbi2d
  (nondecr (S D) C)  anbi2d
  (primes (S D) C)  anbi2d
  D  C  C'  B  df-factorization    syl6bbr
  D  C  C'  A  df-factorization    syl5bb
)
# number 14.5
# First equality identity for factorization
thm (factorizationeq1 () () (-> (= A B) (<-> (factorization A C C' D)
(factorization B C C' D)))

# primeseq1
A  B  pa_ax2    biimpi
x  lteq2d    (prime (beta C x))  imbi1d    x  19.21ai    19.15d
(S A)  C  x  df-primes    syl5bb
(S B)  C  x  df-primes    syl6bbr


# nondecreq1
A  B  pa_ax2    biimpi
(S x)  lteq2d    (<= (beta C x) (beta C (S x)))  imbi1d    x  19.21ai    19.15d
(S A)  C  x  df-nondecr    syl5bb
(S B)  C  x  df-nondecr    syl6bbr


# partprodeq1
  A  B  pa_ax2    biimpi
  (S x)  lteq2d    (= (beta C' (S x)) (* (beta C' x) (beta C x)))  imbi1d    x  19.21ai    19.15d
  (= (beta C (0)) (beta C' (0)))  anbi2d
    (S A)  C  C'  x  df-partprod    syl5bb
    (S B)  C  C'  x  df-partprod    syl6bbr


  A  B  C'   betaeq2
  D  eqeq2d

#assemble
  anbi12d
  anbi12d
  anbi12d

  A  C  C'  D  df-factorization    syl5bb
  B  C  C'  D  df-factorization    syl6bbr
)
# number 15.0
thm (exfactorization.1 ((A y) (A z) (A w)) () (-> (= x A)
  (<-> (E. w (E. y (E. z (factorization w y z (S (S x))))))
       (E. w (E. y (E. z (factorization w y z (S (S A))))))))
(= x A)  id    suceqd    suceqd
  (S (S x))  (S (S A))  w  y  z  factorizationeq4
  z  exbid    y  exbid    w  exbid
syl
)

export (RESULTS peano_thms.ghi (PROP) "")

# number 16.0
# Existence of a factorization for any number bigger than 1.
thm (exfactorization () () (E. x (E. y (E. y' (factorization x y y' (S (S A))))))

# setup
w  (0)  x  y  y'  exfactorization.1
w  (S z)  x  y  y'  exfactorization.1
w  A  x  y  y'  exfactorization.1

# base case: 2, being prime, has a factorization
2prime
  (1)  a1suc    df-1   (1)  (S (0))  pa_ax2  mpbi    eqtr3
(+ (1) (1))  (S (S (0)))  primeeq    ax-mp  mpbi
(S (S (0)))  y  exfactorization.0    ax-mp
  y'  y  tyex
    y'  y  (0)  y  (S (S (0)))  factorizationeq3
    biimprd    y' 19.22i   ax-mp
    y  gen
  pm3.2i
  y  (factorization (0) y y (S (S (0))))  (E. y' (-> (factorization (0) y y (S (S (0)))) (factorization (0) y y' (S (S (0))))))  19.29r    ax-mp
  y'  (factorization (0) y y (S (S (0))))  (-> (factorization (0) y y (S (S (0)))) (factorization (0) y y' (S (S (0)))))  19.41l    biimpri   (factorization (0) y y (S (S (0))))  (factorization (0) y y' (S (S (0))))  pm3.35    y'  19.22i    syl    y  19.22i    ax-mp
  x  gen

  x  (0)  tyex
  x  (0)  y  y'  (S (S (0)))  factorizationeq1    biimprd    y'  19.22d  y  19.22d    x  19.22i    ax-mp
pm3.2i

x  (E. y (E. y' (factorization (0) y y' (S (S (0))))))  (-> (E. y (E. y' (factorization (0) y y' (S (S (0)))))) (E. y (E. y' (factorization x y y' (S (S (0)))))))  19.29   (E. y (E. y' (factorization (0) y y' (S (S (0))))))  (E. y (E. y' (factorization x y y' (S (S (0))))))  pm3.35    x  19.22i    syl    ax-mp



# Strong induction step
v  (S z)  primedivisor

(S (S v))  (S (S z))  dividesle    (S (S v))  (S (S (S z)))  lefoo3  sylib
(prime (S (S v)))  anim2i

(=  w v)  id    z  leeq1d
  w  v  pa_ax2    biimpi    suceqd
  (S (S w))  (S (S v))  x  y  y'  factorizationeq4    syl
  y'  exbid    y  exbid    x  exbid
imbi12d
cla4g

  ?
)