# Building up theorems of peano arithmetic.

import (PROP prop.ghi () "")
import (PEANO_MIN peano_min.ghi (PROP) "")

# This is to get the file to display on a local host:
# import (PROP /peano/prop.ghi () "")
# import (PEANO_MIN /peano/peano_min.ghi (PROP) "")

tvar (wff ph ps ch th ta et ph' ps' ch' th' ta')
tvar (nat A B C D A' B' C' D' A0 A1 A2 A3 i j k)
var (nat v w x y z v' w' x' y' z')

# == Pure predicate calculus ==

thm (a4i ()
  (hyp (A. x ph))
  ph
  hyp x ph ax-4 ax-mp
)

## <table>
##   (-> (A. x [ (-> ph ps) ] ) ps)
##             [ (-> ph ps) ]
## </table>
thm (mpg ()
  (hyp1 (-> (A. x ph) ps)
   hyp2 ph)
  ps
  hyp2
  ## <d>
    x gen
  ## </d>
  hyp1 ax-mp
)

thm (19.3 ((ph x))
  ()
  (<-> (A. x ph) ph)
  x ph ax-4 ph x alnfi impbii
)

thm (notnotbi () () (<-> (-. (-. ph)) ph)
  ph notnot2
  ph notnot1
  impbii
)

# Reverse the hypothesis and conclusion of con4bii.
## <title> Equivalence over Negation </title>
## <table>
##   (<->     [ ph ]       [ ps ] )
##   (<-> (-. [ ph ] ) (-. [ ps ] ))
## </table>
thm (con4biir ()
  (hyp (<-> ph ps))
  (<-> (-. ph) (-. ps))
  hyp ph ps notbi
  mpbi
)

# Reorder sylbi a bit.
## <title> Syllogism </title>
## <table>
##   (->      ps ] ]    ] ch)
##       (<-> ps ] [ ph ] )
##   (->         [ [ ph ] ch)
## </table>
thm (sylbi2()
  (hyp1 (-> ps ch)
   hyp2 (<-> ps ph))
  (-> ph ch)
  hyp2 bicomi hyp1 sylbi
)

thm (biim2i () (hyp (-> ph ps)) (-> (<-> ch ph) (-> ch ps))
  (<-> ch ph) id
  hyp
  syl6bi
)

# The Order reverses which may be a little unexpected.
thm (biim1i () (hyp (-> ph ps)) (-> (<-> ph ch) (-> ch ps))
  hyp
  ch biim2i
  
  ## <d 'Commutative Property '>
    ch ph bicom
    sylbi2
  ## </d 'Commutative Property '>
)

# Commute the conclusion of bitr3i.
## <title> Transitive Property </title>
## <table>
##  (<-> ps [         [ [ ph ] )
##  (<-> ps [      ch ] ]    ] )
##          [ (<-> ch ] [ ph ] )
## </table>
thm (bitr3icom()
  (hyp1 (<-> ps ph)
   hyp2 (<-> ps ch))
  (<-> ch ph)
  hyp1 hyp2 bitr3i bicomi
)

## <title> Equivalence over Disjunction </title>
## <table>
##   (\/      ph ] ]    ] ps)
##       (<-> ph ] [ ch ] )
##   (\/         [ [ ch ] ps)
## </table>
thm (orbi1ii ()
  (hyp1 (\/ ph ps)
   hyp2 (<-> ph ch))
  (\/ ch ps)
  hyp1 hyp2 ps orbi1i mpbi
)

## <title> Equivalence over Disjunction </title>
## <table>
##   (\/ ph       [ ps ] ]    ] )
##           (<-> [ ps ] [ ch ] )
##   (\/ ph       [    [ [ ch ] )
## </table>
thm (orbi2ii ()
  (hyp1 (\/ ph ps)
   hyp2 (<-> ps ch))
  (\/ ph ch)
  hyp1 hyp2 ph orbi2i mpbi
)

## <title> Equivalence over Conjunction </title>
## <table>
##   (/\      ph ] ]    ] ps)
##       (<-> ph ] [ ch ] )
##   (\/         [ [ ch ] ps)
## </table>
thm (anbi1ii ()
  (hyp1 (/\ ph ps)
   hyp2 (<-> ph ch))
  (/\ ch ps)
  hyp1 hyp2 ps anbi1i mpbi
)

## <title> Equivalence over Conjunction </title>
## <table>
##   (/\ ph       [ ps ] ]    ] )
##           (<-> [ ps ] [ ch ] )
##   (/\ ph       [    [ [ ch ] )
## </table>
thm (anbi2ii ()
  (hyp1 (/\ ph ps)
   hyp2 (<-> ps ch))
  (/\ ph ch)
  hyp1 hyp2 ph anbi2i mpbi
)

## <title> Associative Property </title>
thm (orassi () (hyp (\/ (\/ ph ps) ch)) (\/ ph (\/ ps ch))
  hyp
  ph ps ch orass
  mpbi
)

## <title> Associative Property </title>
thm (orassli () (hyp (\/ ph (\/ ps ch))) (\/ (\/ ph ps) ch)
  hyp
  ph ps ch orass
  bicomi
  mpbi
)

## <title> Associative Property </title>
thm (anassi () (hyp (/\ (/\ ph ps) ch)) (/\ ph (/\ ps ch))
  hyp
  ph ps ch anass
  mpbi
)

## <title> Associative Property </title>
thm (anassli () (hyp (/\ ph (/\ ps ch))) (/\ (/\ ph ps) ch)
  hyp
  ph ps ch anass
  bicomi
  mpbi
)

## <title> Associative Property </title>
thm (biassi () (hyp (<-> (<-> ph ps) ch)) (<-> ph (<-> ps ch))
  hyp
  ph ps ch biass
  mpbi
)

## <title> Associative Property </title>
thm (biassli () (hyp (<-> ph (<-> ps ch))) (<-> (<-> ph ps) ch)
  hyp
  ph ps ch biass
  bicomi
  mpbi
)

thm (xorImp1 () () (-> (/\ ph (-. ps)) (-. (<-> ps ph)))
  ps ph xor
  ## <d>
    (-. (<-> ps ph)) (\/ (/\ ps (-. ph)) (/\ ph (-. ps))) bicom
  ## </d>
  mpbi
  biimpi
  olcs
)

thm (xorImp2 () () (-> (/\ ps (-. ph)) (-. (<-> ps ph)))
  ps ph xor
  ## <d>
    (-. (<-> ps ph)) (\/ (/\ ps (-. ph)) (/\ ph (-. ps))) bicom
  ## </d>
  mpbi
  biimpi
  orcs
)

## <title> Definition of ∃ </title>
## <suggest> right('Equivalence', '∀') </suggest>
defthm (df-ex wff (E. x ph) () () (<-> (E. x ph) (-. (A. x (-. ph))))
     (-. (A. x (-. ph))) biid)

# aka 19.7
thm (alnex () ()
  (<-> (A. x (-. ph)) (-. (E. x ph)))
  x ph df-ex con2bii
)

thm (19.8a () ()
  (-> ph (E. x ph))
  x (-. ph) ax-4 con2i
  x ph df-ex sylibr
)

thm (19.8ai () (hyp ph) (E. x ph) hyp ph x 19.8a ax-mp )

thm (19.2 () ()
  (-> (A. x ph) (E. x ph))
  x ph ax-4 ph x 19.8a syl
)

thm (19.9 ((ph x))
  ()
  (<-> (E. x ph) ph)

  x (-. ph) 19.3
  x ph alnex bitr3i con4bii bicomi
)

## <title> Remove Existence Quantifier </title>
## <table>
##   (-> ph [ (E. x [ ps))
##   (-> ph [       [ ps)
## </table>
thm (19.9d ((ps x)) (h (-> ph (E. x ps)))
  (-> ph ps)
  h
  x ps 19.9
  sylib
)

## <title> Distribute ∀ </title>
## <suggest> right('Distribute', '∀') </suggest>
thm (19.15 () ()
  (-> (A. x (<-> ph ps)) (<-> (A. x ph) (A. x ps)))

  ph ps bi1 x gen
  x (<-> ph ps) (-> ph ps) ax-alim ax-mp
  x ph ps ax-alim syl

    ph ps bi2 x gen
    x (<-> ph ps) (-> ps ph) ax-alim ax-mp
    x ps ph ax-alim syl
  impbid
)

thm (19.15i ()
  (hyp (A. x (<-> ph ps)))
  (<-> (A. x ph) (A. x ps))
  hyp x ph ps 19.15 ax-mp)

thm (19.15d () (H1 (-> ph (A. x (<-> ps ch))))
      (-> ph (<-> (A. x ps) (A. x ch)))
     H1 x ps ch 19.15 syl)

## <title> Equivalence over Quantification </title>
## <table>
##   (<->       [ ph ]         [ ps ] )
##   (<-> (A. x [ ph ] ) (A. x [ ps ] ))
## </table>
thm (albii ()
  (hyp (<-> ph ps))
  (<-> (A. x ph) (A. x ps))
  hyp x gen 19.15i)

## <title> Equivalence over Quantification </title>
## <table>
##   (A. x       [ ph ] )
##          (<-> [ ph ] [ ps ] )
##   (A. x       [    [ [ ps ] )
## </table>
thm (albiii ()
  (hyp1 (A. x ph)
   hyp2 (<-> ph ps))
  (A. x ps)
  hyp1 hyp2 x albii mpbi
)

# aka 19.6

## <title> Definition of ∃ </title>
## <suggest> right('Equivalence', '∃') </suggest>
thm (alex () ()
  (<-> (A. x ph) (-. (E. x (-. ph))))
  ph notnot x albii
  x (-. ph) df-ex con2bii bitri
)


## <table>
##   (->       [ ph ]        [ ps ] )
##   (-> (A. x [ ph ]) (A. x [ ps ] ))
## </table>
thm (19.20i ()
  (hyp (-> ph ps))
  (-> (A. x ph) (A. x ps))
  x ph ps ax-alim hyp mpg
)

thm (19.21 ((ph x))
  ()
  (<-> (A. x (-> ph ps)) (-> ph (A. x ps)))

  x ph ps ax-alim ph x alnfi syl5
    (-> ph (A. x ps)) x alnfi
      x ps ax-4
      ph imim2i
      x 19.20i
    syl
  impbii
)

thm (19.21ai ((ph x))
  (hyp (-> ph ps))
  (-> ph (A. x ps))
  ph x alnfi hyp x 19.20i syl
)

thm (albi2d ((ph x)) (hyp (-> ph (<-> ps ch))) (-> ph (<-> (A. x ps) (A. x ch)))
  ph x alnfi
  hyp
  x 19.20i  
  syl
  
  ## <d 'Distribute ∀ '>
    x ps ch 19.15
    syl
  ## </d 'Distribute ∀ '>
)

thm (19.5 () ()
  (<-> (A. x (A. y ph)) (A. y (A. x ph)))
  x (A. y ph) ax-4 y ph ax-4 syl x 19.21ai y 19.21ai
    y (A. x ph) ax-4 x ph ax-4 syl y 19.21ai x 19.21ai
  impbii
)

thm (19.22 () ()
  (-> (A. x (-> ph ps)) (-> (E. x ph) (E. x ps)))

  ph ps con34b x albii
    x (-. ps) (-. ph) ax-alim sylbi con3d
    x ph df-ex x ps df-ex imbi12i sylibr
)

## <table>
##   (->       [ ph ]        [ ps ] )
##   (-> (E. x [ ph ]) (E. x [ ps ] ))
## </table>
thm (19.22i ()
  (hyp (-> ph ps))
  (-> (E. x ph) (E. x ps))
  x ph ps 19.22 hyp mpg
)

thm (19.22d ((ph x))
  (hyp (-> ph (-> ps ch)))
  (-> ph (-> (E. x ps) (E. x ch)))
  hyp x 19.21ai x ps ch 19.22 syl
)

thm (19.18 () ()
  (-> (A. x (<-> ph ps)) (<-> (E. x ph) (E. x ps)))
  ph ps bi1 x 19.20i x ph ps 19.22 syl
    ph ps bi2 x 19.20i x ps ph 19.22 syl
  impbid
)

## <title> Equivalence over Quantification </title>
## <table>
##   (<->       [ ph ]         [ ps ] )
##   (<-> (E. x [ ph ] ) (E. x [ ps ] ))
## </table>
thm (exbii ()
  (hyp (<-> ph ps))
  (<-> (E. x ph) (E. x ps))
  x ph ps 19.18 hyp mpg
)

## <title> Equivalence over Quantification </title>
## <table>
##   (E. x       [ ph ] ]    ] )
##          (<-> [ ph ] [ ps ] )
##   (E. x       [    [ [ ps ] )
## </table>
thm (exbiii ()
  (hyp1 (E. x ph)
   hyp2 (<-> ph ps))
  (E. x ps)
  hyp1 hyp2 x exbii mpbi
)

thm (exbid ((ph x))
  (hyp (-> ph (<-> ps ch)))
  (-> ph (<-> (E. x ps) (E. x ch)))
  hyp x 19.21ai x ps ch 19.18 syl
)

## <title> Distributive Property </title>
## <suggest> right('Distribute', 'R') left('Distribute', '-R') </suggest>
thm (19.26 () ()
  (<-> (A. x (/\ ph ps)) (/\ (A. x ph) (A. x ps)))
  ph ps pm3.26 x 19.20i
    ph ps pm3.27 x 19.20i
  jca
    ph ps pm3.2 x 19.20i x ps  (/\ ph ps) ax-alim syl
    imp
  impbii
)

# 19.26 with reversed
thm (alan12 () () (-> (/\ (A. x ph) (A. x ps)) (A. x (/\ ph ps)))
  x ph ps 19.26 biimpri
)

## <title> Combine Universial and Existence Quantifiers </title>
## <suggest> right('Simplify', '∃') </suggest>
thm (19.29 () ()
  (-> (/\ (A. x ph) (E. x ps)) (E. x (/\ ph ps)))
  x ph (-. ps) ax-alim
    x ps alnex
  syl6ib
  con3i
    (A. x ph) (E. x ps) df-an
      x (-> ph (-. ps)) alex con2bii
  3imtr4i
    ph ps df-an x exbii
  sylibr
)

## <title> Combine Universial and Existence Quantifiers </title>
## <suggest> right('Simplify', '∃') </suggest>
thm (19.29r () ()
  (-> (/\ (E. x ph) (A. x ps)) (E. x (/\ ph ps)))
  x ps ph 19.29 ancoms ps ph ancom x exbii sylib
)

thm (19.32 ((ph x))
  ()
  (<-> (A. x (\/ ph ps)) (\/ ph (A. x ps)))

  x (-. ph) ps 19.21
    ph ps df-or x albii
      ph (A. x ps) df-or
  3bitr4i
)

thm (19.31 ((ps x))
  ()
  (<-> (A. x (\/ ph ps)) (\/ (A. x ph) ps))

  x ps ph 19.32
  ph ps orcom x albii
  (A. x ph) ps orcom
  3bitr4i
)

thm (19.23 ((ps x))
  ()
  (<-> (A. x (-> ph ps)) (-> (E. x ph) ps))

  ph ps imor x albii
  x (-. ph) ps 19.31 bitri
  x ph alnex ps orbi1i bitri
  (E. x ph) ps imor bitr4i
)

## <title> Add existence quantifier </title>
## <table>
##   (->       [ ph  ] ps)
##   (-> (E. x [ ph) ] ps)
## </table>
thm (19.23ai ((ps x))
  (hyp (-> ph ps))
  (-> (E. x ph) ps)
  hyp x 19.22i
  x ps 19.9 sylib
)

thm (19.41 ((ps x)) ()
  (<-> (E. x (/\ ph ps)) (/\ (E. x ph) ps))
  x (/\ ph ps) df-ex
    x (-. ph) (-. ps) 19.31
      ph ps ianor x albii
        (E. x ph) ps ianor x ph alnex (-. ps) orbi1i bitr4i
    3bitr4i con2bii
  bitr4i
)

thm (19.41l ((ph x)) ()
  (<-> (E. x (/\ ph ps)) (/\ ph (E. x ps)))
  ph  ps  ancom    x  exbii
  x  ps  ph  19.41    bitri
  (E. x ps)  ph  ancom    bitri
)

thm (19.41r ((ph x)) ()
  (<-> (E. x (/\ ph ps)) (/\ ph (E. x ps)))
  ph  ps  ancom    x  exbii
  x  ps  ph  19.41    bitri
  (E. x ps)  ph  ancom    bitri
)

thm (albiim () ()
  (<-> (A. x (<-> ph ps)) (/\ (A. x (-> ph ps)) (A. x (-> ps ph))))
  ph ps dfbi2 x albii
  x (-> ph ps) (-> ps ph) 19.26 bitri
)

# 19.28
thm (alan1 ((ph x)) () (<-> (A. x (/\ ph ps)) (/\ ph (A. x ps)))
  x ph ps 19.26
    x ph 19.3 (A. x ps) anbi1i
  bitri
)

# 19.27
thm (alan2 ((ps x)) () (<-> (A. x (/\ ph ps)) (/\ (A. x ph) ps))
  ph  ps  ancom     x  albii    x  ps  ph  alan1  bitri
  ps  (A. x ph)  ancom    bitri
)

thm (exor2 ((ps x)) () (<-> (E. x (\/ ph ps)) (\/ (E. x ph) ps))
x  (\/ ph ps)  df-ex
  ph  ps  ioran    x  albii  notbii
    x (-. ph)  (-. ps)  alan2  notbii
  bitri
  (A. x (-. ph))  ps  pm4.53    bitri
bitri
x  ph  df-ex    ps  orbi1i  bitr4i
)

thm (aaan ((ph y) (ps x)) ()
  (<-> (A. x (A. y (/\ ph ps))) (/\ (A. x ph) (A. y ps)))
  y ph ps alan1 x albii
  x ph (A. y ps) alan2 bitri
)

thm (ex6 () () (-> (E. x ph) (A. x (E. x ph)))
     x ph df-ex
       x (-. ph) ax-6
     sylbi
       x ph df-ex x albii
     sylibr)

thm (axex () () (<-> (A. x (E. x ph)) (E. x ph))
     x (E. x ph) ax-4
     x ph ex6
     impbii)

thm (exax1 () () (-> (E. x (A. x ph)) (A. x ph))
     x (A. x ph) df-ex
       x ph ax-6 con1i
     sylbi)

thm (exax () () (<-> (E. x (A. x ph)) (A. x ph))
     x ph exax1
     (A. x ph) x 19.8a
     impbii)

thm (exax1d () (1 (-> ph (E. x (A. x ps)))) (-> ph (A. x ps))
     1 x ps exax1 syl)

thm (eximp1 () () (-> (E. x (-> ph ps)) (-> (A. x ph) (E. x ps)))
     ph ps pm2.27 x 19.20i
       x (-> ph ps) ps 19.22
     syl com12)

thm (eximp1d () (1 (-> ph (E. x (-> ps ch)))) (-> ph (-> (A. x ps) (E. x ch)))
     1 x ps ch eximp1 syl)

thm (mpexax () () (-> (E. x ph) (-> (A. x (-> ph ps)) (E. x ps)))
     ph ps pm2.27 x 19.22i eximp1d
     )

thm (mpexaxp () () (-> (E. x ph) (-> (A. x (-> ph ps)) (E. x (/\ ph ps))))
     x ph (/\ ph ps) mpexax
       ph ps ancl x 19.20i
     syl5
     )

## <title> Commutativity of existential operators </title>
thm (excom () () (<-> (E. x (E. y ph)) (E. y (E. x ph)))
  y  ph  df-ex  x  exbii
  x  (-. (A. y (-. ph)))  df-ex  bitri
  (A. y (-. ph)) notnot  x  albii  notbii  bitr4i
  x  y  (-. ph)  ax-7  y  x  (-. ph)  ax-7  impbii  notbii  bitri

    x  ph  df-ex  y  exbii
    y  (-. (A. x (-. ph)))  df-ex  bitri
    (A. x (-. ph)) notnot  y  albii  notbii  bitr4i
  bitr4i
)

# A variant of 19.37
thm (imex ((ph x)) () (<-> (-> ph (E. x ps)) (E. x (-> ph ps)))
   ph  (E. x ps)  imor    (-. ph) (E. x ps) orcom  bitri

   x  ps  (-. ph)  exor2   bitr4i
  ph  ps   imor  (-. ph)  ps  orcom  bitri x  exbii  bitr4i
)

# == Predicate calculus with equality ==

## <title> There is a number equal to any expression </title>
thm (tyex ((A x)) ()
  (E. x (= x A))
  x A ax-tyex
  x (= x A) df-ex mpbir
)

## <title> A number exists that proves the antecedent </title>
## <table>
##   (-> <r> (= x A) [ ph)
##                   [ ph
## </table>
thm (vtocle ((A x) (ph x))
  (hyp (-> (= x A) ph))
  ph

  x A tyex
  ## <d 'Given'>
    hyp
  ## </d>
  x 19.23ai ax-mp
)

## <title> Reflexive Property </title>
thm (eqid () () (= A A)
  ## <d>
    x A A ax-eqtr
  ## </d>
  anidms
  vtocle
)

## <title> Commute Conjunction </title>
## <table>
##   (/\ <r> ph <g> ps)
##   (/\ <g> ps <r> ph)
## </table>
thm (ancomi () (hyp (/\ ph ps)) (/\ ps ph)
  hyp
  ph ps ancom
  mpbi
)

## <title> Commute Disjunction </title>
## <table>
##   (\/ <r> ph <g> ps)
##   (\/ <g> ps <r> ph)
## </table>
thm (orcomi () (hyp (\/ ph ps)) (\/ ps ph)
  hyp
  ph ps orcom
  mpbi
)

## <title> Definition of True </title>
## <summary>
##   It is odd that the definition of true uses the number 0 and therefore depends
##   on the peano axioms. (ph -> ph) <-> T seems like a better definition, but I
##   have not been able to get this to work. I think the problem is that while Ghilbert
##   numbers that are binding variables, it has not wffs that are binding variables.
## </summary>
defthm (df-tru wff (T) () () (<-> (T) (= (0) (0)))
        (= (0) (0)) biid)

## <title> Definition of False </title>
## <suggest> auto-left('Simplify', 'F') </suggest>
defthm (df-fal wff (F) () () (<-> (F) (-. (T)))
        (-. (T)) biid)

## <title> T is true </title>
thm (tru () () (T)
  (0) eqid
  df-tru
  mpbir
)

## <title> F is false </title>
thm (notfal () () (-. (F))
  tru
  notnoti
  df-fal
  mtbir
)

## <title> Modus Ponens </title>
## <summary> ax-mp with the order of the first and second hypotheses reversed. </summary>
## <table>
##  (-> ph ] [ ps)
##      ph ] ]
##         [ [ ps
## </table>
thm (ax-mpRemove () (hyp (-> ph ps) hyp2 ph ) ps
  hyp2  hyp  ax-mp
)

## <title> Remove Implies </title>
## <table>
##            [ ph ]
##   (<-> (-> [ ph ] ps) ps)
## </table>
thm (impRemove1 () (hyp ph) (<-> (-> ph ps) ps)
  hyp
  ps a1bi
  bicomi
)

## <title> Remove Implies </title>
## <table>
##               [ ph ]
##   (<-> (-> ps [ ph ] ) (T))
## </table>
thm (impRemove2 () (hyp ph) (<-> (-> ps ph) (T))
  tru
  (-> ps ph) a1i
  hyp ps a1i
  (T) a1i
  impbii
)

## <title> Remove Implies </title>
## <table>
##            [ (-. [ ph ] )
##   (<-> (-> [     [ ph ] ps) (T))
## </table>
thm (impNotRemove1 () (hyp (-. ph)) (<-> (-> ph ps) (T))
  tru
  (-> ph ps) a1i
  hyp
  (T) a1i
  ps pm2.21d
  impbii
)

## <title> Remove Equivalence </title>
## <table>
##               [ (-. [ ph ] )
##   (<-> (-> ps [     [ ph ] ) (-. ps))
## </table>
thm (impNotRemove2 () (hyp (-. ph)) (<-> (-> ps ph) (-. ps))
  hyp
  (-> ps ph) id
  mtoi
  ps ph pm2.21
  impbii
)

## <title> Remove Equivalence </title>
## <table>
##             [ ph ]
##   (<-> (<-> [ ph ] ps) ps)
## </table>
thm (biRemove1 () (hyp ph) (<-> (<-> ph ps) ps)
  hyp
  (<-> ph ps) id
  mpbii
  ps id
  ph a1d

  hyp
  ps a1i
  ps a1i

  impbid
  impbii
)

## <title> Remove Equivalence </title>
## <table>
##                [ ph ]
##   (<-> (<-> ps [ ph ] ) ps)
## </table>
thm (biRemove2 () (hyp ph) (<-> (<-> ps ph) ps)
  hyp
  ps biRemove1
  ph ps bicom
  bitr3icom
)


## <title> Remove Equivalence </title>
## <table>
##                [ (-. [ ph ] )
##   (<-> (<-> ps [     [ ph ] ) (-. ps))
## </table>
thm (biNotRemove2 () (hyp (-. ph)) (<-> (<-> ps ph) (-. ps))
  hyp
  (<-> ps ph) id
  biimpd
  mtoi
  ps ph pm2.21

  hyp
  ps pm2.21i
  (-. ps) a1i
  impbid
  impbii
)

## <title> Remove Equivalence </title>
## <table>
##             [ (-. [ ph ] )
##   (<-> (<-> [     [ ph ] ps) ps)
## </table>
thm (biNotRemove1 () (hyp (-. ph)) (<-> (<-> ph ps) (-. ps))
  hyp ps biNotRemove2
  ps ph bicom
  bitr3icom
)

## <title> Remove AND </title>
## <table>
##            [ ph ]
##   (<-> (/\ [ ph ] ps) ps)
## </table>
thm (anRemove1 () (hyp ph) (<-> (/\ ph ps) ps)
  ps id
  ph adantl
  hyp
  ps a1i
  ancri
  impbii
)


## <title> Remove AND </title>
## <table>
##               [ ph ]
##   (<-> (/\ ps [ ph ] ) ps)
## </table>
thm (anRemove2 () (hyp ph) (<-> (/\ ps ph) ps)
 ps id
 ph adantr
 hyp
 ps a1i
 ancli
 impbii
)

## <title> Remove AND </title>
## <table>
##            [ (-. [ ph ] )
##   (<-> (/\ [     [ ph ] ps) (F))
## </table>
thm (anNotRemove1 () (hyp (-. ph)) (<-> (/\ ph ps) (F))
  ph ps imnan
  con2bii
  hyp
  (-. ps) impNotRemove1
  con4biir
  bitri
  df-fal
  bicomi
  bitri
)

## <title> Remove AND </title>
## <table>
##               [ (-. [ ph ] )
##   (<-> (/\ ps [     [ ph ] ) (F))
## </table>
thm (anNotRemove2 () (hyp (-. ph)) (<-> (/\ ps ph) (F))
  hyp
  ps anNotRemove1
  ph ps ancom
  bitr3icom
)

## <title> Remove OR </title>
## <table>
##            [ ph ]
##   (<-> (\/ [ ph ] ps) (T))
## </table>
thm (orRemove1 () (hyp ph) (<-> (\/ ph ps) (T))
  tru
  (\/ ph ps) a1i
  hyp
  ps orci
  (T) a1i
  impbii
)

## <title> Remove OR </title>
## <table>
##               [ ph ]
##   (<-> (\/ ps [ ph ] ) (T))
## </table>
thm (orRemove2 () (hyp ph) (<-> (\/ ps ph) (T))
  tru
  (\/ ps ph) a1i
  hyp
  ps olci
  (T) a1i
  impbii
)


## <title> Remove OR </title>
## <table>
##            [ (-. [ ph ] )
##   (<-> (\/ [     [ ph ] ps) ps)
## </table>
thm (orNotRemove1 () (hyp (-. ph)) (<-> (\/ ph ps) ps)
  (-. ph) ps imor
  bicomi

  ph notnot
  ps orbi1i
  bicomi
  bitr3icom

  hyp ps impRemove1
  bitri
)

## <title> Remove OR </title>
## <table>
##               [ (-. [ ph ] )
##   (<-> (\/ ps [     [ ph ] ) ps)
## </table>
thm (orNotRemove2 () (hyp (-. ph)) (<-> (\/ ps ph) ps)
  hyp
  ps orNotRemove1
  ph ps orcom
  bitr3icom
)

## <title> Remove For All </title>
## <table>
##              [ ph ]
##   (<-> (A. x [ ph ] ) (T))
## </table>
thm (alRemove2 () (hyp ph) (<-> (A. x ph) (T))
  tru
  (A. x ph) a1i
  hyp
  x gen
  (T) a1i
  pm3.2i  
  (A. x ph) (T) dfbi2
  ## <d 'Commutative Property'>
    (<-> (A. x ph) (T)) (/\ (-> (A. x ph) (T)) (-> (T) (A. x ph))) bicom
    mpbi
  ## </d 'Commutative Property'>
  mpbi
)

## <title> Remove For All </title>
## <table>
##              [ (-. [ ph ] )
##   (<-> (A. x [     [ ph ] ) (F))
## </table>
thm (alNotRemove2() (hyp (-. ph)) (<-> (A. x ph) (F))
  notfal
  (-. (A. x ph)) a1i

  x ph ax-4  
  (A. x ph) ph con34b
  mpbi
  hyp
  ax-mpRemove
  (-. (F)) a1i
  pm3.2i  
  
  (-. (A. x ph)) (-. (F)) dfbi2
  ## <d 'Commutative Property'>
    (<-> (-. (A. x ph)) (-. (F))) (/\ (-> (-. (A. x ph)) (-. (F))) (-> (-. (F)) (-. (A. x ph)))) bicom
    mpbi
  ## </d 'Commutative Property'>
  mpbi
  
  (A. x ph) (F) notbi
  ## <d 'Commutative Property'>
    (<-> (A. x ph) (F)) (<-> (-. (A. x ph)) (-. (F))) bicom
    mpbi
  ## </d 'Commutative Property'>
  mpbi
)

## <title> Remove There Exists </title>
## <table>
##              [ ph ]
##   (<-> (E. x [ ph ] ) (T))
## </table>
thm (exRemove2 () (hyp ph) (<-> (E. x ph) (T))
  tru
  (E. x ph) a1i
  hyp
  x gen
  x ph 19.2
  ax-mp
  (T) a1i
  pm3.2i
  
  (E. x ph) (T) dfbi2
  ## <d 'Commutative Property'>
    (<-> (E. x ph) (T)) (/\ (-> (E. x ph) (T)) (-> (T) (E. x ph))) bicom
    mpbi
  ## </d 'Commutative Property'>
  mpbi
)

## <title> Remove There Exists </title>
## <table>
##              [ (-. [ ph ] )
##   (<-> (E. x [     [ ph ] ) (F))
## </table>
thm (exNotRemove2() (hyp (-. ph)) (<-> (E. x ph) (F))
  notfal (-. (E. x ph)) a1i
  x ph df-ex
  hyp x gen
  notnoti
  (E. x ph) biNotRemove2
  mpbi
  (-. (F)) a1i
  pm3.2i
  
  (-. (E. x ph)) (-. (F)) dfbi2
  ## <d 'Commutative Property'>
    (<-> (-. (E. x ph)) (-. (F))) (/\ (-> (-. (E. x ph)) (-. (F))) (-> (-. (F)) (-. (E. x ph)))) bicom
    mpbi
  ## </d 'Commutative Property'>
  mpbi
  
  (E. x ph) (F) notbi
  ## <d 'Commutative Property'>
    (<-> (E. x ph) (F)) (<-> (-. (E. x ph)) (-. (F))) bicom
    mpbi
  ## </d 'Commutative Property'>
  mpbi
)

thm (impRemoveT1 () () (<-> (-> (T) ps) ps)       tru    ps impRemove1 )
thm (impRemoveT2 () () (<-> (-> ps (T)) (T))      tru    ps impRemove2 )
thm (impRemoveF1 () () (<-> (-> (F) ps) (T))      notfal ps impNotRemove1 )
thm (impRemoveF2 () () (<-> (-> ps (F)) (-. ps))  notfal ps impNotRemove2 )

thm (biRemoveT1 () () (<-> (<-> (T) ps) ps)       tru    ps biRemove1 )
thm (biRemoveT2 () () (<-> (<-> ps (T)) ps)       tru    ps biRemove2 )
thm (biRemoveF1 () () (<-> (<-> (F) ps) (-. ps))  notfal ps biNotRemove1 )
thm (biRemoveF2 () () (<-> (<-> ps (F)) (-. ps))  notfal ps biNotRemove2 )

thm (anRemoveT1 () () (<-> (/\ (T) ps) ps)   tru    ps anRemove1 )
thm (anRemoveT2 () () (<-> (/\ ps (T)) ps)   tru    ps anRemove2 )
thm (anRemoveF1 () () (<-> (/\ (F) ps) (F))  notfal ps anNotRemove1 )
thm (anRemoveF2 () () (<-> (/\ ps (F)) (F))  notfal ps anNotRemove2 )

thm (orRemoveT1 () () (<-> (\/ (T) ps) (T))   tru    ps orRemove1 )
thm (orRemoveT2 () () (<-> (\/ ps (T)) (T))   tru    ps orRemove2 )
thm (orRemoveF1 () () (<-> (\/ (F) ps) ps)    notfal ps orNotRemove1 )
thm (orRemoveF2 () () (<-> (\/ ps (F)) ps)    notfal ps orNotRemove2 )

## <title> Substitution </title>
## <table>
##   (<-> ph (-. (-> ps  [ ch ]   ]    ] )))
##   (<->                [ ch ]   [ th ] )
##   (<-> ph (-. (-> ps  [    [   [ th ] )))
## </table>
thm (BiReplaceBi1Not0Imp1 () (
     replacee (<-> ph (-. (-> ps ch)))
     substitution (<-> ch th)) 
     (<-> ph (-. (-> ps th)))
  replacee
  substitution
ps imbi2i
con4biir
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (->  [ ps ]   ]    ]  th))
##   (<->         [ ps ]   [ ch ] )
##   (<-> ph (->  [    [   [ ch ]  th))
## </table>
thm (BiReplaceBi1Imp0 () (
     replacee (<-> ph (-> ps th))
     substitution (<-> ps ch)) 
     (<-> ph (-> ch th))
  replacee substitution
  th imbi1i
  bitri
)

# mto with the order of the first and second hypotheses reversed.
## <title> Modus Tollens </title>
## <table>
##  (->     [ ph ]   [     [ ps)
##          [    [   [ (-. [ ps)
##      (-. [ ph ] ) ]     ]
## </table>
thm (mtoRemove () (hyp (-> ph ps) hyp2 (-. ps)) (-. ph)
  hyp2  hyp  mto
)

# mpbi with the order of the first and second hypotheses reversed.
## <title> Modus Ponens </title>
## <table>
## (<-> ph ] [ ps ] )
##      ph ] ]    ]
##         [ [ ps ]
## </table>
thm (mpbiRemove () (hyp (<-> ph ps) hyp2 ph ) ps
  hyp2  hyp  mpbi
)

# mpbir with the order of the first and second hypotheses reversed.
## <title> Modus Ponens </title>
## <table>
## (<-> ph ] [ ps ] )
##         [ [ ps ]
##      ph ] ]    ]
## </table>
thm (mpbirRemove () (hyp (<-> ph ps) hyp2 ps ) ph
  hyp2  hyp  mpbir
)

# mtbi with the order of the first and second hypotheses reversed.
## <title> Modus Tollens </title>
## <table>
##  (<->     [ ph ]   [     [ ps)
##           [    [   [ (-. [ ps)
##       (-. [ ph ] ) ]     ]
## </table>
thm (mtbiRemove () (hyp (<-> ph ps) hyp2 (-. ph)) (-. ps)
  hyp2  hyp  mtbi
)

# mtbir with the order of the first and second hypotheses reversed.
## <title> Modus Tollens </title>
## <table>
##   (<->    [ ph  ] [     [ ps)
##           [     [ [ (-. [ ps)
##       (-. [ ph) ] ]     ]
## </table>
thm (mtbirRemove () (hyp (<-> ph ps) hyp2 (-. ps)) (-. ph)
  hyp2  hyp  mtbir
)


thm (biTrue () (hyp ps) (<-> ps (T))
  tru
  hyp
  (T) biRemove1
  
  ## <d 'Commutative Property '>
    (<-> ps (T)) (T) bicom
    mpbi
  ## </d 'Commutative Property '>
  mpbi
)

thm (biFalse () (hyp (-. ph)) (<-> ph (F))
  hyp
  biTrue
  notbii
  df-fal bicomi  
  bitri  
  ## <d 'Double Negative '>
    ph notnotr
    bitr3icom
  ## </d 'Double Negative '>
)

## <title> Truth Table </title>
thm (notT () () (<-> (-. (T)) (F))
  df-fal
  bicomi
)

## <title> Truth Table </title>
thm (notF () () (<-> (-. (F)) (T))
  df-fal  
  ## <d 'Negate Both Sides '>
    (F) (-. (T)) notbi
    mpbi
  ## </d 'Negate Both Sides '>
  ## <d 'Remove Double Negative'>
    (T) notnotr
    bitri
  ## </d 'Remove Double Negative'>
)

## <title> Truth Table </title>
thm (imTT () () (<-> (-> (T) (T)) (T))
  tru
  (T) (T) ax-1
  ax-mp
  biTrue
)

## <title> Truth Table </title>
thm (imFT () () (<-> (-> (F) (T)) (T))
  tru
  (T) (F) ax-1
  ax-mp
  biTrue
)

## <title> Truth Table </title>
thm (imTF () () (<-> (-> (T) (F)) (F))
  notfal
  tru
  (T) (F) mth8
  ax-mp
  ax-mp
  biFalse
)

## <title> Truth Table </title>
thm (imFF () () (<-> (-> (F) (F)) (T))
  (F) id biTrue
)

## <title> Truth Table </title>
thm (biTT () () (<-> (<-> (T) (T)) (T))
  (T) biid biTrue
)

## <title> Truth Table </title>
thm (biTF () () (<-> (<-> (T) (F)) (F))
  (T) (F) pm5.18
  notfal  
  (T) biRemove2
  con4biir
  bitri
  df-fal bicomi  
  bitri
)

## <title> Truth Table </title>
thm (biFT () () (<-> (<-> (F) (T)) (F))
  df-fal notnoti
  (F) (T) pm5.18 bicomi
  mtbi
  biFalse
)

## <title> Truth Table </title>
thm (biFF () () (<-> (<-> (F) (F)) (T))
  (F) biid biTrue
)

## <title> Truth Table </title>
thm (anTT () () (<-> (/\ (T) (T)) (T))
  (T) anidm
)

## <title> Truth Table </title>
thm (anFF () () (<-> (/\ (F) (F)) (F))
  (F) anidm
)

## <title> Truth Table </title>
thm (anTF () () (<-> (/\ (T) (F)) (F))
  (T) (F) df-an
  notfal  
  (T) impRemove2
  con4biir
  bitri
  df-fal bicomi  
  bitri
)

## <title> Truth Table </title>
thm (anFT () () (<-> (/\ (F) (T)) (F))
  (F) (T) df-an
  df-fal bicomi  
  BiReplaceBi1Not0Imp1

  notfal
  (F) impNotRemove1
  con4biir
  df-fal bicomi  
  bitri  
  bitri
)

## <title> Truth Table </title>
thm (orTT () () (<-> (\/ (T) (T)) (T))
  (T) oridm
)

## <title> Truth Table </title>
thm (orFF () () (<-> (\/ (F) (F)) (F))
  (F) oridm
)

## <title> Truth Table </title>
thm (orTF () () (<-> (\/ (T) (F)) (T))
  (T) (F) df-or
  df-fal bicomi  
  BiReplaceBi1Imp0
  (F) id  
  mpbirRemove
  biTrue
)

## <title> Truth Table </title>
thm (orFT () () (<-> (\/ (F) (T)) (T))
  (F) (T) df-or
  tru (-. (F)) a1i  
  mpbirRemove
  biTrue
)

## <title> Symmetric Property </title>
## <suggest> right('Commute', '=') </suggest>
thm (eqcom () () (<-> (= A B) (= B A))
  ## <d 'Prove conditional in one direction'>
    A eqid A B A ax-eqtr mpan2
  ## </d>
  ## <d 'Prove conditional in the opposite direction'>
    B eqid B A B ax-eqtr mpan2
  ## </d 'Prove left to right'>
  impbii
)

## <title> Symmetric Property </title>
## <table>
##   (= <r> A <g> B)
##   (= <g> B <r> A)
## </table>
thm (eqcomi ()
  (hyp (= A B))
  (= B A)
  hyp A B eqcom mpbi)

## <title> Symmetric Property </title>
## <table>
##   (-> ph (= <r> A <g> B))
##   (-> ph (= <g> B <r> A))
## </table>
thm (eqcomd ()
  (hyp (-> ph (= A B)))
  (-> ph (= B A))
  hyp A B eqcom sylib)

## <title> Symmetric Property </title>
thm (eqcoms ()
  (hyp (-> (= A B) ph))
  (-> (= B A) ph)
  B A eqcom hyp sylbi
)

## <title> Equivalence over Equality </title>
thm (eqeq1 () ()
  (-> (= A B) (<-> (= A C) (= B C)))
  A B C ax-eqtr ex
    B A C ax-eqtr ex eqcoms
  impbid
)

## <title> Equivalence over Equality </title>
thm (eqeq2 () ()
  (-> (= A B) (<-> (= C A) (= C B)))
  A B C eqeq1
    A C eqcom B C eqcom bibi12i
  sylib
)

## <title> Equivalence over Equality </title>
## <table>
##   (=      A ]    ] [    B ] )
##   (<-> (= A ] C) ] [ (= B ] C))
## </table>
thm (eqeq1i ()
  (hyp (= A B))
  (<-> (= A C) (= B C))
  hyp A B C eqeq1 ax-mp)

## <title> Equivalence over Equality </title>
## <table>
##   (-> ph (=      A ]    ] [    B ] ))
##   (-> ph (<-> (= A ] C) ] [ (= B ] C)))
## </table>
thm (eqeq1d ()
  (hyp (-> ph (= A B)))
  (-> ph (<-> (= A C) (= B C)))
  hyp A B C eqeq1 syl)
	
## <title> Equivalence over Equality </title>
## <table>
##   (=        [ A  ] [      [ B)
##   (<-> (= C [ A) ] [ (= C [ B))
## </table>
thm (eqeq2i ()
  (hyp (= A B))
  (<-> (= C A) (= C B))
  hyp A B C eqeq2 ax-mp)
	
## <title> Equivalence over Equality </title>
## <table>
##   (-> ph (=        [ A  ] [      [ B))
##   (-> ph (<-> (= C [ A) ] [ (= C [ B)))
## </table>
thm (eqeq2d ()
  (hyp (-> ph (= A B)))
  (-> ph (<-> (= C A) (= C B)))
  hyp A B C eqeq2 syl)

## <title> Equivalence over Equality </title>
thm (eqeq12i ()
  (hyp1 (= A B)
   hyp2 (= C D))
  (<-> (= A C) (= B D))
  hyp1 A B C eqeq1 ax-mp hyp2 C D B eqeq2 ax-mp bitri
)

## <title> Transtitive Property </title>
thm (eqeq12d ()
  (hyp1 (-> ph (= A B))
   hyp2 (-> ph (= C D)))
  (-> ph (<-> (= A C) (= B D)))
  hyp1 C eqeq1d
  hyp2 B eqeq2d bitrd
)

## <title> Substitution </title>
## <table>
##   (= A  [ B ]   ]   ] )
##   (=    [ B ]   [ C ] )
##   (= A  [   [   [ C ] )
## </table>
thm (EqReplaceEq1 () (
     replacee (= A B)
     substitution (= B C)) 
     (= A C)
  replacee
  substitution
A eqeq2i
mpbi
)

## <title> Transtitive Property </title>
## <table>
##   (= A [ B    ] ]  )
##   (= A [      [ [ C)
##        [ (= B ] [ C)
## </table>
thm (eqtr3 ()
  (hyp1 (= A B)
   hyp2 (= A C))
  (= B C)
  hyp1 hyp2 A B C ax-eqtr mp2an
)

## <title> Transtitive Property </title>
## <table>
##   (= A  [    B ] ] )
##         [ (= B ] [ C)
##   (= A  [      [ [ C)
## </table>
thm (eqtr ()
  (hyp1 (= A B)
   hyp2 (= B C))
  (= A C)
  hyp1 eqcomi hyp2 eqtr3
)

## <title> Transtitive Property </title>
## <table>
##   (= A    [   [ B)
##        (= [ C [ B )
##   (= A    [ C ]   )
## </table>
thm (eqtr4 ()
  (hyp1 (= A B)
   hyp2 (= C B))
  (= A C)
  hyp1 hyp2 eqcomi eqtr
)

## <title> Transtitive Property </title>
## <table>
##   (= A [      [ [ B)
##   (= A [    C ] ]  )
##        [ (= C ] [B )
## </table>
thm (eqtr5 ()
  (hyp1 (= A B)
   hyp2 (= A C))
  (= C B)
  hyp1 hyp2 A B C ax-eqtr mp2an eqcomi
)
## <title> Transtitive Property </title>
## <table>
##   (-> ph (= A  [    B ] ] ))
##   (-> ph       [ (= B ] [ C))
##   (-> ph (= A  [      [ [ C))
## </table>
thm (eqtrd ()
  (hyp1 (-> ph (= A B))
   hyp2 (-> ph (= B C)))
  (-> ph (= A C))
  hyp1 hyp2 A eqeq2d mpbid
)

## <title> Syllogism </title>
thm (syl5eq ()
  (hyp1 (-> ph (= A B))
   hyp2 (= C A))
  (-> ph (= C B))
  hyp2 ph a1i hyp1 eqtrd
)

## <title> Syllogism </title>
thm (syl5eqr ()
  (hyp1 (-> ph (= A B))
   hyp2 (= A C))
  (-> ph (= C B))
  hyp2 eqcomi ph a1i hyp1 eqtrd
)

## <title> Syllogism </title>
## <table>
##   (-> ph (= A [    B ] ]  ))
##               [ (= B ] [ C)
##   (-> ph (= A [      [ [ C))
## </table>
thm (syl6eq ()
  (hyp1 (-> ph (= A B))
   hyp2 (= B C))
  (-> ph (= A C))
  hyp1 hyp2 ph a1i eqtrd
)

## <title> Syllogism </title>
thm (syl6eqr ()
  (hyp1 (-> ph (= A B))
   hyp2 (= C B))
  (-> ph (= A C))
  hyp1 hyp2 eqcomi ph a1i eqtrd
)

## <title> Syllogism </title>
thm (sylan9eq ()
  (hyp1 (-> ph (= A B))
   hyp2 (-> ps (= B C)))
  (-> (/\ ph ps) (= A C))
  hyp1 ps adantr
    hyp2 ph adantl
  eqtrd
)

thm (3eqtr4g ()
  (hyp1 (-> ph (= A B))
   hyp2 (= C A)
   hyp3 (= D B))
  (-> ph (= C D))
  hyp1 hyp2 syl5eq hyp3 syl6eqr
)

thm (vtocl ((A x) (ps x))
  (hyp1 (-> (= x A) (<-> ph ps))
   hyp2 ph)
  ps

  hyp2 hyp1 mpbii vtocle
)

thm (ceqsal ((A x) (ps x))
  (hyp (-> (= x A) (<-> ph ps)))
  (<-> (A. x (-> (= x A) ph)) ps)

  hyp pm5.74i x albii
  x (= x A) ps 19.23 bitri
  x A tyex ps a1bi bitr4i
)

thm (ceqsex ((ps x) (A x))
  (hyp (-> (= x A) (<-> ph ps)))
  (<-> (E. x (/\ (= x A) ph)) ps)

  hyp pm5.32i x exbii
  x (= x A) ps 19.41 bitri
  x A tyex mpbiran
)

thm (substex ((ph x y) (ps y) (ch x) (A y))
  (hyp (-> (/\ ph (/\ (= y A) ps)) ch))
  (-> (/\ ph (E. x ps)) (E. y ch))

  hyp ex y 19.21ai
    y (/\ (= y A) ps) ch 19.22
  y (= y A) ps 19.41 y A tyex mpbiran syl5ibr syl
  x 19.21ai
  x ps (E. y ch) 19.23 sylib imp
)

# Version of ax-11 using E.
#thm (ex11 () () (-> (= x y) (-> (E. x (/\ (= x y) ph)) (E. y ph)))
#     x y (-. ph) ax-11
#       y ph alnex biimpri
#     syl5
#       x (-> (= x y) (-. ph)) alex biimpi
#     syl6 con4d
#       (= x y) ph df-an x exbii biimpi
#     syl5)

thm (sbaxex () () (-> (A. x (-> (= x y) ph)) (E. x (/\ (= x y) ph)))
     x y tyex
       x (= x y) ph mpexaxp
     ax-mp)

thm (sbaxexd () (1 (-> ph (A. x (-> (= x y) ps))))
        (-> ph (E. x (/\ (= x y) ps)))
     1 x y ps sbaxex syl)

thm (exlem1 ((ph x)) () (-> (E. x ph) (E. x (/\ (= x y) ph)))
     ph x alnfi
       ph (= x y) ax-1 x 19.20i
     syl x 19.22i exax1d sbaxexd)

thm (exalpha1 ((ph y) (ps x)) (1 (-> (= x y) (-> ph ps)))
     (-> (E. x ph) (E. y ps))
     1 eqcoms com12 y 19.21ai
       y x tyex
         y (= y x) ps mpexax
       ax-mp
     syl x 19.23ai)

thm (exalpha ((ph y) (ps x)) (1 (-> (= x y) (<-> ph ps)))
     (<-> (E. x ph) (E. y ps))
    1 biimpd exalpha1
    y x eqcom 1 sylbi biimprd exalpha1
    impbii)

thm (alpha1 ((ph y) (ps x)) (1 (-> (= x y) (-> ph ps)))
     (-> (A. x ph) (A. y ps))
  1 eqcoms con3d exalpha1 con3i
    x ph alex y ps alex
  3imtr4i
)

thm (alpha ((ph y) (ps x)) (1 (-> (= x y) (<-> ph ps)))
  (<-> (A. x ph) (A. y ps))
    1  biimpd alpha1
    1  eqcoms biimprd alpha1
  impbii
)

# == Substitution thms ==

thm (df-subst-just ((A z y) (ph z y)) ()
      (<-> (E. y (/\ (= y A) (E. x (/\ (= x y) ph))))
          (E. z (/\ (= z A) (E. x (/\ (= x z) ph)))))
     y z A eqeq1
       y z x eqeq2 ph anbi1d x exbid
     anbi12d exalpha
     )

defthm (df-subst wff ([/] A x ph) ((A z) (ph z)) ()
         (<-> ([/] A x ph) (E. z (/\ (= z A) (E. x (/\ (= x z) ph)))))
         y A x ph z df-subst-just)

defthm (df-rwff wff (rwff x ph) () ()
        (<-> (rwff x ph) (A. x (<-> ph ([/] x x ph))))
      (A. x (<-> ph ([/] x x ph))) biid)

## <title> Equality over substitution </title>
## <summary>
##   If A = B, then substituting A into an expression is the same as
##   substituting B.
## </summary>
thm (dfsbcq () ()
  (-> (= A B) (<-> ([/] A x ph) ([/] B x ph)))
  A B y eqeq2 (E. x (/\ (= x y) ph)) anbi1d y exbid
  A x ph y df-subst B x ph y df-subst bibi12i sylibr
)

thm (a4sbc () ()
  (-> (A. x ph) ([/] A x ph))

  x y tyex x ph (= x y) 19.29 mpan2
  ph (= x y) ancom x exbii sylib
  y 19.21ai
    y A tyex (A. x ph) a1i
  jca
  y (E. x (/\ (= x y) ph)) (= y A) 19.29 syl
  (E. x (/\ (= x y) ph)) (= y A) ancom y exbii sylib
  A x ph y df-subst sylibr
)

## <title> Substitution as Existence </title>
## <suggest> right('Equivalence', '∃') left('Equivalence', '[/]') </suggest>
thm (sbc5 ((A x)) ()
  (<-> ([/] A x ph) (E. x (/\ (= x A) ph)))

  A x ph y df-subst
    y A x eqeq2 ph anbi1d
    x exbid
    ceqsex
  bitri
)

thm (sbcco ((ph y) (A y)) ()
  (<-> ([/] A y ([/] y x ph)) ([/] A x ph))

  A y ([/] y x ph) sbc5
    y x ph sbc5
      (= y A) anbi2i y exbii
    bitri
  A x ph y df-subst bitr4i
)

## <title> Make an implicit substitution explicit </title>
thm (sbcie ((A x) (ps x))
  (hyp (-> (= x A) (<-> ph ps)))
  (<-> ([/] A x ph) ps)

  A x ph sbc5
  hyp ceqsex bitri
)

## <title> Substitution </title>
## <table>
##   (<->  [ ph ]   ]    ]  ch)
##   (->   [ ph ]   [ ps ] )
##   (<->  [    [   [ ps ]  ch)
## </table>
thm (ImpReplaceBi0 () (
     replacee (<-> ph ch)
     substitution (-> ph ps)) 
     (-> ch ps)
  replacee substitution
  ch biim1i
  ax-mp
)


## <title> Substitution </title>
## <table>
##   (<-> (/\ ph  [ ps ]   ]    ] ) th)
##   (->          [ ps ]   [ ch ] )
##   (<-> (/\ ph  [    [   [ ch ] ) th)
## </table>
thm (ImpReplaceBi0An1 () (
     replacee (<-> (/\ ph ps) th)
     substitution (-> ps ch)) 
     (-> th (/\ ph ch))
  replacee substitution
  ph anim2i
    ImpReplaceBi0
)

thm (cla4g ((A x) (ps x))
  (hyp (-> (= x A) (<-> ph ps)))
  (-> (A. x ph) ps)
  x ph A a4sbc hyp sbcie sylib
)

thm (sbcbid ((ph x))
  (hyp (-> ph (<-> ps ch)))
  (-> ph (<-> ([/] A x ps) ([/] A x ch)))

  hyp (= x y) anbi2d x exbid
  (= y A) anbi2d y exbid
    A x ps y df-subst
      A x ch y df-subst
  3bitr4g
)

thm (sbcbii ()
  (hyp (<-> ph ps))
  (<-> ([/] A x ph) ([/] A x ps))
  (0) eqid
    hyp (= (0) (0)) a1i A x sbcbid
  ax-mp
)
thm (sbceq12 () (h (rwff x ph))
  (-> (= x A) (<-> ph ([/] A x ph)))
  x A x ph dfsbcq
    h x ph df-rwff mpbi a4i
  syl5bb
)

thm (sb6rf ((ph y)) (h (rwff x ph))
  (<-> ph (A. y (-> (= y x) ([/] y x ph))))
  h x ph df-rwff mpbi a4i
    y x x ph dfsbcq
    ceqsal
  bitr4i
)

## <title> Substitution </title>
## <table>
##   (E. x  [ ph ]   ]    ] )
##   (->    [ ph ]   [ ps ] )
##   (E. x  [    [   [ ps ] )
## </table>
thm (ImpReplaceEx1 () (
     replacee (E. x ph)
     substitution (-> ph ps)) 
     (E. x ps)
  replacee
  substitution
x 19.22i
ax-mp
)

thm (sbcadd ((A z) (ph z)) () (-> ([/] (+ x A) y ph) (E. z ([/] z y ph)))
  ([/] (+ x A) y ph) z alnfi
  z (+ x A) tyex
  z (+ x A) y ph dfsbcq  
  ImpReplaceEx1
  
  ## <d 'Infer Right to Left '>
    ([/] z y ph) ([/] (+ x A) y ph) bi2
    ImpReplaceEx1
  ## </d 'Infer Right to Left '>
  z ([/] (+ x A) y ph) ([/] z y ph) eximp1  
  ax-mp  
  syl
)

thm (sbcex ((A x) (ph x)) () (-> ([/] A y ph) (E. x ([/] x y ph)))
  ([/] A y ph) x alnfi
  x A tyex
  x A y ph dfsbcq    
  ImpReplaceEx1
  ## <d 'Infer Right to Left '>
    ([/] x y ph) ([/] A y ph) bi2
    ImpReplaceEx1
  ## </d 'Infer Right to Left '>
  x ([/] A y ph) ([/] x y ph) eximp1      
  ax-mp  
  syl
)

thm (rwffi ((ps x) (ph y))
  (hyp (-> (= x y) (<-> ph ps)))
  (rwff x ph)
  hyp sbcie x y sbcbii
  hyp x y eqcom ph ps bicom imbi12i mpbi sbcie bitri

  x y x ph sbcco
  bitr3i x gen
  x ph df-rwff mpbir
)

thm (rwffbii () (hyp (<-> ph ps)) (<-> (rwff x ph) (rwff x ps))
  hyp
  hyp
  x x sbcbii
  bibi12i
  x albii

  x ph df-rwff  

  
  ## <d 'Commutative Property '>
    (rwff x ph) (A. x (<-> ph ([/] x x ph))) bicom
    mpbi
  ## </d 'Commutative Property '>
  
  bitr3icom
  x ps df-rwff    
  ## <d 'Commutative Property '>
    (rwff x ps) (A. x (<-> ps ([/] x x ps))) bicom
    mpbi
  ## </d 'Commutative Property '>
  
  bitri
)

thm (sbcid () (hyp (rwff x ph)) (<-> ph ([/] x x ph))
  hyp
  x ph df-rwff
  mpbi
  a4i
)

## <title> Substitution </title>
## <table>
##   (<-> ph (<->  [ ps ]   ]    ]  th))
##   (<->          [ ps ]   [ ch ] )
##   (<-> ph (<->  [    [   [ ch ]  th))
## </table>
thm (BiReplaceBi1Bi0 () (
     replacee (<-> ph (<-> ps th))
     substitution (<-> ps ch)) 
     (<-> ph (<-> ch th))
  replacee substitution
  th bibi1i
  bitri
)

thm (not-rwff.1 () (hyp (rwff x (-. ph)))  (rwff x ph)
  hyp
  y sbceq12      
  ## <d 'Negate Both Sides '>
    (-. ph) ([/] y x (-. ph)) notbi
    ph notnotr
    BiReplaceBi1Bi0
    sylib
  ## </d 'Negate Both Sides '>
  rwffi
)

## <title> Substitution </title>
## <table>
##   (rwff x  [ ph ]   ]    ] )
##   (<->     [ ph ]   [ ps ] )
##   (rwff x  [    [   [ ps ] )
## </table>
thm (BiReplaceRwff1 () (
     replacee (rwff x ph)
     substitution (<-> ph ps)) 
     (rwff x ps)
  replacee substitution
  x rwffbii
  mpbi
)


thm (not-rwff () (hyp (rwff x ph)) (rwff x (-. ph))
  hyp
  ph notnot
  BiReplaceRwff1
  not-rwff.1
)

# == Existential uniqueness ==

## <title> Definition of existential uniqueness </title>
defthm (df-eu wff (E! x ph) ((ph y)) ()
          (<-> (E! x ph) (E. y (A. x (<-> ph (= x y)))))
       z y x eqeq2 ph bibi2d x 19.21ai 19.15d exalpha)

thm (eubid ((ph x))
  (hyp (-> ph (<-> ps ch)))
  (-> ph (<-> (E! x ps) (E! x ch)))
  hyp   (= x z)  bibi1d
  x  19.21ai       19.15d     z  exbid
  x  ps  z  df-eu   syl5bb
  x  ch  z  df-eu      syl6bbr
)

thm (eubii () (h (<-> ph ps)) (<-> (E! x ph) (E! x ps))
  y eqid
    h  (= y y)  a1i   x  eubid
  ax-mp
)

thm (eualpha ((ph y) (ps x)) (h1 (-> (= x y) (<-> ph ps)))
     (<-> (E! x ph) (E! y ps))
    h1
      x  y  z  eqeq1
    bibi12d    alpha
    z  exbii
        x  ph  z  df-eu
          y  ps  z  df-eu
        bibi12i    biimpri
    ax-mp
)

## <title> Unique Existence Implies Existence </title>
## <suggest> right('Infer', '∃') </suggest>
thm (euex () () (-> (E! x ph) (E. x ph))
  x  ph  z  df-eu  biimpi

    x  z  tyex  z  gen    jctil  z  (E. x (= x z))  (A. x (<-> ph (= x z)))  19.29  syl
    x  (<-> ph (= x z))  (= x z)  19.29  ancoms  z  19.22i  syl
      ph  (= x z)  bi2    (= x z)  anim1i
  (= x z)  ph  pm3.35  ancoms  syl  x  19.22i  z  19.22i  syl
  z  (E. x ph)  19.9  sylib
)

thm (eumo0 ((ph y)) ()
  (-> (E! x ph) (E. y (A. x (-> ph (= x y)))))
  x ph y df-eu biimpi
    ph (= x y) bi1 x 19.20i y 19.22i
  syl
)

thm (sb8eu ((ph y)) (h (rwff x ph))
  (<-> (E! x ph) (E! y ([/] y x ph)))
  h x ph df-rwff mpbi a4i x eubii
  x y x ph dfsbcq eualpha bitri
)

thm (mo ((ph y)) (h (rwff x ph))
  (<-> (E. y (A. x (-> ph (= x y)))) (A. x (A. y (-> (/\ ph ([/] y x ph)) (= x y)))))
  z y x eqeq2
  ph imbi2d
  x 19.21ai 19.15d # albidv
  exalpha
    h y sbceq12 biimprd
      x y z eqeq1 biimpd
    imim12d alpha1
    ancli
      x y (-> ph (= x z)) (-> ([/] y x ph) (= y z)) aaan
    sylibr
      ph (= x z) ([/] y x ph) (= y z) prth
        y z x eqeq2 biimprd impcom
      syl6
      y 19.20i x 19.20i
    syl z 19.23ai
  sylbir

    y x (-> ([/] y x ph) (-> ph (= x y))) 19.5
    x ([/] y x ph) (-> ph (= x y)) ax-alim y 19.20i sylbir  # having a7s would shorten slightly
    y (A. x ([/] y x ph)) (A. x (-> ph (= x y))) 19.22 syl
      ([/] y x ph) x alnfi y 19.22i
    syl5com
      ph ([/] y x ph) (= x y) impexp
      ph ([/] y x ph) (= x y) bi2.04 bitri
      y albii x albii
    syl5ib
      y ([/] y x ph) alnex
        h y sbceq12 biimpd eqcoms con3d alpha1
        ph (= x y) pm2.21 x 19.20i syl
        (A. x (-> ph (= x y))) y 19.8a syl
      sylbir
      (A. x (A. y (-> (/\ ph ([/] y x ph)) (= x y)))) a1d
    pm2.61i
  impbii
)

thm (eu1 ((ph y)) (h (rwff x ph))
  (<-> (E! x ph) (E. x (/\ ph (A. y (-> ([/] y x ph) (= x y))))))
  h y sb8eu
  y ([/] y x ph) x df-eu bitri
    x y eqcom ([/] y x ph) imbi2i y albii
      h y sb6rf
    anbi12i
      ph (A. y (-> ([/] y x ph) (= x y))) ancom
        y ([/] y x ph) (= y x) albiim
    3bitr4i x exbii
  bitr4i
)

thm (eu2 ((ph y)) (h (rwff x ph))
  (<-> (E! x ph) (/\ (E. x ph) (A. x (A. y (-> (/\ ph ([/] y x ph)) (= x y))))))
  x ph euex
    x ph y eumo0
    h y mo sylib
  jca
    x ph (A. y (-> (/\ ph ([/] y x ph)) (= x y))) 19.29r
      ph ([/] y x ph) (= x y) impexp y albii
      y ph (-> ([/] y x ph) (= x y)) 19.21 bitri ph anbi2i
      ph (A. y (-> ([/] y x ph) (= x y))) abai bitr4i x exbii
    sylib
    h y eu1 sylibr
  impbii
)

thm (eu3 ((ph y)) (h (rwff x ph))
  (<-> (E! x ph) (/\ (E. x ph) (E. y (A. x (-> ph (= x y))))))
  h y eu2 h y mo (E. x ph) anbi2i bitr4i
)

## <summary> There is exactly one number equal to a given number. </summary>
thm (tyeu ((A x)) () (E! x (= x A))
  y  A  tyex
    y  A  x  eqeq2  bicomd  x  19.21ai  y  19.22i  ax-mp
    x  (= x A)  y  df-eu  mpbir
)

# Exists at most one

defthm (df-mo wff (E* x ph) () ()
  (<-> (E* x ph) (-> (E. x ph) (E! x ph)))
  (-> (E. x ph) (E! x ph)) biid
)

thm (mo2 ((ph y)) (h (rwff x ph))
  (<-> (E* x ph) (E. y (A. x (-> ph (= x y)))))
  x ph df-mo
    x ph alnex
      ph (= x y) pm2.21 x 19.20i
      (A. x (-> ph (= x y))) y 19.8a syl
    sylbir
    x ph y eumo0 ja
      h y eu3 biimpri expcom
    impbii
  bitri
)

thm (mo4 ((ph y) (ps x))  (h (-> (= x y) (<-> ph ps)))
  (<-> (E* x ph) (A. x (A. y (-> (/\ ph ps) (= x y)))))
  h rwffi y mo2 h rwffi y mo bitri  # same as mo3, but shouldn't need it as a separate thm
    h sbcie ph anbi2i (= x y) imbi1i y albii x albii
  bitri
)

thm (eu5 () (h (rwff x ph))
  (<-> (E! x ph) (/\ (E. x ph) (E* x ph)))
  h y eu3
  h y mo2 (E. x ph) anbi2i bitr4i
)

thm (eu4 ((ph y) (ps x))
  (h (-> (= x y) (<-> ph ps)))
  (<-> (E! x ph) (/\ (E. x ph) (A. x (A. y (-> (/\ ph ps) (= x y))))))
  h rwffi eu5 h mo4 (E. x ph) anbi2i bitri
)

# == Basic Peano arithmetic ==

## <title> Definition of 1 </title>
defthm (df-1 nat (1) () () (= (1) (S (0)))
        (S (0)) eqid)

## <title> Add a number to both sides of an equation </title>
## <table>
##   (-> (= <g> A <b> B) (= (+ <g> A <r> C) (+ <b> B <r> C)))
## </table>
thm (addeq1 () ()
  (-> (= A B) (= (+ A C) (+ B C)))
  C eqid A B C C addeq12 mpan2)

## <title> Add a number to both sides of an equation </title>
thm (addeq2 () ()
  (-> (= A B) (= (+ C A) (+ C B)))
  C eqid C C A B addeq12 mpan)

## <title> Equality over Addition </title>
thm (addeq12i ()
  (hyp1 (= A B)
   hyp2 (= C D))
  (= (+ A C) (+ B D))
  hyp1 hyp2 A B C D addeq12 mp2an
)

## <title> Equality over Addition </title>
thm (addeq1d ()
  (h (-> ph (= A B)))
  (-> ph (= (+ A C) (+ B C)))
  h A B C addeq1 syl
)

## <title> Equality over Addition </title>
thm (addeq2d ()
  (h (-> ph (= A B)))
  (-> ph (= (+ C A) (+ C B)))
  h A B C addeq2 syl
)

## <title> Equality over Addition </title>
thm (addeq12d ()
  (hyp1 (-> ph (= A B))
   hyp2 (-> ph (= C D)))
  (-> ph (= (+ A C) (+ B D)))
  hyp1 hyp2 jca A B C D addeq12 syl
)

## <title> Equality over Succession </title>
## <table>
##  (=    A  ] [    B)
##  (= (S A) ] [ (S B)
## </table>	
thm (pa_ax2i () (hyp (= A B)) (= (S A) (S B))
  hyp
  A B pa_ax2
  mpbi
)

## <title> Add a number to both sides </title>
## <table>
##  (=    A ]        ]    [ B ] )
##  (= (+ A ] <g> C) ] (+ [ B ] <g> C))
## </table>
thm (addeq1i ()
  (hyp (= A B))
  (= (+ A C) (+ B C))
  hyp A B C addeq1 ax-mp
)

## <title> Add a number to both sides </title>
## <table>
##  (=          [ A ]   [          [ B )
##  (= (+ <g> C [ A ] ) [ (+ <g> C [ B))
## </table>
thm (addeq2i ()
  (hyp (= A B))
  (= (+ C A) (+ C B))
  C eqid hyp C C A B addeq12 mp2an
)

## <title> Equality over Multiplication </title>
## <table>
##   (-> (= A B) (= (* A <r> C) (* B <r> C)))
## </table>
thm (muleq1 () ()
  (-> (= A B) (= (* A C) (* B C)))
  C eqid A B C C muleq12 mpan2)

## <title> Equality over Multiplication </title>
## <table>
##   (-> (= A B) (= (* <r> C A) (* <r> C B)))
## </table>
thm (muleq2 () ()
  (-> (= A B) (= (* C A) (* C B)))
  C eqid C C A B muleq12 mpan)

## <title> Equality over Multiplication </title>
thm (muleq12i ()
  (hyp1 (= A B)
   hyp2 (= C D))
  (= (* A C) (* B D))
  hyp1 hyp2 A B C D muleq12 mp2an
)

## <title> Equality over Multiplication </title>
thm (muleq1d ()
  (hyp (-> ph (= A B)))
  (-> ph (= (* A C) (* B C)))
  hyp C eqid A B C C muleq12 mpan2 syl
)

## <title> Multiply both sides by a number </title>
## <table>
##   (=    A ]       [ B ] )
##   (= (* A ] C) (* [ B ] C))
## </table>
thm (muleq1i ()
  (hyp (= A B))
  (= (* A C) (* B C))
  hyp A B C muleq1 ax-mp
)

## <title> Multiply both sides by a number </title>
## <table>
##   (=      [ A ]        [ B )
##   (= (* C [ A ] ) (* C [ B))
## </table>
thm (muleq2i () (hyp (= A B))
  (= (* C A) (* C B))
  hyp A B C muleq2 ax-mp
)

thm (muleq2d () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (* C A) (* C B)))
  hyp1
  A B C muleq2
  syl
)

thm (suceqd ()
  (hyp (-> ph (= A B)))
  (-> ph (= (S A) (S B)))
  hyp A B pa_ax2 sylib)

## <title> Proof by Induction </title>
thm (finds ((A x) (ch x) (th x) (ta x) (ph y))
  (hyp1 (-> (= x (0)) (<-> ph ps))
   hyp2 (-> (= x y) (<-> ph ch))
   hyp3 (-> (= x (S y)) (<-> ph th))
   hyp4 (-> (= x A) (<-> ph ta))
   basis ps
   induction (-> ch th))
  ta

  hyp4
    basis hyp1 mpbiri x gen
      induction
        hyp2 ceqsal
          hyp3 ceqsal
      3imtr4i y gen
    x ph y pa_ind mp2an
    a4i
  vtocl
)

## <title> Induction </title>
## <table>
##       ([/] (0) z ph) ] ]                  ]
##   (-> ([/]  y  z ph) ] [ ([/] (S y) z [ ph))
##                      [ [ ([/] A         z [ ph)
## </table>
## <summary>
##   Induction using substitution and the successor operation. Using substitution, 
##   we can simplify the 6 hypotheses of <a href="finds">finds</a> into just two
##   the basis case and the inductive step. For a similar proof, using +1 instead of
##   the successor see <a href="induction">induction</a>.
## </summary>
thm (inductionsuc ((ph y)) (basis ([/] (0) z ph) inductiveHyp (-> ([/] y z ph) ([/] (S y) z ph))) ([/] A z ph)
  x (0) z ph dfsbcq
  x y z ph dfsbcq
  x (S y) z ph dfsbcq
  x A z ph dfsbcq
  basis
  inductiveHyp
  finds
)

## <title> Additive Identity </title>
## <table> 
##   (= (+ <r> (0) A) A)
## </table>
## <suggest> auto-right('Simplify', '0') </suggest>
thm (pa_ax3r () ()
  (= (+ (0) A) A)

  x (0) (0) addeq2 (= x (0)) id eqeq12d
    x y (0) addeq2 (= x y) id eqeq12d
      x (S y) (0) addeq2 (= x (S y)) id eqeq12d
        x A (0) addeq2 (= x A) id eqeq12d
          (0) pa_ax3
            (+ (0) y) y pa_ax2
              (0) y pa_ax4 (S y) eqeq1i
            bitr4i biimpi
  finds
)

## <title> Peano Axiom 4: Addition </title>
## <suggest> left('Equivalence', 'L') </suggest>
thm (pa_ax4r () ()
  (= (+ (S A) B) (S (+ A B)))

  x (0) (S A) addeq2 x (0) A addeq2 suceqd eqeq12d
    x y (S A) addeq2 x y A addeq2 suceqd eqeq12d
      x (S y) (S A) addeq2 x (S y) A addeq2 suceqd eqeq12d
        x B (S A) addeq2 x B A addeq2 suceqd eqeq12d

          (S A) pa_ax3 A pa_ax3 (+ A (0)) A pa_ax2 mpbi eqtr4

            (+ (S A) y) (S (+ A y)) pa_ax2 biimpi
              A y pa_ax4 (+ A (S y)) (S (+ A y)) pa_ax2 mpbi
            syl6eqr
              (S A) y pa_ax4
             syl5eq

  finds
)

## <title> Substitution </title>
## <table>
##   (-> ph (=  [ A ]   ]   ]  C))
##   (=         [ A ]   [ B ] )
##   (-> ph (=  [   [   [ B ]  C))
## </table>
thm (EqReplaceImp1Eq0 () (
     replacee (-> ph (= A C))
     substitution (= A B)) 
     (-> ph (= B C))
  replacee substitution
  C eqeq1i
  sylib
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A  [ B ]   ]   ] ))
##   (=           [ B ]   [ C ] )
##   (-> ph (= A  [   [   [ C ] ))
## </table>
thm (EqReplaceImp1Eq1 () (
     replacee (-> ph (= A B))
     substitution (= B C)) 
     (-> ph (= A C))
  replacee substitution
  A eqeq2i
  sylib
)

## <title> Perform a substitution </title>
## <summary>
##   Substitute A in for y in an expression describing the
##   <a href="addcom">commutative  property of addition</a>.
## </summary>
thm (sbc-addcom ((A y) (B y)) () (<-> ([/] A y (= (+ y B) (+ B y))) (= (+ A B) (+ B A)))
  y A B addeq1
  y A B addeq2
  eqeq12d
  sbcie
)

## <title> Commutative Property of Addition </title>
## <table> (= (+ <r> A <g> B) (+ <g> B <r> A)) </table>
## <suggest> right('Commute', '+') </suggest>
thm (addcom () () (= (+ A B) (+ B A))
  ## <d>
    ## <d 'Basis Case'>
      B pa_ax3r
      ## <d 'Additive Identity'>
        ## <d 'Additive Identity'>
          B pa_ax3 eqcomi 
        ## </d 'Additive Identity'>
        eqtr
      ## </d 'Additive Identity'>
      ## <d 'Substitute x in for 0'>
        ## <d 'Substitute x in for 0'>
          (0) x B sbc-addcom
          bicomi
        ## </d 'Substitute x in for 0'>
        mpbi
      ## </d 'Substitute x in for 0'>
    ## </d 'Basis Case'>
    ## <d 'If numbers are equal, their successors are too'>
      (+ y B) (+ B y) pa_ax2 biimpi
    ## </d>
  ## </d>
  ## <d 'Apply Peano Axiom 4'>
    ## <d 'Apply Peano Axiom 4'>
      y B pa_ax4r eqcomi  
    ## </d>
    EqReplaceImp1Eq0
  ## </d>
  ## <d 'Apply Peano Axiom 4'>
    ## <d 'Apply Peano Axiom 4'>
      B y pa_ax4 eqcomi  
    ## </d>
    EqReplaceImp1Eq1
  ## </d>
  ## <d 'Induction'>
    ## <d 'Substitute y and y" with x'>
      y x B sbc-addcom bicomi  
      sylbi2

      (S y) x B sbc-addcom bicomi
      sylib
    ## </d>
    ## <d 'Induction'>
      A inductionsuc
    ## </d>
    ## <d 'Substitute A in for x'>
      A x B sbc-addcom  
      mpbi
    ## </d>
  ## </d>
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (+ B  [ C ]   ]   ] )))
##   (=                [ C ]   [ D ] )
##   (-> ph (= A (+ B  [   [   [ D ] )))
## </table>
thm (EqReplaceImp1Eq1Add1 () (
     replacee (-> ph (= A (+ B C)))
     substitution (= C D)) 
     (-> ph (= A (+ B D)))
  replacee substitution
  B addeq2i
  EqReplaceImp1Eq1
)

## <title> Substitution </title>
## <table>
##   (-> ph (= (+  [ A ]   ]   ]  C) D))
##   (=            [ A ]   [ B ] )
##   (-> ph (= (+  [   [   [ B ]  C) D))
## </table>
thm (EqReplaceImp1Eq0Add0 () (
     replacee (-> ph (= (+ A C) D))
     substitution (= A B)) 
     (-> ph (= (+ B C) D))
  replacee substitution
  C addeq1i
  EqReplaceImp1Eq0
)

## <title> Perform a substitution </title>
## <summary>
##   Substitute A in for y in an expression describing the
##   <a href="addass">associate property of addition</a>.
## </summary>
thm (sbc-addass ((A y) (B y) (C y)) () (<-> ([/] A y (= (+ (+ y B) C) (+ y (+ B C)))) (= (+ (+ A B) C) (+ A (+ B C))))
  y A B addeq1 C addeq1d
  y A (+ B C) addeq1
  eqeq12d
  sbcie
)

## <title> Associative Property </title>
## <suggest> right('Associate', 'R') left('Associate', 'L') </suggest>
thm (addass () () (= (+ (+ A B) C) (+ A (+ B C)))
  ## <d>
    ## <d 'Basis Case'>
      ## <d>
        B pa_ax3r
      ## </d>
      ## <d>
        C addeq1i
      ## </d>
      ## <d 'Additive Identity'>
        (+ B C) pa_ax3r eqcomi  
        EqReplaceEq1
      ## </d 'Additive Identity'>
      ## <d 'Substitute x in for 0'>
        ## <d 'Substitute x in for 0'>
          (0) x B C sbc-addass
          bicomi
        ## </d 'Substitute x in for 0'>
        mpbi
      ## </d 'Substitute x in for 0'>
    ## </d 'Basis Case'>
    ## <d 'If numbers are equal, their successors are too'>
      (+ (+ y B) C) (+ y (+ B C)) pa_ax2 biimpi
    ## </d 'If numbers are equal, their successors are too'>
  ## </d>
  ## <d 'Apply Peano Axiom 4 Several Times'>
    ## <d 'Peano Axiom 4'>
      ## <d 'Peano Axiom 4: Addition '>
        (+ y B) C pa_ax4r
        eqcomi
      ## </d 'Peano Axiom 4: Addition '>
      EqReplaceImp1Eq0
    ## </d 'Peano Axiom 4'>
    ## <d 'Peano Axiom 4'>
      ## <d 'Peano Axiom 4: Addition '>
        y B pa_ax4r
        eqcomi
      ## </d 'Peano Axiom 4: Addition '>
      EqReplaceImp1Eq0Add0
    ## </d 'Peano Axiom 4'>
    ## <d 'Peano Axiom 4'>
      ## <d 'Peano Axiom 4: Addition '>
        y (+ B C) pa_ax4r
        eqcomi
      ## </d 'Peano Axiom 4: Addition '>
      EqReplaceImp1Eq1
    ## </d 'Peano Axiom 4'>
  ## </d 'Apply Peano Axiom 4 Several Times'>

  ## <d 'Induction'>
    ## <d 'Substitute y and y" with x'>
      ## <d 'Substitute y with x'>
        y x B C sbc-addass bicomi  
        sylbi2
      ## </d 'Substitute y with x'>
      ## <d 'Substitute y" with x'>
        (S y) x B C sbc-addass bicomi
        sylib
      ## </d 'Substitute y" with x'>
    ## </d>
    ## <d 'Induction'>
      A inductionsuc
    ## </d>
    ## <d 'Substitute A in for x'>
      A x B C sbc-addass
      mpbi
    ## </d>
  ## </d>
)

## <title> Multiply by 0 </title>
## <suggest> auto-right('Simplify','0') </suggest>
thm (pa_ax5r () ()
  (= (* (0) A) (0))

  x (0) (0) muleq2 (0) eqeq1d
    x y (0) muleq2 (0) eqeq1d
      x (S y) (0) muleq2 (0) eqeq1d
        x A (0) muleq2 (0) eqeq1d
          (0) pa_ax5
            (0) y pa_ax6
            (* (0) y) pa_ax3 eqtr (0) eqeq1i biimpri
  finds
)

## <title> Peano Axiom 6 Reversed </title>
thm (pa_ax6r () ()
  (= (* (S A) B) (+ (* A B) B))

  x (0) (S A) muleq2 x (0) A muleq2 (= x (0)) id addeq12d eqeq12d
    x y (S A) muleq2 x y A muleq2 (= x y) id addeq12d eqeq12d
      x (S y) (S A) muleq2 x (S y) A muleq2 (= x (S y)) id addeq12d eqeq12d
        x B (S A) muleq2 x B A muleq2 (= x B) id addeq12d eqeq12d
          (S A) pa_ax5 A pa_ax5 (0) addeq1i (0) pa_ax3 eqtr eqtr4

            (* (S A) y) (+ (* A y) y) (S A) addeq1
            (S A) y pa_ax6 syl5eq
            (+ (* A y) y) A pa_ax4 syl6eq
              (* A y) y A addass y A addcom (* A y) addeq2i eqtr
              (* A y) A y addass eqtr4
              (+ (+ (* A y) y) A) (+ (+ (* A y) A) y) pa_ax2 mpbi
            syl6eq
              A y pa_ax6 (S y) addeq1i
              (+ (* A y) A) y pa_ax4 eqtr
            syl6eqr
  finds
)

## <title> Perform a substitution </title>
## <summary>
##   Substitute A in for y in an expression describing the
##   <a href="mulcom">commutative  property of multiplication</a>.
## </summary>
thm (sbc-mulcom ((A y) (B y)) () (<-> ([/] A y (= (* y B) (* B y))) (= (* A B) (* B A)))
  y A B muleq1
  y A B muleq2
  eqeq12d
  sbcie
)

## <title> Commutative Property </title>
## <table>
##   (= (* <r> A <g> B) (* <g> B <r> A))
## </table>
## <suggest> right('Commute', '*') </suggest>
thm (mulcom () () (= (* A B) (* B A))
  ## <d>
    ## <d 'Basis Case'>
      B pa_ax5r
      ## <d 'Multiply by 0'>
        B pa_ax5 eqcomi
      ## </d>
      ## <d 'Multiply by 0'>
        eqtr
      ## </d>
      ## <d 'Substitute x in for 0'>
        ## <d 'Substitute x in for 0'>
          (0) x B sbc-mulcom
          bicomi
        ## </d 'Substitute x in for 0'>
        mpbi
      ## </d 'Substitute x in for 0'>
    ## </d 'Basis Case'>
    ## <d 'Add B to both sides'>
      (* y B) (* B y) B addeq1
    ## </d>
  ## </d>
  ## <d 'Peano Axiom 6'>
    ## <d 'Peano Axiom 6'>
      y B pa_ax6r eqcomi
    ## </d>
    EqReplaceImp1Eq0
  ## </d 'Peano Axiom 6'>
  ## <d 'Peano Axiom 6'>
    ## <d 'Peano Axiom 6'>
      B y pa_ax6 eqcomi
    ## </d>
    EqReplaceImp1Eq1
  ## </d>
  ## <d 'Induction'>
    ## <d 'Substitute y and y" with x'>
      y x B sbc-mulcom bicomi
      sylbi2

      (S y) x B sbc-mulcom bicomi
      sylib
    ## </d>
    ## <d 'Induction'>
      A inductionsuc
    ## </d>
    ## <d 'Substitute A in for x'>
      A x B sbc-mulcom
      mpbi
    ## </d>
  ## </d>
)

## <title> Substitution </title>
## <table>
##   (=  [ A ]   ]   ]  C)
##   (=  [ A ]   [ B ] )
##   (=  [   [   [ B ]  C)
## </table>
thm (EqReplaceEq0 () (
     replacee (= A C)
     substitution (= A B)) 
     (= B C)
  replacee substitution
  C eqeq1i
  mpbi
)

## <title> Substitution </title>
## <table>
##   (= (* A  [ B ]   ]   ] ) D)
##   (=       [ B ]   [ C ] )
##   (= (* A  [   [   [ C ] ) D)
## </table>
thm (EqReplaceEq0Mul1 () (
     replacee (= (* A B) D)
     substitution (= B C)) 
     (= (* A C) D)
  replacee substitution
  A muleq2i
  EqReplaceEq0
)

## <title> Substitution </title>
## <table>
##   (= A (+  [ B ]   ]   ]  D))
##   (=       [ B ]   [ C ] )
##   (= A (+  [   [   [ C ]  D))
## </table>
thm (EqReplaceEq1Add0 () (
     replacee (= A (+ B D))
     substitution (= B C)) 
     (= A (+ C D))
  replacee substitution
  D addeq1i
  EqReplaceEq1
)

## <title> Multiplicative Identity </title>
## <summary>
##   One is the identity of multiplication. Proved from the
##   <a href="/peano/peano_min.ghi">peano axioms</a>. </summary>
## <suggest> right('Simplify', '1') </suggest>
## <table>
##   (= (* A <r> (1)) A)
## </table>
## <suggest> auto-right('Simplify') </suggest>
thm (mulid () () (= (* A (1)) A)
  A (0) pa_ax6
  ## <d 'Multiplication by 0' >
    A pa_ax5
    EqReplaceEq1Add0
  ## </d 'Multiplication by 0' >
  ## <d 'Additive Identity' >
    A pa_ax3r
    eqtr
  ## </d 'Additive Identity' >
  ## <d 'Definition of 1' >
    ## <d 'Definition of 1' >
      df-1 eqcomi
    ## </d>
    EqReplaceEq0Mul1
  ## </d>
)
	
## <title> Multiplicative Identity </title>
## <suggest> auto-right('Simplify', '1') </suggest>
thm (mulidr() () (= (* (1) A) A)
  A mulid
  A (1) mulcom
  eqtr5
)

thm (add23 () ()
  (= (+ (+ A B) C) (+ (+ A C) B))
  A B C addass
  B C addcom A addeq2i eqtr
  A C B addass eqtr4
)

## <title> Rearrange Addition Terms </title>
## <table>
##   (= (+ (+ A <g> B) (+ <r> C D)) (+ (+ A <r> C) (+ <g> B D)))
## </table>
thm (add4 () ()
  (= (+ (+ A B) (+ C D)) (+ (+ A C) (+ B D)))
  (+ A B) C D addass
  A B C add23 D addeq1i eqtr3
  (+ A C) B D addass eqtr
)

## <title> Perform a substitution </title>
## <summary>
##   Substitute A in for y in an expression describing the
##   <a href="distr">distributive property</a>.
## </summary>
thm (sbc-distr ((A y) (B y) (C y)) () (<-> ([/] A y (= (* y (+ B C)) (+ (* y B) (* y C)))) (= (* A (+ B C)) (+ (* A B) (* A C))))
  y A (+ B C) muleq1
  y A B muleq1
  y A C muleq1
  addeq12d
  eqeq12d
  sbcie
)

## <title> Substitution </title>
## <table>
##   (= A (+ B  [ C ]   ]   ] ))
##   (=         [ C ]   [ D ] )
##   (= A (+ B  [   [   [ D ] ))
## </table>
thm (EqReplaceEq1Add1 () (
     replacee (= A (+ B C))
     substitution (= C D)) 
     (= A (+ B D))
  replacee substitution
  B addeq2i
  EqReplaceEq1
)

## <title> Distributive Property </title>
## <summary>
##   Distribution of addition through multiplication. See <a href="distl">distl</a>
##   for distribution in the opposite direction.
## </summary>
## <table>
##   (= (* <c> A (+ B C)) (+ (* <c> A B) (* <c> A C)))
## </table>
## <suggest> right('Distribute', 'R') left('Distribute', '-R') </suggest>
thm (distr () () (= (* A (+ B C)) (+ (* A B) (* A C)))
  ## <d>
    ## <d 'Basis Case'>
      ## <d 'Multiply B+C by 0'>
        (+ B C) pa_ax5r
      ## </d 'Multiply by 0'>
      ## <d 'Multiply B and C by 0'>
        ## <d 'Multiply B and C by 0'>
          ## <d 'Multiply B and C by 0'>
            B pa_ax5r
            C pa_ax5r
            addeq12i
          ## </d>
          ## <d 'Add 0 + 0'>
            (0) pa_ax3 eqtr
          ## </d>
          eqcomi
        ## </d 'Multiply B and C by 0'>
        eqtr
      ## </d 'Multiply B and C by 0'>
      ## <d 'Substitute x in for 0'>
        ## <d 'Substitute x in for 0'>
          (0) x B C sbc-distr
          bicomi
        ## </d 'Substitute x in for 0'>
        mpbi
      ## </d 'Substitute x in for 0'>
    ## </d 'Basis Case'>
    ## <d 'Add B+C to both sides'> 
      (* y (+ B C)) (+ (* y B) (* y C)) (+ B C) addeq1
    ## </d 'Add B+C to both sides'>
  ## </d>

  ## <d 'Peano Axiom 6'>
    ## <d 'Peano Axiom 6'>
      y (+ B C) pa_ax6r eqcomi
    ## </d 'Peano Axiom 6'>
    EqReplaceImp1Eq0
  ## </d 'Peano Axiom 6'>
  ## <d 'Rearrange terms & Peano Axiom 6'>
    ## <d>
      (* y B) (* y C) B C add4
    ## </d>
    ## <d 'Peano Axiom 6'>
      ## <d 'Peano Axiom 6'>
        y B pa_ax6r eqcomi
      ## </d 'Peano Axiom 6'>
      EqReplaceEq1Add0
    ## </d 'Peano Axiom 6'>
    ## <d 'Peano Axiom 6'>
      ## <d 'Peano Axiom 6'>
        y C pa_ax6r eqcomi
      ## </d 'Peano Axiom 6'>
      EqReplaceEq1Add1
    ## </d 'Peano Axiom 6'>
    EqReplaceImp1Eq1
  ## </d>
  ## <d 'Induction'>
    ## <d 'Substitute y and y" with x'>
      y x B C sbc-distr bicomi
      sylbi2
      (S y) x B C sbc-distr bicomi
      sylib
    ## </d>
    ## <d 'Induction'>
      A inductionsuc
    ## </d>
    ## <d 'Substitute A in for x'>
      A x B C sbc-distr
      mpbi
    ## </d>
  ## </d>
)

## <title> Distributive Property </title>
## <summary>
##   Distribution of addition through multiplication. See <a href="distr">distr</a>
##   for distribution in the opposite direction.
## </summary>
## <table>
##   (= (* (+ A B) <c> C) (+ (* A <c> C) (* B <c> C)))
## </table>
## <suggest> right('Distribute', 'L') left('Distribute', '-L') </suggest>
thm (distl () () (= (* (+ A B) C) (+ (* A C) (* B C)))
   ## <d>
     C A B distr
   ## </d>
   ## <d 'Commute C∙(A + B)' >
     C (+ A B) mulcom
     EqReplaceEq0
   ## </d>
   ## <d 'Commute C∙A' >
     C A mulcom
     EqReplaceEq1Add0
   ## </d>
   ## <d 'Commute C∙B' >
     C B mulcom  
     EqReplaceEq1Add1
   ## </d>
)

## <title> Distributive Property </title>
## <table>
##   (= (* (+ <m> A <b> B) (+ <c> C <g> D)) (+ (+ (* <m> A <c> C) (* <b> B <c> C)) (+ (* <m> A <g> D) (* <b> B <g> D))))
## </table>
## <summary> Distribution of addition through multiplication, both arguments </summary>
thm (distrl () () (= (* (+ A B) (+ C D)) (+ (+ (* A C) (* B C)) (+ (* A D) (* B D))))
  ## <d 'Distribute A+B'>
    (+ A B) C D distr
  ## </d>
  ## <d 'Distribute C'>
    A B C distl  
    EqReplaceEq1Add0
  ## </d>
  ## <d 'Distribute D'>
    A B D distl  
    EqReplaceEq1Add1
  ## </d>
)

## <title> Perform a substitution </title>
## <summary>
##   Substitute A in for y in an expression describing the
##   <a href="mulass">associate property of multiplication</a>.
## </summary>
thm (sbc-mulass ((A y) (B y) (C y)) () (<-> ([/] A y (= (* (* y B) C) (* y (* B C)))) (= (* (* A B) C) (* A (* B C))))
  y A B muleq1 C muleq1d
  y A (* B C) muleq1
  eqeq12d
  sbcie
)

## <title> Substitution </title>
## <table>
##   (= A (*  [ B ]   ]   ]  D))
##   (=       [ B ]   [ C ] )
##   (= A (*  [   [   [ C ]  D))
## </table>
thm (EqReplaceEq1Mul0 () (
     replacee (= A (* B D))
     substitution (= B C)) 
     (= A (* C D))
  replacee substitution
  D muleq1i
  EqReplaceEq1
)


## <title> Associative Property </title>
## <summary> Multiplication is associative </summary>
## <suggest> right('Associate', 'R') left('Associate', 'L') </suggest>
thm (mulass () () (= (* (* A B) C) (* A (* B C)))
  ## <d>
    ## <d 'Basis Case'>
      ## <d 'Multiply by 0'>
        ## <d>
          B pa_ax5r
        ## </d>
        ## <d 'Multiply both sides by C'>
          C muleq1i
        ## </d>
        ## <d 'Multiply by 0'>
          C pa_ax5r
          eqtr
        ## </d>
      ## </d 'Multiply by 0'>
      ## <d 'Multiply by 0'>
        ## <d 'Multiply by 0'>
          (* B C) pa_ax5r eqcomi
        ## </d 'Multiply by 0'>
        eqtr
      ## </d 'Multiply by 0'>
      ## <d 'Substitute x in for 0'>
        ## <d 'Substitute x in for 0'>
          (0) x B C sbc-mulass
          bicomi
        ## </d 'Substitute x in for 0'>
        mpbi
      ## </d 'Substitute x in for 0'>
    ## </d 'Basis Case'>
    ## <d 'Add B∙ C to both sides'>
      (* (* y B) C) (* y (* B C)) (* B C) addeq1
    ## </d>
  ## </d>
  ## <d 'Distribution & Peano Axiom 6'>
    ## <d 'Distribution & Peano Axiom 6'>
      ## <d 'Distributive Property'> 
        (* y B) B C distl eqcomi
      ## </d 'Distributive Property'>
      ## <d 'Peano Axiom 6'>
        y B pa_ax6r eqcomi
      ## </d 'Peano Axiom 6'>
      EqReplaceEq1Mul0
    ## </d>
    EqReplaceImp1Eq0
  ## </d>
  ## <d 'Peano Axiom 6'>
    ## <d 'Peano Axiom 6'>
      y (* B C) pa_ax6r eqcomi
    ## </d>
    EqReplaceImp1Eq1
  ## </d>
  ## <d 'Induction'>
    ## <d 'Substitute y and y" with x'>
      ## <d 'Substitute y with x'>
        y x B C sbc-mulass bicomi  
        sylbi2
      ## </d 'Substitute y with x'>
      ## <d 'Substitute y" with x'>
        (S y) x B C sbc-mulass bicomi
        sylib
      ## </d 'Substitute y" with x'>
    ## </d>
    ## <d 'Induction'>
      A inductionsuc
    ## </d>
    ## <d 'Substitute A in for x'>
      A x B C sbc-mulass
      mpbi
    ## </d>
  ## </d>
)

## <title> Cancellation of addition </title>
thm (addcan () ()
  (<-> (= (+ B A) (+ C A)) (= B C))
  x (0) B addeq2 x (0) C addeq2 eqeq12d (= B C) bibi1d
    x y B addeq2 x y C addeq2 eqeq12d (= B C) bibi1d
      x (S y) B addeq2 x (S y) C addeq2 eqeq12d (= B C) bibi1d
        x A B addeq2 x A C addeq2 eqeq12d (= B C) bibi1d

          B pa_ax3 C pa_ax3 eqeq12i

            B y pa_ax4 C y pa_ax4 eqeq12i
            (+ B y) (+ C y) pa_ax2 bitr4i (= B C) bibi1i biimpri
  finds
)

## <title> Cancellation of addition </title>
thm (addcan2 () ()
  (<-> (= (+ A B) (+ A C)) (= B C))
  A B addcom A C addcom eqeq12i
    B A C addcan bitri
)

## <title> Inequality over Addition </title>
## <table>
##   (-. (=    [ A ]   ]      [ B ] ))
##   (-. (= (+ [ A ] C ] ) (+ [ B ] C)))
## </table>
thm (addneq1i () (hyp (-. (= A B)))  (-. (= (+ A C) (+ B C)))
  A C B addcan
  hyp mtbirRemove
)

## <title> Inequality over Addition </title>
## <table>
##   (-. (=      [ A ]      [   [ B ))
##   (-. (= (+ C [ A ] ) (+ [ C [ B)))
## </table>
thm (addneq2i () (hyp (-. (= A B))) (-. (= (+ C A) (+ C B)))
  C A B addcan2
  hyp mtbirRemove
)

## <title> Substitution </title>
## <table>
##   (= A (S  [ B ]   ]   ] ))
##   (=       [ B ]   [ C ] )
##   (= A (S  [   [   [ C ] ))
## </table>
thm (EqReplaceEq1Suc0 () (
     replacee (= A (S B))
     substitution (= B C)) 
     (= A (S C))
  replacee substitution
  pa_ax2i
  EqReplaceEq1
)

## <title> Successor Adds One </title>
## <summary> Successor is equivalent to adding one </summary>
## <suggest> right('Equivalence', '+1') </suggest>
thm (a1suc () () (= (S A) (+ A (1)))
  ## <d>
    df-1
  ## </d>
  ## <d>
    A addeq2i
  ## </d>
  ## <d 'Peano Axiom 4'>
    A (0) pa_ax4 eqtr
  ## </d>
  ## <d 'Additive Identity'>
    A pa_ax3
    EqReplaceEq1Suc0
  ## </d>
  eqcomi
)

## <title> Substitution </title>
## <table>
##   (-> (= A  [ B ]   ]   ] ) ph)
##   (=        [ B ]   [ C ] )
##   (-> (= A  [   [   [ C ] ) ph)
## </table>
thm (EqReplaceImp0Eq1 () (
     replacee (-> (= A B) ph)
     substitution (= B C)) 
     (-> (= A C) ph)
  replacee
  substitution
A eqeq2i
ph imbi1i
mpbi
)

## <title> Proof by Induction </title>
## <summary>
##   Same as <a href="finds">finds</a> except uses +1 instead of successor.
## </summary>
thm (findplus1 ((A x) (ch x) (th x) (ta x) (ph y))
  (hyp1 (-> (= x (0)) (<-> ph ps))
   hyp2 (-> (= x y) (<-> ph ch))
   hyp3 (-> (= x (+ y (1))) (<-> ph th))
   hyp4 (-> (= x A) (<-> ph ta))
   basis ps
   induction (-> ch th))
  ta

  hyp1
  hyp2
  hyp3
  y a1suc  
  eqcomi
  EqReplaceImp0Eq1
  hyp4
  basis
  induction
  finds
)

## <title> Substitution </title>
## <table>
##   (-> (/\ ph  [ ps ]   ]    ] ) th)
##   (<->        [ ps ]   [ ch ] )
##   (-> (/\ ph  [    [   [ ch ] ) th)
## </table>
thm (BiReplaceImp0An1 () (
     replacee (-> (/\ ph ps) th)
     substitution (<-> ps ch)) 
     (-> (/\ ph ch) th)
  replacee
  substitution
  ph anbi2i
  th imbi1i
  mpbi
)

## <title> Proof by Induction </title>
## <table>
##       ([/] (0) z ph) ] ]                  ]
##   (-> ([/]  y  z ph) ] [ ([/] (+ y (1)) z [ ph))
##                      [ [ ([/] A         z [ ph)
## </table>
## <summary>
##   Using substitution, we simplify the 6 hypotheses of <a href="findplus1">findplus1</a>
##   into just two the basis case and the inductive step. For a similar proof, using the successor
##   instead of +1 see <a href="inductionsuc">inductionsuc</a>.
## </summary>
thm (induction ((ph y)) (basis ([/] (0) z ph) inductiveHyp (-> ([/] y z ph) ([/] (+ y (1)) z ph))) ([/] A z ph)
  x (0) z ph dfsbcq
  x y z ph dfsbcq
  x (+ y (1)) z ph dfsbcq
  x A z ph dfsbcq
  basis
  inductiveHyp
  findplus1
)

## <title> Substitution </title>
## <table>
##   (-> (/\  [ ph ]   ]    ]  ch) th)
##   (<->     [ ph ]   [ ps ] )
##   (-> (/\  [    [   [ ps ]  ch) th)
## </table>
thm (BiReplaceImp0An0 () (
     replacee (-> (/\ ph ch) th)
     substitution (<-> ph ps)) 
     (-> (/\ ps ch) th)
  replacee
  substitution
  ch anbi1i
  th imbi1i
  mpbi
)

## <title> Substitution </title>
## <table>
##   (-> (/\ ph (A. x  [ ps ]   ]    ] )) th)
##   (<->              [ ps ]   [ ch ] )
##   (-> (/\ ph (A. x  [    [   [ ch ] )) th)
## </table>
thm (BiReplaceImp0An1Al1 () (
     replacee (-> (/\ ph (A. x ps)) th)
     substitution (<-> ps ch)) 
     (-> (/\ ph (A. x ch)) th)
  replacee substitution
  x albii
  BiReplaceImp0An1
)


## <title> Substitution </title>
## <table>
##   (-> (/\ ph (A. x (->  [ ps ]   ]    ]  th))) ta)
##   (<->                  [ ps ]   [ ch ] )
##   (-> (/\ ph (A. x (->  [    [   [ ch ]  th))) ta)
## </table>
thm (BiReplaceImp0An1Al1Imp0 () (
     replacee (-> (/\ ph (A. x (-> ps th))) ta)
     substitution (<-> ps ch)) 
     (-> (/\ ph (A. x (-> ch th))) ta)
  replacee substitution
  th imbi1i
  BiReplaceImp0An1Al1
)

## <title> Substitution </title>
## <table>
##   (-> (/\ ph (A. x (-> ps  [ ch ]   ]    ] ))) ta)
##   (<->                     [ ch ]   [ th ] )
##   (-> (/\ ph (A. x (-> ps  [    [   [ th ] ))) ta)
## </table>
thm (BiReplaceImp0An1Al1Imp1 () (
     replacee (-> (/\ ph (A. x (-> ps ch))) ta)
     substitution (<-> ch th)) 
     (-> (/\ ph (A. x (-> ps th))) ta)
  replacee substitution
  ps imbi2i
  BiReplaceImp0An1Al1
)


## <title> Substitution </title>
## <table>
##   (-> (/\ ph (A. x (-> ps (A. y  [ ch ]   ]    ] )))) ta)
##   (<->                           [ ch ]   [ th ] )
##   (-> (/\ ph (A. x (-> ps (A. y  [    [   [ th ] )))) ta)
## </table>
thm (BiReplaceImp0An1Al1Imp1Al1 () (
     replacee (-> (/\ ph (A. x (-> ps (A. y ch)))) ta)
     substitution (<-> ch th)) 
     (-> (/\ ph (A. x (-> ps (A. y th)))) ta)
  replacee substitution
  y albii
  BiReplaceImp0An1Al1Imp1
)


## <title> Substitution </title>
## <table>
##   (-> (/\ ph (A. x (-> ps (A. y (->  [ ch ]   ]    ]  ta))))) et)
##   (<->                               [ ch ]   [ th ] )
##   (-> (/\ ph (A. x (-> ps (A. y (->  [    [   [ th ]  ta))))) et)
## </table>
thm (BiReplaceImp0An1Al1Imp1Al1Imp0 () (
     replacee (-> (/\ ph (A. x (-> ps (A. y (-> ch ta))))) et)
     substitution (<-> ch th)) 
     (-> (/\ ph (A. x (-> ps (A. y (-> th ta))))) et)
  replacee substitution
  ta imbi1i
  BiReplaceImp0An1Al1Imp1Al1
)


## <title> Substitution </title>
## <table>
##   (-> (/\ ph (A. x (-> ps (A. y (-> (= A  [ B ]   ]   ] ) ch))))) th)
##   (=                                      [ B ]   [ C ] )
##   (-> (/\ ph (A. x (-> ps (A. y (-> (= A  [   [   [ C ] ) ch))))) th)
## </table>
thm (EqReplaceImp0An1Al1Imp1Al1Imp0Eq1 () (
     replacee (-> (/\ ph (A. x (-> ps (A. y (-> (= A B) ch))))) th)
     substitution (= B C)) 
     (-> (/\ ph (A. x (-> ps (A. y (-> (= A C) ch))))) th)
  replacee substitution
  A eqeq2i
  BiReplaceImp0An1Al1Imp1Al1Imp0
)

## <title> Induction </title>
## <table>
##   (-> ph     ([/] (0) z ph) ] ]                  ] )
##   (-> ph (-> ([/]  y  z ph) ] [ ([/] (+ y (1)) z [ ph)))
##   (-> ph                    [ [ ([/] A         z [ ph))
## </table>
thm (inductiond ((ph y) (ps y))
  (basis (-> ps ([/] (0) z ph)) induction (-> ps (-> ([/] y z ph) ([/] (+ y (1)) z ph))))
  (-> ps ([/] A z ph))

  basis
  induction
  y 19.21ai
  jca

  x ([/] x z ph) y pa_ind
  x (0) z ph dfsbcq  ceqsal
  BiReplaceImp0An0
  x y z ph dfsbcq  ceqsal
  BiReplaceImp0An1Al1Imp0  
  ## <d 'Successor Adds One '>
    y a1suc
    EqReplaceImp0An1Al1Imp1Al1Imp0Eq1
  ## </d 'Successor Adds One '>
  x (+ y (1)) z ph dfsbcq  ceqsal

  BiReplaceImp0An1Al1Imp1  
  syl
  x A z ph dfsbcq
  cla4g
  syl
)

## <title> Substitution </title>
## <table>
##   (-> ph (A. x  [ ps ]   ]    ] ))
##   (->           [ ps ]   [ ch ] )
##   (-> ph (A. x  [    [   [ ch ] ))
## </table>
thm (ImpReplaceImp1Al1 () (
     replacee (-> ph (A. x ps))
     substitution (-> ps ch)) 
     (-> ph (A. x ch))
  replacee substitution
  x 19.20i
  syl
)

## <title> Substitution </title>
## <table>
##   (= A (* B  [ C ]   ]   ] ))
##   (=         [ C ]   [ D ] )
##   (= A (* B  [   [   [ D ] ))
## </table>
thm (EqReplaceEq1Mul1 () (
     replacee (= A (* B C))
     substitution (= C D)) 
     (= A (* B D))
  replacee
  substitution
B muleq2i
A eqeq2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph  [ ps ]   ]    ] )
##   (->      [ ps ]   [ ch ] )
##   (<-> ph  [    [   [ ch ] )
## </table>
thm (ImpReplaceBi1 () (
     replacee (<-> ph ps)
     substitution (-> ps ch)) 
     (-> ph ch)
  replacee
  substitution
  ph biim2i
  ax-mp
)

## <suggest> right('Simplify', '↔') </suggest>
thm (mpbi-inline () () (-> (/\ ph (<-> ph ps)) ps)
  ph ps pm5.36  
  ## <d>
    ps (<-> ph ps) pm3.26
    ImpReplaceBi1
  ## </d>
)

## <title> Substitution </title>
## <table>
##   (-. (= A  [ B ]   ]   ] ))
##   (=        [ B ]   [ C ] )
##   (-. (= A  [   [   [ C ] ))
## </table>
thm (EqReplaceNot0Eq1 () (
     replacee (-. (= A B))
     substitution (= B C)) 
     (-. (= A C))
  replacee
  substitution
A eqeq2i
con4biir
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (-. (E. x  [ ps ]   ]    ] )))
##   (<->               [ ps ]   [ ch ] )
##   (<-> ph (-. (E. x  [    [   [ ch ] )))
## </table>
thm (BiReplaceBi1Not0Ex1 () (
     replacee (<-> ph (-. (E. x ps)))
     substitution (<-> ps ch)) 
     (<-> ph (-. (E. x ch)))
  replacee
  substitution
x exbii
con4biir
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (-. (E. x (/\ ps  [ ch ]   ]    ] ))))
##   (<->                      [ ch ]   [ th ] )
##   (<-> ph (-. (E. x (/\ ps  [    [   [ th ] ))))
## </table>
thm (BiReplaceBi1Not0Ex1An1 () (
     replacee (<-> ph (-. (E. x (/\ ps ch))))
     substitution (<-> ch th)) 
     (<-> ph (-. (E. x (/\ ps th))))
  replacee
  substitution
ps anbi2i
x exbii
con4biir
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (E. x (/\ ph (/\  [ ps ]   ]    ]  th)))
##   (->               [ ps ]   [ ch ] )
##   (E. x (/\ ph (/\  [    [   [ ch ]  th)))
## </table>
thm (ImpReplaceEx1An1An0 () (
     replacee (E. x (/\ ph (/\ ps th)))
     substitution (-> ps ch)) 
     (E. x (/\ ph (/\ ch th)))
  replacee
  substitution
th anim1i
ph anim2i
x 19.22i
ax-mp
)

## <title> Substitution </title>
## <table>
##   (E. x (/\ ph (/\ ps  [ ch ]   ]    ] )))
##   (->                  [ ch ]   [ th ] )
##   (E. x (/\ ph (/\ ps  [    [   [ th ] )))
## </table>
thm (ImpReplaceEx1An1An1 () (
     replacee (E. x (/\ ph (/\ ps ch)))
     substitution (-> ch th)) 
     (E. x (/\ ph (/\ ps th)))
  replacee
  substitution
ps anim2i
ph anim2i
x 19.22i
ax-mp
)

## <title> Substitution </title>
## <table>
##   (E. x (/\ ph (/\ (-.  [ ps ]   ]    ] ) th)))
##   (<->                  [ ps ]   [ ch ] )
##   (E. x (/\ ph (/\ (-.  [    [   [ ch ] ) th)))
## </table>
thm (BiReplaceEx1An1An0Not0 () (
     replacee (E. x (/\ ph (/\ (-. ps) th)))
     substitution (<-> ps ch)) 
     (E. x (/\ ph (/\ (-. ch) th)))
  replacee
  substitution
con4biir
th anbi1i
ph anbi2i
x exbii
mpbi
)

thm (pa_ax1plus () () (-. (= (0) (+ A (1))))
  A pa_ax1
  A a1suc
  EqReplaceNot0Eq1
)

## <summary> Replace an equal statement in the second part of an AND statement using the first part of the AND. </summary>
thm (anReplaceEq () () (<-> (/\ (= A B) (= B C)) (/\ (= A B) (= A C)))
  (= A B) (= B C) pm3.26

  B A C ax-eqtr
  B A eqcom
  (= B C) anbi1i
  sylbi2
  jca

  (= A B) (= A C) pm3.26
  A B C ax-eqtr
  jca

  impbii
)

thm (inlineEq () () (<-> (/\ (= A B) (= A C)) (/\ (= A B) (= B C)))
  (= A B) (= A C) pm3.26
  A B C ax-eqtr
  jca

  (= A B) (= B C) pm3.26
  B A C ax-eqtr

  B A eqcom
  (= B C) anbi1i
  sylbi2
  jca
  impbii
)

thm (inlineNeqLem () ()
  (-> (/\ (= A B) (-. (= B C))) (/\ (= A B) (-. (= A C))))

  A B C ax-eqtr
  con3i
  (= A B) anim2i
  (= A B) (/\ (= A B) (= A C)) pm4.52
  sylib
  (-. (= A B)) (= A B) (= A C)
  ordi
  con4biir
  sylib
  (= A B) exmid

  (= A B) (-. (= A B)) orcom
  mpbi

  (\/ (-. (= A B)) (= A C))
  anRemove1
  
  con4biir
  sylib

  (= A B) (= A C) pm4.52
  bicomi
  sylib
)

thm (inlineNeq () () (<-> (/\ (= A B) (-. (= B C))) (/\ (= A B) (-. (= A C)))) 

  A B C inlineNeqLem
  B A C inlineNeqLem

  B A eqcom
  (-. (= A C)) anbi1i
  sylbi2

  B A eqcom
  (-. (= B C)) anbi1i
  sylib
  impbii
)

thm (df-le-just ((A x) (B x) (A y) (B y)) ()
       (<-> (E. x (= (+ A x) B)) (E. y (= (+ A y) B)))
      x y A addeq2 B eqeq1d exalpha)

## <title> Definition of Less Than or Equal to </title>
## <suggest> right('Define', '≤') left('Simplify', '≤') </suggest>
defthm (df-le wff (<= A B) ((A x) (B x)) ()
        (<-> (<= A B) (E. x (= (+ A x) B)))
        # WTS (<-> (E. y (= (+ A y) B)) (E. x (= (+ A x) B)))
        y A B x df-le-just)

## <title> Definition of Less Than </title>
defthm (df-lt wff (< A B) () () (<-> (< A B) (/\ (<= A B) (-. (= A B))))
        (/\ (<= A B) (-. (= A B))) biid)

## <title> Inequality Conversion </title>
## <suggest> right('Infer', '≤') </suggest>
thm (ltle () () (-> (< A B) (<= A B))
  (<= A B) (-. (= A B)) pm3.26
  A B df-lt
  bicomi
  sylbi2
)

## <title> Inequality Conversion </title>
thm (ltlei ()
  (hyp (< A B))
       (<= A B)
  hyp
  A B df-lt
  mpbi
  pm3.26i
)

## <title> Operator Conversion </title>
## <suggest> right('Infer', '≠') </suggest>
thm (ltneq () () (-> (< A B) (-. (= A B)))
  (<= A B) (-. (= A B)) pm3.27
  A B df-lt
  bicomi

  sylbi2 
)

## <title> Inequality Conversion </title>
thm (ltneqi() (hyp (< A B)) (-. (= A B))
  hyp
  A B ltneq
  ax-mp
)

thm (netr ()
  (hyp (=  A B)
   hyp2 (-. (= B C)))
       (-. (= A C))
  hyp2
  hyp
  C eqeq1i
  mtbir
)

thm (ltDiff ((A x) (B x)) (hyp (< A B)) (<-> (< A B) (E. x (/\ (= (+ A x) B) (-. (= x (0)))))) 
  A B df-lt

  A B x df-le
  (-. (= A B))
  anbi1i
  bitri

  x (= (+ A x) B) (-. (= A B)) 19.41
  bicomi
  bitri

  A x (0) addcan2
  bicomi
  A pa_ax3r
  (0) A addcom
  eqtr5
  (+ A x) eqeq2i
  bitri
  notbii
  (= (+ A x) B) anbi2i

  (+ A x) B A inlineNeq 
  B A eqcom
  con4biir
  (= (+ A x) B) anbi2i
  bitr3icom

  bicomi
  bitri
  bicomi

  x exbii
  bitri
)


## <title> Inequality Equivalence </title>
## <summary> Equality deduction for less than or equal relation </summary>
thm (leeq1d ()
  (hyp (-> ph (= A B)))
  (-> ph (<-> (<= A C) (<= B C)))
  hyp
    A B x addeq1 C eqeq1d x exbid
      A C x df-le B C x df-le bibi12i
    sylibr
  syl
)

## <title> Inequality Equivalence </title>
## <summary> Equality deduction for less than or equal relation </summary>
## <table>
##   (-> ph (=         [ A ]       [   [ B ] ))
##   (-> ph (<-> (<= C [ A ] ) (<= [ C [ B ] )))
## </table>
thm (leeq2d ()
  (hyp (-> ph (= A B)))
  (-> ph (<-> (<= C A) (<= C B)))
  hyp
    A B (+ C x) eqeq2 x exbid
      C A x df-le C B x df-le bibi12i
    sylibr
  syl
)

## <title> Inequality Equivalence </title>
thm (leeq1 () () (-> (= A B) (<-> (<= A C) (<= B C)))
 (= A B) id
 C leeq1d
)

## <title> Inequality Equivalence </title>
thm (leeq2 () () (-> (= A B) (<-> (<= C A) (<= C B)))
 (= A B) id
 C leeq2d
)

## <title> Equivalence over Inequality </title>
## <summary> Equality inference for less than or equal relation </summary>
## <table>
##   (=       A ]   ]       [ B ]   )
##   (<-> (<= A ] C ] ) (<= [ B ] C))
## </table>
thm (leeq1i ()
  (hyp (= A B))
  (<-> (<= A C) (<= B C))
  hyp (= A B) id C leeq1d ax-mp
)

## <title> Equivalence over Inequality </title>
## <summary> Equality inference for less than or equal relation </summary>
## <table>
##   (=         [ A ]       [   [ B ] )
##   (<-> (<= C [ A ] ) (<= [ C [ B ] ))
## </table>
thm (leeq2i ()
  (hyp (= A B))
  (<-> (<= C A) (<= C B))
  hyp (= A B) id C leeq2d ax-mp
)

## <title> Equivalence over Inequality </title>
## <summary> Equality inference for less than or equal relation </summary>
## <table>
##  (<=    A ] ]   ] [ C)
##      (= A ] [ B ] ] )
##  (<=      [ [ B ] [ C)
## </table>
thm (leeq1ii ()
  (hyp1 (<= A C)
   hyp2 (= A B))
  (<= B C)
  hyp1 hyp2 C leeq1i mpbi
)

## <title> Equivalence over Inequality </title>
## <summary> Equality inference for less than or equal relation </summary>
## <table>
##  (<= C   [ A ] ] )
##       (= [ A ] [ B)
##  (<= C   [   [ [ B)
## </table>
thm (leeq2ii ()
  (hyp1 (<= C A)
   hyp2 (= A B))
  (<= C B)
  hyp1 hyp2 C leeq2i mpbi
)

thm (le-rwff1 ((A x)) ()  (rwff x (<= x A))
  x y A leeq1 rwffi
)
thm (le-rwff2 ((A x)) ()  (rwff x (<= A x))
  x y A leeq2 rwffi
)

## <title> Addition is Monotonic </title>
## <summary> Addition is strictly monotonic in the first addend </summary>
## <suggest> left('Cancel', '+') </suggest>
thm (leadd1 () ()
  (<-> (<= A B) (<= (+ A C) (+ B C)))
  (+ A x) C B addcan
  A x C add23 (+ B C) eqeq1i bitr3i
  x exbii
    A B x df-le
      (+ A C) (+ B C) x df-le
  3bitr4i
)

## <title> Addition is Monotonic </title>
## <summary> Addition is strictly monotonic in the second addend </summary>
## <suggest> left('Cancel', '+') </suggest>
## <table>
##   (<-> (<= A B) (<= (+ <g> C A) (+ <g> C B)))
## </table>
thm (leadd2 () ()
  (<-> (<= A B) (<= (+ C A) (+ C B)))
  A B C leadd1
  A C addcom (+ B C) leeq1i bitri
  B C addcom (+ C A) leeq2i bitri
)

## <title> Addition Over Inequality </title>
## <table>
##  (<=    A ]    ]    [ B ] )
##  (<= (+ A ] C) ] (+ [ B ] C))
## </table>
thm (leadd1i () (hyp (<= A B)) (<= (+ A C) (+ B C))
  A B C leadd1
  hyp
  mpbiRemove
)

## <title> Addition Over Inequality </title>
## <table>
##  (<=      [ A ]        [ B )
##  (<= (+ C [ A ] ) (+ C [ B ))
## </table>
thm (leadd2i () (hyp (<= A B)) (<= (+ C A) (+ C B))
  A B C leadd2
  hyp
  mpbiRemove
)

## <title> Inequality relation for two equal sums </title>
thm (leadd12 () ()
  (-> (= (+ A B) (+ C D)) (<-> (<= A C) (<= D B)))
  (= (+ A B) (+ C D)) id (+ C B) leeq1d
  D B C leadd2 syl6bbr
  A C B leadd1 syl5bb
)

## <title> Addition is Monotonic </title>
## <suggest> left('Cancel', '+') </suggest>
thm (ltadd1 () () (<-> (< A B) (< (+ A C) (+ B C)))
  A B C leadd1
    A C B addcan bicomi notbii
  anbi12i

    A B df-lt
      (+ A C) (+ B C) df-lt
  3bitr4i
)

## <title> Addition is Monotonic </title>
## <suggest> left('Cancel', '+') </suggest>
thm (ltadd2 () () (<-> (< A B) (< (+ C A) (+ C B)))
   A B df-lt
  (+ C A) (+ C B) df-lt
  A B C leadd2
    C A B addcan2 bicomi notbii
  anbi12i
  bicomi
  bitri
  ## <d>
    bicomi
  ## </d>
  bitri
)


## <title> Addition Over Inequality </title>
## <table>
##  (-. (<=    A ]       [ B ] ))
##  (-. (<= (+ A ] C) (+ [ B ] C)))
## </table>
thm (gtadd1i () (hyp (-. (<= A B))) (-. (<= (+ A C) (+ B C)))
  A B C leadd1
  hyp
  mtbiRemove
)

## <title> Addition Over Inequality </title>
## <table>
##  (-. (<=      [ A ]        [ B ))
##  (-. (<= (+ C [ A ] ) (+ C [ B )))
## </table>
thm (gtadd2i () (hyp (-. (<= A B))) (-. (<= (+ C A) (+ C B)))
  A B C leadd2
  hyp
  mtbiRemove
)

## <title> Addition Over Inequality </title>
## <table>
##  (-. (<    A ]       [ B ] ))
##  (-. (< (+ A ] C) (+ [ B ] C)))
## </table>
thm (geadd1i () (hyp (-. (< A B))) (-. (< (+ A C) (+ B C)))
  A B C ltadd1
  hyp
  mtbiRemove
)

## <title> Addition Over Inequality </title>
## <table>
##  (-. (<      [ A ]        [ B ))
##  (-. (< (+ C [ A ] ) (+ C [ B )))
## </table>
thm (geadd2i () (hyp (-. (< A B))) (-. (< (+ C A) (+ C B)))
  A B C ltadd2
  hyp
  mtbiRemove
)

## <title> Basic Inequality </title>
thm (1nle0 () ()
  (-. (<= (1) (0)))
  x pa_ax1 (0) (S x) eqcom mtbi
  x a1suc x (1) addcom eqtr (0) eqeq1i mtbi
  x gen x (= (+ (1) x) (0)) alnex mpbi
  (1) (0) x df-le mtbir
)

## <title> Equivalence over Inequality </title>
thm (lteq2d ()
  (hyp (-> ph (= A B)))
  (-> ph (<-> (< C A) (< C B)))
  hyp C leeq2d
  hyp C eqeq2d notbid anbi12d
    C A df-lt
      C B df-lt
  3bitr4g
)

## <title> Equivalence over Inequality </title>
thm (lteq2 () () (-> (= A B) (<-> (< C A) (< C B)))
 (= A B) id
 C lteq2d
)

## <title> Equivalence over Inequality </title>
## <table>
##   (=        [ A ]      [   [ B ] )
##   (<-> (< C [ A ] ) (< [ C [ B ] ))
## </table>
thm (lteq2i ()
  (hyp (= A B))
  (<-> (< C A) (< C B))
  hyp (= A B) id C lteq2d ax-mp
)

## <title> Equivalence over Inequality </title>
## <table>
##  (< C   [ A ] ] )
##      (= [ A ] [ B)
##  (< C   [   [ [ B)
## </table>
thm (lteq2ii ()
  (hyp1 (< C A)
   hyp2 (= A B))
  (< C B)
  hyp1 hyp2 C lteq2i mpbi
)

thm (addge01t () ()
  (<= A (+ A B))
  x B tyex x B A addeq2 x 19.22i ax-mp
  A (+ A B) x df-le mpbir
)

thm (addge02t () ()
  (<= A (+ B A))
  A B addge01t A B addcom A leeq2i mpbi
)

## <title> Reflexive Property </title>
## <summary> Less than or equal is a reflexive relation </summary>
thm (leid () ()
  (<= A A)
  A (0) addge01t
  A pa_ax3 A leeq2i mpbi
)

thm (lenlttlem () ()
  (-. (<= (+ A (1)) A))
  1nle0 (1) (0) A leadd1 mtbi
  (1) A addcom (+ (0) A) leeq1i mtbi
  A pa_ax3r (+ A (1)) leeq2i mtbi
)

## <title> Transitive Property </title>
## <suggest> right('Simplify', '< <') </suggest>
## <title> Transitive Property </title>
## <suggest> right('Simplify', '< <') </suggest>
thm (letr () () (-> (/\ (<= A B) (<= B C)) (<= A C))
  ## <d 'Add A to both sides'>
    z (+ x y) A addeq2
    A x y addass syl6eqr 
  ## </d>
  ## <d 'Let A+x = B'>
    (= (+ A x) B) adantr
    (+ A x) B y addeq1 (= z (+ x y)) adantl eqtrd
  ## </d>
  ## <d 'Let B+y = C'>
    C eqeq1d biimprd imp 
  ## </d>
  ## <d 'Add Existential Quantifiers'>
    ancoms x substex ex
    y 19.23ai com12 imp
  ## </d>
  ## <d 'Apply Definition of ≤'>
    ## <d 'Define A ≤ B'>
      ## <d 'Define A ≤ B'>
        A B x df-le bicomi
      ## </d>
      BiReplaceImp0An0
    ## </d>
    ## <d 'Define B ≤ C'>
      ## <d 'Define B ≤ C'>
        B C y df-le bicomi
      ## </d>  
      BiReplaceImp0An1
    ## </d>  
    ## <d 'Define A ≤ C'>
      ## <d 'Define A ≤ C'>
        A C z df-le bicomi
      ## </d>
      sylib
    ## </d>
  ## <d 'Apply Definition of ≤'>
)

thm (lefoo ((A z)) ()
  (\/ (= A (0)) (E. z (= (+ (1) z) A)))
  x (0) (0) eqeq1 x (0) (+ (1) z) eqeq2 z exbid orbi12d
    x y (0) eqeq1 x y (+ (1) z) eqeq2 z exbid orbi12d
      x (S y) (0) eqeq1 x (S y) (+ (1) z) eqeq2 z exbid orbi12d
        x A (0) eqeq1 x A (+ (1) z) eqeq2 z exbid orbi12d

  # invariant: x = 0 \/ E. z 1 + z = x
  (0) eqid (E. z (= (+ (1) z) (0))) orci

  z y tyex
    z y (1) addeq2
    y a1suc y (1) addcom eqtr syl6eqr
    z 19.22i
  ax-mp (= (S y) (0)) olci
  (\/ (= y (0)) (E. z (= (+ (1) z) y))) a1i
  finds
)

thm (lefoo3 () ()
  (<-> (<= A B) (\/ (= A B) (<= (+ A (1)) B)))
  A B x df-le
    x y lefoo
      x (0) A addeq2
      A pa_ax3 syl6eq B eqeq1d biimpd com12
        (+ (1) y) x A addeq2 A (1) y addass syl5eq
        B eqeq1d biimprd com12
        y 19.22d
        (+ A (1)) B y df-le syl6ibr
      orim12d
    mpi
  x 19.23ai sylbi
    A leid (= A B) id A leeq2d mpbii
      A (1) addge01t A (+ A (1)) B letr mpan
    jaoi
  impbii
)

## <title> Equality Conversion </title>
## <suggest> right('Infer', '≤') </suggest>
thm (eqle() () (-> (= A B) (<= A B))
  A B lefoo3  
  ## <d>
    (<= A B) (\/ (= A B) (<= (+ A (1)) B)) bicom
  ## </d>
  mpbi
  biimpi
  orcs
)

thm (nnltp1let () ()
  (<-> (< A B) (<= (+ A (1)) B))
  A B df-lt
  A B lefoo3 (-. (= A B)) anbi1i bitri
    A lenlttlem
    (= A B) id (+ A (1)) leeq2d mtbii
    con2i pm4.71i

      (<= (+ A (1)) B) (= A B) pm5.61
      (<= (+ A (1)) B) (= A B) orcom (-. (= A B)) anbi1i bitr3i
    bitri
  bitr4i
)

thm (nn0nlt0 () ()
  (-. (< A (0)))
    1nle0 (1) A addge02t
    (1) (+ A (1)) (0) letr mpan
  mto
  A (0) nnltp1let mtbir
)

thm (lenltt () ()
  (<-> (<= A B) (-. (< B A)))
  (= x (0)) id B leeq1d (= x (0)) id B lteq2d notbid bibi12d
    (= x y) id B leeq1d (= x y) id B lteq2d notbid bibi12d
      (= x (S y)) id B leeq1d (= x (S y)) id B lteq2d notbid bibi12d
        (= x A) id B leeq1d (= x A) id B lteq2d notbid bibi12d

  # base case
  (0) B addge02t
    B pa_ax3 (0) leeq2i
  mpbi
  B nn0nlt0 2th

  # induction step
  (<= y B) (-. (< B y)) (-. (= y B)) anbi1
    y B nnltp1let y B df-lt bitr3i
      B (+ y (1)) nnltp1let
      B y (1) leadd1 bitr4i
      B y lefoo3 bitri
      B y nnltp1let (= B y) orbi2i bitr4i
        B y eqcom (< B y) orbi1i
        (= y B) (< B y) orcom bitri
      bitri notbii
      (< B y) (= y B) ioran bitri
    bibi12i
  sylibr
    y a1suc B leeq1i y a1suc B lteq2i notbii bibi12i
  sylibr
  finds
)

## <title> No Natural Numbers Below Zero </title>
thm (0le () () (<= (0) A)
  (0) A lenltt
   bicomi
   A nn0nlt0
   mpbiRemove
)

## <title> Equality deduction for less than relation </title>
thm (lteq1d () (hyp (-> ph (= A B)))
  (-> ph (<-> (< A C) (< B C)))
  hyp C leeq2d
  C A lenltt
  C B lenltt
 bibi12i
 sylib
 con4bid
)

## <title> Equivalence over Inequality </title>
thm (lteq1 () () (-> (= A B) (<-> (< A C) (< B C)))
 (= A B) id
 C lteq1d
)

# Equality inference for less than relation
## <title> Equivalence over Inequality </title>
## <table>
##   (=      A ]   ]      [ B ]   )
##   (<-> (< A ] C ] ) (< [ B ] C))
## </table>
thm (lteq1i () (h (= A B))
  (<-> (< A C) (< B C))
  h (= A B) id C lteq1d ax-mp)

## <title> Equivalence over Inequality </title>
## <summary> Equality deduction for less than relation </summary>
## <table>
##  (<    A ] ]   ] [ C)
##     (= A ] [ B ] ] )
##  (<      [ [ B ] [ C)
## </table>
thm (lteq1ii ()
  (hyp1 (< A C)
   hyp2 (= A B))
  (< B C)
  hyp1 hyp2 C lteq1i mpbi
)

thm (eq-rwff1 ((A x)) ()  (rwff x (= x A))
  x y A eqeq1 rwffi
)

thm (eq-rwff2 ((A x)) ()  (rwff x (= A x))
  x y A eqeq2 rwffi
)

thm (lt-rwff1 ((A x)) ()  (rwff x (< x A))
  x y A lteq1 rwffi
)

thm (lt-rwff2 ((A x)) ()  (rwff x (< A x))
  x y A lteq2 rwffi
)

## <title> Basic Inequality </title>
thm (0ne1 () ()
  (-. (= (0) (1)))
  (0) pa_ax1
  df-1 (0) eqeq2i mtbir
)

## <title> Transitive law </title>
## <suggest> right('Simplify', '<') </suggest>
thm (lelttr () ()
  (-> (/\ (<= A B) (< B C)) (< A C))
  A B (1) leadd1
  B C nnltp1let
  anbi12i
  (+ A (1)) (+ B (1)) C letr sylbi
  A C nnltp1let
  sylibr
)

## <title> Transitive law </title>
## <suggest> right('Simplify', '<') </suggest>
thm (lelttr2 () ()
  (-> (/\ (< A B) (<= B C)) (< A C))
  A B nnltp1let (<= B C) anbi1i
  (+ A (1)) B C letr sylbi
  A C nnltp1let sylibr
)

thm (addge01t2 () (hyp (< A B)) (< A (+ B C))
   A B (+ B C) lelttr2
  hyp  
  (<= B (+ B C)) anRemove1
  (< A (+ B C)) imbi1i
  mpbi
  B C addge01t  
  ax-mpRemove
)

## <title> Inequality Conversion </title>
## <suggest> left('Simplify', '<') </suggest>
thm (axlttri () ()
  (<-> (< A B) (-. (\/ (= A B) (< B A))))
  A B df-lt
  A B lenltt (-. (= A B)) anbi1i bitri
    (< B A) (= A B) ioran
      (< B A) (= A B) orcom notbii
    bitr3i
  bitri
)

## <title> ≤ means < OR = </title>
## <summary> Less than or equal to expressed in terms of less than or equals </summary>
## <suggest> right('Equivalence', '∨') left('Simplify', '≤') </suggest>
thm (leleo () ()
  (<-> (<= A B) (\/ (< A B) (= A B)))
  A B lenltt
    B A axlttri con2bii
  bitr4i
  B A eqcom (< A B) orbi1i bitri
  (= A B) (< A B) orcom bitri
)

## <title> Commute Inequality </title>
## <suggest> right('Commute', '<') </suggest>
thm (ltcom () () (<-> (< A B) (-. (<= B A)))
  A B axlttri
  A B eqcom
  (< B A) orbi1i
  con4biir
  bitri
  B A leleo
  (< B A) (= B A) orcom
  bitri
  bicomi
  con4biir
  bitri
)

## <title> Commute Inequality </title>
thm (ltcomi () (hyp (< A B)) (-. (<= B A))
  hyp
  A B axlttri
  mpbi
  A B eqcom
  (< B A) orbi1i
  mtbi
  B A leleo
  (< B A) (= B A) orcom
  bitri
  bicomi
  mtbi
)

## <title> Commute Inequality </title>
## <suggest> right('Commute', '≤') </suggest>
thm (lecom () () (<-> (<= A B) (-. (< B A)))
  B A ltcom
  notbii
  bicomi
  (<= A B) notnot
  bicomi
  bitr3icom
)

## <title> Commute Inequality </title>
thm (lecomi () (hyp (<= A B)) (-. (< B A))
  hyp
  A B lecom
  mpbi
)

## <title> Addition is Monotonic </title>
thm (geadd1 () ()  (<-> (-. (< A B)) (-. (< (+ A C) (+ B C))))
  B A C leadd1  
  ## <d 'Commute Inequality '>
    B A lecom
    bitr3icom
  ## </d 'Commute Inequality '>    
  ## <d 'Commute Inequality '>
    (+ B C) (+ A C) lecom
    bitri
  ## </d 'Commute Inequality '>    
)

## <title> Addition is Monotonic </title>
thm (geadd2 () ()  (<-> (-. (< A B)) (-. (< (+ C A) (+ C B))))
  B A C leadd2      
  ## <d 'Commute Inequality '>
    B A lecom       
    bitr3icom
  ## </d 'Commute Inequality '>            
  ## <d 'Commute Inequality '>
    (+ C B) (+ C A) lecom      
    bitri
  ## </d 'Commute Inequality '>
)

## <title> No Natural Numbers Below Zero </title>
thm (ge0 () () (-. (< A (0)))
  A 0le
  lecomi
)

## <title> Equivalence over Inequality </title>
## <table>
##   (=           A ]   ]            [ B ]   )
##   (<-> (-. (<= A ] C ] )) (-. (<= [ B ] C)))
## </table>
thm (gteq1i ()
  (hyp (= A B))
  (<-> (-. (<= A C)) (-. (<= B C)))
  hyp
  C lteq2i  
  ## <d>
    C A ltcom
  ## </d>
  bitr3icom
  
  ## <d>
    C B ltcom
  ## </d>
  bitri
)

## <title> Equivalence over Inequality </title>
## <table>
##   (=             [ A ]            [   [ B ] )
##   (<-> (-. (<= C [ A ] )) (-. (<= [ C [ B ] )))
## </table>
thm (gteq2i ()
  (hyp (= A B))
  (<-> (-. (<= C A)) (-. (<= C B)))
  hyp
  C lteq1i  
  ## <d>
    A C ltcom
  ## </d>
  bitr3icom
  
  ## <d>
    B C ltcom
  ## </d>
  bitri
)

## <title> Equivalence over Inequality </title>
## <table>
##   (=          A ]   ]           [ B ]   )
##   (<-> (-. (< A ] C ] )) (-. (< [ B ] C)))
## </table>
thm (geeq1i ()
  (hyp (= A B))
   (<-> (-. (< A C)) (-. (< B C)))
  hyp
  C leeq2i  
  ## <d>
    C A lecom
  ## </d>
  bitr3icom
  
  ## <d>
    C B lecom
  ## </d>
  bitri
)

## <title> Equivalence over Inequality </title>
## <table>
##   (=            [ A ]           [   [ B ] )
##   (<-> (-. (< C [ A ] )) (-. (< [ C [ B ] )))
## </table>
thm (geeq2i ()
  (hyp (= A B))
  (<-> (-. (< C A)) (-. (< C B)))
  hyp
  C leeq1i  
  ## <d>
    A C lecom
  ## </d>
  bitr3icom
  
  ## <d>
    B C lecom
  ## </d>
  bitri
)

thm (lttri () (hyp (< A B) hyp2 (< B C)) (< A C)
  hyp2 ltcomi
  C B ltle
  mto
  hyp
  (= A C) id B lteq1d
  mpbii
  mto

  hyp ltlei
  hyp2 ltlei
  pm3.2i
  A B C letr
  ax-mp
  A C lecom
  mpbi

  pm3.2i

  (= A C) (< C A) ioran
  bicomi
  mpbi

  A C axlttri
  bicomi
  mpbi
)

thm (nelt0 () (hyp (-. (= x (0)))) (-. (<= x (0)))
  x nn0nlt0
  hyp
  pm3.2ni

  x (0) leleo
  mtbir
)

## <title> Substitution </title>
## <table>
##   (<-> ph (/\ ps  [ ch ]   ]    ] ))
##   (<->            [ ch ]   [ th ] )
##   (<-> ph (/\ ps  [    [   [ th ] ))
## </table>
thm (replaceBi1An1 () (
     replacee (<-> ph (/\ ps ch))
     substitution (<-> ch th)) 
     (<-> ph (/\ ps th))
  replacee
  substitution
ps anbi2i
bitri
)



## <title> Substitution </title>
## <table>
##   (<-> ph (\/ ps (-.  [ ch ]   ]    ] )))
##   (<->                [ ch ]   [ th ] )
##   (<-> ph (\/ ps (-.  [    [   [ th ] )))
## </table>
thm (BiReplaceBi1Or1Not0 () (
     replacee (<-> ph (\/ ps (-. ch)))
     substitution (<-> ch th)) 
     (<-> ph (\/ ps (-. th)))
  replacee
  substitution
con4biir
ps orbi2i
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (\/ ps (E. x (-.  [ ch ]   ]    ] ))))
##   (<->                      [ ch ]   [ th ] )
##   (<-> ph (\/ ps (E. x (-.  [    [   [ th ] ))))
## </table>
thm (BiReplaceBi1Or1Ex1Not0 () (
     replacee (<-> ph (\/ ps (E. x (-. ch))))
     substitution (<-> ch th)) 
     (<-> ph (\/ ps (E. x (-. th))))
  replacee
  substitution
con4biir
x exbii
ps orbi2i
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (\/ ps (E. x  [ ch ]   ]    ] )))
##   (<->                  [ ch ]   [ th ] )
##   (<-> ph (\/ ps (E. x  [    [   [ th ] )))
## </table>
thm (BiReplaceBi1Or1Ex1 () (
     replacee (<-> ph (\/ ps (E. x ch)))
     substitution (<-> ch th)) 
     (<-> ph (\/ ps (E. x th)))
  replacee
  substitution
x exbii
ps orbi2i
ph bibi2i
mpbi
)

## <title> One-Digit Inequality </title>
thm (0notEqual1 () () (-. (= (0) (1)))
  (0) pa_ax1plus
  ## <d 'Evaluate'>
    (1) pa_ax3r
    EqReplaceNot0Eq1
  ## </d 'Evaluate'>
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (/\ ch  [ th ]   ]    ] )))
##   (->                   [ th ]   [ ta ] )
##   (-> ph (-> ps (/\ ch  [    [   [ ta ] )))
## </table>
thm (ImpReplaceImp1Imp1An1 () (
     replacee (-> ph (-> ps (/\ ch th)))
     substitution (-> th ta)) 
     (-> ph (-> ps (/\ ch ta)))
  replacee
  substitution
ch anim2i
ps imim2i
ph imim2i
ax-mp
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps  [ ch ]   ]    ] ))
##   (->            [ ch ]   [ th ] )
##   (-> ph (-> ps  [    [   [ th ] ))
## </table>
thm (ImpReplaceImp1Imp1 () (
     replacee (-> ph (-> ps ch))
     substitution (-> ch th)) 
     (-> ph (-> ps th))
  replacee
  substitution
ps imim2i
ph imim2i
ax-mp
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (E. x  [ ch ]   ]    ] )))
##   (<->                 [ ch ]   [ th ] )
##   (-> ph (-> ps (E. x  [    [   [ th ] )))
## </table>
thm (BiReplaceImp1Imp1Ex1 () (
     replacee (-> ph (-> ps (E. x ch)))
     substitution (<-> ch th)) 
     (-> ph (-> ps (E. x th)))
  replacee
  substitution
x exbii
ps imbi2i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (E. x (/\ ch  [ th ]   ]    ] ))))
##   (<->                        [ th ]   [ ta ] )
##   (-> ph (-> ps (E. x (/\ ch  [    [   [ ta ] ))))
## </table>
thm (BiReplaceImp1Imp1Ex1An1 () (
     replacee (-> ph (-> ps (E. x (/\ ch th))))
     substitution (<-> th ta)) 
     (-> ph (-> ps (E. x (/\ ch ta))))
  replacee
  substitution
ch anbi2i
x exbii
ps imbi2i
ph imbi2i
mpbi
)

## <title> Inequality Conversion </title>
## <suggest> left('Simplify', '<') </suggest>
thm (axlttri2 () () (<-> (< A B) (/\ (-. (= A B)) (<= A B)))
  A B axlttri
  (= A B) (< B A) ioran bitri
  A B lecom
  ## <d>
    bicomi
  ## </d>
  replaceBi1An1
)

## <title> Convert between inequalities </title>
thm (axlttri2i () (hyp (-. (= A B)) hyp2 (<= A B)) (< A B)
  hyp
  hyp2
  pm3.2i
  ## <d>
    A B axlttri2  
  ## </d>
  ## <d>
    ## <d>
      (< A B) (/\ (-. (= A B)) (<= A B)) bicom
    ## </d>
    mpbi
  ## </d>
  mpbi
)

## <title> Equality Conversion </title>
## <suggest> right('Infer', '≥') </suggest>
thm (eqge() () (-> (= A B) (-. (< A B)))
  A B axlttri2
  biimpi
  pm3.26d
  con2i
)

## <title> One-Digit Inequality </title>
thm (0less1 () () (< (0) (1))
    0notEqual1
  ## <d 'Less Than Or Equal To Zero'>
    (1) 0le
  ## </d 'Less Than Or Equal To Zero'>
  axlttri2i
)

## <title> Substitution </title>
## <table>
##   (<-> ph (/\ (-.  [ ps ]   ]    ] ) th))
##   (<->             [ ps ]   [ ch ] )
##   (<-> ph (/\ (-.  [    [   [ ch ] ) th))
## </table>
thm (replaceBi1An0Not0 () (
     replacee (<-> ph (/\ (-. ps) th))
     substitution (<-> ps ch)) 
     (<-> ph (/\ (-. ch) th))
  replacee
  substitution
  con4biir
  th anbi1i
  bitri
)

## <title> Substitution </title>
## <table>
##   (<-> (/\  [ ph ]   ]    ]  ch) th)
##   (<->      [ ph ]   [ ps ] )
##   (<-> (/\  [    [   [ ps ]  ch) th)
## </table>
thm (BiReplaceBi0An0 () (
     replacee (<-> (/\ ph ch) th)
     substitution (<-> ph ps)) 
     (<-> (/\ ps ch) th)
  replacee
  substitution
ch anbi1i
th bibi1i
mpbi
)

## <title> Inequality Conversion </title>
## <suggest> left('Simplify', '>') </suggest>
thm (axgrtri () () (<-> (-. (<= A B)) (/\ (-. (= A B)) (-. (< A B))))
  B A axlttri2
  B A ltcom bitr3icom
  B A lecom  replaceBi1An1
  B A eqcom  replaceBi1An0Not0
)

## <title> Inequality Conversion </title>
thm (axgrtrii () (hyp (-. (= A B)) hyp2 (-. (< A B))) (-. (<= A B))
  hyp
  hyp2
  pm3.2i
  ## <d>
    A B axgrtri
  ## </d>  
  ## <d>
    ## <d>
      (-. (<= A B)) (/\ (-. (= A B)) (-. (< A B))) bicom
    ## </d>
    mpbi
  ## </d>  
  mpbi
)

## <title> Inequality Conversion </title>
## <suggest> right('Infer', '≠') </suggest>
thm (gtneq () () (-> (-. (<= A B)) (-. (= A B)))
 (-. (= A B)) (-. (< A B)) pm3.26
 A B axgrtri  
  ## <d>
    (-. (<= A B)) (/\ (-. (= A B)) (-. (< A B))) bicom
  ## </d>
  mpbi
  sylbi2
)

## <title> Inequality Conversion </title>
## <suggest> right('Infer', '≥') </suggest>
thm (gtge () () (-> (-. (<= A B)) (-. (< A B)))
 (-. (= A B)) (-. (< A B)) pm3.27
 A B axgrtri  
  ## <d>
    (-. (<= A B)) (/\ (-. (= A B)) (-. (< A B))) bicom
  ## </d>
  mpbi
  sylbi2
)

## <title> Inequality Conversion </title>
thm (gtneqi() (hyp (-. (<= A B))) (-. (= A B))
  hyp
  A B axgrtri
  mpbi
  pm3.26i
)

## <title> Inequality Conversion </title>
thm (gtgei() (hyp (-. (<= A B))) (-. (< A B))
  hyp
  A B axgrtri
  mpbi
  pm3.27i
)

## <title> Inequality Over Addition </title>
## <table>
##  (<    A ]       [ B ] )
##  (< (+ A ] C) (+ [ B ] C))
## </table>
thm (ltadd1i () (hyp (< A B)) (< (+ A C) (+ B C))
  hyp
  A B C ltadd1
  mpbi
)

## <title> Inequality Over Addition </title>
## <table>
##  (<      [ A ]        [ B )
##  (< (+ C [ A ] ) (+ C [ B ))
## </table>
thm (ltadd2i () (hyp (< A B)) (< (+ C A) (+ C B))
  hyp
  A B C ltadd2
  mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> (< A  [ B ]   ]   ] ) ph)
##   (=         [ B ]   [ C ] )
##   (<-> (< A  [   [   [ C ] ) ph)
## </table>
thm (EqReplaceBi0Lt1 () (
     replacee (<-> (< A B) ph)
     substitution (= B C)) 
     (<-> (< A C) ph)
  replacee
  substitution
A lteq2i
ph bibi1i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (<=  [ A ]   ]   ]  C))
##   (=           [ A ]   [ B ] )
##   (<-> ph (<=  [   [   [ B ]  C))
## </table>
thm (EqReplaceBi1Le0 () (
     replacee (<-> ph (<= A C))
     substitution (= A B)) 
     (<-> ph (<= B C))
  replacee
  substitution
C leeq1i
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (E. x (=  [ A ]   ]   ]  C)))
##   (=                [ A ]   [ B ] )
##   (<-> ph (E. x (=  [   [   [ B ]  C)))
## </table>
thm (EqReplaceBi1Ex1Eq0 () (
     replacee (<-> ph (E. x (= A C)))
     substitution (= A B)) 
     (<-> ph (E. x (= B C)))
  replacee
  substitution
C eqeq1i
x exbii
ph bibi2i
mpbi
)

## <title> Multiply Both Sides </title>
## <summary> Multiplication is monotonic in its second argument </summary>
thm (lemul2 () ()
  (-> (<= A B) (<= (* C A) (* C B)))

  A B x df-le
    (0) eqid
      y (* C x) (* C A) addeq2
        (+ A x) B C muleq2
        C A x distr syl5eqr
      sylan9eq
      (= (0) (0)) adantl x substex
    mpan
  sylbi
    (* C A) (* C B) y df-le
  sylibr
)

thm (lemul4 () ()
  (-> (<= (* A (S C)) (* B (S C)))  (<= A B))
  A  B  lenltt    biimpri   con1i
  B  A  df-lt    sylib
  B  A  x  df-le    biimpi    (-. (= B A)) anim1i    syl
  x  (= (+ B x) A)  (-. (= B A))  19.41    biimpri    syl
      x  (0)  B  addeq2    B  pa_ax3    syl6eq    A  eqeq1d    biimpd    com12    con3d
      (= (+ B x) A)  (-. (= B A))  (-. (= x (0)))    pm3.31    ax-mp
        (+ B x)  A  (S C)  muleq1
        (+ B x)  (S C)  mulcom    (S C)  B  x  distr   eqtr
        (S C)  B  mulcom    (* (S C) x)  addeq1i    eqtr    syl5eqr
        (-. (= B A)) adantr
      jca
      x  y  lefoo      ori
          z  (* (1) C)tyex
            z  (* (1) C)  (1) addeq2
            (1)  C  pa_ax6    (1)  (S C)  mulcom    eqtr3    (* (1) C)  (1)  addcom    eqtr3  eqcomi    syl6eq
          z  19.22i    ax-mp
          (1)  (* (S C) (1))  z  df-le    mpbir
          (1)  (* (S C) (1))  (* (S C) y)  leadd1    mpbi
            (+ (1) y)  x  (S C)  muleq2    (S C)  (1)  y  distr    syl5eqr
            (+ (1) (* (S C) y))  leeq2d    biimpd
          mpi
            (1)  (* (S C) y)  addge01t    (1)  (+ (1) (* (S C) y))  (* (S C) x)  letr
            (<= (1) (+ (1) (* (S C) y)))  (<= (+ (1) (* (S C) y)) (* (S C) x))  (<= (1) (* (S C) x))  pm3.3    ax-mp    ax-mp
          syl
      y  19.22i    syl    y  (<= (1) (* (S C) x))  19.9    sylib
      (1)  (* (S C) x)  (* B (S C))  leadd2    sylib
      (= (+ (* B (S C)) (* (S C) x)) (* A (S C)))  id    (+ (* B (S C)) (1))  leeq2d    biimpd    anim12i
     (<= (+ (* B (S C)) (1)) (+ (* B (S C)) (* (S C) x)))  (<= (+ (* B (S C)) (1)) (* A (S C)))  pm3.35    syl
    syl
  x  19.22i    syl    x  (<= (+ (* B (S C)) (1)) (* A (S C)))  19.9    sylib
  (* B (S C))  (* A (S C))  nnltp1let    biimpri    syl
  (* A (S C))  (* B (S C))  lenltt    biimpi    con2i    syl
  con4i
)

## <summary> Multiplication is strictly monotonic when the other multiplicand is nonzero </summary>
thm (ltmul1 () ()
  (-> (< (0) A) (-> (< B C) (< (* A B) (* A C))))
  (0) A (* A B) ltadd1
  (* A B) pa_ax3r (+ A (* A B)) lteq1i bitri
  A (* A B) addcom (* A B) lteq2i bitri
    A B (1) distr
    A mulid (* A B) addeq2i eqtr
    (* A B) lteq2i
  bitr4i biimpi
    B C nnltp1let
    (+ B (1)) C A lemul2 sylbi
  anim12i
  (* A B) (* A (+ B (1))) (* A C) lelttr2 syl ex
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (<  [ A ]   ]   ]  C)))
##   (=                [ A ]   [ B ] )
##   (-> ph (-> ps (<  [   [   [ B ]  C)))
## </table>
thm (EqReplaceImp1Imp1Lt0 () (
     replacee (-> ph (-> ps (< A C)))
     substitution (= A B)) 
     (-> ph (-> ps (< B C)))
  replacee
  substitution
C lteq1i
ps imbi2i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (< A  [ B ]   ]   ] )))
##   (=                  [ B ]   [ C ] )
##   (-> ph (-> ps (< A  [   [   [ C ] )))
## </table>
thm (EqReplaceImp1Imp1Lt1 () (
     replacee (-> ph (-> ps (< A B)))
     substitution (= B C)) 
     (-> ph (-> ps (< A C)))
  replacee
  substitution
A lteq2i
ps imbi2i
ph imbi2i
mpbi
)

## <title> Multiplication is Monotonic </title>
## <table>
##  (<    B ] ]     ]      [ C ] ]   )
##  (<      [ [ (0) ]      [   [ [ A )
##  (< (* B ] [  A  ] ) (* [ C ] [ A ))
## </table>
thm (ltmul2i () (hyp (< B C) hyp2 (< (0) A)) (< (* B A) (* C A))
  hyp
  hyp2
  A B C ltmul1
  ## <d>
    A B mulcom
  ## </d>
    EqReplaceImp1Imp1Lt0
  ## <d>
    A C mulcom
  ## </d>
    EqReplaceImp1Imp1Lt1
  ax-mp
  ax-mp
)

## <title> Substitution </title>
## <table>
##   (-> ph (->  [ ps ]   ]    ]  th))
##   (<->        [ ps ]   [ ch ] )
##   (-> ph (->  [    [   [ ch ]  th))
## </table>
thm (BiReplaceImp1Imp0 () (
     replacee (-> ph (-> ps th))
     substitution (<-> ps ch)) 
     (-> ph (-> ch th))
  replacee
  substitution
th imbi1i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps  [ ch ]   ]    ] ))
##   (<->           [ ch ]   [ th ] )
##   (-> ph (-> ps  [    [   [ th ] ))
## </table>
thm (BiReplaceImp1Imp1 () (
     replacee (-> ph (-> ps ch))
     substitution (<-> ch th)) 
     (-> ph (-> ps th))
  replacee
  substitution
ps imbi2i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (-. (<=  [ A ]   ]   ]  C))))
##   (=                     [ A ]   [ B ] )
##   (-> ph (-> ps (-. (<=  [   [   [ B ]  C))))
## </table>
thm (EqReplaceImp1Imp1Not0Le0 () (
     replacee (-> ph (-> ps (-. (<= A C))))
     substitution (= A B)) 
     (-> ph (-> ps (-. (<= B C))))
  replacee
  substitution
C leeq1i
con4biir
ps imbi2i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (-. (<= A  [ B ]   ]   ] ))))
##   (=                       [ B ]   [ C ] )
##   (-> ph (-> ps (-. (<= A  [   [   [ C ] ))))
## </table>
thm (EqReplaceImp1Imp1Not0Le1 () (
     replacee (-> ph (-> ps (-. (<= A B))))
     substitution (= B C)) 
     (-> ph (-> ps (-. (<= A C))))
  replacee
  substitution
A leeq2i
con4biir
ps imbi2i
ph imbi2i
mpbi
)

thm (gtmul2() () (-> (-. (<= A (0))) (-> (-. (<= C B)) (-. (<= (* C A) (* B A)))))
  A B C ltmul1  
  ## <d>
    (0) A ltcom
  ## </d>
  sylbi2
  
  ## <d>
    B C ltcom
  ## </d>
    BiReplaceImp1Imp0
  
  ## <d>
    (* A B) (* A C) ltcom
  ## </d>
    BiReplaceImp1Imp1
  
  ## <d>
    A C mulcom
  ## </d>
    EqReplaceImp1Imp1Not0Le0
  
  ## <d>
    A B mulcom
  ## </d>
    EqReplaceImp1Imp1Not0Le1
)

## <title> Multiplication is Monotonic </title>
## <table>
##  (-. (<=    B ] ]   ]      [ C ] ]     ))
##  (-. (<=      [ [ A ]      [   [ [ (0) ))
##  (-. (<= (+ B ] [ A ] ) (+ [ C ] [  A  )))
## </table>
thm (gtmul2i () (hyp (-. (<= B C)) hyp2 (-. (<= A (0))))  (-. (<= (* B A) (* C A)))
   hyp
   hyp2
   A B C gtmul2
   ax-mp
   ax-mp
)

## <summary> Multiplication is strictly monotonic with nonzero multiplicand </summary>
thm (lemul5 () ()
  (<-> (<= (* A (S C)) (* B (S C))) (<= A B))
  A C B lemul4
    A B (S C) lemul2
    (S C) A mulcom (* (S C) B) leeq1i sylib
    (S C) B mulcom (* A (S C)) leeq2i sylib
  impbii
)

## <summary> Trichotomy law (may be a poor choice of name) </summary>
## <suggest> left('Simplify', '=') </suggest>
thm (lesym () ()
  (<-> (= A B) (/\ (<= A B) (<= B A)))
  # A=B -> A<=B
  B leid    (= A B) id B leeq1d    mpbiri
  # A=B -> B<=A
  A leid    (= A B) id A leeq1d    mpbii
  jca

  A B lenltt
  B A df-lt
  notbii   bitri
  (<= B A) (-. (= B A)) ianor
  bitri biimpi

  (<= B A) (-. (-. (= B A))) imor bicomi biimpi syl  imp
  (= B A) notnot2 syl
  eqcomd

  impbii
)

## <suggest> right('Simplify', '=') </suggest>
thm (eqle0 () () (<-> (<= A (0)) (= A (0)))
  A (0) lesym
  A 0le  
  (<= A (0)) anRemove2
  (= A (0)) bibi2i
  mpbi
  bicomi
)

## <summary> For naturals, equal to zero is equivalent to less than or equal to zero </summary>
thm (eq0le0 () () (<-> (= A (0)) (<= A (0)))
     A (0) lesym
     # 0 <= A
     (0) A addge01t    A pa_ax3r (0) leeq2i     mpbi
   mpbiran2
)

## <summary> Less than or equal is a total relationship </summary>
thm (letot () () (\/ (<= A B) (<= B A))
(< B A)  id   (< B A)  (< B A)  imor    mpbi
   A  B  lenltt  biimpri
   B  A  df-lt    biimpi  pm3.26d
orim12i

ax-mp
)

## <summary> If a product of a nonzero number and some other number is zero, that number is zero </summary>
thm (mul0 () () (-> (= (* (S A) B) (0)) (= B (0)))
x  (* A B)  tyex
  x (* A B)  B  addeq1
  A  B  pa_ax6r        syl6eqr
  (0)  eqeq1d    biimprd  com12    x  B  addcom  (0)  eqeq1i   syl6ib
  x  19.22d
mpi
B  (0)  x  df-le  sylibr
B  eq0le0        sylibr
)

## <summary> Multiplication cancellation with nonzero multiplicand </summary>
thm (mulcan () ()
  (<-> (= (* A (S C)) (* B (S C))) (= A B))
  (* A (S C)) (* B (S C)) lesym
    A C B lemul5
      B C A lemul5
    anbi12i
  bitri
    A B lesym
  bitr4i
)

## <summary> Cancellation for multiplication (over nonzero multiplicand) </summary>
thm (mulcan2.1 () () (-> (<= A B) (-> (= (* (S C) A) (* (S C) B)) (= A B)))
  A  B  x  df-le  biimpi
    (+ A x)  B  (S C)  muleq2
    (S C)  A  x  distr  (* (S C) B)  eqeq1i  sylib  eqcomd
      (* (S C) A)  pa_ax3
      (* (S C) B)  eqeq1i  biimpri  eqcomd
      anim12i    (* (S C) B)  (+ (* (S C) A) (* (S C) x))  (+ (* (S C) A) (0))  ax-eqtr  syl
      (* (S C) A)  (* (S C) x)  (0)  addcan2  sylib
      C  x  mul0  syl     A   addeq2d
      ex  anc2li    (+ A x)  B  (+ A (0))  ax-eqtr  syl6   A  pa_ax3  B   eqeq2i  biimpi  eqcomd syl6
    x  19.22i  syl
       19.9d
)

# number 127.5
thm (mulcan2 () () (-> (= (* (S A) B) (* (S A) C)) (= B C))
  B  C  letot
    B  C  A  mulcan2.1
      C  B  A  mulcan2.1
      (* (S A) C)  (* (S A) B)  eqcom  (= C B)   imbi1i  sylib
      imp  eqcomd  ex

    jaoi
  ax-mp
)

thm (mulcant () ()
  (-> (< (0) C) (<-> (= (* A C) (* B C)) (= A B)))

  (0) C axlttri C nn0nlt0 (= (0) C) biorfi  (0) C eqcom bitr3i notbii bitri
  C x lefoo ori sylbi
  x a1suc x (1) addcom eqtr C eqeq1i x exbii sylibr

    (S x) C A muleq2 (S x) C B muleq2 eqeq12d
    A x B mulcan syl5rbbr x 19.23ai
  syl
)

thm (mulcant2 () ()
  (-> (< (0) C) (<-> (= (* C A) (* C B)) (= A B)))
  C A B mulcant
  A C mulcom B C mulcom eqeq12i syl5bbr
)

export (PEANO /peano/peano_ax.ghi (PROP PEANO_MIN) "")

# == Some naive set theory ==

import (NAIVE_SET /peano/naive_set.ghi (PROP PEANO_MIN PEANO) "")

tvar (set S T U V S0 S1 S2 S3 S4 S5 S6 S7 S8 S9)
tvar (wff zi si)



thm (eqri ((S x) (T x))
  (hyp (<-> (e. x S) (e. x T)))
  (=_ S T)
  hyp x gen S T x df-seq mpbir
)

# Set equality is reflexive
## <title> Reflexive Property </title>
thm (seqid () () (=_ S S)
  (e. x S)  biid  x gen
  S  S  x  df-seq  biimpri  ax-mp
)

## <title> Commutative Property of Set Equality </title>
## <table>
##   (<-> (=_ <r> S <g> T) (=_ <g> T <r> S))
## </table>
## <suggest> right('Commute', '=') </suggest>
thm (seqcom () () (<-> (=_ S T) (=_ T S))
  S  T  x  df-seq
    (e. x T)  (e. x S)  bicom
    x albii
  bitr4i
  T  S  x  df-seq
  bitr4i
)

## <title> Commutative Property of Set Equality </title>
## <table>
##   (=_ <r> S <g> T)
##   (=_ <g> T <r> S)
## </table>
thm (seqcomi () (hyp (=_ S T)) (=_ T S)
  hyp
  S T seqcom
  mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (A. x  [ ps ]   ]    ] ))
##   (->            [ ps ]   [ ch ] )
##   (<-> ph (A. x  [    [   [ ch ] ))
## </table>
thm (ImpReplaceBi1Al1 () (
     replacee (<-> ph (A. x ps))
     substitution (-> ps ch)) 
     (-> ph (A. x ch))
  replacee substitution
  x 19.20i
  ImpReplaceBi1
)

## <title> Transitive Property </title>
## <suggest> right('Simplify', '=') </suggest>
thm (seqtr () () (-> (/\ (=_ S T) (=_ T U)) (=_ S U))
  S T x df-seq
  T U x df-seq
  pm3.2i  
  ## <d>
    (=_ S T) (A. x (<-> (e. x S) (e. x T))) (=_ T U) (A. x (<-> (e. x T) (e. x U))) pm4.38
    ax-mp
  ## </d>
  
  ## <d 'Distributive Property '>
    x (<-> (e. x S) (e. x T)) (<-> (e. x T) (e. x U)) 19.26
    ## <d 'Commutative Property'>
      (A. x (/\ (<-> (e. x S) (e. x T)) (<-> (e. x T) (e. x U)))) (/\ (A. x (<-> (e. x S) (e. x T))) (A. x (<-> (e. x T) (e. x U)))) bicom
      mpbi
    ## </d 'Commutative Property'>
    bitri
  ## </d 'Distributive Property '>
  
  ## <d 'Transitive Property '>
    (e. x S) (e. x T) (e. x U) bitr
    ImpReplaceBi1Al1
  ## </d 'Transitive Property '>

  S U x df-seq bicomi  
  sylib
)

## <title> Equivalence over Element Of </title>
## <table>
##   (=       A ]    ] [     B ] )
##   (<-> (e. A ] S) ] [ (e. B ] S))
## </table>
thm (eleq1i () (hyp (= A B)) (<-> (e. A S) (e. B S))
  hyp
  A B S ax-eleq1
  ax-mp
)
thm (eleq1d ()
  (h (-> ph (= A B)))
  (-> ph (<-> (e. A S) (e. B S))) 
  h A B S ax-eleq1 syl
)
thm (eleq2 () ()
  (-> (=_ S T) (<-> (e. A S) (e. A T)))
  S T x df-seq
    x A S ax-eleq1 x A T ax-eleq1 bibi12d
  cla4g sylbi
)

## <title> Equivalence over Element Of </title>
## <table>
##   (=_        [ S  ] [       [ T )
##   (<-> (e. A [ S) ] [ (e. A [ T ))
## </table>
thm (eleq2i ()
  (hyp (=_ S T))
  (<-> (e. A S) (e. A T))
  hyp S T A eleq2 ax-mp
)
thm (eleq2d ()
  (h (-> ph (=_ S T)))
  (-> ph (<-> (e. A S) (e. A T)))
  h S T A eleq2 syl
)
## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (E. x (/\ ch (/\  [ th ]   ]    ]  et)))))
##   (<->                            [ th ]   [ ta ] )
##   (-> ph (-> ps (E. x (/\ ch (/\  [    [   [ ta ]  et)))))
## </table>
thm (BiReplaceImp1Imp1Ex1An1An0 () (
     replacee (-> ph (-> ps (E. x (/\ ch (/\ th et)))))
     substitution (<-> th ta)) 
     (-> ph (-> ps (E. x (/\ ch (/\ ta et)))))
  replacee
  substitution
et anbi1i
ch anbi2i
x exbii
ps imbi2i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (E. x (/\  [ ch ]   ]    ]  ta))))
##   (<->                     [ ch ]   [ th ] )
##   (-> ph (-> ps (E. x (/\  [    [   [ th ]  ta))))
## </table>
thm (BiReplaceImp1Imp1Ex1An0 () (
     replacee (-> ph (-> ps (E. x (/\ ch ta))))
     substitution (<-> ch th)) 
     (-> ph (-> ps (E. x (/\ th ta))))
  replacee
  substitution
ta anbi1i
x exbii
ps imbi2i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (E. x (/\ ch (/\ (-.  [ th ]   ]    ] ) et)))))
##   (<->                                [ th ]   [ ta ] )
##   (-> ph (-> ps (E. x (/\ ch (/\ (-.  [    [   [ ta ] ) et)))))
## </table>
thm (BiReplaceImp1Imp1Ex1An1An0Not0 () (
     replacee (-> ph (-> ps (E. x (/\ ch (/\ (-. th) et)))))
     substitution (<-> th ta)) 
     (-> ph (-> ps (E. x (/\ ch (/\ (-. ta) et)))))
  replacee
  substitution
con4biir
et anbi1i
ch anbi2i
x exbii
ps imbi2i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (E. x (/\ ch (/\ th  [ ta ]   ]    ] )))))
##   (<->                               [ ta ]   [ et ] )
##   (-> ph (-> ps (E. x (/\ ch (/\ th  [    [   [ et ] )))))
## </table>
thm (BiReplaceImp1Imp1Ex1An1An1 () (
     replacee (-> ph (-> ps (E. x (/\ ch (/\ th ta)))))
     substitution (<-> ta et)) 
     (-> ph (-> ps (E. x (/\ ch (/\ th et)))))
  replacee
  substitution
th anbi2i
ch anbi2i
x exbii
ps imbi2i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (E. x  [ ps ]   ]    ] ))
##   (->            [ ps ]   [ ch ] )
##   (<-> ph (E. x  [    [   [ ch ] ))
## </table>
thm (ImpReplaceBi1Ex1 () (
     replacee (<-> ph (E. x ps))
     substitution (-> ps ch)) 
     (-> ph (E. x ch))
  replacee
  substitution
x 19.22i
ph biim2i
ax-mp
)

thm (abid ()
  (hyp (rwff x ph))
  (<-> (e. x ({|} x ph)) ph)
  x x ph ax-elab
    hyp x ph df-rwff mpbi a4i
  bitr4i
)

thm (elab ((A x) (ps x))
  (hyp (-> (= x A) (<-> ph ps)))
  (<-> (e. A ({|} x ph)) ps)
  A x ph ax-elab
  hyp sbcie bitri
)

thm (elab2 ((A x) (ps x))
  (hyp1 (-> (= x A) (<-> ph ps))
   hyp2 (=_ S ({|} x ph)))
  (<-> (e. A S) ps)
  hyp2 A eleq2i hyp1 elab bitri
)

## <title> Remove Set Abstraction </title>
## <suggest> left('Simplify', '{|}') </suggest>
thm (elabid ((S x)) () (<-> (e. x ({|} x (e. x S))) (e. x S))
  x y S ax-eleq1
  rwffi
  abid
)

## <suggest> left('Simplify', '{|}') </suggest>
thm (removeab ((S x)) () (=_ ({|} x (e. x S)) S)
  x S elabid
  x gen  
  ## <d 'Definition of Set Equality '>
    ({|} x (e. x S)) S x df-seq bicomi
    mpbi
  ## </d 'Definition of Set Equality '>
)

## <title> Element in intersection is in both sets </title>
## <suggest> right('Distribute', 'R') left('Distribute', '-R') </suggest>
thm (elin () ()
  (<-> (e. A (i^i S T)) (/\ (e. A S) (e. A T)))

  x A S ax-eleq1 x A T ax-eleq1 anbi12d
    S T x df-in
  elab2
)

## <title> An element of a union is in one of the sets </title>
## <suggest> right('Distribute, 'R') left('Distribute', '-R') </suggest>
thm (elun () ()
  (<-> (e. A (u. S T)) (\/ (e. A S) (e. A T)))

  x A S ax-eleq1 x A T ax-eleq1 orbi12d
    S T x df-un
  elab2
)

thm (unc () () (-> (e. A S) (e. A (u. S T)))
  (e. A S) (e. A T) orc
  A S T elun  
  ## <d 'Infer Right to Left '>
    (e. A (u. S T)) (\/ (e. A S) (e. A T)) bi2
    ax-mp
  ## </d 'Infer Right to Left '>  
  syl
)

# Problem: this theorem verified, but is not true, without
# constraints (S x) (T x). Consider S = {x + 1}, T = {x + 2}.
# The problem was that df-seq lacked these constraints, but needs them.
# Fixed.
thm (dfss2 ((S x) (T x)) ()
  (<-> (C_ S T) (A. x (-> (e. x S) (e. x T))))

  S T df-ss
    (e. x S) (e. x T) pm4.71 (e. x S) (/\ (e. x S) (e. x T)) bicom bitri

      x S T elin
      (e. x S) bibi1i
    bitr4i x albii
    (i^i S T) S x df-seq bitr4i

  bitr4i
)

## <title> Substitution </title>
## <table>
##   (<-> ph (A. x  [ ps ]   ]    ] ))
##   (<->           [ ps ]   [ ch ] )
##   (<-> ph (A. x  [    [   [ ch ] ))
## </table>
thm (BiReplaceBi1Al1 () (
     replacee (<-> ph (A. x ps))
     substitution (<-> ps ch)) 
     (<-> ph (A. x ch))
  replacee substitution
  x albii
  bitri
)


## <title> Substitution </title>
## <table>
##   (<-> ph (A. x (->  [ ps ]   ]    ]  th)))
##   (<->               [ ps ]   [ ch ] )
##   (<-> ph (A. x (->  [    [   [ ch ]  th)))
## </table>
thm (BiReplaceBi1Al1Imp0 () (
     replacee (<-> ph (A. x (-> ps th)))
     substitution (<-> ps ch)) 
     (<-> ph (A. x (-> ch th)))
  replacee substitution
  th imbi1i
    BiReplaceBi1Al1
)

## <title> Substitution </title>
## <table>
##   (<-> ph (A. x (-> ps  [ ch ]   ]    ] )))
##   (<->                  [ ch ]   [ th ] )
##   (<-> ph (A. x (-> ps  [    [   [ th ] )))
## </table>
thm (BiReplaceBi1Al1Imp1 () (
     replacee (<-> ph (A. x (-> ps ch)))
     substitution (<-> ch th)) 
     (<-> ph (A. x (-> ps th)))
  replacee substitution
  ps imbi2i
  BiReplaceBi1Al1
)

thm (ssImplies () (hyp (rwff x ph) hyp2 (rwff x ps))  (<-> (C_ ({|} x ph) ({|} x ps)) (A. x (-> ph ps)))
  ({|} x ph) ({|} x ps) x dfss2
  hyp abid BiReplaceBi1Al1Imp0
  hyp2 abid   
  BiReplaceBi1Al1Imp1
)

## <title> Substitution </title>
## <table>
##   (<-> ph (A. x (<-> ps  [ ch ]   ]    ] )))
##   (<->                   [ ch ]   [ th ] )
##   (<-> ph (A. x (<-> ps  [    [   [ th ] )))
## </table>
thm (BiReplaceBi1Al1Bi1 () (
     replacee (<-> ph (A. x (<-> ps ch)))
     substitution (<-> ch th)) 
     (<-> ph (A. x (<-> ps th)))
  replacee
  substitution
  ps bibi2i
  x albii
  ph bibi2i
  mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (A. x (<->  [ ps ]   ]    ]  th)))
##   (<->                [ ps ]   [ ch ] )
##   (<-> ph (A. x (<->  [    [   [ ch ]  th)))
## </table>
thm (BiReplaceBi1Al1Bi0 () (
     replacee (<-> ph (A. x (<-> ps th)))
     substitution (<-> ps ch)) 
     (<-> ph (A. x (<-> ch th)))
  replacee
  substitution
th bibi1i
x albii
ph bibi2i
mpbi
)

## <title> Alpha conversion for set abstraction </title> 
thm (abeq ((ph y) (ps x))
  (h1 (-> (= x y) (<-> ph ps)))
  (=_ ({|} x ph) ({|} y ps))
  z  x  ph  ax-elab
  z  x  ph  y' df-subst    bitri
      z  y  ps  ax-elab
      z  y  ps  y' df-subst    bitri
          x  y  y'  ax-eqtr    ex
          y  x  y'  ax-eqtr    ex    eqcoms  impbid
          h1    anbi12d
          exalpha
          (= y' z)  anbi2i
          y'  exbii
      bitr4i
  bitr4i
  eqri
)

## <title> Equality theorem for set abstraction </title>
## <suggest> right('Infer', '{|}') </suggest>
thm (abbi2 () ()
    (-> (A. x (<-> ph ps)) (=_ ({|} x ph) ({|} x ps)))
    x  (<-> ph ps)  ax-4
    y  x  sbcbid
    y  x  ph  ax-elab    syl5bb
    y  x  ps  ax-elab    syl6bbr
    y  19.21ai   ({|} x ph)  ({|} x ps)  y  df-seq    biimpri    syl
)

## <title> Equivalence over set abstraction </title>
## <table>
##   (<->       [ ph  ] [        [ ps )
##   (=_ ({|} x [ ph) ] [ ({|} x [ ps ))
## </table>
thm (abbi2i () (h (<-> ph ps))
  (=_ ({|} x ph) ({|} x ps))
  h x gen x ph ps abbi2 ax-mp
)

thm (seqseq1i () (hyp (=_ S T)) (<-> (=_ S U) (=_ T U))
  S U x df-seq
  hyp
  S T x df-seq
  mpbi
  x (<-> (e. x S) (e. x T)) ax-4
  ax-mp
  BiReplaceBi1Al1Bi0
  T U x df-seq

  ## <d>
    bicomi
  ## </d>

  bitri
)

thm (seqseq2i () (hyp (=_ S T)) (<-> (=_ U S) (=_ U T))
  U S x df-seq
  hyp
  S T x df-seq
  mpbi
  x (<-> (e. x S) (e. x T)) ax-4
  ax-mp
  BiReplaceBi1Al1Bi1
  U T x df-seq
  ## <d>
    bicomi
  ## </d>
  bitri
)

## <title> Substitution </title>
## <table>
##   (=_ S ({|} x  [ ph ]   ]    ] ))
##   (<->          [ ph ]   [ ps ] )
##   (=_ S ({|} x  [    [   [ ps ] ))
## </table>
thm (BiReplaceSeq1Ab1 () (
     replacee (=_ S ({|} x ph))
     substitution (<-> ph ps)) 
     (=_ S ({|} x ps))
  replacee
  substitution
x abbi2i
S seqseq2i
mpbi
)

## <title> Definition of Empty Set </suggest>
## <suggest> left('Simplify', '∅') right('Define', '∅') </suggest>
thm (df-emptysetF () () (=_ ({/}) ({|} x (F)))
  x df-emptyset
  x eqid
  biTrue  
  ## <d 'Negate Both Sides '>
    (= x x) (T) notbi
    mpbi
    df-fal
    ## <d 'Commutative Property'>
      (F) (-. (T)) bicom
      mpbi
    ## </d 'Commutative Property'>
    bitri
  ## </d 'Negate Both Sides '>  
  BiReplaceSeq1Ab1
)

## <title> Empty Set Contains No Elements </title>
thm (noel () ()
  (-. (e. A ({/})))

  A eqid
    (= x A) id (= x A) id eqeq12d notbid
      x df-emptyset
    elab2
  con2bii mpbi
)

## <title> Singleton has One Element </title>
## <suggest> right('Simplify', '=') </suggest>
thm (elsnc () ()
  (<-> (e. A ({} B)) (= A B))
  x A B eqeq1
    B x df-sn
  elab2
)

## <title> Singleton has One Element </title>
thm (snid () () (e. A ({} A))
  A eqid
  A A elsnc
  mpbir
)

## <title> Subset and Element Of Equivalence <title>
## <suggest> left('Simplify', '∈') right('Infer', '⊆') </suggest>
thm (elSubset () () (<-> (e. A S) (C_ ({} A) S))
  x A S ax-eleq1  
  ## <d 'Infer Right to Left '>
    (e. x S) (e. A S) bi2
    syl
  ## </d 'Infer Right to Left '>
  com12
  x gen
  x (e. A S) (-> (= x A) (e. x S)) 19.21  
  mpbi
  ({} A) S x dfss2 
  ## <d 'Singleton has One Element '>
    x A elsnc
    BiReplaceBi1Al1Imp0
  ## </d 'Singleton has One Element '>  
  ## <d 'Commutative Property '>
    (C_ ({} A) S) (A. x (-> (= x A) (e. x S))) bicom
    mpbi
  ## </d 'Commutative Property '>
  
  sylib

  ({} A) S x dfss2 
  x A ({} A) ax-eleq1
  x A S ax-eleq1
  imbi12d
  cla4g
  ImpReplaceBi1
  
  A snid
  
  (e. A S) impRemove1
  (C_ ({} A) S) imbi2i
  mpbi
  impbii
)

## <title> Equality deduction for set abstraction </title>
thm (abbi2d ((ph x)) (h (-> ph (<-> ps ch)))
  (-> ph (=_ ({|} x ps) ({|} x ch)))
  h x 19.21ai x ps ch abbi2 syl
)

## <title> Substitution </title>
## <table>
##   (=_  [ S ]   ]   ]  U)
##   (=_  [ S ]   [ T ] )
##   (=_  [   [   [ T ]  U)
## </table>
thm (SeqReplaceSeq0 () (
     replacee (=_ S U)
     substitution (=_ S T)) 
     (=_ T U)
  replacee
  substitution
U seqseq1i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (=_  [ S ]   ]   ]  U))
##   (=_         [ S ]   [ T ] )
##   (-> ph (=_  [   [   [ T ]  U))
## </table>
thm (SeqReplaceImp1Seq0 () (
     replacee (-> ph (=_ S U))
     substitution (=_ S T)) 
     (-> ph (=_ T U))
  replacee
  substitution
U seqseq1i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (=_ S  [ T ]   ]   ] ))
##   (=_           [ T ]   [ U ] )
##   (-> ph (=_ S  [   [   [ U ] ))
## </table>
thm (SeqReplaceImp1Seq1 () (
     replacee (-> ph (=_ S T))
     substitution (=_ T U)) 
     (-> ph (=_ S U))
  replacee
  substitution
S seqseq2i
ph imbi2i
mpbi
)

thm (sneq () () (-> (= A B) (=_ ({} A) ({} B))) 
  (= A B) x alnfi
  A B x eqeq2
  x 19.20i  
  syl
  x (= x A) (= x B) abbi2     
  syl  
  ## <d>
    A x df-sn
    ## <d 'Commutative Property'>
      ({} A) ({|} x (= x A)) seqcom
      mpbi
    ## </d 'Commutative Property'>
    SeqReplaceImp1Seq0
  ## </d>
  ## <d>
    B x df-sn
    ## <d 'Commutative Property'>
      ({} B) ({|} x (= x B)) seqcom
      mpbi
    ## </d 'Commutative Property'>
    SeqReplaceImp1Seq1
  ## </d>
)

thm (sneqi () (hyp (= A B)) (=_ ({} A) ({} B))
  hyp
  A B sneq
  ax-mp
)

## <title> Substitution </title>
## <table>
##   (=_ S  [ T ]   ]   ] )
##   (=_    [ T ]   [ U ] )
##   (=_ S  [   [   [ U ] )
## </table>
thm (SeqReplaceSeq1 () (
     replacee (=_ S T)
     substitution (=_ T U)) 
     (=_ S U)
  replacee
  substitution
S seqseq2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (=_ U ({|} x (\/ (e. A  [ S ]   ]   ] ) ph)))
##   (=_                     [ S ]   [ T ] )
##   (=_ U ({|} x (\/ (e. A  [   [   [ T ] ) ph)))
## </table>
thm (SeqReplacerSeq0Ab1Or0El0 () (
     replacee (=_ U ({|} x (\/ (e. A S) ph)))
     substitution (=_ S T)) 
     (=_ U ({|} x (\/ (e. A T) ph)))
  replacee
  substitution
A eleq2i
ph orbi1i
x abbi2i
U seqseq2i
mpbi
)

thm (abNotRemove2 () (hyp (-. ph)) (=_ ({|} x ph) ({/}))
  hyp
  biTrue  
  ## <d 'Negate Both Sides '>
    (-. ph) (T) notbi
    mpbi
    ph notnotr
    bitr3icom
    df-fal
    ## <d 'Commutative Property'>
      (F) (-. (T)) bicom
      mpbi
    ## </d 'Commutative Property'>
    bitri
  ## </d 'Negate Both Sides '>
  x abbi2i  
  ## <d 'Definition of Empty Set '>
    x df-emptysetF
    ## <d 'Commutative Property'>
      ({/}) ({|} x (F)) seqcom
      mpbi
    ## </d 'Commutative Property'>
    SeqReplaceSeq1
  ## </d 'Definition of Empty Set '>
)

## <title> Equivalence over Union </title>
## <table>
##   (=_     S ]    ] [     T ] )
##   (=_ (u. S ] U) ] [ (u. T ] U))
## </table>
thm (uneq1i () (hyp (=_ S T)) (=_ (u. S U) (u. T U))
  S U x df-un
  hyp
  SeqReplacerSeq0Ab1Or0El0
 
  T U x df-un

  ## <d>
    (u. T U) ({|} x (\/ (e. x T) (e. x U))) seqcom
  ## </d>
  mpbi
  SeqReplaceSeq1
)

## <title> Substitution </title>
## <table>
##   (=_ U ({|} x (\/ ph (e. A  [ S ]   ]   ] ))))
##   (=_                        [ S ]   [ T ] )
##   (=_ U ({|} x (\/ ph (e. A  [   [   [ T ] ))))
## </table>
thm (SeqReplaceSeq0Ab1Or1El0 () (
     replacee (=_ U ({|} x (\/ ph (e. A S))))
     substitution (=_ S T)) 
     (=_ U ({|} x (\/ ph (e. A T))))
  replacee
  substitution
A eleq2i
ph orbi2i
x abbi2i
U seqseq2i
mpbi
)

## <title> Equivalence over Union </title>
## <table>
##   (=_       [ S  ] [       [ T)
##   (=_ (u. U [ S) ] [ (u. U [ T))
## </table>
thm (uneq2i () (hyp (=_ S T)) (=_ (u. U S) (u. U T))
  U S x df-un
  hyp  
  SeqReplaceSeq0Ab1Or1El0
  U T x df-un
  
  ## <d>
    (u. U T) ({|} x (\/ (e. x U) (e. x T))) seqcom
  ## </d>
  mpbi
  SeqReplaceSeq1
)

## <title> Substitution </title>
## <table>
##   (=_ U ({|} x (/\ (e. A  [ S ]   ]   ] ) ph)))
##   (=_                   [ S ]   [ T ] )
##   (=_ U ({|} x (/\ (e. A  [   [   [ T ] ) ph)))
## </table>
thm (SeqReplaceSeq0Ab1An0El0 () (
     replacee (=_ U ({|} x (/\ (e. A S) ph)))
     substitution (=_ S T)) 
     (=_ U ({|} x (/\ (e. A T) ph)))
  replacee
  substitution
A eleq2i
ph anbi1i
x abbi2i
U seqseq2i
mpbi
)

## <title> Equivalence over Intersection </title>
thm (inseq1 () () (-> (=_ S T) (=_ (i^i S U) (i^i T U)))
  S T x eleq2
  (e. x U) anbi1d
  x gen
  x (=_ S T) (<-> (/\ (e. x S) (e. x U)) (/\ (e. x T) (e. x U))) 19.21  
  mpbi
  
  ## <d 'Equality theorem for set abstraction '>
    x (/\ (e. x S) (e. x U)) (/\ (e. x T) (e. x U)) abbi2
    syl
  ## </d 'Equality theorem for set abstraction '>
  T U x df-in seqcomi  
  SeqReplaceImp1Seq1
  S U x df-in seqcomi  
  SeqReplaceImp1Seq0
)

thm (inseq1i () (hyp1 (=_ S T)) (=_ (i^i S U) (i^i T U))
  hyp1
  S T U inseq1
  ax-mp
)

## <title> Equivalence for ∩ </title> ##
thm (inseq2 () () (-> (=_ T U) (=_ (i^i S T) (i^i S U)))
  T U x eleq2
  (e. x S) anbi2d
  x abbi2d
  S T x df-in
  ## <d 'Commutative Property'>
    (i^i S T) ({|} x (/\ (e. x S) (e. x T))) seqcom
    mpbi
  ## </d 'Commutative Property'>
  SeqReplaceImp1Seq0
  S U x df-in
  ## <d 'Commutative Property'>
    (i^i S U) ({|} x (/\ (e. x S) (e. x U))) seqcom
    mpbi
  ## </d 'Commutative Property'>
  SeqReplaceImp1Seq1
)


thm (inseq1d () (
     hyp1 (-> ph (=_ S T)))
     (-> ph (=_ (i^i S U) (i^i T U)))
  hyp1
  S T U inseq1
  syl
)

thm (inseq2i () (
     hyp1 (=_ T U))
     (=_ (i^i S T) (i^i S U))
  hyp1
  T U S inseq2
  ax-mp
)

thm (inseq2d () (
     hyp1 (-> ph (=_ T U)))
     (-> ph (=_ (i^i S T) (i^i S U)))
  hyp1
  T U S inseq2
  syl
)

## <title> Substitution </title>
## <table>
##   (=_ U ({|} x (/\ ph (e. A  [ S ]   ]   ] ))))
##   (=_                        [ S ]   [ T ] )
##   (=_ U ({|} x (/\ ph (e. A  [   [   [ T ] ))))
## </table>
thm (SeqReplaceSeq0Ab1An1El0 () (
     replacee (=_ U ({|} x (/\ ph (e. A S))))
     substitution (=_ S T)) 
     (=_ U ({|} x (/\ ph (e. A T))))
  replacee
  substitution
A eleq2i
ph anbi2i
x abbi2i
U seqseq2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> (=_ (i^i  [ S ]   ]   ]  U) V) ph)
##   (=_            [ S ]   [ T ] )
##   (<-> (=_ (i^i  [   [   [ T ]  U) V) ph)
## </table>
thm (SeqReplaceBi0Seq0In0 () (
     replacee (<-> (=_ (i^i S U) V) ph)
     substitution (=_ S T)) 
     (<-> (=_ (i^i T U) V) ph)
  replacee
  substitution
U inseq1i
V seqseq1i
ph bibi1i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> (=_ S  [ T ]   ]   ] ) ph)
##   (=_         [ T ]   [ U ] )
##   (<-> (=_ S  [   [   [ U ] ) ph)
## </table>
thm (SeqReplaceBi0Seq1 () (
     replacee (<-> (=_ S T) ph)
     substitution (=_ T U)) 
     (<-> (=_ S U) ph)
  replacee
  substitution
S seqseq2i
ph bibi1i
mpbi
)

## <title> Equivalence over Subset </title>
## <table>
##   (=_     S ]    ] [     T ] )
##   (=_ (C_ S ] U) ] [ (C_ T ] U))
## </table>
thm (sseq1i () (hyp (=_ S T)) (<-> (C_ S U) (C_ T U))
  S U df-ss  
  ## <d>
    (C_ S U) (=_ (i^i S U) S) bicom
  ## </d>
  mpbi

  hyp  
  SeqReplaceBi0Seq0In0
  hyp
  
  SeqReplaceBi0Seq1
  T U df-ss

  ## <d>
    (C_ T U) (=_ (i^i T U) T) bicom
  ## </d>
  mpbi
  
  bitr3icom
  
  ## <d>
    (C_ T U) (C_ S U) bicom
  ## </d>
  mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> (=_ (i^i S  [ T ]   ]   ] ) V) ph)
##   (=_              [ T ]   [ U ] )
##   (<-> (=_ (i^i S  [   [   [ U ] ) V) ph)
## </table>
thm (SeqReplaceBi0Seq0In1 () (
     replacee (<-> (=_ (i^i S T) V) ph)
     substitution (=_ T U)) 
     (<-> (=_ (i^i S U) V) ph)
  replacee
  substitution
S inseq2i
V seqseq1i
ph bibi1i
mpbi
)

thm (sseq2i () (hyp (=_ S T)) (<-> (C_ U S) (C_ U T))
  U S df-ss  
  ## <d>
    (C_ U S) (=_ (i^i U S) U) bicom
  ## </d>
  mpbi
  hyp  
  
  SeqReplaceBi0Seq0In1

  U T df-ss
  
  ## <d>
    (C_ U T) (=_ (i^i U T) U) bicom
  ## </d>
  mpbi
  
  bitr3icom
  
  ## <d>
    (C_ U T) (C_ U S) bicom
  ## </d>
  mpbi
)

## <title> Commutative Property of Union </title>
## <suggest> right('Commute', '∪') </suggest>
thm (uncom () () (=_ (u. S T) (u. T S))
  ## <d>
    S T x df-un
  ## </d>
  ## <d 'Commutative Property of OR'>
    (e. x S) (e. x T) orcom
    BiReplaceSeq1Ab1
  ## </d>
  ## <d 'Definition of Union'>
    ## <d 'Definition of Union'>
      T S x df-un
      seqcomi
    ## </d 'Definition of Union'>
    SeqReplaceSeq1
  ## </d 'Definition of Union'>
)

## <title> Commutative Property of Intersection </title>
## <suggest> right('Commute', '∩') </suggest>
thm (incom () () (=_ (i^i S T) (i^i T S))
  ## <d>
    S T x df-in
  ## </d>
  ## <d 'Commutative Property of AND'>
    (e. x S) (e. x T) ancom
    BiReplaceSeq1Ab1
  ## </d>
  ## <d 'Definition of Intersection'>
    ## <d 'Definition of Intersection'>
      T S x df-in
      seqcomi
    ## </d 'Definition of Intersection'>
    SeqReplaceSeq1
  ## </d 'Definition of Intersection'>
)

## <title> Substitution </title>
## <table>
##   (<-> ph (/\ ps  [ ch ]   ]    ] ))
##   (<->            [ ch ]   [ th ] )
##   (<-> ph (/\ ps  [    [   [ th ] ))
## </table>
thm (BiReplaceBi1An1 () (
     replacee (<-> ph (/\ ps ch))
     substitution (<-> ch th)) 
     (<-> ph (/\ ps th))
  replacee
  substitution
ps anbi2i
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (/\  [ ps ]   ]    ]  th))
##   (<->         [ ps ]   [ ch ] )
##   (<-> ph (/\  [    [   [ ch ]  th))
## </table>
thm (BiReplaceBi1An0 () (
     replacee (<-> ph (/\ ps th))
     substitution (<-> ps ch)) 
     (<-> ph (/\ ch th))
  replacee
  substitution
th anbi1i
ph bibi2i
mpbi
)

## <title> Associative Property </title>
## <suggest> right('Associate', 'R') left('Associate', 'L') </suggest>
thm (inass () () (=_ (i^i (i^i S T) U) (i^i S (i^i T U)))
  x S (i^i T U) elin
  x T U elin
  BiReplaceBi1An1  
  ## <d>
    (e. x S) (e. x T) (e. x U) anass
    ## <d>
      (/\ (/\ (e. x S) (e. x T)) (e. x U)) (/\ (e. x S) (/\ (e. x T) (e. x U))) bicom
    ## </d>
    mpbi
  ## </d>
  bitri
  x (i^i S T) U elin
  x S T elin
  
    BiReplaceBi1An0
  
  ## <d>
    (e. x (i^i (i^i S T) U)) (/\ (/\ (e. x S) (e. x T)) (e. x U)) bicom
  ## </d>
  mpbi
  
  bitri
  x gen
  (i^i S (i^i T U)) (i^i (i^i S T) U)  x df-seq  
  
  ## <d>
    (=_ (i^i S (i^i T U)) (i^i (i^i S T) U)) (A. x (<-> (e. x (i^i S (i^i T U))) (e. x (i^i (i^i S T) U)))) bicom
  ## </d>
  mpbi
  mpbi

  ## <d>
    (i^i S (i^i T U)) (i^i (i^i S T) U) seqcom
  ## </d>
  mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (\/ ps  [ ch ]   ]    ] ))
##   (<->            [ ch ]   [ th ] )
##   (<-> ph (\/ ps  [    [   [ th ] ))
## </table>
thm (BiReplaceBi1Or1 () (
     replacee (<-> ph (\/ ps ch))
     substitution (<-> ch th)) 
     (<-> ph (\/ ps th))
  replacee
  substitution
ps orbi2i
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph  [ ps ]   ]    ] )
##   (<->     [ ps ]   [ ch ] )
##   (<-> ph  [    [   [ ch ] )
## </table>
thm (BiReplaceBi1 () (
     replacee (<-> ph ps)
     substitution (<-> ps ch)) 
     (<-> ph ch)
  replacee
  substitution
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (\/  [ ps ]   ]    ]  th))
##   (<->         [ ps ]   [ ch ] )
##   (<-> ph (\/  [    [   [ ch ]  th))
## </table>
thm (BiReplaceBi1Or0 () (
     replacee (<-> ph (\/ ps th))
     substitution (<-> ps ch)) 
     (<-> ph (\/ ch th))
  replacee
  substitution
th orbi1i
ph bibi2i
mpbi
)

## <title> Associative Property </title>
## <suggest> right('Associate', 'R') left('Associate', 'L') </suggest>
thm (unass () () (=_ (u. (u. S T) U) (u. S (u. T U)))
  x S (u. T U) elun
  x T U elun
  BiReplaceBi1Or1

## <d>
  (e. x S) (e. x T) (e. x U) orass
  ## <d>
    bicomi
  ## </d>
## </d>
  BiReplaceBi1
  x (u. S T) U elun
  x S T elun
  BiReplaceBi1Or0

## <d>
  bicomi
## </d>

BiReplaceBi1
x gen

  (u. S (u. T U)) (u. (u. S T) U)  x df-seq

## <d>
  bicomi
## </d>

mpbi
  
  ## <d>
    (u. S (u. T U)) (u. (u. S T) U) seqcom
  ## </d>
  mpbi
)

## <title> Distributive Property </title>
## <suggest> right('Distribute', 'L') left('Distribute', '-L') </suggest>
thm (undi () () (=_ (u. S (i^i T U)) (i^i (u. S T) (u. S U))) 
  x S (i^i T U) elun
  x T U elin  
  BiReplaceBi1Or1
  
  ## <d>
    (e. x S) (e. x T) (e. x U) ordi
  ## </d>
  bitri
  x S T elun    
  ## <d>
    bicomi
  ## </d>
  
  BiReplaceBi1An0
  x S U elun
  ## <d>
    bicomi
  ## </d>
  BiReplaceBi1An1

  x (u. S T) (u. S U) elin    
  ## <d>
    bicomi
  ## </d>
  
  bitri
  x gen  

  (u. S (i^i T U)) (i^i (u. S T) (u. S U)) x df-seq
  
  ## <d>
    bicomi
  ## </d>
  mpbi
 )

## <title> Distributive Property </title>
## <suggest> right('Distribute', 'R') left('Distribute', '-R') </suggest>
 thm (undir () () (=_ (u. (i^i T U) S) (i^i (u. T S) (u. U S))) 
  x (i^i T U) S elun
  x T U elin  
  BiReplaceBi1Or0
  
  ## <d>
    (e. x T) (e. x U) (e. x S) ordir
  ## </d>
  bitri
  x T S elun  
  ## <d>
    bicomi
  ## </d>
  
  BiReplaceBi1An0
  x U S elun  
    
  ## <d>
    bicomi
  ## </d>
  
  BiReplaceBi1An1
  x (u. T S) (u. U S) elin  
  ## <d>
    bicomi
  ## </d> 
  bitri

  x gen 
  (u. (i^i T U) S) (i^i (u. T S) (u. U S)) x df-seq  
  ## <d>
    bicomi
  ## </d>
  mpbi
)

## <title> Distributive Property </title>
## <suggest> right('Distribute', 'R') left('Distribute', '-R') </suggest>
thm (indir () () (=_ (i^i (u. T U) S) (u. (i^i T S) (i^i U S))) 
  x (u. T U) S elin
  x T U elun
  
  BiReplaceBi1An0
  
  ## <d>
    (e. x T) (e. x U) (e. x S) andir
  ## </d>
  bitri
  x T S elin  
  ## <d>
    bicomi
  ## </d>
  BiReplaceBi1Or0
  x U S elin  
  ## <d>
    bicomi
  ## </d>  
  BiReplaceBi1Or1
  x (i^i T S) (i^i U S) elun  
  ## <d>
    bicomi
  ## </d>
  
  bitri
  x gen  
  (i^i (u. T U) S) (u. (i^i T S) (i^i U S)) x df-seq
  
  ## <d>
    bicomi
  ## </d>
  mpbi
)

## <title> Distributive Property </title>
## <suggest> right('Distribute', 'L') left('Distribute', '-L') </suggest>
thm (indi () () (=_ (i^i S (u. T U)) (u. (i^i S T) (i^i S U)))
  x S (u. T U) elin
  x T U elun   
  BiReplaceBi1An1
  
  ## <d>
    (e. x S) (e. x T) (e. x U) andi
  ## </d>
  bitri
  
  ## <d>
    x S T elin
    ## <d>
      bicomi
    ## </d>
  ## </d>
  BiReplaceBi1Or0
  
  ## <d>
    x S U elin
    ## <d>
      bicomi
    ## </d>
  ## </d>
  BiReplaceBi1Or1
  
  ## <d>
    x (i^i S T) (i^i S U) elun
    ## <d>
      bicomi
    ## </d>
  ## </d>
  bitri

  x gen
  (i^i S (u. T U)) (u. (i^i S T) (i^i S U)) x df-seq    
  ## <d>
    bicomi
  ## </d>
  mpbi
)


## <summary> If an element is in a set, it is also in the set unioned with anything. </summary>
thm (unionAttach1 () (hyp (e. A S)) (e. A (u. S U))
  tru
  A S U elun
  hyp
   
  (e. A U) orRemove1
  (e. A (u. S U)) bibi2i
  mpbi
  mpbir
)

## <summary> If an element is in a set, it is also in the set unioned with anything. </summary>
thm (unionAttach2 () (hyp (e. A S)) (e. A (u. U S))
  tru
  A U S elun
  hyp
   
  (e. A U) orRemove2
  (e. A (u. U S)) bibi2i
  mpbi
  mpbir
)



## <title> Substitution </title>
## <table>
##   (<-> ph (=_  [ S ]   ]   ]  U))
##   (=_          [ S ]   [ T ] )
##   (<-> ph (=_  [   [   [ T ]  U))
## </table>
thm (SeqReplaceBi1Seq0 () (
     replacee (<-> ph (=_ S U))
     substitution (=_ S T)) 
     (<-> ph (=_ T U))
  replacee
  substitution
U seqseq1i
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (=_ (u.  [ S ]   ]   ]  U) V))
##   (=_              [ S ]   [ T ] )
##   (<-> ph (=_ (u.  [   [   [ T ]  U) V))
## </table>
thm (SeqReplaceBi1Seq0Un0 () (
     replacee (<-> ph (=_ (u. S U) V))
     substitution (=_ S T)) 
     (<-> ph (=_ (u. T U) V))
  replacee substitution
  U uneq1i
  SeqReplaceBi1Seq0
)

## <title> Substitution </title>
## <table>
##   (<-> (C_  [ S ]   ]   ]  U) ph)
##   (=_       [ S ]   [ T ] )
##   (<-> (C_  [   [   [ T ]  U) ph)
## </table>
thm (SeqReplaceBi0Ss0 () (
     replacee (<-> (C_ S U) ph)
     substitution (=_ S T)) 
     (<-> (C_ T U) ph)
  replacee substitution
  U sseq1i
  bitr3icom
)

## <title> Substitution </title>
## <table>
##   (<-> ph (=_ (u. S  [ T ]   ]   ] ) V))
##   (=_                [ T ]   [ U ] )
##   (<-> ph (=_ (u. S  [   [   [ U ] ) V))
## </table>
thm (SeqReplaceBi1Seq0Un1 () (
     replacee (<-> ph (=_ (u. S T) V))
     substitution (=_ T U)) 
     (<-> ph (=_ (u. S U) V))
  replacee substitution
  S uneq2i
  SeqReplaceBi1Seq0
)

## <summary> If a set is a subset of two sets, it is a subset of their union. </summary>
thm (unSubset () (hyp (C_ S U) hyp2 (C_ T U)) (C_ (u. S T) U)
  (u. S T) U df-ss
  ## <d 'Distributive Property '>
    S T U indir
    SeqReplaceBi1Seq0
  ## </d 'Distributive Property '>
  hyp  
  ## <d 'Definition of Subset '>
    S U df-ss
    mpbi
  ## </d 'Definition of Subset '>
  
    SeqReplaceBi1Seq0Un0
  hyp2  
  ## <d 'Definition of Subset '>
    T U df-ss
    mpbi
  ## </d 'Definition of Subset '>
    
    SeqReplaceBi1Seq0Un1
  
  (u. S T) seqid
  
  mpbirRemove
)

## <summary> If an element is not in two sets, it is not in the union of the sets. </summary>
thm (notInUnion () (hyp (-. (e. A S)) hyp2 (-. (e. A T))) (-. (e. A (u. S T)))
  A S T elun
  hyp 
  (e. A T) orNotRemove1
  (e. A (u. S T)) bibi2i
  mpbi
  hyp2  
  mtbirRemove
  # TODO: Apply the two hypotheses together.
)

## <summary> Proof that an element is not in a singleton. </summary>
thm (notInSingleton () (hyp (-. (= A B)))  (-. (e. A ({} B)))
  A B elsnc
  hyp  
  mtbirRemove
)

## <summary> Proof that an element is not in the union of singleton and another set. </summary>
thm (notInSingletonUnion () (hyp (-. (= A B)) hyp2 (-. (e. A S))) (-. (e. A (u. ({} B) S)))
  hyp  
  notInSingleton
  hyp2
  notInUnion
)

## <title> Substitution </title>
## <table>
##   (-> (-. (-.  [ ph ]   ]    ] )) ch)
##   (<->         [ ph ]   [ ps ] )
##   (-> (-. (-.  [    [   [ ps ] )) ch)
## </table>
thm (BiReplaceImp0Not0Not0 () (
     replacee (-> (-. (-. ph)) ch)
     substitution (<-> ph ps)) 
     (-> (-. (-. ps)) ch)
  replacee
  substitution
con4biir
con4biir
ch imbi1i
mpbi
)

## <title> Empty Set Intersection </title>
## <suggest> auto-right('Simplify', '∅') </suggest>
thm (emptyIn1 () () (=_ (i^i ({/}) S) ({/}))
  ## <d 'Definition of Intersection '>
    ({/}) S x df-in
  ## </d 'Definition of Intersection '>
  x noel
  (e. x S) anNotRemove1
  BiReplaceSeq1Ab1
  
  ## <d 'Definition of Empty Set '>
    x df-emptysetF
    ## <d 'Commutative Property'>
      ({/}) ({|} x (F)) seqcom
      mpbi
    ## </d 'Commutative Property'>
    SeqReplaceSeq1
  ## </d 'Definition of Empty Set '>
)

thm (emptyIn2 () () (=_ (i^i S ({/})) ({/}))
  S emptyIn1  
  ## <d 'Commutative Property '>
    ({/}) S incom
    SeqReplaceSeq0
  ## </d 'Commutative Property '>
)

## <title> Empty Set is a Subset </title>
## <suggest> full('Simplify', 'T') </suggest>
thm (emptyss () () (C_ ({/}) S)
  ## <d 'Definition of Subset '>
    ({/}) S df-ss
  ## </d 'Definition of Subset '>  
  ## <d 'Empty Set Intersection '>
    S emptyIn1
    SeqReplaceBi1Seq0
  ## </d 'Empty Set Intersection '> 
  ({/}) seqid
  mpbirRemove
)

thm (emptySnIn1 () (hyp (-. (e. A S))) (=_ (i^i ({} A) S) ({/}))
  (i^i ({} A) S) ({/}) x df-seq

  x noel    
  (e. x (i^i ({} A) S)) biNotRemove2
  x albii
  (=_ (i^i ({} A) S) ({/})) bibi2i
  mpbi

  x ({} A) S elin
  x A elsnc  
  BiReplaceBi1An0
  x A S ax-eleq1
  hyp  
  (e. x S) biNotRemove2
  (= x A) imbi2i
  mpbi
  con2i
  (= x A) anim2i
  sylbi
  (= x A) pm3.24  
  mtoRemove
  
  x gen  
  mpbirRemove
)

thm (emptySnIn2 () (hyp (-. (e. A S))) (=_ (i^i S ({} A)) ({/}))
  hyp
  emptySnIn1  
  ## <d>
    ({} A) S incom
  ## </d>
    SeqReplaceSeq0
)

## <title> Intersection is Idempotent </title>
## <suggest> right('Simplify', '∩') </suggest>
thm (inidm() () (=_ (i^i S S) S)
  (i^i S S) S x df-seq
  x S S elin
  (e. x S) anidm  
  bitri
  x gen  
  mpbirRemove
)

## <title> Union is Idempotent </title>
## <suggest> right('Simplify', '∪') </suggest>
thm (unidm() () (=_ (u. S S) S)
  ## <d>
    (u. S S) S x df-seq
    ## <d 'An element of a union is in one of the sets'>
      x S S elun
    ## </d 'An element of a union is in one of the sets'>
  ## </d>
  ## <d 'Disjunction is idempotent'>
    (e. x S) oridm
    bitri
  ## </d 'Disjunction is idempotent'>
  ## <d 'Definition of Set Equality'>
    x gen
    ## <d 'Definition of Set Equality'>
      mpbirRemove
    ## </d>
  ## </d 'Definition of Set Equality'>
)

thm (inEmpty1() () (=_ (i^i S ({/})) ({/}))
  (i^i S ({/})) ({/}) x df-seq
  x S ({/}) elin
  x noel
  
  (e. x S) anNotRemove2
  (e. x (i^i S ({/}))) bibi2i
  mpbi
  notfal  
  mtbirRemove

  (e. x ({/})) biNotRemove1
  x albii
  (=_ (i^i S ({/})) ({/})) bibi2i
  mpbi

  x noel
  x gen
    
  mpbirRemove
)

thm (inEmpty2() () (=_ (i^i ({/}) S) ({/}))
  S inEmpty1  
  ## <d>
    S ({/}) incom
  ## </d>
  SeqReplaceSeq0
)

## <title> Union Identity </title>
thm (unid() () (=_ (u. S ({/})) S)
  (u. S ({/})) S x df-seq
  x S ({/}) elun
  x noel
  (e. x S) orNotRemove2
  (e. x (u. S ({/}))) bibi2i
  mpbi
  x gen
  mpbirRemove
)

## <title> Union Identity </title>
thm (unidr() () (=_ (u. ({/}) S) S)
  (u. ({/}) S) S x df-seq
  x ({/}) S elun
  x noel
  (e. x S) orNotRemove1
  (e. x (u. ({/}) S)) bibi2i
  mpbi
  x gen
  mpbirRemove
)

## <title> All nonzero natural numbers are positive </title>
## <suggest> right('Equivalence', '<') </suggest>
thm (0inequalities () () (<-> (-. (= (0) A)) (< (0) A))
  A 0le    
      
      ## <d '≤ means < OR = '>
        (0) A leleo
        mpbi
      ## </d '≤ means < OR = '>
      
      ## <d 'Definition of OR '>
        (< (0) A) (= (0) A) df-or
        mpbi
        
        ## <d 'Negate Both Sides '>
          (-. (< (0) A)) (= (0) A) con34b
          mpbi
          (< (0) A) notnotr
          sylib
        ## </d 'Negate Both Sides '>
          
        ## <d 'Operator Conversion '>
          (0) A ltneq
        ## </d 'Operator Conversion '>
  impbii
)



## <title> Substitution </title>
## <table>
##   (<-> (-.  [ ph ]   ]    ] ) ch)
##   (<->      [ ph ]   [ ps ] )
##   (<-> (-.  [    [   [ ps ] ) ch)
## </table>
thm (BiReplaceBi0Not0 () (
     replacee (<-> (-. ph) ch)
     substitution (<-> ph ps)) 
     (<-> (-. ps) ch)
  replacee substitution
  con4biir
  bitr3icom
)

## <title> All nonzero natural numbers are positive </title>
## <suggest> right('Equivalence', '<') </suggest>
thm (0inequalities2 () () (<-> (-. (= A (0))) (-. (<= A (0))))
  A 0inequalities  
  ## <d 'Symmetric Property '>
    (0) A eqcom
    BiReplaceBi0Not0
  ## </d 'Symmetric Property '>
  
  ## <d 'Commute Inequality '>
    (0) A ltcom  
    bitri
  ## </d 'Commute Inequality '>
)

thm (df-interval-just ((A x) (A y) (B x) (B y)) () (=_ ({|} x (/\ (<= A x) (<= x B))) ({|} y (/\ (<= A y) (<= y B))))
  x y A leeq2
  x y B leeq1
  anbi12d
  abeq
)

## <title> Natural Number Interval Definition </title>
## <suggest> right('Define', '{...}') left('Simplify', '{...}') </suggest>
defthm (df-interval set ({...} A B) ((A x) (B x)) () (=_ ({...} A B) ({|} x (/\ (<= A x) (<= x B)))) 
  y A B x df-interval-just
)

thm (intervaleq1 () () (-> (= A C) (=_ ({...} A B) ({...} C B)))
  (= A C) x alnfi
  A C x leeq1
  x 19.20i  
  syl
  (<= A x) (<= C x) (<= x B) anbi1  
  ImpReplaceImp1Al1
  
  ## <d>
    x (/\ (<= A x) (<= x B)) (/\ (<= C x) (<= x B)) abbi2
    syl
  ## </d>
  
  ## <d 'Natural Number Interval Definition '>
    A B x df-interval
    ## <d 'Commutative Property'>
      ({...} A B) ({|} x (/\ (<= A x) (<= x B))) seqcom
      mpbi
    ## </d 'Commutative Property'>
    SeqReplaceImp1Seq0
  ## </d 'Natural Number Interval Definition '>
  
  ## <d 'Natural Number Interval Definition '>
    C B x df-interval
    ## <d 'Commutative Property'>
      ({...} C B) ({|} x (/\ (<= C x) (<= x B))) seqcom
      mpbi
    ## </d 'Commutative Property'>
    SeqReplaceImp1Seq1
  ## </d 'Natural Number Interval Definition '>
)

## <title> Equivalence over Interval </title>
## <table>
##   (=         A ]   ]          [ B ]   )
##   (=_ ({...} A ] C ] ) ({...} [ B ] C))
## </table>
thm (intervaleq1i () (hyp (= A C)) (=_ ({...} A B) ({...} C B))
  hyp
  A C B intervaleq1
  ax-mp
)

thm (intervaleq2 () () (-> (= B C) (=_ ({...} A B) ({...} A C)))
  (= B C) x alnfi
  B C x leeq2
  x 19.20i  
  syl
  (<= x B) (<= x C) (<= A x) anbi2  
  ImpReplaceImp1Al1
  
  ## <d>
    x (/\ (<= A x) (<= x B)) (/\ (<= A x) (<= x C)) abbi2
    syl
  ## </d>
  
  ## <d 'Natural Number Interval Definition '>
    A B x df-interval
    ## <d 'Commutative Property'>
      ({...} A B) ({|} x (/\ (<= A x) (<= x B))) seqcom
      mpbi
    ## </d 'Commutative Property'>
    SeqReplaceImp1Seq0
  ## </d 'Natural Number Interval Definition '>
  
  ## <d 'Natural Number Interval Definition '>
    A C x df-interval
    ## <d 'Commutative Property'>
      ({...} A C) ({|} x (/\ (<= A x) (<= x C))) seqcom
      mpbi
    ## </d 'Commutative Property'>
    SeqReplaceImp1Seq1
  ## </d 'Natural Number Interval Definition '>
)

## <title> Equality over Interval </title>
## <table>
##   (=          A ]   ]          [ B ]   )
##   (<-> ({...} A ] C ] ) ({...} [ B ] C))
## </table>
thm (intervaleq2i () (hyp (= B C)) (=_ ({...} A B) ({...} A C))
  hyp
  B C A intervaleq2
  ax-mp
)

## <title> Substitution </title>
## <table>
##   (<-> ph (/\ (\/  [ ps ]   ]    ]  th) ta))
##   (<->             [ ps ]   [ ch ] )
##   (<-> ph (/\ (\/  [    [   [ ch ]  th) ta))
## </table>
thm (BiReplaceBi1An0Or0 () (
     replacee (<-> ph (/\ (\/ ps th) ta))
     substitution (<-> ps ch)) 
     (<-> ph (/\ (\/ ch th) ta))
  replacee
  substitution
th orbi1i
ta anbi1i
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (/\ (\/ ps  [ ch ]   ]    ] ) ta))
##   (<->                [ ch ]   [ th ] )
##   (<-> ph (/\ (\/ ps  [    [   [ th ] ) ta))
## </table>
thm (BiReplaceBi1An0Or1 () (
     replacee (<-> ph (/\ (\/ ps ch) ta))
     substitution (<-> ch th)) 
     (<-> ph (/\ (\/ ps th) ta))
  replacee
  substitution
ps orbi2i
ta anbi1i
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (\/ ps (\/ ch  [ th ]   ]    ] )))
##   (<->                   [ th ]   [ ta ] )
##   (<-> ph (\/ ps (\/ ch  [    [   [ ta ] )))
## </table>
thm (BiReplaceBi1Or1Or1 () (
     replacee (<-> ph (\/ ps (\/ ch th)))
     substitution (<-> th ta)) 
     (<-> ph (\/ ps (\/ ch ta)))
  replacee
  substitution
ch orbi2i
ps orbi2i
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (\/ ps (\/ (/\ ch  [ th ]   ]    ] ) et)))
##   (->                        [ th ]   [ ta ] )
##   (<-> ph (\/ ps (\/ (/\ ch  [    [   [ ta ] ) et)))
## </table>
thm (ImpReplaceBi1Or1Or0An1 () (
     replacee (<-> ph (\/ ps (\/ (/\ ch th) et)))
     substitution (-> th ta)) 
     (-> ph (\/ ps (\/ (/\ ch ta) et)))
  replacee
  substitution
ch anim2i
et orim1i
ps orim2i
ph biim2i
ax-mp
)

## <title> Substitution </title>
## <table>
##   (-> ph (\/  [ ps ]   ]    ]  th))
##   (<->        [ ps ]   [ ch ] )
##   (-> ph (\/  [    [   [ ch ]  th))
## </table>
thm (BiReplaceImp1Or0 () (
     replacee (-> ph (\/ ps th))
     substitution (<-> ps ch)) 
     (-> ph (\/ ch th))
  replacee
  substitution
th orbi1i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (\/ (\/ ps (/\  [ ch ]   ]    ]  ta)) et))
##   (->                    [ ch ]   [ th ] )
##   (-> ph (\/ (\/ ps (/\  [    [   [ th ]  ta)) et))
## </table>
thm (ImpReplaceImp1Or0Or1An0 () (
     replacee (-> ph (\/ (\/ ps (/\ ch ta)) et))
     substitution (-> ch th)) 
     (-> ph (\/ (\/ ps (/\ th ta)) et))
  replacee
  substitution
ta anim1i
ps orim2i
et orim1i
ph imim2i
ax-mp
)

## <title> Substitution </title>
## <table>
##   (-> ph (\/ (\/ ps  [ ch ]   ]    ] ) ta))
##   (<->               [ ch ]   [ th ] )
##   (-> ph (\/ (\/ ps  [    [   [ th ] ) ta))
## </table>
thm (BiReplaceImp1Or0Or1 () (
     replacee (-> ph (\/ (\/ ps ch) ta))
     substitution (<-> ch th)) 
     (-> ph (\/ (\/ ps th) ta))
  replacee
  substitution
ps orbi2i
ta orbi1i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (\/ (/\ ps  [ ch ]   ]    ] ) ta))
##   (->                [ ch ]   [ th ] )
##   (-> ph (\/ (/\ ps  [    [   [ th ] ) ta))
## </table>
thm (ImpReplaceImp1Or0An1 () (
     replacee (-> ph (\/ (/\ ps ch) ta))
     substitution (-> ch th)) 
     (-> ph (\/ (/\ ps th) ta))
  replacee
  substitution
ps anim2i
ta orim1i
ph imim2i
ax-mp
)

thm (intervalSnLem () () (-> (/\ (<= A x) (<= x A)) (= x A))
  (/\ (<= A x) (<= x A)) biid  
  
  A x leleo
  BiReplaceBi1An0
  
  A x ltcom
    BiReplaceBi1An0Or0
  
  A x eqcom
    BiReplaceBi1An0Or1
  
  x A leleo
  BiReplaceBi1An1
  
  (-. (<= x A)) (= x A) (\/ (< x A) (= x A)) andir
  bitri
  
  (= x A) (< x A) (= x A) andi
  BiReplaceBi1Or1
  
  (= x A) anidm
    BiReplaceBi1Or1Or1
  
  x A ltneq
    ImpReplaceBi1Or1Or0An1
  
  (= x A) pm3.24
  
  (= x A) orNotRemove1
  (/\ (-. (<= x A)) (\/ (< x A) (= x A))) orbi2i
  (/\ (<= A x) (<= x A)) imbi2i
  mpbi
  
  (-. (<= x A)) (< x A) (= x A) andi
    BiReplaceImp1Or0
  
  x A gtneq
    ImpReplaceImp1Or0Or1An0
  
  (-. (= x A)) (= x A) ancom
    BiReplaceImp1Or0Or1
  
  (= x A) pm3.24
  
  (/\ (-. (<= x A)) (< x A)) orNotRemove2
  (= x A) orbi1i
  (/\ (<= A x) (<= x A)) imbi2i
  mpbi
  
  x A ltle
    ImpReplaceImp1Or0An1
  
  (-. (<= x A)) (<= x A) ancom
  BiReplaceImp1Or0
  
  (<= x A) pm3.24
  
  (= x A) orNotRemove1
  (/\ (<= A x) (<= x A)) imbi2i
  mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (/\ (-.  [ ps ]   ]    ] ) th))
##   (<->            [ ps ]   [ ch ] )
##   (-> ph (/\ (-.  [    [   [ ch ] ) th))
## </table>
thm (BiReplaceImp1An0Not0 () (
     replacee (-> ph (/\ (-. ps) th))
     substitution (<-> ps ch)) 
     (-> ph (/\ (-. ch) th))
  replacee
  substitution
con4biir
th anbi1i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (/\  [ ps ]   ]    ]  th))
##   (<->        [ ps ]   [ ch ] )
##   (-> ph (/\  [    [   [ ch ]  th))
## </table>
thm (BiReplaceImp1An0 () (
     replacee (-> ph (/\ ps th))
     substitution (<-> ps ch)) 
     (-> ph (/\ ch th))
  replacee
  substitution
th anbi1i
ph imbi2i
mpbi
)

thm (intervalSnLem2 () () (<-> (= x A) (/\ (<= A x) (<= x A)))
  x A eqge
  x A eqle     
  jca
  
  x A ltcom
    BiReplaceImp1An0Not0
  (<= A x) notnotr
    BiReplaceImp1An0
  A x intervalSnLem

  pm3.2i  
  (= x A) (/\ (<= A x) (<= x A)) dfbi2
  ## <d 'Commutative Property'>
    (<-> (= x A) (/\ (<= A x) (<= x A))) (/\ (-> (= x A) (/\ (<= A x) (<= x A))) (-> (/\ (<= A x) (<= x A)) (= x A))) bicom
    mpbi
  ## </d 'Commutative Property'>
  mpbi
)

## <title> Interval with One Element </title>
## <suggest> right('Simplify', '{}') </suggest>
thm (intervalSn () () (=_ ({...} A A) ({} A))
  A A x df-interval
  x A intervalSnLem2  
  (= x A) (/\ (<= A x) (<= x A)) bicom
  mpbi
  
  BiReplaceSeq1Ab1
  
  A x df-sn
  ## <d 'Commutative Property'>
    ({} A) ({|} x (= x A)) seqcom
    mpbi
  ## </d 'Commutative Property'>
  SeqReplaceSeq1
)

## <title> Substitution </title>
## <table>
##   (=_ ({|} x (\/ (e. A  [ S ]   ]   ] ) ph)) U)
##   (=_                   [ S ]   [ T ] )
##   (=_ ({|} x (\/ (e. A  [   [   [ T ] ) ph)) U)
## </table>
thm (SeqReplaceSeq0Ab1Or0El1 () (
     replacee (=_ ({|} x (\/ (e. A S) ph)) U)
     substitution (=_ S T)) 
     (=_ ({|} x (\/ (e. A T) ph)) U)
  replacee
  substitution
A eleq2i
ph orbi1i
x abbi2i
U seqseq1i
mpbi
)

## <title> Substitution </title>
## <table>
##   (=_ ({|} x (\/  [ ph ]   ]    ]  ch)) S)
##   (<->            [ ph ]   [ ps ] )
##   (=_ ({|} x (\/  [    [   [ ps ]  ch)) S)
## </table>
thm (BiReplaceSeq0Ab1Or0 () (
     replacee (=_ ({|} x (\/ ph ch)) S)
     substitution (<-> ph ps)) 
     (=_ ({|} x (\/ ps ch)) S)
  replacee
  substitution
ch orbi1i
x abbi2i
S seqseq1i
mpbi
)

## <title> Substitution </title>
## <table>
##   (=_ ({|} x (\/ ph (e. A  [ S ]   ]   ] ))) U)
##   (=_                      [ S ]   [ T ] )
##   (=_ ({|} x (\/ ph (e. A  [   [   [ T ] ))) U)
## </table>
thm (SeqReplaceSeq0Ab1Or1El1 () (
     replacee (=_ ({|} x (\/ ph (e. A S))) U)
     substitution (=_ S T)) 
     (=_ ({|} x (\/ ph (e. A T))) U)
  replacee
  substitution
A eleq2i
ph orbi2i
x abbi2i
U seqseq1i
mpbi
)

## <title> Substitution </title>
## <table>
##   (=_ ({|} x (\/ ph  [ ps ]   ]    ] )) S)
##   (<->               [ ps ]   [ ch ] )
##   (=_ ({|} x (\/ ph  [    [   [ ch ] )) S)
## </table>
thm (BiReplaceSeq0Ab1Or1 () (
     replacee (=_ ({|} x (\/ ph ps)) S)
     substitution (<-> ps ch)) 
     (=_ ({|} x (\/ ph ch)) S)
  replacee
  substitution
ph orbi2i
x abbi2i
S seqseq1i
mpbi
)

## <title> Substitution </title>
## <table>
##   (=_ S ({|} x (\/ (/\ ph  [ ps ]   ]    ] ) th)))
##   (<->                     [ ps ]   [ ch ] )
##   (=_ S ({|} x (\/ (/\ ph  [    [   [ ch ] ) th)))
## </table>
thm (BiReplaceSeq1Ab1Or0An1 () (
     replacee (=_ S ({|} x (\/ (/\ ph ps) th)))
     substitution (<-> ps ch)) 
     (=_ S ({|} x (\/ (/\ ph ch) th)))
  replacee
  substitution
ph anbi2i
th orbi1i
x abbi2i
S seqseq2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (=_ S ({|} x (/\ ph  [ ps ]   ]    ] )))
##   (<->                 [ ps ]   [ ch ] )
##   (=_ S ({|} x (/\ ph  [    [   [ ch ] )))
## </table>
thm (BiReplaceSeq1Ab1An1 () (
     replacee (=_ S ({|} x (/\ ph ps)))
     substitution (<-> ps ch)) 
     (=_ S ({|} x (/\ ph ch)))
  replacee
  substitution
ph anbi2i
x abbi2i
S seqseq2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (=_ S ({|} x (\/ ph (/\ ps  [ ch ]   ]    ] ))))
##   (<->                        [ ch ]   [ th ] )
##   (=_ S ({|} x (\/ ph (/\ ps  [    [   [ th ] ))))
## </table>
thm (BiReplaceSeq1Ab1Or1An1 () (
     replacee (=_ S ({|} x (\/ ph (/\ ps ch))))
     substitution (<-> ch th)) 
     (=_ S ({|} x (\/ ph (/\ ps th))))
  replacee
  substitution
ps anbi2i
ph orbi2i
x abbi2i
S seqseq2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (=_ S ({|} x (\/ ph  [ ps ]   ]    ] )))
##   (<->                 [ ps ]   [ ch ] )
##   (=_ S ({|} x (\/ ph  [    [   [ ch ] )))
## </table>
thm (BiReplaceSeq1Ab1Or1 () (
     replacee (=_ S ({|} x (\/ ph ps)))
     substitution (<-> ps ch)) 
     (=_ S ({|} x (\/ ph ch)))
  replacee
  substitution
ph orbi2i
x abbi2i
S seqseq2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (=_ S ({|} x (\/ ph (\/ ps  [ ch ]   ]    ] ))))
##   (<->                        [ ch ]   [ th ] )
##   (=_ S ({|} x (\/ ph (\/ ps  [    [   [ th ] ))))
## </table>
thm (BiReplaceSeq1Ab1Or1Or1 () (
     replacee (=_ S ({|} x (\/ ph (\/ ps ch))))
     substitution (<-> ch th)) 
     (=_ S ({|} x (\/ ph (\/ ps th))))
  replacee
  substitution
ps orbi2i
ph orbi2i
x abbi2i
S seqseq2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-. (/\ ph  [ ps ]   ]    ] ))
##   (<->        [ ps ]   [ ch ] )
##   (-. (/\ ph  [    [   [ ch ] ))
## </table>
thm (BiReplaceNot0An1 () (
     replacee (-. (/\ ph ps))
     substitution (<-> ps ch)) 
     (-. (/\ ph ch))
  replacee
  substitution
ph anbi2i
con4biir
mpbi
)

## <title> Substitution </title>
## <table>
##   (=_ S ({|} x (/\ ph (\/  [ ps ]   ]    ]  th))))
##   (<->                     [ ps ]   [ ch ] )
##   (=_ S ({|} x (/\ ph (\/  [    [   [ ch ]  th))))
## </table>
thm (BiReplaceSeq1Ab1An1Or0 () (
     replacee (=_ S ({|} x (/\ ph (\/ ps th))))
     substitution (<-> ps ch)) 
     (=_ S ({|} x (/\ ph (\/ ch th))))
  replacee
  substitution
th orbi1i
ph anbi2i
x abbi2i
S seqseq2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (=_ S ({|} x (/\ ph (\/ ps  [ ch ]   ]    ] ))))
##   (<->                        [ ch ]   [ th ] )
##   (=_ S ({|} x (/\ ph (\/ ps  [    [   [ th ] ))))
## </table>
thm (BiReplaceSeq1Ab1An1Or1 () (
     replacee (=_ S ({|} x (/\ ph (\/ ps ch))))
     substitution (<-> ch th)) 
     (=_ S ({|} x (/\ ph (\/ ps th))))
  replacee
  substitution
ps orbi2i
ph anbi2i
x abbi2i
S seqseq2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-. (-.  [ ph ]   ]    ] ))
##   (<->     [ ph ]   [ ps ] )
##   (-. (-.  [    [   [ ps ] ))
## </table>
thm (BiReplaceNot0Not0 () (
     replacee (-. (-. ph))
     substitution (<-> ph ps)) 
     (-. (-. ps))
  replacee
  substitution
con4biir
con4biir
mpbi
)

## <title> Substitution </title>
## <table>
##   (=_ S ({|} x (/\  [ ph ]   ]    ]  ch)))
##   (<->              [ ph ]   [ ps ] )
##   (=_ S ({|} x (/\  [    [   [ ps ]  ch)))
## </table>
thm (BiReplaceSeq1Ab1An0 () (
     replacee (=_ S ({|} x (/\ ph ch)))
     substitution (<-> ph ps)) 
     (=_ S ({|} x (/\ ps ch)))
  replacee
  substitution
ch anbi1i
x abbi2i
S seqseq2i
mpbi
)

thm (emptyInterval () (hyp (-. (<= A B))) (=_ ({...} A B) ({/}))
  A B x df-interval
  hyp
  A x B letr
  ## <d 'Negate Both Sides '>
    (/\ (<= A x) (<= x B)) (<= A B) con34b
    mpbi
  ## </d 'Negate Both Sides '>
  ax-mp
  x abNotRemove2
  SeqReplaceSeq1
)



# Proofs in progress:

# thm (modlt () ()
#   (-> (< 0 B) (< (mod A B) B))
# ?)

# thm (modcyc () ()
#   (-> (< 0 B) (= (mod (+ A (* B C)) B) (mod A B)))
# ?)

# thm (modadd () ()
#   (-> (/\ (< 0 D) (= (mod A D) (mod B D)))
#    (= (mod (+ A C) D) (mod (+ B C) D)))
# ?)

# thm (divcan4 () ()
#   (-> (< 0 B) (= (div (* A B) B) A))
# ?)
#!

# == Ordered pair ==

# number 1.0
thm (opth1 () ()
   (-> (/\ (= A C) (= B D)) (= (<,> A B) (<,> C D)))
  A C B D addeq12 (+ A B) muleq1d
  A C B D addeq12 (+ A B) (+ C D) (+ C D) muleq2 syl eqtrd
  (= A C) (= B D) pm3.27
  addeq12d
  A B df-op C D df-op 3eqtr4g
)

# number 2.5
thm (nalexi () (hyp (-. (A. x (-. ph)))) (E. x ph)
  hyp x ph df-ex mpbir)

# number 4.0
thm (impexpi  () (hyp (-> (/\ ph ps) ch)) (-> ps (-> ph ch))
  hyp ancoms ps ph ch impexp mpbi)

## <title> Import-Export Theorem </title>
## <table>
##   (-> (/\ ph [ ps ] ) [ ch)
##   (-> ph (-> [ ps ]   [ ch)) 
## </table>
thm (impexpi2 () (hyp (-> (/\ ph ps) ch)) (-> ph (-> ps ch)) 
  hyp ph ps ch impexp mpbi
)

# number 7.0
thm (lemul3lem1 () (hyp (-> ph (= (+ A B) C))) (-> ph (<= A C))
  A B addge01t
   hyp
   A leeq2d
  mpbii
)
# number 8.0
thm (lemul3lem2 () (hyp (-> ph (<= (+ A B) C))) (-> ph (<= A C))
  A B addge01t ph a1i
   hyp
  jca
    A (+ A B) C letr
  syl)
# number 9.0
thm (exani ((ps x)) (hyp (-> ph ps)) (-> (E. x ph) ps)
  hyp
  x 19.22i
  x ps 19.9 sylib)
# number 10.0

## <title> Inequality & Multiplication </title>
thm (lemul3 () ()
  (-> (/\(<= A B) (<= C D)) (<= (* A C) (* B D)))
  A B x df-le C D y df-le anbi12i
  x (= (+ A x) B) (E. y (= (+ C y) D)) 19.41 bitr4i
    y (= (+ A x) B) (= (+ C y) D) 19.29
    y (= (+ A x) B) 19.3
    sylanbr
  x 19.22i  sylbi

  (+ A x) B (+ C y) D muleq12
    A x C y distrl
  syl5eqr
 lemul3lem1 lemul3lem2
 y exani x exani syl)

# number 11.0
## <title> Transitive Property </title>
## <suggest> right('Simplify', '< <') </suggest>
thm (lttr () ()
  (-> (/\ (< A B) (< B C)) (< A C))
  A B nnltp1let B C nnltp1let anbi12i biimpi
  B (1) addge01t
  (+ A (1)) B (+ B (1)) letr mpan2 (<= (+ B (1)) C) anim1i syl
  (+ A (1)) (+ B (1)) C letr syl
  A C nnltp1let sylibr)

# number 12.0
thm (addassrli () (h (= A (+ B (+ C D))))
   (= A (+ (+ B C) D))
   h
   B C D addass eqtr4)

thm (ltmul () () (
  -> (/\ (< A B) (< C D)) (< (* A C) (* B D)))
  A B nnltp1let C D nnltp1let anbi12i
  (+ A (1)) B (+ C (1)) D lemul3 sylbi

  (* A C) (+ (* (1) C) (* A (1))) addge01t
    (* A C) (* (1) C) (* A (1)) addass (* A C) leeq2i  mpbir
     (* A C) (+ (+ (* A C) (* (1) C)) (* A (1))) (1) leadd1 mpbi
    A (1) C (1) distrl addassrli
      (1) mulid (+ (+ (* A C) (* (1) C)) (* A (1))) addeq2i eqtr
      (+ (* A C) (1)) leeq2i
  mpbir
  jctil
  (+ (* A C) (1)) (* (+ A (1)) (+ C (1))) (* B D) letr syl
  (* A C) (* B D) nnltp1let sylibr)

## <summary> Squaring (of nonnegative numbers) is monotonic </summary>
thm (sqle () ()
  (<-> (<= A B) (<= (* A A) (* B B)))
  A B A B lemul3 anidms
  (* A A) (* B B) lenltt
    B A B A ltmul anidms con3i sylbi A B lenltt sylibr
  impbii)

## <title> Transitive Inequality </title>
thm (ltTrlti () (hyp (< A B)) (-> (< B C) (< A C))
  A B C lttr  
  hyp
  (< B C) anRemove1
  (< A C) imbi1i
  mpbi
)

## <title> Transitive Inequality </title>
thm (leTreti () (hyp (<= A B)) (-> (<= B C) (<= A C))
  A B C letr
  hyp
  (<= B C) anRemove1
  (<= A C) imbi1i
  mpbi
)

## <title> Transitive Inequality </title>
thm (geTrgei () (hyp (-. (< B A)))  (-> (<= B C) (<= A C))
  A B C letr
  hyp
  ## <d>
    B A ltcom
  ## </d>
  
  mtbi
    
  ## <d>
    (<= A B) notnotr
  ## </d>
  mpbi
  
  (<= B C) anRemove1
  (<= A C) imbi1i
  mpbi
)

## <title> Transitive Inequality </title>
thm (gtTrgti () (hyp (-. (<= B A)))  (-> (< B C) (< A C))
  A B C lttr
  hyp
  ## <d>
    B A lecom
  ## </d>
  
  mtbi
    
  ## <d>
    (< A B) notnotr
  ## </d>
  mpbi
  
  (< B C) anRemove1
  (< A C) imbi1i
  mpbi
)

## <title> Transitive Inequality </title>
## <table>
##   (<       [ B ]      [   [ C ] )
##   (-> (< A [ B ] ) (< [ A [ C ] ))
## </table>
thm (ltTrlt () (hyp (< B C)) (-> (< A B) (< A C))
  A B C lttr
  hyp
  (< A B) anRemove2
  (< A C) imbi1i
  mpbi
)

## <title> Transitive Inequality </title>
## <table>
##   (<        [ B ]      [   [ C ] )
##   (-> (<= A [ B ] ) (< [ A [ C ] ))
## </table>
thm (ltTrle () (hyp (< B C)) (-> (<= A B) (< A C))
  A B C lelttr
  hyp
  (<= A B) anRemove2
  (< A C) imbi1i
  mpbi
)

## <title> Transitive Inequality </title>
## <table>
##   (<       [ B ]      [   [ C ] )
##   (-> (= A [ B ] ) (< [ A [ C ] ))
## </table>
thm (ltTreq () (hyp (< B C)) (-> (= A B) (< A C))
  (= A B) id C lteq1d
  hyp
 
  (< A C) biRemove2
  (= A B) imbi2i
  mpbi
)

## <title> Transitive Inequality </title>
## <table>
##   (<=      [ B ]       [   [ C ] )
##   (-> (= A [ B ] ) (<= [ A [ C ] ))
## </table>
thm (leTreq () (hyp (<= B C)) (-> (= A B) (<= A C))
  (= A B) id C leeq1d
  hyp
 
  (<= A C) biRemove2
  (= A B) imbi2i
  mpbi
)

## <title> Transitive Inequality </title>
## <table>
##   (<=      [ B ]       [   [ C ] )
##   (-> (= A [ B ] ) (<= [ A [ C ] ))
## </table>
thm (leTrlt () (hyp (<= B C)) (-> (< A B) (< A C))
  A B C lelttr2
  hyp
  (< A B) anRemove2
  (< A C) imbi1i
  mpbi
)

## <title> Transitive Inequality </title>
## <table>
##   (<=       [ B ]       [   [ C ] )
##   (-> (<= A [ B ] ) (<= [ A [ C ] ))
## </table>
thm (leTrle () (hyp (<= B C)) (-> (<= A B) (<= A C))
  A B C letr
  hyp
  (<= A B) anRemove2
  (<= A C) imbi1i
  mpbi
)

## <title> Transitive Property </title>
## <suggest> right('Simplify', '=') </suggest>
thm (eqtr1 () () (-> (/\ (= B A) (= A C)) (= B C))
  A B C ax-eqtr  
  ## <d 'Symmetric Property '>
    A B eqcom
    BiReplaceImp0An0
  ## </d 'Symmetric Property '>
)

## <title> Transitive Inequality </title>
## <table>
##   (-. (<=       [ B ]            [   [ C ] ))
##   (-> (-. (<= A [ B ] )) (-. (<= [ A [ C ] )))
## </table>
thm (gtTrgt () (hyp (-. (<= B C))) (-> (-. (<= A B)) (-. (<= A C)))
  C B A lttr
  ## <d>
    C B ltcom
  ## </d>
  BiReplaceImp0An0
  ## <d>
    B A ltcom
  ## </d>
  BiReplaceImp0An1
  ## <d>
    C A ltcom
  ## </d>
  sylib
  ## <d>
    (-. (<= B C)) (-. (<= A B)) ancom
  ## </d>
  sylbi2
  hyp
  (-. (<= A B)) anRemove2
  (-. (<= A C)) imbi1i
  mpbi
)

## <title> Transitive Inequality </title>
## <table>
##   (-. (<        [ B ]            [   [ C ] ))
##   (-> (-. (<= A [ B ] )) (-. (<= [ A [ C ] )))
## </table>
thm (geTrgt () (hyp (-. (< B C))) (-> (-. (<= A B)) (-. (<= A C)))
  C B A lelttr
  ## <d>
    C B lecom
  ## </d>
  BiReplaceImp0An0
  ## <d>
    B A ltcom
  ## </d>
  BiReplaceImp0An1
  ## <d>
    C A ltcom
  ## </d>
  sylib
  ## <d>
    (-. (< B C)) (-. (<= A B)) ancom
  ## </d>
  sylbi2
  hyp
  (-. (<= A B)) anRemove2
  (-. (<= A C)) imbi1i
  mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (<->  [ ps ]   ]    ]  th))
##   (<->         [ ps ]   [ ch ] )
##   (-> ph (<->  [    [   [ ch ]  th))
## </table>
thm (BiReplaceImp1Bi0 () (
     replacee (-> ph (<-> ps th))
     substitution (<-> ps ch)) 
     (-> ph (<-> ch th))
  replacee
  substitution
  th bibi1i
  ph imbi2i
  mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (<-> ps  [ ch ]   ]    ] ))
##   (<->            [ ch ]   [ th ] )
##   (-> ph (<-> ps  [    [   [ th ] ))
## </table>
thm (BiReplaceImp1Bi1 () (
     replacee (-> ph (<-> ps ch))
     substitution (<-> ch th)) 
     (-> ph (<-> ps th))
  replacee
  substitution
  ps bibi2i
  ph imbi2i
  mpbi
)

thm (anbi2new () () (-> (<-> ps ph) (<-> (/\ ch ps) (/\ ch ph)))
  ps ph ch anbi1  
  ## <d>
    ps ch ancom
  ## </d>
  BiReplaceImp1Bi0
  
  ## <d>
    ph ch ancom
  ## </d>
  BiReplaceImp1Bi1
)

## <title> Transitive Inequality </title>
## <table>
##   (-. (<   [ B ]          [   [ C ] ))
##   (-> (= A [ B ] ) (-. (< [ A [ C ] )))
## </table>
thm (geTreq () (hyp (-. (< B C))) (-> (= A B) (-. (< A C)))
  (= A B) id C lteq1d

  (< A C) (< B C) notbi
  sylib
  hyp
  (-. (< A C)) biRemove2
  (= A B) imbi2i
  mpbi
)

## <title> Transitive Inequality </title>
## <table>
##   (-. (<=  [ B ]           [   [ C ] ))
##   (-> (= A [ B ] ) (-. (<= [ A [ C ] )))
## </table>
thm (gtTreq () (hyp (-. (<= B C))) (-> (= A B) (-. (<= A C)))
  (= A B) id C leeq1d

  (<= A C) (<= B C) notbi
  sylib
  hyp

  (-. (<= A C)) biRemove2
  (= A B) imbi2i
  mpbi
)

## <title> Transitive Inequality </title>
## <table>
##   (-. (<=      [ B ]            [   [ C ] ))
##   (-> (-. (< A [ B ] )) (-. (<= [ A [ C ] )))
## </table>
thm (gtTrge () (hyp (-. (<= B C))) (-> (-. (< A B)) (-. (<= A C)))
  C B A lelttr2

  ## <d>
    C B ltcom
  ## </d>
  BiReplaceImp0An0

  ## <d>
    B A lecom
  ## </d>
  BiReplaceImp0An1

  ## <d>
    C A ltcom
  ## </d>
  sylib
  hyp

  (-. (< A B)) anRemove1
  (-. (<= A C)) imbi1i
  mpbi
)

## <title> Transitive Inequality </title>
## <table>
##   (-. (<       [ B ]           [   [ C ] ))
##   (-> (-. (< A [ B ] )) (-. (< [ A [ C ] )))
## </table>
thm (geTrge () (hyp (-. (< B C))) (-> (-. (< A B)) (-. (< A C)))
  C B A letr
  ## <d>
    C B lecom
  ## </d>
  BiReplaceImp0An0
  ## <d>
    B A lecom
  ## </d>
  BiReplaceImp0An1
  ## <d>
    C A lecom
  ## </d>
  sylib

  hyp
  (-. (< A B)) anRemove1
  (-. (< A C)) imbi1i
  mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (-.  [ ps ]   ]    ] ))
##   (<->        [ ps ]   [ ch ] )
##   (-> ph (-.  [    [   [ ch ] ))
## </table>
thm (BiReplaceImp1Not0 () (
     replacee (-> ph (-. ps))
     substitution (<-> ps ch)) 
     (-> ph (-. ch))
  replacee
  substitution
con4biir
ph imbi2i
mpbi
)

thm (notSeqLem ((S x) (T x)) ()  (-> (E. x (/\ (e. x S) (-. (e. x T)))) (-. (=_ S T)))
 (e. x S) (e. x T) xorImp2
 x 19.22i  
 x (-. (<-> (e. x S) (e. x T))) df-ex  
  sylib  
  (<-> (e. x S) (e. x T)) notnotbi
  x albii  
  BiReplaceImp1Not0
  S T x df-seq  
  ## <d>
    (=_ S T) (A. x (<-> (e. x S) (e. x T))) bicom
  ## </d>
  mpbi
  
  BiReplaceImp1Not0
)

thm (sbc-elnotseq ((A x) (S x) (T x)) () (<-> ([/] A x (/\ (e. x S) (-. (e. x T)))) (/\ (e. A S) (-. (e. A T))))
  x A S ax-eleq1
  x A T ax-eleq1
  notbid
  anbi12d
  sbcie
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x  [ ps ]   ]    ] ))
##   (<->          [ ps ]   [ ch ] )
##   (-> ph (E. x  [    [   [ ch ] ))
## </table>
thm (BiReplaceImp1Ex1 () (
     replacee (-> ph (E. x ps))
     substitution (<-> ps ch)) 
     (-> ph (E. x ch))
  replacee substitution
  x exbii
  sylib
)

## <title> Sets are not equal </title>
## <suggest> right('Infer', '≠') </suggest>
thm (elnotseq () () (-> (/\ (e. A S) (-. (e. A T))) (-. (=_ S T)))
  A y (/\ (e. y S) (-. (e. y T))) x sbcex
  A y S T sbc-elnotseq     
  sylbi2
  x y S T sbc-elnotseq       
  BiReplaceImp1Ex1
  x S T notSeqLem  
  syl
)

## <title> Sets are not equal </title>
thm (elnotseqcom () () (-> (/\ (e. A S) (-. (e. A T))) (-. (=_ T S)))
  A S T elnotseq  
  ## <d 'Commutative Property '>
    S T seqcom
    BiReplaceImp1Not0
  ## </d 'Commutative Property '>
)

thm (exInAndOut ((A x)) (hyp (e. A S) hyp2 (-. (e. A T)))  (E. x (/\ (e. x S) (-. (e. x T))))
  x A tyex
  x A S ax-eleq1
  (e. x S) (e. A S) (-. (e. A T)) anbi1
  syl
  ## <d>
    (/\ (e. x S) (-. (e. A T))) (/\ (e. A S) (-. (e. A T))) bicom
  ## </d>
  sylib

  x A T ax-eleq1
  (e. x T) (e. A T) notbi
  sylib
  (-. (e. x T)) (-. (e. A T)) (e. x S) anbi2
  syl
  ## <d>
    (/\ (e. x S) (-. (e. x T))) (/\ (e. x S) (-. (e. A T))) bicom
  ## </d>
  sylib
  bitrd
  ImpReplaceEx1
  hyp
  hyp2
  pm3.2i

  (/\ (e. x S) (-. (e. x T))) biRemove1
  x exbii
  mpbi
)

## <title> Sets are not equal </title>
thm (notSeq () (hyp (e. A S) hyp2 (-. (e. A T))) (-. (=_ S T))
  hyp
  hyp2
  x exInAndOut 
  x S T notSeqLem
  ax-mp
)

thm (notSeq2Lem ((S x) (T x)) () (-> (E. x (/\ (e. x T) (-. (e. x S)))) (-. (=_ S T)))
 (e. x T) (e. x S) xorImp1
 x 19.22i

 x (-. (<-> (e. x S) (e. x T))) df-ex  
  sylib  
  (<-> (e. x S) (e. x T)) notnotbi
  x albii  
  BiReplaceImp1Not0
  S T x df-seq  
  ## <d>
    (=_ S T) (A. x (<-> (e. x S) (e. x T))) bicom
  ## </d>
  mpbi
  
  BiReplaceImp1Not0
)

## <title> Sets are not equal </title>
thm (notSeq2 () (hyp (-. (e. A S)) hyp2 (e. A T)) (-. (=_ S T))
  hyp2
  hyp
  notSeq
  ## <d>
    T S seqcom
  ## </d>
  mtbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (-. (A. x  [ ps ]   ]    ] )))
##   (<->               [ ps ]   [ ch ] )
##   (<-> ph (-. (A. x  [    [   [ ch ] )))
## </table>
thm (BiReplaceBi1Not0Al1 () (
     replacee (<-> ph (-. (A. x ps)))
     substitution (<-> ps ch)) 
     (<-> ph (-. (A. x ch)))
  replacee
  substitution
x albii
con4biir
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (-.  [ ps ]   ]    ] ))
##   (<->         [ ps ]   [ ch ] )
##   (<-> ph (-.  [    [   [ ch ] ))
## </table>
thm (BiReplaceBi1Not0 () (
     replacee (<-> ph (-. ps))
     substitution (<-> ps ch)) 
     (<-> ph (-. ch))
  replacee
  substitution
con4biir
ph bibi2i
mpbi
)

thm (notSsLem ((S x) (T x)) ()  (-> (E. x (/\ (e. x S) (-. (e. x T)))) (-. (C_ S T)))
  (e. x S) (e. x T) pm4.61
  bicomi
  biimpi
  x 19.22i
  x (-. (-> (e. x S) (e. x T))) df-ex
  (-> (e. x S) (e. x T))  notnotbi
  BiReplaceBi1Not0Al1

  S T x dfss2
  ## <d>
    (C_ S T) (A. x (-> (e. x S) (e. x T))) bicom
  ## </d>
  mpbi
  
  BiReplaceBi1Not0
  sylib
)



## <title> Substitution </title>
## <table>
##   (-> ph (A. x  [ ps ]   ]    ] ))
##   (<->          [ ps ]   [ ch ] )
##   (-> ph (A. x  [    [   [ ch ] ))
## </table>
thm (BiReplaceImp1Al1 () (
     replacee (-> ph (A. x ps))
     substitution (<-> ps ch)) 
     (-> ph (A. x ch))
  replacee substitution
  x albii
  sylib
)

## <title> Substitution </title>
## <table>
##   (-> ph (A. x (-.  [ ps ]   ]    ] )))
##   (<->              [ ps ]   [ ch ] )
##   (-> ph (A. x (-.  [    [   [ ch ] )))
## </table>
thm (BiReplaceImp1Al1Not0 () (
     replacee (-> ph (A. x (-. ps)))
     substitution (<-> ps ch)) 
     (-> ph (A. x (-. ch)))
  replacee substitution
  con4biir
  BiReplaceImp1Al1
)

## <title> Substitution </title>
## <table>
##   (<-> ph (-. (\/ ps  [ ch ]   ]    ] )))
##   (<->                [ ch ]   [ th ] )
##   (<-> ph (-. (\/ ps  [    [   [ th ] )))
## </table>
thm (BiReplaceBi1Not0Or1 () (
     replacee (<-> ph (-. (\/ ps ch)))
     substitution (<-> ch th)) 
     (<-> ph (-. (\/ ps th)))
  replacee substitution
  ps orbi2i
  BiReplaceBi1Not0
)

## <title> Subsets cannot have additional elements </title>
thm (subsetnoextra () () (-> (/\ (C_ S T) (-. (e. A T))) (-. (e. A S)))
  x S T notSsLem
  ## <d 'Negate Both Sides '>
    (E. x (/\ (e. x S) (-. (e. x T)))) (-. (C_ S T)) con34b
    mpbi
    (C_ S T) notnotr
    sylbi2
  ## </d 'Negate Both Sides '>

  ## <d 'Definition of ∃ '>
    x (/\ (e. x S) (-. (e. x T))) df-ex
    BiReplaceImp1Not0
  ## </d 'Definition of ∃ '>

  ## <d 'Double Negative '>
    (A. x (-. (/\ (e. x S) (-. (e. x T))))) notnotr
    sylib
  ## </d 'Double Negative '>


  ## <d 'DeMorgan's Law '>
    (e. x S) (-. (e. x T)) anor
    (e. x T) notnotr
    BiReplaceBi1Not0Or1
    BiReplaceImp1Al1Not0
  ## </d 'DeMorgan's Law '>


  ## <d 'Double Negative '>
    (\/ (-. (e. x S)) (e. x T)) notnotr
    BiReplaceImp1Al1
  ## </d 'Double Negative '>

  ## <d 'Definition of OR '>
    (-. (e. x S)) (e. x T) df-or
    (e. x S) notnotr
    BiReplaceBi1Imp0
    BiReplaceImp1Al1
  ## </d 'Definition of OR '>

  ## <d 'Negate Both Sides '>
    (e. x S) (e. x T) con34b
    BiReplaceImp1Al1
  ## </d 'Negate Both Sides '>
  x A T ax-eleq1
  notbid
  x A S ax-eleq1
  notbid
  imbi12d
  cla4g
  syl
  
  ## <d 'Import-Export Theorem '>
    (C_ S T) (-. (e. A T)) (-. (e. A S)) impexp
    ## <d 'Commutative Property'>
      (-> (/\ (C_ S T) (-. (e. A T))) (-. (e. A S))) (-> (C_ S T) (-> (-. (e. A T)) (-. (e. A S)))) bicom
      mpbi
    ## </d 'Commutative Property'>
    mpbi
  ## </d 'Import-Export Theorem '>
)

thm (ssid () () (C_ S S)
  ## <d>
  S inidm
  ## </d>
  S S df-ss
  ## <d>
    (C_ S S) (=_ (i^i S S) S) bicom
  mpbi
  mpbi
)

thm (setpm4.45 () () (=_ (i^i S (u. S T)) S)
  x S (u. S T) elin
  x S T elun  
  BiReplaceBi1An1
  (e. x S) (e. x T) pm4.45
  ## <d>
    (e. x S) (/\ (e. x S) (\/ (e. x S) (e. x T))) bicom
  ## </d>
  mpbi
  bitri
  x gen
  (i^i S (u. S T)) S  x df-seq
  ## <d>
    (=_ (i^i S (u. S T)) S) (A. x (<-> (e. x (i^i S (u. S T))) (e. x S))) bicom
  ## </d>
  mpbi
  mpbi
)

## <title> Subset of a Union </title>
thm (ssUnion () () (C_ S (u. S T))
  S seqid
  S (u. S T) df-ss
  S T setpm4.45  
  SeqReplaceBi1Seq0
  ## <d>
    (C_ S (u. S T)) (=_ S S) bicom
  ## </d>
  mpbi 
  mpbi
)

## <title> Not a Subset </title>
thm (notSs () (hyp (e. A S) hyp2 (-. (e. A T))) (-. (C_ S T))
  hyp
  hyp2
  x exInAndOut 
  x S T notSsLem
  ax-mp
)

## <title> Combine Set Inclusions </title>
thm (dfpssi () (hyp (C_ S T) hyp2 (-. (=_ S T))) (C. S T)
  hyp
  hyp2
  pm3.2i
  S T df-pss
  ## <d>
    (C. S T) (/\ (C_ S T) (-. (=_ S T))) bicom
  ## </d>
  mpbi 
  mpbi
)

## <title> Proper Subset Implies Subset </title>
## <suggest> right('Infer', '⊆') </suggest>
thm (pssSs () ()  (-> (C. S T) (C_ S T))
  (C_ S T) (-. (=_ S T)) pm3.26
  S T df-pss
  bicomi
  sylbi2
)

## <title> Proper Subset Implies Inequality </title>
## <suggest> right('Infer', '≠') </suggest>
thm (pssNeq () () (-> (C. S T) (-. (=_ S T)))
  (C_ S T) (-. (=_ S T)) pm3.27
  S T df-pss
  bicomi
  sylbi2
)

## <title> Not Subset Implies Not Proper Subset </title>
## <suggest> right('Infer', '⊄') </suggest>
thm (nssNpss () () (-> (-. (C_ S T)) (-. (C. S T)))
 (C_ S T) (-. (=_ S T)) pm3.26
 con3i
 S T df-pss
   
  ## <d>
    (C. S T) (/\ (C_ S T) (-. (=_ S T))) bicom
  ## </d>
  mpbi
  BiReplaceImp1Not0
)

## <title> Equality Implies Not Proper Subset </title>
## <suggest> right('Infer', '⊄') </suggest>
thm (seqNpss () () (-> (=_ S T) (-. (C. S T)))
 (C_ S T) (-. (=_ S T)) pm3.27
 con3i
 S T df-pss
   
  ## <d>
    (C. S T) (/\ (C_ S T) (-. (=_ S T))) bicom
  ## </d>
  mpbi
  BiReplaceImp1Not0
  (=_ S T) notnotbi  
  sylbi2
)

## <title> Two equal set are also subsets </title>
thm (seqss () () (-> (=_ S T) (C_ S T))
  S T S inseq2  
  ## <d 'Intersection is Idempotent '>
    S inidm
    SeqReplaceImp1Seq0
  ## </d 'Intersection is Idempotent '>
    
  ## <d 'Definition of Subset '>
    S T df-ss
  ## </d 'Definition of Subset '>
  
  ## <d 'Commutative Property '>
    (i^i S T) S seqcom
    bitri
  ## </d 'Commutative Property '>
  bicomi  
  sylib
)

# number 17.0
thm (muleq12d ()
  (hyp1 (-> ph (= A B))
   hyp2 (-> ph (= C D)))
  (-> ph (= (* A C) (* B D)))
  hyp1  hyp2
  jca
  A B C D muleq12
  syl
)
# number 18.0
thm (sqrtlem5 () ()
  (E. x (/\ (<= (* x x) (0)) (< (0) (* (S x) (S x)))))
   x (0) tyex
      (0) leid  (0) pa_ax5 (0) leeq1i  mpbir
   (= x (0)) id (= x (0)) id muleq12d  (0) leeq1d  mpbiri
     1nle0 (1) (0) lenltt mtbi notnotri
        (1) mulid  df-1 df-1  pm3.2i
        (1) (S (0)) (1) (S (0)) muleq12
      ax-mp eqtr3  (0) lteq2i
     mpbi
     (= x (0)) id  suceqd
     (= (S x) (S (0))) id (= (S x) (S (0))) id muleq12d syl (0) lteq2d mpbiri
  jca
  x 19.22i ax-mp
)
# number 19.0
thm (sqrtlem1 ((A x)) ()
  (-> (= y A)
     (<-> (E. x (/\ (<= (* x x) y) (< y (* (S x) (S x)))))
          (E. x (/\ (<= (* x x) A) (< A (* (S x) (S x)))))))
  (= y A) id (* x x) leeq2d
  (= y A) id (* (S x) (S x)) lteq1d
  anbi12d x exbid
)

## <title> Commutation of conjuncts in consequent </title> 
thm (ancomd () (h (-> ph (/\ ps ch)))
  (-> ph (/\ ch ps))
  h
  ps ch ancom
 sylib
)

# number 24.0
thm (sqrtlem6 () ()
  (-> (E. x (/\ (<= (* x x) y) (< y (* (S x) (S x)))))
      (E. x (/\ (<= (* x x) (S y)) (< (S y) (* (S x) (S x))))))

  # y < x' * x' <-> case A \/ case B
  y (* (S x) (S x)) nnltp1let    (+ y (1)) (* (S x) (S x)) lefoo3     bitri

  # spruce this up by adding (... and PH) to both sides
  biimpi (<= (* x x) y) anim1i ancoms ancomd

  # For MUCH later, to factor out the common AND
  (<= (* x x) y)
    (= (+ y (1)) (* (S x) (S x)))
      (<= (+ (+ y (1)) (1)) (* (S x) (S x)))
  andi

  # We don't need this AND term, but Case B does, so add it in here
  (<= (* x x) y) (= (+ y (1)) (* (S x) (S x))) pm3.27

  # Tuck this away for "later"...
  z (S x) tyex

  # Case A -> x' * x' = y'
  y a1suc eqcomi    (+ y (1)) (* (S x) (S x)) (S y)  eqeq1     mpbii

  # Case A -> x' * x' <= y'
  (* (S x) (S x)) leid
  (= (* (S x) (S x)) (S y)) id (* (S x) (S x)) leeq2d mpbii
  # Introduce z as x'
  (= z (S x)) id   (= z (S x)) id   muleq12d   (S y) leeq1d     biimprcd  syl


  # x' < x''
  (+ (S x) (1)) leid   (S x) a1suc  (+ (S x) (1)) leeq2i  mpbir   (S x) (S (S x)) nnltp1let    mpbir
  # x' * x' < x'' * x''
  (< (S x) (S (S x))) pm4.24  mpbi (S x) (S (S x)) (S x) (S (S x)) ltmul  ax-mp
  # Case A -> y' < x'' * x''
  (= (* (S x) (S x)) (S y)) id (* (S (S x)) (S (S x))) lteq1d mpbii
  (= z (S x)) id suceqd  (= z (S x)) id suceqd   muleq12d (S y) lteq2d
      biimprcd syl

  # Join it all up for case A
  jcad syl  z 19.21ai
  z (= z (S x)) (/\ (<= (* z z) (S y)) (< (S y) (* (S z) (S z))))  19.22 syl
  # ... and it's finally "later".
  mpi
  # Bring in the extra AND clause
  syl

  # Okay, time to consider Case B
  # Tuck this away for "later"...
  z x tyex

  # y <= y'
  y (1) addge02t y a1suc y (1) addcom eqtr y leeq2i mpbir
  # x*x <=y -> x*x <= y'
  (* x x) y (S y) letr mpan2

  # y + 1 + 1 < x' * x' -> y + 1 < x' * x'
  (+ y (1)) (* (S x) (S x)) nnltp1let  biimpri
  # ... -> y' < x' * x'
  y a1suc  (* (S x) (S x))  lteq1i  sylibr

  # Join up case B
  anim12i
  # Now to add the z
  # z=x -> z*z<=y' <-> x*x<=y'
  z x z x muleq12 anidms (S y) leeq1d
  # z=x -> y'<z'*z'<-> y'<x'*x'
  z x pa_ax2 biimpi   z x pa_ax2 biimpi muleq12d (S y) lteq2d
  # put it all together
  anbi12d biimprcd syl
  z 19.21ai
  z (= z x) (/\ (<= (* z z) (S y)) (< (S y) (* (S z) (S z))))  19.22  syl
  # And it's finally "later" again.
  mpi


  # Unify the cases
  jaoi
  # Now it is MUCH later, time to factor
  sylbi
  # Both cases are handled!
  syl

  # Existential plumbing
  x  19.22i 19.9d
  # alpha switch
  z x z x muleq12 anidms (S y) leeq1d
  z x pa_ax2 biimpi   z x pa_ax2 biimpi muleq12d (S y) lteq2d
  anbi12d exalpha sylib
)

## <title> Square root </title> 
thm (sqrt ((A x)) ()
   (E. x (/\ (<= (* x x) A) (< A (* (S x) (S x)))))
  z (0) x sqrtlem1
  z y x sqrtlem1
  z (S y) x sqrtlem1
  z A x sqrtlem1
  x sqrtlem5
  x y sqrtlem6
  finds
)

# 
## <title> Square root is monotonic </title> 
thm (sqlt () () (<-> (< A B) (< (* A A) (* B B)))
  B A sqle
  notbii
  (* B B) (* A A) lenltt
  notbii bitri
  (< (* A A) (* B B)) notnot bicomi bitri

  B A lenltt notbii
  bitr3i
  (< A B) notnot bicomi bitri bicomi
)

# number 28.0
thm (lesuc () ()
  (<-> (< A (S B)) (<= A B))
   A (S B) nnltp1let
   B a1suc   (+ A (1)) leeq2i bitri
   A B (1) leadd1 bicomi bitri
)

## <title> Convert between ≤ and < </title>
## <suggest> right('Equivalence', '≤-1') left('Equivalence', '<') </suggest>
thm (lePlus1 () () (<-> (< A (+ B (1))) (<= A B))
  A B lesuc
  B a1suc  
  EqReplaceBi0Lt1
)

## <title> Convert between ≤ and < </title>
## <suggest> right('Equivalence', '≤+1') left('Equivalence', '<-1') </suggest>
thm (ltle2 () () (<-> (< A B) (<= (+ A (1)) B))
  (+ A (1)) B lesuc
  B a1suc  
  EqReplaceBi0Lt1
  A B (1) ltadd1  
  ## <d>
    (< A B) (< (+ A (1)) (+ B (1))) bicom
  ## </d>
  mpbi
  bitr3icom
)

## <title> Convert between ≥ and > </title>
## <suggest> right('Equivalence', '≥') </suggest>
thm (gtge2 () () (<-> (-. (<= A B)) (-. (< A (+ B (1)))))
  B A ltle2  
 
  B A ltcom
  bitr3icom
  
  (+ B (1)) A lecom
  bitri
)

## <title> Numbers above 0 have predecessors </title>
thm (hasPredecessor((B x)) () (<-> (< (0) B) (E. x (= (S x) B)))
  (0) B ltle2  
  ## <d 'Evaluate'>
    (1) pa_ax3r
      EqReplaceBi1Le0
  ## </d 'Evaluate'>

  (1) B x df-le  
  bitri
  x a1suc  
  ## <d>
    x (1) addcom
  ## </d>
  EqReplaceEq1
  
  ## <d>
    (S x) (+ (1) x) eqcom
  ## </d>
  mpbi
  EqReplaceBi1Ex1Eq0
)


## <title> Square root is unique </title>
thm (sqrtuniq () ()
   (-> (/\ (/\ (<= (* A A) B) (< B (* (S A) (S A))))
           (/\ (<= (* C C) B) (< B (* (S C) (S C)))))
   (= A C))

   # Diddle with and ordering
   (<= (* C C) B)  (< B (* (S C) (S C)))  ancom
      (/\ (<= (* A A) B)    (< B (* (S A) (S A)))) anbi2i
   (<= (* A A) B) (< B (* (S A) (S A)))
      (< B (* (S C) (S C)))    (<= (* C C) B)    an4
   bitri

   (* A A) B (* (S C) (S C)) lelttr
   (* C C) B (* (S A) (S A)) lelttr ancoms anim12i
   sylbi

   # ... -> A < C' /\ C < A'
   A (S C) sqlt  C (S A) sqlt anbi12i  biimpri syl

   A C lesuc   C A lesuc
   anbi12i
   A C lesym bicomi bitri biimpi syl
)

# number 30.0
thm (opthlem1 () ()
   (/\ (<= (* (+ A B) (+ A B)) (+ (* (+ A B) (+ A B)) B))
       (< (+ (* (+ A B) (+ A B)) B) (* (S (+ A B)) (S (+ A B)))))
 # First part is easy
 (* (+ A B) (+ A B)) B  addge01t

   # A + B <= A + B
   (+ A B) leid
   # A + B <= (A + B)'
   (+ A B)  (1) addge01t  (+ A B) a1suc (+ A B) leeq2i mpbir
 # Now multiply them out
 (+ A B) (+ A B) (+ A B) (S (+ A B)) lemul3 mp2an

 # Throw in a free A on the right side
 (* (+ A B) (S (+ A B))) A addge01t
 (* (+ A B) (+ A B)) (* (+ A B) (S (+ A B))) (+  (* (+ A B) (S (+ A B))) A) letr mp2an
 # And add B to each side
 (* (+ A B) (+ A B)) (+ (* (+ A B) (S (+ A B))) A)  B leadd1 mpbi
 # Convert le to lt using suc
(+ (* (+ A B) (+ A B)) B) (+ (+ (* (+ A B) (S (+ A B))) A)  B) lesuc mpbir


 # Expand left side of (A+B)'**2 and distribute.
 (+ A B) a1suc (S (+ A B)) muleq1i
 (+ A B) (1) (S (+ A B)) distl eqtr
 # Remove 1*
 (S (+ A B)) (1) mulcom   (S (+ A B)) mulid eqtr3     (* (+ A B) (S (+ A B))) addeq2i eqtr
 # Expand (A+B)'
 (+ A B) a1suc (* (+ A B) (S (+ A B))) addeq2i eqtr
 # Pull the 1 out to the right and reassoc
 addassrli
 (* (+ A B) (S (+ A B))) A B addass (1) addeq1i eqtr4
 # Convert the +1 to a suc

 (+ (+ (* (+ A B) (S (+ A B))) A) B)  a1suc eqtr4
 (+ (* (+ A B) (+ A B)) B)  lteq2i mpbir

 pm3.2i
)
# number 31.0
thm (opthlem2 () ()
    (-> (= (<,> A B) (<,> C D)) (= (+ C D) (+ A B)))

    A B opthlem1

    A B df-op (<,> C D) eqeq1i biimpi  C D df-op  syl6eq
    (* (+ A B) (+ A B)) leeq2d
    A B df-op (<,> C D) eqeq1i biimpi  C D df-op  syl6eq
    (* (S (+ A B)) (S (+ A B))) lteq1d
    anbi12d
  mpbii

  C D opthlem1
  (+ C D) (+ (* (+ C D) (+ C D)) D) (+ A B) sqrtuniq
  mpan

  syl
)
# number 32.0
thm (opthlem3 () ()
    (-> (= (<,> A B) (<,> C D)) (= B D))
  A B C D opthlem2

  # Duplicate the conclusion
  (= (<,> A B) (<,> C D)) (= (+ C D) (+ A B)) anidmdbi mpbir
  # Square the conclusion
  (+ C D) (+ A B) (+ C D) (+ A B) muleq12 syl

  eqcomd B addeq1d eqcomd

  A B df-op (<,> C D) eqeq1i biimpi  C D df-op  syl6eq

  eqtrd
  (* (+ C D) (+ C D)) B D addcan2
  sylib
)

## <title> Ordered pair theorem </title>
thm (opth () ()
    (<-> (= (<,> A B) (<,> C D)) (/\ (= A C) (= B D)))
  A B C D opthlem2

    A B C D opthlem3
    A B D addcan2
  sylibr

  eqtrd
  C D A addcan
  sylib
  eqcomd
  A B C D opthlem3
  jca
  A C B D opth1



 impbii
)

# number 78.0
## <title> Ordered Pair Equality </title>
thm (opeq2 () () (-> (= A B) (= (<,> C A) (<,> C B)))
  A  B  C  addeq2
  A  B  C  addeq2  jca
  (+ C A)  (+ C B)  (+ C A)  (+ C B)  muleq12    syl
  ancri
  (* (+ C A) (+ C A))  (* (+ C B) (+ C B))  A  B  addeq12    syl
  C  A  df-op       syl5eq
  C  B  df-op       syl6eqr
)

thm (opeq2i () (
     hyp1 (= A B))
     (= (<,> C A) (<,> C B))
  hyp1
  A B C opeq2
  ax-mp
)

thm (opeq2d () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (<,> C A) (<,> C B)))
  hyp1
  A B C opeq2
  syl
)
# number 78.5
## <title> Ordered Pair Equality </title>
thm (opeq1 () () (-> (= A B) (= (<,> A C) (<,> B C)))
    A  B  C  addeq1    A  B  C  addeq1    jca
    (+ A C) (+ B C) (+ A C) (+ B C) muleq12    syl
    C  addeq1d
        A  C  df-op
    syl5eq
    B  C  df-op   syl6eqr
)

thm (opeq1i () (
     hyp1 (= A B))
     (= (<,> A C) (<,> B C))
  hyp1
  A B C opeq1
  ax-mp
)

thm (opeq1d () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (<,> A C) (<,> B C)))
  hyp1
  A B C opeq1
  syl
)

## <title> Ordered Pair Equality </title>
thm (opeq12 () () (-> (/\ (= A B) (= C D)) (= (<,> A C) (<,> B D)))
  A B C D addeq12
  A B C D addeq12
  muleq12d
  (= A B) (= C D) pm3.27
  addeq12d
  A C df-op
  eqcomi
  EqReplaceImp1Eq0
  B D df-op
  eqcomi
  EqReplaceImp1Eq1
)
## <title> Ordered Pair Equality </title>
thm (opeq12i () (hyp1 (= A B) hyp2 (= C D)) (= (<,> A C) (<,> B D))
  hyp1 hyp2 A B C D opeq12 mp2an
)
## <title> Ordered Pair Equality </title>
thm (opeq12d ()
  (hyp1 (-> ph (= A B))
   hyp2 (-> ph (= C D)))
  (-> ph (= (<,> A C) (<,> B D)))
  hyp1 hyp2 jca A B C D opeq12 syl
)
# number 79.0
thm (df-tail-just ((A x) (A y') (A y) (A z)) ()
    (= (iota ({|} x (E. y (= (<,> y x) A))))
       (iota ({|} z (E. y' (= (<,> y' z) A)))))
  x  z  y  opeq2  A  eqeq1d    y  exbid
  y  y'  z  opeq1    A  eqeq1d   exalpha   syl6bb    abeq
  ({|} x (E. y (= (<,> y x) A)))  ({|} z (E. y' (= (<,> y' z) A)))    ax-iotaeq    ax-mp
)
defthm  (df-tail nat (tail A) ((A x) (A y')) ()
  (= (tail A)  (iota ({|} x (E. y' (= (<,> y' x) A)))))
  z  y  A  x  y'  df-tail-just)

# number 80.0
## <title> Apply Tail Operator </title>
## <suggest> right('Simplify', 'Tl') </suggest>
thm (tailop () () (= (tail (<,> A B)) B)
  (<,> A B)  x  z  df-tail
    z  x  A  B  opth    z  exbii
    z  (= z A)  (= x B)  19.41   bitri
    z  A  tyex    (E. z (= z A))  (= x B)  ibar    ax-mp    bitr4i
    x  gen    x  (E. z (= (<,> z x) (<,> A B)))  (= x B)  abbi2    ax-mp
    ({|} x (E. z (= (<,> z x) (<,> A B))))  ({|} x (= x B))  ax-iotaeq    ax-mp
  eqtr
  B  x df-sn    ({} B)  ({|} x (= x B))  ax-iotaeq    ax-mp    eqtr4
  B  ax-iota    eqtr
)
# number 81.0
thm (df-head-just ((A x) (A y') (A y) (A z)) ()
    (= (iota ({|} x (E. y (= (<,> x y) A))))
       (iota ({|} z (E. y' (= (<,> z y') A)))))
  x  z  y  opeq1  A  eqeq1d    y  exbid
  y  y'  z  opeq2    A  eqeq1d   exalpha   syl6bb    abeq
  ({|} x (E. y (= (<,> x y) A)))  ({|} z (E. y' (= (<,> z y') A)))   ax-iotaeq    ax-mp
)
defthm  (df-head nat (head A) ((A x) (A y')) ()
  (= (head A)  (iota ({|} x (E. y' (= (<,> x  y') A)))))
  z  y  A  x  y'  df-head-just)

# number 83.0
## <title> Apply Head Operator </title>
## <suggest> right('Simplify', 'Hd') </suggest>
thm (headop () () (= (head (<,> A B)) A)
  (<,> A B)  x  z  df-head


    x  z  A  B  opth    z  exbii
    z  (= x A)  (= z B)  19.41r   bitri
    z  B  tyex    (E. z (= z B))  (= x A)  iba    ax-mp    bitr4i
    x  gen    x  (E. z (= (<,> x z) (<,> A B)))  (= x A)  abbi2    ax-mp
    ({|} x (E. z (= (<,> x z) (<,> A B))))  ({|} x (= x A))  ax-iotaeq    ax-mp
  eqtr
  A  x df-sn    ({} A)  ({|} x (= x A))  ax-iotaeq    ax-mp    eqtr4
  A  ax-iota    eqtr
)

## <title> Equality theorem for head </title>
thm (headeq () () (-> (= A B) (= (head A) (head B)))
  A  B  (<,> x y)  eqeq2  y  exbid   x  19.21ai
  x  (E. y (= (<,> x y) A))  (E. y (= (<,> x y) B))  abbi2    syl
  ({|} x (E. y (= (<,> x y) A)))  ({|} x (E. y (= (<,> x y) B)))  ax-iotaeq  syl
  A  x  y  df-head  syl5eq
  B  x  y  df-head  syl6eqr
)

thm (headeqi () (
     hyp1 (= A B))
     (= (head A) (head B))
  hyp1
  A B headeq
  ax-mp
)

thm (headeqd () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (head A) (head B)))
  hyp1
  A B headeq
  syl
)

## <title> Equality theorem for tail </title>
thm (taileq () () (-> (= A B) (= (tail A) (tail B)))
  A  B  (<,> y x)  eqeq2  y  exbid  x  19.21ai
  x (E. y (= (<,> y x) A))  (E. y (= (<,> y x) B))  abbi2  syl
  ({|} x (E. y (= (<,> y x) A)))  ({|} x (E. y (= (<,> y x) B)))  ax-iotaeq  syl
  A  x  y  df-tail  syl5eq
  B  x  y  df-tail  syl6eqr
)

thm (taileqi () (
     hyp1 (= A B))
     (= (tail A) (tail B))
  hyp1
  A B taileq
  ax-mp
)

thm (taileqd () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (tail A) (tail B)))
  hyp1
  A B taileq
  syl
)

# == Iota ==

thm (iotaseqi () (hyp (=_ S T)) (= (iota S) (iota T))
  hyp
  S T ax-iotaeq
  ax-mp
)

thm (iotaseqd () (hyp (-> ph (=_ S T))) (-> ph (= (iota S) (iota T)))
  hyp
  S T ax-iotaeq
  syl
)

## <title> Substitution </title>
## <table>
##   (= A (iota  [ S ]   ]   ] ))
##   (=_         [ S ]   [ T ] )
##   (= A (iota  [   [   [ T ] ))
## </table>
thm (SeqReplaceEq1Iota0 () (
     replacee (= A (iota S))
     substitution (=_ S T)) 
     (= A (iota T))
  replacee substitution
  iotaseqi
  EqReplaceEq1
)

## <title> Substitution </title>
## <table>
##   (= A (iota ({|} x  [ ph ]   ]    ] )))
##   (<->               [ ph ]   [ ps ] )
##   (= A (iota ({|} x  [    [   [ ps ] )))
## </table>
thm (BiReplaceEq1Iota0Ab1 () (
     replacee (= A (iota ({|} x ph)))
     substitution (<-> ph ps)) 
     (= A (iota ({|} x ps)))
  replacee substitution
  x abbi2i
  SeqReplaceEq1Iota0
)

thm (ex-nf ((ph x)) () (-> (E. x ph) ph)
  x ph 19.9 biimpi
)

## <summary> Existential uniqueness implies iota is a member </summary>
thm (iotacl ((S x)) ()
   (-> (E! x (e. x S)) (e. (iota S) S))
  x (e. x S) y df-eu biimpi


    x y elsnc (e. x S)  bibi2i x gen 19.15i biimpri
    S ({} y) x  df-seq biimpri
  syl
  y 19.22i syl

  S ({} y) ax-iotaeq y ax-iota  syl6eq
  (iota S) y elsnc  sylibr
  S ({} y) (iota S) eleq2

  biimprd mpd y 19.22i
  syl
    y (e. (iota S) S) ex-nf
  syl
)

## <summary> Another iota utility theorem.  Asserts that if exactly one x has the property ph, then that x can be found using iota. </summary>
thm (iotacl2 () ()
   (-> (E! x ph) (e. (iota ({|} x ph)) ({|} x ph)))
x  ph  y  df-eu   biimpi
  x  ph  (= x y)  abbi2
    ({|} x ph)  ({|} x (= x y))  ax-iotaeq
      y  x  df-sn    ({} y)  ({|} x (= x y))  ax-iotaeq  ax-mp
  y  ax-iota       eqtr3     (iota ({|} x ph))  eqeq2i  biimpi    syl  syl
   (iota ({|} x ph))  y  x  ph  dfsbcq   biimprd  syl
   (iota ({|} x ph))  x  ph  ax-elab   syl6ibr
    ph  (= x y)  bi2  x  19.20i
    x  (-> (= x y) ph)  y  a4sbc    syl

    y  x  (-> (= x y) ph)  z  df-subst   sylib
    x  (= z y)  (/\ (= x z) (-> (= x y) ph))  19.41l   biimpri  z  19.22i    #syl
      # ugh.
      (= z y)  (= x z)  (-> (= x y) ph)  anass
        (= z y)  (= x z)  (-> (= x y) ph)  anass
          (= z y)  (= x z)  (-> (= x y) ph)  anass
          z  y  x  ax-eqtr   z  x  eqcom        sylan2br   (-> (= x y) ph)  anim1i     sylbir
          y  x  eqcom    biimpi    (-> (= x y) ph)  anim1i  syl
         (= x y)  ph  pm3.35    syl
        sylbi  (/\ (= z y) (= x z))  (-> (= x y) ph)  ph  pm5.3      mpbi
       sylbir
      (= z y)  (= x z)  ph  anass  sylib
     x  19.22i  z  19.22i  syl
    x  (= z y)  (/\ (= x z)  ph)  19.41l  biimpi  z  19.22i  syl
   syl
   y  x  ph  z  df-subst    sylibr
 jca
 ([/] y x ph)  (e. (iota ({|} x ph)) ({|} x ph))  pm3.35  ancoms  syl
 y  19.22i  syl
 y  (e. (iota ({|} x ph)) ({|} x ph))  ex-nf  syl
)

## <title> Basic identity for iota </title>
thm (iotaeq () ()
  (= (iota ({|} x (= x A))) A)
  A x df-sn
  ({} A) ({|} x (= x A)) ax-iotaeq ax-mp eqcomi
  A ax-iota eqtr
)

# == Ternary conditional for naturals ==

# Ternary expressions for naturals: (ph ? A : B)
thm (df-ifn-just ((ph x y) (A x y) (B x y)) () (=
  (iota ({|} x (\/ (/\ ph (= x A)) (/\ (-. ph) (= x B)))))
  (iota ({|} y (\/ (/\ ph (= y A)) (/\ (-. ph) (= y B))))))

  x  y  A  eqeq1
  ph  anbi2d
    x  y  B  eqeq1
    (-. ph)  anbi2d
  orbi12d
  abeq
  ({|} x (\/ (/\ ph (= x A)) (/\ (-. ph) (= x B))))  ({|} y (\/ (/\ ph (= y A)) (/\ (-. ph) (= y B))))  ax-iotaeq    ax-mp
)

defthm (df-ifn nat (ifn ph A B) ((ph x) (A x) (B x)) ()
  (= (ifn ph A B)   (iota ({|} x (\/ (/\ ph (= x A)) (/\ (-. ph) (= x B))))))
  y  ph  A  B  x  df-ifn-just)

## <title> First branch of ternary expression </title>
thm (ifn1 () () (-> ph (= (ifn ph A B) A))
     ph  (= x A)  iba
     ph  (= x A)  ancom    syl6bbr
       (-. ph)  (= x B)  pm3.26    con2i
       (/\ (-. ph) (= x B))  (/\ ph (= x A))  biorf    syl
         (/\ (-. ph) (= x B))  (/\ ph (= x A))  orcom
       syl6rbb
     bitr4d
     x  19.21ai
       x  (= x A)  (\/ (/\ ph (= x A)) (/\ (-. ph) (= x B)))  abbi2
     syl
     ({|} x (= x A))  ({|} x (\/ (/\ ph (= x A)) (/\ (-. ph) (= x B))))  ax-iotaeq    syl
         ph  A  B  x  df-ifn
      syl6eqr
      eqcomd
        A  x  df-sn
          ({} A)  ({|} x (= x A))  ax-iotaeq    ax-mp
        syl6eqr
      A  ax-iota    syl6eq
)

## <title> Second branch of ternary expression </title>
thm (ifn2 () () (-> (-. ph) (= (ifn ph A B) B))
     (-. ph)  (= x B)  iba
     (-. ph)  (= x B)  ancom    syl6bbr
       ph  (= x A)  pm3.26    con3i
       (/\ ph (= x A))  (/\ (-. ph) (= x B))  biorf    syl
       bitr2d
       x  19.21ai
         x  (\/ (/\ ph (= x A)) (/\ (-. ph) (= x B)))  (= x B)  abbi2
       syl
     ({|} x (\/ (/\ ph (= x A)) (/\ (-. ph) (= x B))))  ({|} x (= x B))  ax-iotaeq    syl
     eqcomd
         ph  A  B  x  df-ifn
      syl6eqr
      eqcomd
        B  x  df-sn
          ({} B)  ({|} x (= x B))  ax-iotaeq    ax-mp
        syl6eqr
      B  ax-iota    syl6eq
)

## <title> Equivalence of predicate in ifn </title>
thm (ifnbi1 () () (-> (<-> ph ps) (= (ifn ph A B) (ifn ps A B)))
  ph ps dfbi3
    ph A B ifn1 ps adantr ps A B ifn1 ph adantl eqcomd eqtrd
      ph A B ifn2 (-. ps) adantr ps A B ifn2 (-. ph) adantl eqcomd eqtrd
    jaoi
  sylbi
)

thm (ifnbi1i () (
     hyp1 (<-> ph ps))
     (= (ifn ph A B) (ifn ps A B))
  hyp1
  ph ps A B ifnbi1
  ax-mp
)

thm (ifnbi1d () (
     hyp1 (-> ch (<-> ph ps)))
     (-> ch (= (ifn ph A B) (ifn ps A B)))
  hyp1
  ph ps A B ifnbi1
  syl
)

## <title> Equality of first term for ifn </title>
thm (ifneq2 () () (-> (= A B) (= (ifn ph A C) (ifn ph B C)))
  ph A C ifn1 B eqeq1d biimprd imp
  ph B C ifn1 (= A B) adantr eqcomd eqtrd ex
    ph A C ifn2
    ph B C ifn2 eqcomd eqtrd (= A B) a1d
  pm2.61i
)

thm (ifneq2i () (
     hyp1 (= A B))
     (= (ifn ph A C) (ifn ph B C))
  hyp1
  A B ph C ifneq2
  ax-mp
)

thm (ifneq2d () (
     hyp1 (-> ps (= A B)))
     (-> ps (= (ifn ph A C) (ifn ph B C)))
  hyp1
  A B ph C ifneq2
  syl
)

## <title> Equality of second term for ifn </title>
thm (ifneq3 () () (-> (= A B) (= (ifn ph C A) (ifn ph C B)))
  ph C A ifn1
  ph C B ifn1 eqcomd eqtrd (= A B) a1d
    ph C A ifn2 B eqeq1d biimprd imp
    ph C B ifn2 (= A B) adantr eqcomd eqtrd ex
  pm2.61i
)

thm (ifneq3i () (
     hyp1 (= A B))
     (= (ifn ph C A) (ifn ph C B))
  hyp1
  A B ph C ifneq3
  ax-mp
)

thm (ifneq3d () (
     hyp1 (-> ps (= A B)))
     (-> ps (= (ifn ph C A) (ifn ph C B)))
  hyp1
  A B ph C ifneq3
  syl
)

thm (ifneq13 () () (-> (/\ (<-> ph ps) (= A B)) (= (ifn ph C A) (ifn ps C B)))
  ph ps C A ifnbi1
  A B ps C ifneq3
  pm3.2i  
  ## <d 'Praeclarum Theorema '>
    (<-> ph ps) (= (ifn ph C A) (ifn ps C A)) (= A B) (= (ifn ps C A) (ifn ps C B)) prth
    ax-mp
  ## </d 'Praeclarum Theorema '>
  
  ## <d 'Symmetric Property '>
    (ifn ph C A) (ifn ps C A) eqcom
    BiReplaceImp1An0
  ## </d 'Symmetric Property '>
  
  ## <d 'Transitive Property '>
    (ifn ps C A) (ifn ph C A) (ifn ps C B) ax-eqtr
    syl
  ## </d 'Transitive Property '>
)

## <title> Substitution </title>
## <table>
##   (-> ph (<=  [ A ]   ]   ]  C))
##   (=          [ A ]   [ B ] )
##   (-> ph (<=  [   [   [ B ]  C))
## </table>
thm (EqReplaceImp1Le0 () (
     replacee (-> ph (<= A C))
     substitution (= A B)) 
     (-> ph (<= B C))
  replacee substitution
  C leeq1i
  sylib
)

## <title> Substitution </title>
## <table>
##   (<-> ph (<  [ A ]   ]   ]  C))
##   (=          [ A ]   [ B ] )
##   (<-> ph (<  [   [   [ B ]  C))
## </table>
thm (EqReplaceBi1Lt0 () (
     replacee (<-> ph (< A C))
     substitution (= A B)) 
     (<-> ph (< B C))
  replacee substitution
  C lteq1i
  bitri
)

thm (mulmonotonic () () (-> (-. (<= B (0))) (<= A (* A B)))
  (1) B A lemul2  
  ## <d 'Evaluate'>
    A mulid
    EqReplaceImp1Le0
  ## </d 'Evaluate'>
  
  ## <d 'Convert between ≤ and < '>
    (1) B lePlus1
    ## <d 'Commutative Property'>
      (< (1) (+ B (1))) (<= (1) B) bicom
      mpbi
    ## </d 'Commutative Property'>
    sylbi2
  ## </d 'Convert between ≤ and < '>
  (0) B (1) ltadd1  
  ## <d 'Additive Identity Axiom '>
    (1) pa_ax3r
    EqReplaceBi1Lt0
  ## </d 'Additive Identity Axiom '>
  bicomi  
  sylbi2
  (0) B ltcom
  sylbi2
)

# == Subtraction over natural numbers ==

# Justification for definition of halfminus
thm (df-halfminus-just ((A x y) (B x y)) ()
  (= (ifn (< A B) (0) (iota ({|} x (= A (+ B x)))))
    (ifn (< A B) (0) (iota ({|} y (= A (+ B y))))))
  x y B addeq2 A eqeq2d abeq
  ({|} x (= A (+ B x))) ({|} y (= A (+ B y))) ax-iotaeq ax-mp
  (iota ({|} x (= A (+ B x)))) (iota ({|} y (= A (+ B y)))) (< A B) (0) ifneq3 ax-mp
)

# Definition of "half minus"
defthm (df-halfminus nat (.- A B) ((A x) (B x)) ()
  (= (.- A B) (ifn (< A B) (0) (iota ({|} x (= A (+ B x))))))
  A B y x df-halfminus-just
)

thm (halfminuseq1 () () (-> (= A C) (= (.- A B) (.- C B)))
  A C B lteq1
  A C (+ B x) eqeq1
  x abbi2d
  iotaseqd
  jca
  (< A B) (< C B) (iota ({|} x (= A (+ B x)))) (iota ({|} x (= C (+ B x)))) (0) ifneq13
  syl

  A B x df-halfminus
  ## <d 'Commutative Property'>
    (.- A B) (ifn (< A B) (0) (iota ({|} x (= A (+ B x))))) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq0
  C B x df-halfminus  
  ## <d 'Symmetric Property '>
    (.- C B) (ifn (< C B) (0) (iota ({|} x (= C (+ B x))))) eqcom
    mpbi
  ## </d 'Symmetric Property '>
  EqReplaceImp1Eq1
)

thm (halfminuseq1i () (
     hyp1 (= A B))
     (= (.- A C) (.- B C))
  hyp1
  A B C halfminuseq1
  ax-mp
)

thm (halfminuseq1d () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (.- A C) (.- B C)))
  hyp1
  A B C halfminuseq1
  syl
)

## <title> Equivalence for - </title>
thm (halfminuseq2 () () (-> (= B C) (= (.- A B) (.- A C)))
  B C A lteq2
  B C x addeq1
  A eqeq2d
  x abbi2d
  iotaseqd
  jca  
  (< A B) (< A C) (iota ({|} x (= A (+ B x)))) (iota ({|} x (= A (+ C x)))) (0) ifneq13
  syl

  A B x df-halfminus
  ## <d 'Commutative Property'>
    (.- A B) (ifn (< A B) (0) (iota ({|} x (= A (+ B x))))) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq0
  A C x df-halfminus  
  ## <d 'Symmetric Property '>
    (.- A C) (ifn (< A C) (0) (iota ({|} x (= A (+ C x))))) eqcom
    mpbi
  ## </d 'Symmetric Property '>
  EqReplaceImp1Eq1
)

thm (halfminuseq2i () (
     hyp1 (= B C))
     (= (.- A B) (.- A C))
  hyp1
  B C A halfminuseq2
  ax-mp
)

thm (halfminuseq2d () (
     hyp1 (-> ph (= B C)))
     (-> ph (= (.- A B) (.- A C)))
  hyp1
  B C A halfminuseq2
  syl
)

thm (halfminuseq12 () () (-> (/\ (= A B) (= C D)) (= (.- A C) (.- B D)))
  A B C halfminuseq1
  C D B halfminuseq2
  anim12i  
  ## <d 'Transitive Property '>
    (.- A C) (.- B C) (.- B D) eqtr1
    syl
  ## </d 'Transitive Property '>
)

## <title> Minus is the inverse of addition </title>
thm (halfminus () ()
  (-> (<= B A) (= (+ (.- A B) B) A))
  B A lenltt
  (< A B) (0) (iota ({|} x (= A (+ B x)))) ifn2 sylbi
  A B x df-halfminus syl5eq
  B addeq1d
    B A x df-le
    (+ B x) A eqcom x exbii bitri

      A (+ B x) (+ B y) ax-eqtr
      B x y addcan2 sylib
      y gen x gen (E. x (= A (+ B x))) biantru bitri
      x y B addeq2 A eqeq2d eu4
    bitr4i

      x (= A (+ B x)) iotacl2
    sylbi

      x (iota ({|} x (= A (+ B x)))) B addeq2 A eqeq2d elab
    sylib
    B (iota ({|} x (= A (+ B x)))) addcom syl6eq
  eqcomd eqtrd
)

## <title> A number minus zero is itself </title>
thm (halfminuszero () () (= (.- A (0)) A)
  (.- A (0)) pa_ax3 eqcomi
    A nn0nlt0 (0) A lenltt mpbir
    (0) A halfminus ax-mp
  eqtr
)

## <title> A number minus itself is zero </title>
## <suggest> right('Cancel', '-') </suggest>
## <table>
##   (= (.- <r> A <r> A) (0))
## </table>
thm (halfminusid () () (= (.- A A) (0))
  A leid A A halfminus ax-mp
  A pa_ax3r eqcomi eqtr
  (.- A A) A (0) addcan mpbi
)

## <title> Substitution </title>
## <table>
##   (<=  [ A ]   ]   ]  C)
##   (=   [ A ]   [ B ] )
##   (<=  [   [   [ B ]  C)
## </table>
thm (EqReplaceLe0 () (
     replacee (<= A C)
     substitution (= A B)) 
     (<= B C)
  replacee substitution
  C leeq1i
  mpbi
)

## <title> Half minus cancellation </title>
## <suggest> right('Simplify', '-') </suggest>
## <table>
##   (= (.- (+ A <r> B) <r> B) A)
## </table>
thm (halfminuscan() () (= (.- (+ A B) B) A)
  A 0le
  B leadd1i  
  ## <d 'Additive Identity Axiom '>
    B pa_ax3r
    EqReplaceLe0
  ## </d 'Additive Identity Axiom '>
  B (+ A B) halfminus  
  ax-mp
  (.- (+ A B) B) B A addcan  
  mpbi
)

## <suggest> right('Equivalence', '-') left('Equivalence', '+') </suggest>
thm (addhalfminus() () (-> (= (+ A C) B) (= A (.- B C)))
  (+ A C) B C halfminuseq1  
  ## <d>
    A C halfminuscan
    EqReplaceImp1Eq0
  ## </d>
)

## <title> Addition & Subtraction Equivalence </title>
thm (addhalfminusi () (hyp (= C (+ A B))) (= (.- C A) B)
  hyp eqcomi
  ## <d 'Commutative Property '>
    A B addcom
    EqReplaceEq0
  ## </d 'Commutative Property '>
  B A C addhalfminus
  ax-mp

  ## <d 'Symmetric Property '>
    B (.- C A) eqcom
    mpbi
  ## </d 'Symmetric Property '>
)

## <title> Substitution </title>
## <table>
##   (= (+ A  [ B ]   ]   ] ) D)
##   (=       [ B ]   [ C ] )
##   (= (+ A  [   [   [ C ] ) D)
## </table>
thm (EqReplaceEq0Add1 () (
     replacee (= (+ A B) D)
     substitution (= B C)) 
     (= (+ A C) D)
  replacee substitution
  A addeq2i
  EqReplaceEq0
)

## <title> Substitution </title>
## <table>
##   (-> ph (= (+ A  [ B ]   ]   ] ) D))
##   (=              [ B ]   [ C ] )
##   (-> ph (= (+ A  [   [   [ C ] ) D))
## </table>
thm (EqReplaceImp1Eq0Add1 () (
     replacee (-> ph (= (+ A B) D))
     substitution (= B C)) 
     (-> ph (= (+ A C) D))
  replacee substitution
  A addeq2i
  EqReplaceImp1Eq0
)

## <title> Commute Half Minus </title>
## <table>
##   (-> (<= <r> B <g> A) (= (+ (.- <g> A <r> B) <b> C) (.- (+ <g> A <b> C) <r> B)))
## </table>
thm (halfminusaddcom () () (-> (<= B A) (= (+ (.- A B) C) (.- (+ A C) B)))
  B A halfminus
  C addeq1d  
  ## <d 'Associative Property '>
    (.- A B) B C addass
    EqReplaceImp1Eq0
  ## </d 'Associative Property '>
  
  ## <d 'Commutative Property '>
    B C addcom
    EqReplaceImp1Eq0Add1
  ## </d 'Commutative Property '>
  
  ## <d 'Associative Property '>
    (.- A B) C B addass
    ## <d 'Commutative Property'>
      (+ (+ (.- A B) C) B) (+ (.- A B) (+ C B)) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq0
  ## </d 'Associative Property '>
  B halfminuseq1d  
  ## <d>
    (+ (.- A B) C) B halfminuscan
    EqReplaceImp1Eq0
  ## </d>
)

## <title> Cancel same numbers with subtraction </title>
## <suggest> right('Simplify', '-') </suggest>
## <table>
##   (= (.- (+ <r> A B) <r> A) B)
## </table>
thm (halfminuscan2 () () (= (.- (+ A B) A) B)
  A leid
  A A B halfminusaddcom
  ## <d 'Symmetric Property '>
    (+ (.- A A) B) (.- (+ A B) A) eqcom
    sylib
  ## </d 'Symmetric Property '>
  ax-mp    
  ## <d 'A number minus itself is zero '>
    A halfminusid
    EqReplaceEq1Add0
  ## </d 'A number minus itself is zero '>
  
  ## <d 'Additive Identity Axiom '>
    B pa_ax3r
    EqReplaceEq1
  ## </d 'Additive Identity Axiom '>
)

## <title> Substitution </title>
## <table>
##   (-> ph (/\ ps  [ ch ]   ]    ] ))
##   (->            [ ch ]   [ th ] )
##   (-> ph (/\ ps  [    [   [ th ] ))
## </table>
thm (ImpReplaceImp1An1 () (
     replacee (-> ph (/\ ps ch))
     substitution (-> ch th)) 
     (-> ph (/\ ps th))
  replacee substitution
  ps anim2i
  syl
)

thm (lthalfminus () () (-> (< A B) (< (0) (.- B A)))
  A B ltle
  A B halfminus
  syl
  A lteq2d  
  ## <d 'Implication & Biconditional '>
    (< A B) (< A (+ (.- B A) A)) ibibr
    ## <d 'Commutative Property'>
      (-> (< A B) (< A (+ (.- B A) A))) (-> (< A B) (<-> (< A (+ (.- B A) A)) (< A B))) bicom
      mpbi
    ## </d 'Commutative Property'>
    mpbi
  ## </d 'Implication & Biconditional '>
  (0) (.- B A) A ltadd1
  
  ## <d 'Additive Identity Axiom '>
    A pa_ax3r
    EqReplaceBi1Lt0
  ## </d 'Additive Identity Axiom '>
  bicomi
  sylib
)

## <title> Half-minus Never Goes Negative </suggest>
thm (halfminus-neg () () (-> (<= A B) (= (.- A B) (0)))
  (< A B) (0) (iota ({|} x (= A (+ B x)))) ifn1  
  A B x df-halfminus
  eqcomi  
  EqReplaceImp1Eq0
  A B A halfminuseq2
  
  ## <d 'A number minus itself is zero '>
    A halfminusid
    EqReplaceImp1Eq0
  ## </d 'A number minus itself is zero '>  
  ## <d 'Symmetric Property '>
    (0) (.- A B) eqcom
    sylib
  ## </d 'Symmetric Property '>
  jaoi
  
  ## <d ' '>
    A B leleo
    ## <d 'Commutative Property'>
      (<= A B) (\/ (< A B) (= A B)) bicom
      mpbi
    ## </d 'Commutative Property'>
    sylbi2
  ## </d ' '>
)

## <title> Half-minus Never Goes Negative </suggest>
thm (halfminus-negi () (hyp (<= A B)) (= (.- A B) (0))
  hyp
  A B halfminus-neg   
  ax-mp
)



## <title> Distributive Property </title>
thm (halfminusdist.1 () () (-> (<= C B) (= (* A (.- B C)) (.- (* A B) (* A C))))
  C B halfminus
  A muleq2d    
  ## <d 'Distributive Property '>
    A (.- B C) C distr
    EqReplaceImp1Eq0
  ## </d 'Distributive Property '>
  (* A (.- B C)) (* A C) (* A B) addhalfminus  
  syl
)

## <title> Distributive Property </title>
## <suggest> right('Distribute', 'R') left('Distribute', '-R') </suggest>
thm (halfminusdist () () (= (* A (.- B C)) (.- (* A B) (* A C)))
  C B A halfminusdist.1

  B C ltle
  B C halfminus-neg
  A muleq2d  
  ## <d 'Commutative Property '>
    A (0) mulcom
    A pa_ax5r
    EqReplaceEq1
    EqReplaceImp1Eq1
  ## </d 'Commutative Property '>

  B C A lemul2
  (* A B) (* A C) halfminus-neg  
  syl
  ## <d 'Symmetric Property '>
    (.- (* A B) (* A C)) (0) eqcom
    sylib
  ## </d 'Symmetric Property '>
  eqtrd  
  syl  
  ## <d 'Commute Inequality '>
    B C ltcom
  ## </d>    
  sylbi2
  jaoi
  (<= C B) exmid    
  ax-mpRemove
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A   [ B ]   ]   ] ))
##   (<=           [ B ]   [ C ] )
##   (-> ph (<= A  [   [   [ C ] ))
## </table>
thm (LeReplaceImp1Eq1 () (
     replacee (-> ph (= A B))
     substitution (<= B C)) 
     (-> ph (<= A C))
  replacee substitution
  A leTreq
  syl
)


thm (halfminus-monotonic () () (<= (.- A B) A)
  A B halfminus-neg
  A 0le  
  LeReplaceImp1Eq1

  A B gtge
  B A halfminus  
  ## <d 'Commute Inequality '>
    B A lecom
  ## </d 'Commute Inequality '>
  sylbi2
  syl

  B 0le
  A leadd2i    
  ## <d 'Additive Identity Axiom '>
    A pa_ax3
    EqReplaceLe0
  ## </d 'Additive Identity Axiom '>
  (+ (.- A B) B) leTreq    
  syl
  (.- A B) A B leadd1 bicomi
  sylib
  jaoi
  (<= A B) exmid    
  ax-mpRemove
)

thm (lehalfminus1 () () (-> (<= A B) (<= (.- A C) (.- B C)))
  A B x df-le
  (+ A x) B C halfminuseq1  
  ImpReplaceBi1Ex1
    C A x halfminusaddcom  
  ## <d 'Symmetric Property '>
  (+ (.- A C) x) (.- (+ A x) C) eqcom
  sylib
  (.- B C) eqeq1d
  x exbid
  pm3.2i    
    ## <d 'Praeclarum Theorema '>
      (<= A B) (E. x (= (.- (+ A x) C) (.- B C))) (<= C A) (<-> (E. x (= (.- (+ A x) C) (.- B C))) (E. x (= (+ (.- A C) x) (.- B C)))) prth
      ax-mp
    ## </d 'Praeclarum Theorema '>    
  ## <d>
    (E. x (= (.- (+ A x) C) (.- B C))) (E. x (= (+ (.- A C) x) (.- B C))) mpbi-inline
    syl
  ## </d>
  
  ## <d 'Definition of Less Than or Equal to '>
    (.- A C) (.- B C) x df-le
    ## <d 'Commutative Property'>
      (<= (.- A C) (.- B C)) (E. x (= (+ (.- A C) x) (.- B C))) bicom
      mpbi
    ## </d 'Commutative Property'>
    sylib
  ## </d 'Definition of Less Than or Equal to '>

  A C ltle
  A C halfminus-neg
  (.- B C) 0le  
  LeReplaceImp1Eq1  
  syl
  A C ltcom 
  sylbi2
  jaoi    
  ## <d 'Distributive Property '>
    (<= A B) (<= C A) (-. (<= C A)) ordir
  ## </d>  
  sylbi2
  (<= C A) exmid      
  (\/ (<= A B) (-. (<= C A))) anRemove2
  (<= (.- A C) (.- B C)) imbi1i
  mpbi
  orcs
)

## <title> Halfminus Over Inequality </title>
## <table>
##  (<=     A ]    ]     [ B ] )
##  (<= (.- A ] C) ] (.- [ B ] C))
## </table>
thm (lehalfminus1i () (hyp (<= A B)) (<= (.- A C) (.- B C))
  hyp
  A B C lehalfminus1
  ax-mp
)


thm (halfminus-com.1 () () (-> (<= A B) (= (.- (.- A B) C) (.- (.- A C) B)))
  A B halfminus-neg
  C halfminuseq1d
  C 0le
  (0) C halfminus-neg  
  ax-mp  
  EqReplaceImp1Eq1
  ## <d 'Symmetric Property '>
    (.- (.- A B) C) (0) eqcom
    sylib
  ## </d 'Symmetric Property '>

  (.- A C) A B letr
  A C halfminus-monotonic
  
  (<= A B) anRemove1
  (<= (.- A C) B) imbi1i
  mpbi
  (.- A C) B halfminus-neg  
  syl
  
  ## <d 'Symmetric Property '>
    (.- (.- A C) B) (0) eqcom
    sylib
  ## </d 'Symmetric Property '>
  jca  
  ## <d 'Transitive Property '>
    (0) (.- (.- A B) C) (.- (.- A C) B) ax-eqtr
    syl
  ## </d 'Transitive Property '>
)

# == Division, primality ==

# number 36.5
thm (df-divides-just ((A x) (B x) (A y) (B y)) ()
       (<-> (E. x (= (* A x) B)) (E. y (= (* A y) B)))
      x y A muleq2 B eqeq1d exalpha)

## <title> Divides Definition </title>
## <suggest> left('Simplify', '|') right('Define', '|') </suggest>
defthm (df-divides wff (| A B) ((A x) (B x)) ()
       (<-> (| A B) (E. x (= (* A x) B)))
        y A B x df-divides-just)

# number 37.0
thm (divideseq1imp () ()
  (-> (= A B) (-> (| A C) (| B C)))

  (= A B) z alnfi

    A B z muleq1    (= (* A z) C) anim1i
    (* A z) C (* B z) ax-eqtr   eqcomd   ancoms
  syl    ex


    z gen  z (= A B) (-> (= (* A z) C) (= (* B z) C)) ax-alim   ax-mp
  syl
    z (= (* A z) C) (= (* B z) C) 19.22
  syl


  A C z df-divides
  syl5ib


  B C z df-divides
  (| A C) imbi2i
  sylibr
)
# number 38.1
thm (divideseq1 () ()
  (-> (= A B) (<-> (| A C) (| B C)))

  A B C divideseq1imp
  B A C divideseq1imp eqcoms
    impbid
)

# Equality inference for the divides relation.
## <title> Equivalence over Divides </title>
## <table>
##   (=      A ]   ]      [ B ]   )
##   (<-> (| A ] C ] ) (| [ B ] C))
## </table>
thm (divideseq1i ()
  (hyp (= A B))
  (<-> (| A C) (| B C))
  hyp A B C divideseq1 ax-mp
)

# Equality inference for the Divides relation.
## <title> Equivalence over divides </title>
## <table>
##  (|    A ] ]   ] [ C)
##     (= A ] [ B ] ] )
##  (|      [ [ B ] [ C)
## </table>
thm (divideseq1ii ()
  (hyp1 (| A C)
   hyp2 (= A B))
  (| B C)
  hyp1 hyp2 C divideseq1i mpbi
)

# number 48.0
thm (divideseq2imp () ()
  (-> (= A B) (-> (| C A) (| C B)))
  A B (* C z) eqeq2    biimpd
  z 19.22d
  C B z df-divides biimpri    syl6

  C A z df-divides biimpi

  syl5
)
# number 49.0
thm (divideseq2 () ()
  (-> (= A B) (<-> (| C A) (| C B)))
   A B C divideseq2imp
   B A C divideseq2imp eqcoms
  impbid
)

## <title> Equivalence over Divides </title>
## <table>
##   (=        [ A ]      [   [ B ] )
##   (<-> (| C [ A ] ) (| [ C [ B ] ))
## </table>
thm (divideseq2i ()
  (hyp (= A B))
  (<-> (| C A) (| C B))
  hyp A B C divideseq2 ax-mp
)

## <title> Equivalence over Divides </title>
## <table>
##  (| C   [ A ] ] )
##      (= [ A ] [ B)
##  (| C   [   [ [ B)
## </table>
thm (divideseq2ii ()
  (hyp1 (| C A)
   hyp2 (= A B))
  (| C B)
  hyp1 hyp2 C divideseq2i mpbi
)

thm (divideseq1d () (
     hyp1 (-> ph (= A B)))
     (-> ph (<-> (| A C) (| B C)))
  hyp1
  A B C divideseq1
  syl
)

thm (divideseq2d () (
     hyp1 (-> ph (= A B)))
     (-> ph (<-> (| C A) (| C B)))
  hyp1
  A B C divideseq2
  syl
)

## <title> Substitution </title>
## <table>
##   (E. x (= A  [ B ]   ]   ] ))
##   (=          [ B ]   [ C ] )
##   (E. x (= A  [   [   [ C ] ))
## </table>
thm (EqReplaceEx1Eq1 () (
     replacee (E. x (= A B))
     substitution (= B C)) 
     (E. x (= A C))
  replacee
  substitution
A eqeq2i
x exbii
mpbi
)

thm (proveDivides () (hyp (= (* A B) C)) (| A C)
  x B tyex
  x B A muleq2  
  ImpReplaceEx1
  hyp
  EqReplaceEx1Eq1
  A C x df-divides
  
  bicomi
  mpbi
)

thm (proveDividesd () (hyp (-> ph (= (* A B) C))) (-> ph (| A C))
  ph x alnfi
  x B tyex
  x B A muleq2
  C eqeq1d
  ph imbi2d
  ImpReplaceEx1
  hyp
  
  (-> ph (= (* A x) C)) biRemove2
  x exbii
  mpbi
  
  x ph (= (* A x) C) eximp1  
  ax-mp  
  syl
  
  ## <d 'Divides Definition '>
    A C x df-divides
    ## <d 'Commutative Property'>
      (| A C) (E. x (= (* A x) C)) bicom
      mpbi
    ## </d 'Commutative Property'>
    sylib
  ## </d 'Divides Definition '>
)

thm (notDivides () ()  (-> (/\ (< (* A C) B) (< B (* A (+ C (1))))) (-. (| A B)))
  (/\ (< (* A C) B) (< B (* A (+ C (1))))) x alnfi
  (<= x C) exmid
  (/\ (< (* A C) B) (< B (* A (+ C (1))))) anRemove1  
  ## <d 'Commutative Property '>
    (/\ (\/ (<= x C) (-. (<= x C))) (/\ (< (* A C) B) (< B (* A (+ C (1)))))) (/\ (< (* A C) B) (< B (* A (+ C (1))))) bicom
    mpbi
  ## </d 'Commutative Property '>
  x albii  
  sylib


  x C A lemul2
  (< (* A C) B) anim1i
  (* A x) (* A C) B lelttr
  syl
  (* A x) B ltneq
  syl
  (< B (* A (+ C (1)))) adantr
  ## <d>
    (<= x C) (< (* A C) B) (< B (* A (+ C (1)))) anass
  ## </d>
  sylbi2 

  (+ C (1)) x A lemul2
  (< B (* A (+ C (1))) ) anim2i

  B (* A (+ C (1))) (* A x) lelttr2
  syl
  B (* A x) ltneq

  ## <d>
    B (* A x) eqcom
  ## </d>
  BiReplaceImp1Not0
  syl

  ## <d>
    (< B (* A (+ C (1)))) (<= (+ C (1)) x) ancom
  ## </d>
  sylbi2

  ## <d>
    (+ C (1)) x lecom
  ## </d>
  BiReplaceImp0An0
  C x nnltp1let

  ## <d>
    (+ C (1)) x lecom
  ## </d>
  bitri
  ## <d>
    C x ltcom
  ## </d>
  bitr3icom
  ## <d>
    bicomi
  ## </d>
  BiReplaceImp0An0

  (< (* A C) B) adantr
  ## <d>
    (-. (<= x C)) (< B (* A (+ C (1)))) (< (* A C) B) anass
  ## </d>
  sylbi2 

  ## <d>
    (< B (* A (+ C (1)))) (< (* A C) B) ancom
  ## </d>
  BiReplaceImp0An1
  jaoi
  (<= x C) (-. (<= x C)) (/\ (< (* A C) B) (< B (* A (+ C (1))))) andir
  ## <d>
    bicomi
  ## </d>
  sylbi2
  
  ImpReplaceImp1Al1
  
  ## <d>
    x (-. (= (* A x) B)) alex
    (= (* A x) B) notnotr
    BiReplaceBi1Not0Ex1
    sylib
  ## </d>  
  ## <d 'Divides Definition '>
    A B x df-divides
    ## <d 'Commutative Property'>
      (| A B) (E. x (= (* A x) B)) bicom
      mpbi
    ## </d 'Commutative Property'>
    BiReplaceImp1Not0
  ## </d 'Divides Definition '>
)

## <title> Substitution </title>
## <table>
##   (-> ph (<  [ A ]   ]   ]  C))
##   (=         [ A ]   [ B ] )
##   (-> ph (<  [   [   [ B ]  C))
## </table>
thm (EqReplaceImp1Lt0 () (
     replacee (-> ph (< A C))
     substitution (= A B)) 
     (-> ph (< B C))
  replacee substitution
  C lteq1i
  sylib
)

## <title> Substitution </title>
## <table>
##   (<-> ph (< A  [ B ]   ]   ] ))
##   (=            [ B ]   [ C ] )
##   (<-> ph (< A  [   [   [ C ] ))
## </table>
thm (EqReplaceBi1Lt1 () (
     replacee (<-> ph (< A B))
     substitution (= B C)) 
     (<-> ph (< A C))
  replacee substitution
  A lteq2i
  bitri
)

# number 39.0
thm (df-prime-just ((A x) (A y)) ()
    (<-> (/\ (-. (<= A (1))) (A. x (-> (| x A) (\/ (= x (1)) (= x A))))) 
         (/\ (-. (<= A (1))) (A. y (-> (| y A) (\/ (= y (1)) (= y A))))))
    x y A divideseq1
    x y (1) eqeq1
    x y A eqeq1  orbi12d
  imbi12d
  alpha
  (-. (<= A (1))) anbi2i
)

## <title> Prime Definition </title>
defthm (df-prime wff (prime A) ((A x))  ()
  (<-> (prime A) (/\ (-. (<= A (1))) (A. x (-> (| x A) (\/ (= x (1)) (= x A))))))
A y x df-prime-just)

## <title> Equality theorem for primeness </title> 
thm (primeeq () () (-> (= A B) (<-> (prime A) (prime B)))
    A B (1) leeq1
    (<= A (1)) (<= B (1)) notbi  
    sylib

    A B x divideseq2
      A B x eqeq2
      (= x (1)) orbi2d
    imbi12d
    x 19.21ai
    19.15d
    anbi12d

      A x df-prime
        B x df-prime
    3bitr4g
)

## <title> Def. Set of Prime Numbers </title>
## <suggest> right('Define', 'Pr') left('Simplify', 'Pr') </suggest>
defthm (df-primeset set (primeset) () () (=_ (primeset) ({|} y (prime y)))
  x y primeeq abeq
)

## <title> Def. Set of Prime Numbers </title>
## <suggest> right('Equivalence', '∈') left('Equivalence', '∈') </suggest>
thm (elprimeset () () (<-> (e. A (primeset)) (prime A))
  x df-primeset
  A eleq2i
  ## <d>
    A x (prime x) ax-elab
    bitri
  ## </d>
  x A primeeq
  sbcie
  bitri
)

thm (interval-rwff ((A x) (B x)) () (rwff x (/\ (<= A x) (<= x B)))
  x y A leeq2
  x y B leeq1
  jca
  ## <d>
    (<= A x) (<= A y) (<= x B) (<= y B) pm4.38
    syl
  ## </d>
  rwffi
)

thm (intervallt-rwff ((A x) (B x)) () (rwff x (/\ (< A x) (< x B)))
  x y A lteq2
  x y B lteq1
  jca
  ## <d>
    (< A x) (< A y) (< x B) (< y B) pm4.38
    syl
  ## </d>
  rwffi
)

thm (divides-rwff1 ((A x)) () (rwff x (| x A))
  x y A divideseq1
  rwffi
)

thm (divides-rwff2 ((A x)) () (rwff x (| A x))
  x y A divideseq2
  rwffi
)

thm (prime-rwff () () (rwff x (prime x))
  x y primeeq
  rwffi
)

thm (notDividesSet ((B x) (A x)) () (<-> (e. A ({|} x (-. (| x B)))) (-. (| A B)))
  x B divides-rwff1
  not-rwff
  abid
  x gen
  x A ({|} x (-. (| x B))) ax-eleq1
  x A B divideseq1
  notbid
  bibi12d
  cla4g
  ax-mp
)

thm (notDividesSeti ((B x) (A x)) (hyp (-. (| A B)))  (e. A ({|} x (-. (| x B))))
  hyp
  A x B notDividesSet
  ## <d 'Commutative Property '>
    (e. A ({|} x (-. (| x B)))) (-. (| A B)) bicom
    mpbi
  ## </d 'Commutative Property '>  
  mpbi
)

thm (intervalAttach () (hyp (<= A B)) (=_ (u. ({...} A B) ({} (+ B (1)))) ({...} A (+ B (1)))) 
  ({...} A B) ({} (+ B (1))) x df-un
  
  (u. ({...} A B) ({} (+ B (1)))) ({|} x (\/ (e. x ({...} A B))    (e. x ({} (+ B (1)))))) seqcom
  mpbi
   A B x df-interval
  SeqReplaceSeq0Ab1Or0El1

  x A B interval-rwff
  abid
  BiReplaceSeq0Ab1Or0  
  ## <d 'Singleton has One Element '>
    x (+ B (1)) elsnc
    BiReplaceSeq0Ab1Or1
  ## </d 'Singleton has One Element '>

  ({|} x (\/ (/\ (<= A x) (<= x B)) (= x (+ B (1))))) (u. ({...} A B) ({} (+ B (1)))) seqcom
  mpbi
  
  x B lePlus1
  ## <d 'Commutative Property'>
    (< x (+ B (1))) (<= x B) bicom
    mpbi
  ## </d 'Commutative Property'>
    BiReplaceSeq1Ab1Or0An1
  
  (<= A x) (< x (+ B (1))) (= x (+ B (1))) ordir
  BiReplaceSeq1Ab1
  
  x (+ B (1)) leleo
  ## <d 'Commutative Property'>
    (<= x (+ B (1))) (\/ (< x (+ B (1))) (= x (+ B (1)))) bicom
    mpbi
  ## </d 'Commutative Property'>
    BiReplaceSeq1Ab1An1
  
  (<= A x) (= x (+ B (1))) (<= x (+ B (1))) andir
  BiReplaceSeq1Ab1
  
  x (+ B (1)) leleo
    BiReplaceSeq1Ab1Or1An1
  
  (= x (+ B (1))) (< x (+ B (1))) (= x (+ B (1))) andi
    BiReplaceSeq1Ab1Or1
    
  (= x (+ B (1))) anidm
    BiReplaceSeq1Ab1Or1Or1

  
  x (+ B (1)) ltneq
  
  (< x (+ B (1))) (-. (= x (+ B (1)))) iman
  mpbi
  (= x (+ B (1))) notnotr
    BiReplaceNot0An1
  
  (< x (+ B (1))) (= x (+ B (1))) ancom
  mtbi
  
  (= x (+ B (1))) orNotRemove1
  (/\ (<= A x) (<= x (+ B (1)))) orbi2i
  x abbi2i
  (u. ({...} A B) ({} (+ B (1)))) seqseq2i
  mpbi
  
  (<= A x) (<= x (+ B (1))) (= x (+ B (1))) ordir
  BiReplaceSeq1Ab1
  
  x (+ B (1)) leleo
    BiReplaceSeq1Ab1An1Or0
  
  (< x (+ B (1))) (= x (+ B (1))) (= x (+ B (1))) orass
  BiReplaceSeq1Ab1An1
  
  (= x (+ B (1))) oridm
    BiReplaceSeq1Ab1An1Or1
  
  x (+ B (1)) leleo
  ## <d 'Commutative Property'>
    (<= x (+ B (1))) (\/ (< x (+ B (1))) (= x (+ B (1)))) bicom
    mpbi
  ## </d 'Commutative Property'>
  BiReplaceSeq1Ab1An1
    
  x (+ B (1)) eqge
  x B gtge2  
  (-. (<= x B)) (-. (< x (+ B (1)))) bicom
  mpbi
  
  sylib
  
  x B lecom
  BiReplaceImp1Not0
  (< B x) notnotr
  sylib
  
  B x ltle
  syl
  
  A B x letr  
  hyp
  (<= B x) anRemove1
  (<= A x) imbi1i
  mpbi
    
  syl
  (<= A x) orim2i  
  (<= A x) oridm
  sylib

  (<= A x) (= x (+ B (1))) orc
  pm3.2i  
  (\/ (<= A x) (= x (+ B (1)))) (<= A x) dfbi2
  ## <d 'Commutative Property'>
    (<-> (\/ (<= A x) (= x (+ B (1)))) (<= A x)) (/\ (-> (\/ (<= A x) (= x (+ B (1)))) (<= A x)) (-> (<= A x) (\/ (<= A x) (= x (+ B (1)))))) bicom
    mpbi
  ## </d 'Commutative Property'>
  mpbi
  
    BiReplaceSeq1Ab1An0
  
  A (+ B (1)) x df-interval
  ## <d 'Commutative Property'>
    ({...} A (+ B (1))) ({|} x (/\ (<= A x) (<= x (+ B (1))))) seqcom
    mpbi
  ## </d 'Commutative Property'>
  SeqReplaceSeq1
)

## <title> Substitution </title>
## <table>
##   (<-> ph (/\ ps (-. (E. x  [ ch ]   ]    ] ))))
##   (<->                      [ ch ]   [ th ] )
##   (<-> ph (/\ ps (-. (E. x  [    [   [ th ] ))))
## </table>
thm (BiReplaceBi1An1Not0Ex1 () (
     replacee (<-> ph (/\ ps (-. (E. x ch))))
     substitution (<-> ch th)) 
     (<-> ph (/\ ps (-. (E. x th))))
  replacee
  substitution
x exbii
con4biir
ps anbi2i
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (/\ ps (-. (E. x (/\ ch  [ th ]   ]    ] )))))
##   (<->                             [ th ]   [ ta ] )
##   (<-> ph (/\ ps (-. (E. x (/\ ch  [    [   [ ta ] )))))
## </table>
thm (BiReplaceBi1An1Not0Ex1An1 () (
     replacee (<-> ph (/\ ps (-. (E. x (/\ ch th)))))
     substitution (<-> th ta)) 
     (<-> ph (/\ ps (-. (E. x (/\ ch ta)))))
  replacee
  substitution
ch anbi2i
x exbii
con4biir
ps anbi2i
ph bibi2i
mpbi
)

## <title> Equivalence over Prime </title>
## <table>
##   (=          [ A ]          [ B ]   )
##   (<-> (prime [ A ] ) (prime [ B ] ))
## </table>
thm (primeeqi ()
  (hyp (= A B))
  (<-> (prime A) (prime B))
  hyp A B primeeq ax-mp
)

## <title> Equivalence over Prime </title>
## <table>
##  (prime    [ A ] ]   ] )
##         (= [ A ] [ B ] )
##  (prime    [   [ [ B ] )
## </table>
thm (primeeqii ()
  (hyp1 (prime A)
   hyp2 (= A B))
   (prime B)
  hyp1 hyp2 primeeqi mpbi
)

thm (notPrime () (hyp (| B A) hyp2 (/\ (< (1) B) (< B A))) (-. (prime A))
  A x df-prime
  x (-> (| x A) (\/ (= x (1)) (= x A)))  alex
  (-. (<= A (1))) anbi2i
  bitri


  (| x A) (-. (\/ (= x (1)) (= x A))) df-an
  (\/ (= x (1)) (= x A)) notnotbi
  BiReplaceBi1Not0Imp1

  ## <d>
    (/\ (| x A) (-. (\/ (= x (1)) (= x A)))) (-. (-> (| x A) (\/ (= x (1)) (= x A)))) bicom
  ## </d>
  mpbi

  BiReplaceBi1An1Not0Ex1
  (= x (1)) (= x A) ioran  
  BiReplaceBi1An1Not0Ex1An1
  x B tyex
  x B A divideseq1
  x B (1) lteq2
  x B A lteq1
  anbi12d
  anbi12d

  hyp
  hyp2
  pm3.2i

  (/\ (| x A) (/\ (< (1) x) (< x A))) biRemove2
  (= x B) imbi2i
  mpbi

  ImpReplaceEx1
  (1) x ltneq
  ImpReplaceEx1An1An0

  x A ltneq
  ImpReplaceEx1An1An1

  ## <d>
    (1) x eqcom
  ## </d>
  BiReplaceEx1An1An0Not0
  
  notnoti
  (-. (<= A (1))) anNotRemove2
  (prime A) bibi2i
  mpbi
  notfal  
  mtbirRemove
)

# number 40.0
## <title> Natural Number </title>
thm (0orpos () () (\/ (= A (0)) (<= (1) A))
  # x = 0 \/ 1<= x
    A z lefoo
    (1) A z df-le    (= A (0)) orbi2i
  mpbir
)

## <title> Definition of 2 </title>
defthm (df-2 nat (2) () () (= (2) (+ (1) (1)))
        (+ (1) (1)) eqid)

## <title> Definition of 3 </title>
defthm (df-3 nat (3) () () (= (3) (+ (2) (1)))
        (+ (2) (1)) eqid)

## <title> Definition of 4 </title>
defthm (df-4 nat (4) () () (= (4) (+ (3) (1)))
        (+ (3) (1)) eqid)

## <title> Definition of 5 </title>
defthm (df-5 nat (5) () () (= (5) (+ (4) (1)))
        (+ (4) (1)) eqid)

## <title> Definition of 6 </title>
defthm (df-6 nat (6) () () (= (6) (+ (5) (1)))
        (+ (5) (1)) eqid)

## <title> Definition of 7 </title>
defthm (df-7 nat (7) () () (= (7) (+ (6) (1)))
        (+ (6) (1)) eqid)

## <title> Definition of 8 </title>
defthm (df-8 nat (8) () () (= (8) (+ (7) (1)))
        (+ (7) (1)) eqid)

## <title> Definition of 9 </title>
defthm (df-9 nat (9) () () (= (9) (+ (8) (1)))
        (+ (8) (1)) eqid)

## <title> Definition of 10 </title>
defthm (df-10 nat (10) () () (= (10) (+ (9) (1)))
        (+ (9) (1)) eqid)

thm (2p2eq4 () () (= (+ (2) (2)) (4))
  df-2
  (2) addeq2i
  ## <d>
    (2) (1) (1) addass
    eqcomi
  ## </d>
  eqtr
  ## <d>
    df-3
    eqcomi
    (1) addeq1i
  ## </d>
  eqtr
  ## <d>
    df-4
    eqcomi
  ## </d>
  eqtr
)

# number 42.0
## <title> Basic Inequality </title>
thm (0ne2 () () (-. (= (0) (+ (1) (1))))
    (1) pa_ax1  (1) a1suc (0) eqeq2i  mtbi #  (= (* x y) (+ (1) (1)))  mt2bi bicomi
)
# number 43.0
#jctil with hyps listed backwards
thm (jctilb () (h1 ch h2 (-> ph ps)) (-> ph (/\ ch ps))
  h2 h1 jctil
)


## <title> Substitution </title>
## <table>
##   (-. (<=  [ A ]   ]   ]  C))
##   (=       [ A ]   [ B ] )
##   (-. (<=  [   [   [ B ]  C))
## </table>
thm (EqReplaceNot0Le0 () (
     replacee (-. (<= A C))
     substitution (= A B)) 
     (-. (<= B C))
  replacee
  substitution
C gteq1i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-. (<= A  [ B ]   ]   ] ))
##   (=         [ B ]   [ C ] )
##   (-. (<= A  [   [   [ C ] ))
## </table>
thm (EqReplaceNot0Le1 () (
     replacee (-. (<= A B))
     substitution (= B C)) 
     (-. (<= A C))
  replacee
  substitution
A gteq2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-. (<  [ A ]   ]   ]  C))
##   (=      [ A ]   [ B ] )
##   (-. (<  [   [   [ B ]  C))
## </table>
thm (EqReplaceNot0Lt0 () (
     replacee (-. (< A C))
     substitution (= A B)) 
     (-. (< B C))
  replacee
  substitution
C geeq1i
mpbi
)

thm (1plus1gt1 () () (-. (<= (+ (1) (1)) (1)))
  ## <d 'Add To Both Sides'>
    ## <d 'Derive Smaller Inequality'>
      ## <d 'Number is Not Zero'>
        (0) pa_ax1plus
        ## <d 'Evaluate'>
          (1) pa_ax3r
          EqReplaceNot0Eq1
        ## </d 'Evaluate'>
        ## <d 'Commutative Property'>
          (0) (1) eqcom
          mtbi
        ## </d 'Commutative Property'>
      ## </d 'Number is Not Zero'>
      ## <d 'Greater Than Or Equal To Zero'>
        (1) ge0
      ## </d 'Greater Than Or Equal To Zero'>
      axgrtrii
    ## </d 'Derive Smaller Inequality'>
    ## <d 'Add To Both Sides'>
      (1) gtadd2i
    ## </d 'Add To Both Sides'>
    ## <d 'Simplify Left Side'>
      df-2
      ## <d 'Commutative Property'>
        (2) (+ (1) (1)) eqcom
        mpbi
      ## </d 'Commutative Property'>
        EqReplaceNot0Le0
    ## </d 'Simplify Left Side'>
    ## <d 'Simplify Right Side'>
      (1) pa_ax3
        EqReplaceNot0Le1
    ## </d 'Simplify Right Side'>
  ## </d 'Add To Both Sides'>

  ## <d 'Evaluate'>
    df-2
    ## <d 'Commutative Property'>
      (2) (+ (1) (1)) eqcom
      mpbi
    ## </d 'Commutative Property'>
  ## </d 'Evaluate'>

  ## <d>
    (+ (1) (1)) (2) eqcom
  ## </d>  
  mpbi
  
  EqReplaceNot0Le0
)

# number 44.0
## <title> 2 is Prime Lemma </title>
thm (2primelem1 ()
  (h1 (\/ ph ps)
   h2 (\/ ch (\/ th (\/ ta et)))
   h3 (-> (/\ ps et) (-. si))
   h4 (-> ph (-. si))
   h5 (-> ch (-. si)))
   (-> si (\/ th ta))

  h4 con2i
  h1 ph ps df-or mpbi syl
  h3  con2i  ps et ianor sylib    ps et pm4.62 sylibr   mpd
  h5 con2i
  h2  ch (\/ th (\/ ta et)) df-or mpbi syl
  th ta et 3orass sylibr
  th ta et df-3or sylib   (\/ th ta) et df-or sylib con1d   mpd
)
# number 45.0
## <title> 2 is Prime </title>
thm (2prime () () (prime (+ (1) (1)))
  1plus1gt1
  ## <d>
    x (+ (1) (1)) y df-divides
  ## </d>

  # y is 0 or >=1.
  y 0orpos
  # x is 0, 1 2, or >= 3
  x 0orpos
  ## <d>
    (1) x lefoo3    (= x (0)) orbi2i
  ## </d>
  mpbi
  ## <d>
    (+ (1) (1)) x lefoo3   (= (1) x) orbi2i (= x (0)) orbi2i
  ## </d>
  mpbi


  # 1<=y and 3<=x means x * y >= 1*3
  (1) y (+ (+ (1) (1)) (1)) x lemul3
  # replace 1*3  with 3
  ## <d>
    (+ (+ (1) (1)) (1)) mulid
    (+ (+ (1) (1)) (1)) (1) mulcom
    eqtr3
    (* y x) leeq1i
    bicomi
  ## </d>

  sylib
  # but it's not true that 3 <= 2
  ## <d>
    1nle0
    ## <d>
      (1) (0) (+ (1) (1)) leadd2
      ## <d>
        (+ (1) (1)) pa_ax3 (+ (+ (1) (1)) (1)) leeq2i
      ## </d>
      bitri   notbii
    ## </d>
  ## </d>
  mpbi

  # so this line of reasoning means that x * y != 2
  ## <d>
    x y mulcom
    (+ (1) (1)) eqeq1i
    biimpi (+ (+ (1) (1)) (1)) leeq2d
  ## </d>
  mtbiri  con2i  syl

  # y=0 can't give us x*y = 2
  0ne2
  ## <d>
    y (0) x muleq2
    ## <d>
      x pa_ax5
    ## </d>
    syl6eq
    (+ (1) (1)) eqeq1d
    biimpd
  ## </d>
  mtoi

  # x=0 can't give us x*y = 2 either
  0ne2
  ## <d>
    x (0) y muleq1
    ## <d>
      y pa_ax5r
    ## </d>
    syl6eq
    (+ (1) (1)) eqeq1d
    biimpd
  ## </d>
  mtoi

  # That's all the math -- from here on out it's juggling predicates,
  # connectives, and quantifiers. If the verifier autounified I
  # wouldn't have to carry around all the mandhyps baggage. Instead I
  # tried to tuck most of it away in a lemma.
  2primelem1

  ## <d>
    (1) x eqcom   (= (+ (1) (1)) x) orbi1i
  ## </d>
  sylib
  ## <d>
    (+ (1) (1)) x eqcom (= x (1)) orbi2i
  ## </d>
  sylib
  y 19.22i
  ## <d>
    y (\/ (= x (1)) (= x (+ (1) (1)))) 19.9
  ## </d>
  sylib
  sylbi
  x gen

  pm3.2i
  ## <d>
    (+ (1) (1)) x df-prime
  ## </d>
  mpbir
)

# number 46.0
thm (dividesmul () ()
    (-> (| A B) (| A (* B C)))
  A B x df-divides biimpi

   y (* x C) tyex
   y (* x C) A muleq2   y 19.22i
  ax-mp

  (* A x) B C muleq1
  A x C mulass  syl5eqr
  (* A y) eqeq2d
  biimpd

  y 19.21ai    y (= (* A y) (* A (* x C))) (= (* A y) (* B C)) 19.22 syl

  mpi
  x 19.22i syl
  x (E. y (= (* A y) (* B C))) 19.9   biimpi  syl

  A (* B C) y df-divides   biimpri   syl
)

thm (dividesmuli () (hyp (| A B)) (| A (* B C))
  hyp
  A B C dividesmul  
  ax-mp
)

# number 47.0
# Induction tool for exfactorial
thm (exfactorial.1 ((A x) (A y)) ()
    (-> (= z A)
        (<-> (E. x (A. y (-> (<= (S y) (S z)) (| (S y) (S (S x))))))
             (E. x (A. y (-> (<= (S y) (S A)) (| (S y) (S (S x))))))))

   (= z A) id  suceqd
   (= (S z) (S A)) id (S y) leeq2d syl
   (| (S y) (S (S x))) imbi1d
   y 19.21ai
   19.15d
   x exbid
)

# number 47.0
# Induction tool for exfactorial
thm (exfactoriallem1 ((A x) (A y)) ()
    (-> (= z A)
        (<-> (E. x (A. y (-> (<= (S (S y)) (S (S z))) (| (S (S y)) (S (S x))))))
             (E. x (A. y (-> (<= (S (S y)) (S (S A))) (| (S (S y)) (S (S x))))))))

   (= z A) id  suceqd      (= (S z) (S A)) id  suceqd  syl
   (= (S (S z)) (S (S A))) id (S (S y)) leeq2d syl
   (| (S (S y)) (S (S x))) imbi1d
   y 19.21ai
   19.15d
   x exbid
)

## <title> A number divides itself </title>
## <suggest> full('Simplify', 'T') </suggest>
thm (dividessym () () (| A A)
    x (1) tyex
    x (1) A muleq2  eqcomd  A mulid  eqcomi syl5eq   eqcomd  x 19.22i
  ax-mp
  A A x df-divides
  mpbir
)

## <title> A number divides a multiple of itself </title>
## <suggest> full('Simplify', 'T') </suggest>
thm (dividessymmul () () (| A (* A B))
  A A B dividesmul  
  ## <d 'Divides Definition '>
    A dividessym
    ax-mpRemove
  ## </d 'Divides Definition '>
)

# number 52.0
# Base case for induction in exfactorial
thm (exfactorial.2 () ()
  (E. x (A. y (-> (<= (S y) (S (0))) (| (S y) (S (S x))))))

  x (0) tyex

  # (for later, prove 1 | 2)
  x  (S (S (0))) tyex
   x  (S (S (0)))  (S (0)) muleq2
    df-1   (S (S (0))) muleq1i  (1)  (S (S (0)))  mulcom  eqtr3
    (S (S (0))) mulid   eqtr
   syl6eq
  x  19.22i  ax-mp
  (S (0))  (S (S (0)))  x  df-divides  mpbir

  # Prove y'<= 0' -> y' = 0'
    y (0) (1) leadd1
    y a1suc (+ (0) (1)) leeq1i
  bitr4i
   (0) a1suc
   (S y) leeq2i bitr4i
  biimpri
  y eq0le0 sylibr
  suceqd

  # ... -> y' | 0''  (it's later)
    (S y) (S (0)) (S (S (0))) divideseq1  syl  biimprd
  mpi

  # ... which is the same as y'' | x'' when x=0
     (= x (0)) a1i
     x (0) eqcom biimpi suceqd suceqd    (S (S (0))) (S (S x)) (S y) divideseq2   syl  biimpd
  syld

  y 19.21ai
  x 19.22i ax-mp
)
# number 52.0
# Base case for induction in exfactorial
thm (exfactoriallem2 () ()
  (E. x (A. y (-> (<= (S (S y)) (S (S (0)))) (| (S (S y)) (S (S x))))))

  x (0) tyex

  # (for later)
    (S (S (0))) dividessym
  # Prove y''<= 0'' -> y'' = 0''
    y (0) (1) leadd1
    y a1suc (+ (0) (1)) leeq1i
  bitr4i
  (S y) (+ (0) (1)) (1) leadd1 bitri
  (S y) a1suc (+ (+ (0) (1)) (1)) leeq1i  bitr4i
  (+ (0) (1)) a1suc (S (S y)) leeq2i bitr4i
  (0) a1suc     (S (0)) (+ (0) (1)) pa_ax2  mpbi   (S (S y)) leeq2i bitr4i
  biimpri
  y eq0le0 sylibr
  suceqd suceqd

  # ... -> y'' | 0''  (it's later)
    (S (S y)) (S (S (0))) (S (S (0))) divideseq1  syl  biimprd
  mpi

  # ... which is the same as y'' | x'' when x=0
     (= x (0)) a1i
     x (0) eqcom biimpi suceqd suceqd    (S (S (0))) (S (S x)) (S (S y)) divideseq2   syl  biimpd
  syld

  y 19.21ai
  x 19.22i ax-mp
)
# number 53.0
## <summary> Utility to avoid excessive mandhyp baggage in exfactoriallem3 </summary>
thm (exfactoriallem4 ()
  (h1 (-> ph (\/ ps ch))
   h2 (-> th ps))
  (-> (-> ch th) (-> ph ps))

  h1
  (-> ch th) anim1i
  ps ch (-> ch th) andir  sylib
  ps (-> ch th) pm3.26   (/\ ch (-> ch th)) orim1i  syl
  ch th pm3.35  ps orim2i syl
  h2 ps orim2i syl
  ps oridm sylib
  expcom
)
# number 54.0
# Inductive step for exfactorial
thm (exfactorial.3 () ()
  (-> (E. x (A. y (-> (<= (S y) (S z)) (| (S y) (S (S x))))))
      (E. x (A. y (-> (<= (S y) (S (S z))) (| (S y) (S (S x)))))))

  # Set up the two cases
    (S y) (S (S z)) lefoo3 biimpi

  # first case: y' = z'''.  This becomes y' | z''' * x''
  (S (S z)) dividessym    (S (S z)) (S (S z)) (S (S x)) dividesmul ax-mp
  (S y) (S (S z))  (* (S (S z)) (S (S x))) divideseq1  mpbiri
  (<= (+ (S y) (1)) (S (S z))) orim1i syl

  # Second case: y'' + 1 <= z'''.  This becomes y'' <= z''
  (S y) (S z) (1) leadd1
  (S z) a1suc   (+ (S y) (1)) leeq2i  bitr4i biimpri
  (| (S y) (* (S (S z)) (S (S x)))) orim2i syl
  # Handle second case by adding an assumption
    (S y) (S (S x)) (S (S z))  dividesmul
      (S (S x)) (S (S z)) mulcom
    (* (S (S x)) (S (S z))) (* (S (S z)) (S (S x))) (S y) divideseq2  ax-mp sylib
  exfactoriallem4

  # So (z''' * x'') is our new x''... we need to show it is at least 2
    (S (S z)) (S x) pa_ax6
    (* (S (S z)) (S x)) (S z) pa_ax4 eqtr
      (* (S (S z)) (S x)) z pa_ax4
      (+ (* (S (S z)) (S x)) (S z)) (S (+ (* (S (S z)) (S x)) z)) pa_ax2 mpbi
    eqtr
      (* (S (S z)) (S (S x))) (S (S (+ (* (S (S z)) (S x)) z))) (S y) divideseq2
    ax-mp
  biimpi  (<= (S y) (S (S z))) imim2i syl

  # Bundle up...
  y 19.20i
  x 19.22i

  # for later still
    x' (+ (* (S (S z)) (S x)) z) tyex
  # Need an substitution: x -> (z''' * x' + z')
      x' (+ (* (S (S z)) (S x)) z) pa_ax2 biimpi suceqd
        (S (S x')) (S (S (+ (* (S (S z)) (S x)) z))) (S y) divideseq2  biimprd
        (| (S y) (S (S (+ (* (S (S z)) (S x)) z)))) (| (S y) (S (S x'))) (<= (S y) (S (S z))) imim2 syl
        y 19.21ai
        y (-> (<= (S y) (S (S z))) (| (S y) (S (S (+ (* (S (S z)) (S x)) z))))) (-> (<= (S y) (S (S z))) (| (S y) (S (S x')))) ax-alim syl
      syl
      com12
      x' 19.22d
    mpi
    x 19.22i
  syl
  x (E. x' (A. y (-> (<= (S y) (S (S z))) (| (S y) (S (S x')))))) 19.9 sylib
  # now alpha change x' back to x
    x' x pa_ax2 biimpi suceqd
    (S (S x')) (S (S x)) (S y) divideseq2 biimpd  syl
    (| (S y) (S (S x'))) (| (S y) (S (S x))) (<= (S y) (S (S z))) imim2 syl
    y 19.21ai
    y (-> (<= (S y) (S (S z))) (| (S y) (S (S x')))) (-> (<= (S y) (S (S z))) (| (S y) (S (S x)))) ax-alim syl
    exalpha1
  syl
)
# number 54.0
# Inductive step for exfactorial
thm (exfactoriallem3 () ()
  (-> (E. x (A. y (-> (<= (S (S y)) (S (S z))) (| (S (S y)) (S (S x))))))
      (E. x (A. y (-> (<= (S (S y)) (S (S (S z)))) (| (S (S y)) (S (S x)))))))

  # Set up the two cases
    (S (S y)) (S (S (S z))) lefoo3 biimpi

  # first case: y'' = z'''.  This becomes y'' | z''' * x''
  (S (S (S z))) dividessym    (S (S (S z))) (S (S (S z))) (S (S x)) dividesmul ax-mp
  (S (S y)) (S (S (S z)))  (* (S (S (S z))) (S (S x))) divideseq1  mpbiri
  (<= (+ (S (S y)) (1)) (S (S (S z)))) orim1i syl

  # Second case: y'' + 1 <= z'''.  This becomes y'' <= z''
  (S (S y)) (S (S z)) (1) leadd1
  (S (S z)) a1suc   (+ (S (S y)) (1)) leeq2i  bitr4i biimpri
  (| (S (S y)) (* (S (S (S z))) (S (S x)))) orim2i syl
  # Handle second case by adding an assumption
    (S (S y)) (S (S x)) (S (S (S z)))  dividesmul
      (S (S x)) (S (S (S z))) mulcom
    (* (S (S x)) (S (S (S z)))) (* (S (S (S z))) (S (S x))) (S (S y)) divideseq2  ax-mp sylib
  exfactoriallem4

  # So (z''' * x'') is our new x''... we need to show it is at least 2
    (S (S (S z))) (S x) pa_ax6
    (* (S (S (S z))) (S x)) (S (S z)) pa_ax4 eqtr
      (* (S (S (S z))) (S x)) (S z) pa_ax4
      (+ (* (S (S (S z))) (S x)) (S (S z))) (S (+ (* (S (S (S z))) (S x)) (S z))) pa_ax2 mpbi
    eqtr
      (* (S (S (S z))) (S (S x))) (S (S (+ (* (S (S (S z))) (S x)) (S z)))) (S (S y)) divideseq2
    ax-mp
  biimpi  (<= (S (S y)) (S (S (S z)))) imim2i syl

  # Bundle up...
  y 19.20i
  x 19.22i

  # for later still
    x' (+ (* (S (S (S z))) (S x)) (S z)) tyex
  # Need an substitution: x -> (z''' * x' + z')
      x' (+ (* (S (S (S z))) (S x)) (S z)) pa_ax2 biimpi suceqd
        (S (S x')) (S (S (+ (* (S (S (S z))) (S x)) (S z)))) (S (S y)) divideseq2  biimprd
        (| (S (S y)) (S (S (+ (* (S (S (S z))) (S x)) (S z))))) (| (S (S y)) (S (S x'))) (<= (S (S y)) (S (S (S z)))) imim2 syl
        y 19.21ai
        y (-> (<= (S (S y)) (S (S (S z)))) (| (S (S y)) (S (S (+ (* (S (S (S z))) (S x)) (S z)))))) (-> (<= (S (S y)) (S (S (S z)))) (| (S (S y)) (S (S x')))) ax-alim syl
      syl
      com12
      x' 19.22d
    mpi
    x 19.22i
  syl
  x (E. x' (A. y (-> (<= (S (S y)) (S (S (S z)))) (| (S (S y)) (S (S x')))))) 19.9 sylib
  # now alpha change x' back to x
    x' x pa_ax2 biimpi suceqd
    (S (S x')) (S (S x)) (S (S y)) divideseq2 biimpd  syl
    (| (S (S y)) (S (S x'))) (| (S (S y)) (S (S x))) (<= (S (S y)) (S (S (S z)))) imim2 syl
    y 19.21ai
    y (-> (<= (S (S y)) (S (S (S z)))) (| (S (S y)) (S (S x')))) (-> (<= (S (S y)) (S (S (S z)))) (| (S (S y)) (S (S x)))) ax-alim syl
    exalpha1
  syl
)

## <summary>
##    There exists a number that is divided all numbers up to #(S A)#. While factorial is
##    certainly one such, it's not the only, so perhaps this is not an ideal name.
## </summary> 
thm (exfactorial ((A x) (A y)) ()
    (E. x (A. y (-> (<= (S y) (S A))
                     (| (S y) (S (S x))))))
    z (0) x y exfactorial.1
    z y' x y exfactorial.1
    z (S y') x y exfactorial.1
    z A x y exfactorial.1
    x y exfactorial.2
    x y y' exfactorial.3
    finds
)

# number 57.0
thm (dividesle () () (-> (| A (S B)) (<= A (S B)))
    A (S B) x df-divides biimpi
        B pa_ax1
            x (0) A muleq2    A pa_ax5  syl6eq
            (* A x) (0) (S B) eqeq1   syl   biimpd   con3d
        mpi
        con2i
            x y lefoo
            (= x (0)) (E. y (= (+ (1) y) x)) df-or   biimpi    ax-mp
        syl
            y a1suc   y (1) addcom     eqtr     x eqeq1i   biimpri
            (S y) x A muleq2    syl
            (* A (S y)) (* A x) (S B) eqeq1    syl  biimprd
                A (* A y) addge01t
                    A y pa_ax6    (* A y) A  addcom eqtr   (S B) eqeq1i   biimpi    A leeq2d  biimpd
                mpi
            syl6
        y 19.22i    syl
        y (-> (= (* A x) (S B)) (<= A (S B))) 19.9  sylib
        pm2.43i
    x 19.22i syl
    x (<= A (S B)) 19.9 sylib
)

thm (dividesle2 () () (-> (-. (<= B (0))) (-> (| A B) (<= A B)))
  B x hasPredecessor
  (S x) B A divideseq2
  (S x) B A leeq2
  imbi12d
  A x dividesle  
  (-> (| A B) (<= A B)) biRemove1
  (= (S x) B) imbi2i
  mpbi
  x 19.22i  
  ImpReplaceBi1
  x (-> (| A B) (<= A B)) 19.9  
  sylib
  
  ## <d>
    (0) B ltcom
  ## </d>
  sylbi2
)

# number 58.0
thm (sindlem1 ()
  (h1 (-> ch (-> ps (\/ (-> th ph) ta)))
   h2 (-> si (/\ th (-> ta ph))))
  (-> si (-> ch (-> ps ph)))

  si ch pm3.2
  h2   h1    anim12i    syl6

  (/\ th (-> ta ph))  ps  ax-1    (-> ps (\/ (-> th ph) ta))  anim1i    syl6
  ps  (/\ th (-> ta ph))  (\/ (-> th ph) ta)  pm3.43    syl6

  th  (-> ta ph)  (\/ (-> th ph) ta)  anass    biimpi    syl8


    (-> ta ph)  (-> th ph)  ta  andi    biimpi
    (-> ta ph)  (-> th ph)  pm3.27    (/\ (-> ta ph) ta)  orim1i    syl
    (-> ta ph)  ta  ancom    biimpi   (-> th ph)  orim2i    syl
    th  anim2i
  syl8

  ta  ph  pm3.35    (-> th ph)  orim2i    th  anim2i    syl8

  th  (-> th ph)  ph  andi    biimpi    th  ph  pm3.27    (/\ th (-> th ph)) orim2i    syl    syl8

  th  ph  pm3.35    ph  orim1i    syl8

  ph  pm1.2    syl8
)

## <title> Strong Induction </title>
thm (sind ((A x) (ta x) (ph y))                    # ph(x) is some term in x; ph(A) is to be proved
  (hyp1 (-> (= x (0))   (<-> ph ps))               # ps is ph(0)
   hyp3 (-> (= x (S y)) (<-> ph th))               # th is ph(y')
   hyp4 (-> (= x A)     (<-> ph ta))               # ta is ph(A)
   hyp5 ps
   hyp6 (-> (A. x (-> (<= x y) ph)) th))           # ph(x) holds for all x<=y  -->  ph(y') holds
  ta

# Tuck this away for later
hyp4
  z  x  tyex    x  leid    (= z x)  id    x  leeq2d    biimprd    mpi    z 19.22i    ax-mp

    # Don't blink, or you'll miss the actual math content of this proof.
    (= z (S y)) id    x leeq2d    biimpd
       x (S y) lefoo3    biimpi
       y a1suc (+ x (1)) leeq2i  biimpi    x y (1) leadd1  sylibr (= x (S y)) orim2i syl
    syl6
    # That was it!  All that's left is a little bit of logic and a lot of juggling.
    hyp3    biimprd  (<= x y) orim1i    syl6
#      x  ph  ps  19.21    biimpri
        z y tyex
          (= z y) id   x leeq2d    biimprd    (<= x y) (<= x z) ph imim1    syl   x  19.21ai
          x  (-> (<= x z) ph)  (-> (<= x y) ph)  ax-alim    syl
          a2i    z 19.20i
          z  (= z y)  (A. x (-> (<= x y) ph))  19.22    syl
        mpi    z  (A. x (-> (<= x y) ph))  ex-nf    syl
#.     syl .
      # Now the logic is all done, and we just need to juggle.
      # We'll need to use the consequent "x<=y -> ph" twice, so duplicate it here
      (A. z (-> (= z y) (A. x (-> (<= x z) ph))))  (A. x (-> (<= x y) ph))  anidmdbi  biimpri  ax-mp
      # Grind the first one into a theta
      hyp6    (A. x (-> (<= x y) ph))  anim1i  syl
      # Pull the quantifier off the second one
      x  (-> (<= x y) ph)  ax-4    th  anim2i    syl
    # Juggling lematized for your convenience
    sindlem1

    x    19.21ai    x  (= z (S y))  (-> (<= x z) ph)  19.21    sylib
    z  19.21ai
    y  gen

        # Base case
        (= z (0)) id    x leeq2d    biimpd   x eq0le0 biimpri    hyp5 hyp1 mpbiri   syl  syl6    x 19.21ai    z gen
            # Instead of calling "x  ph  y pa_ind" as in finds, we call it like this:
            z  (A. x (-> (<= x z) ph))  y  pa_ind
        mpan
    ax-mp

    # Huzzah!  Now just some cleanup.
    a4i    a4i
  z 19.22i    ax-mp    z  ph  ex-nf    ax-mp
vtocl
)

# Strong Induction using + 1 instead of successor.
## <title> Strong Induction </title>
thm (sindplus1 ((A x) (ta x) (ph y))               # ph(x) is some term in x; ph(A) is to be proved
  (hyp1 (-> (= x (0))   (<-> ph ps))               # ps is ph(0)
   hyp2 (-> (= x (+ y (1))) (<-> ph th))           # th is ph(y+1)
   hyp3 (-> (= x A)     (<-> ph ta))               # ta is ph(A)
   basis ps
   induction (-> (A. x (-> (<= x y) ph)) th))      # ph(x) holds for all x<=y  -->  ph(y') holds
   ta

  hyp1
  hyp2
  y a1suc
  eqcomi  
  EqReplaceImp0Eq1

  hyp3
  basis
  induction
  sind
)

# Induction tool
thm (infDescentLem1 () () (-> (= y A) (<-> (-. ([/] y x ph)) (-. ([/] A x ph))))
  y A x ph dfsbcq
  ([/] y x ph) ([/] A x ph) notbi  
  sylib
)

## <title> Proof By Infinite Descent </title>
thm (infiniteDescent((ph w) (ph y))
    (hyp (-> ([/] w x ph) (E. y (/\ (< y w) ([/] y x ph)))))
    (-. ([/] x x ph))
  y (0) x ph infDescentLem1
  y (+ z (1)) x ph infDescentLem1
  y x x ph infDescentLem1

  # Universal Instantiate for w = 0
  hyp
  w gen
  w (0) x ph dfsbcq
  w (0) y lteq2
  (< y w) (< y (0)) ([/] y x ph) anbi1
  syl
  y exbid
  imbi12d
  cla4g
  ax-mp

  y ge0
  ([/] y x ph) anNotRemove1
  y exbii
  ([/] (0) x ph) imbi2i
  mpbi
  y (F) df-ex
  notfal
  y gen
  notnoti
  mtbirRemove
  mtoRemove

  (<= y z) ([/] y x ph) df-an
  y (+ z (1)) ltle2
  y z (1) leadd1
  ## <d>
    (<= y z) (<= (+ y (1)) (+ z (1))) bicom
  ## </d>
  mpbi
  bitri
  ## <d>
    (< y (+ z (1))) (<= y z) bicom
  ## </d>
  mpbi
  BiReplaceBi0An0
  con2bii
  y albii
  y (/\ (< y (+ z (1))) ([/] y x ph)) df-ex
  con2bii
  bitri

  # Universal Instantiation of w = z + 1
  hyp
  w gen
  w (+ z (1)) x ph dfsbcq
  w (+ z (1)) y lteq2
  (< y w) (< y (+ z (1))) ([/] y x ph) anbi1
  syl
  y exbid
  imbi12d
  cla4g
  ax-mp

  con3i
  sylbi
  sindplus1
)

## <title> 0 does not divide positive numbers </title>
thm (not0divides () () (-. (| (0) (S A)))
  A pa_ax1
    (0)  (S A)  x  df-divides    biimpi
    x  pa_ax5   x  (0)  mulcom    eqtr3    (S A)  eqeq1i    biimpri    x 19.22i    syl
    x  (= (0) (S A))  ex-nf    syl
  mto
)

## <title> 0 does not divide positive numbers </title>
thm (not0divides2 () () (-> (< (0) A) (-. (| (0) A)))
  A x hasPredecessor
  (S x) A (0) divideseq2
  notbid
  x not0divides  
  (-. (| (0) A)) biRemove1
  (= (S x) A) imbi2i
  mpbi
  ImpReplaceBi1Ex1
  x (-. (| (0) A)) 19.9  
  sylib
)



## <title> Substitution </title>
## <table>
##   (<-> ph (-. (\/  [ ps ]   ]    ]  th)))
##   (<->             [ ps ]   [ ch ] )
##   (<-> ph (-. (\/  [    [   [ ch ]  th)))
## </table>
thm (BiReplaceBi1Not0Or0 () (
     replacee (<-> ph (-. (\/ ps th)))
     substitution (<-> ps ch)) 
     (<-> ph (-. (\/ ch th)))
  replacee substitution
  th orbi1i
  BiReplaceBi1Not0
)

## <title> Substitution </title>
## <table>
##   (<-> ph (\/ ps (E. x (/\ ch  [ th ]   ]    ] ))))
##   (<->                         [ th ]   [ ta ] )
##   (<-> ph (\/ ps (E. x (/\ ch  [    [   [ ta ] ))))
## </table>
thm (BiReplaceBi1Or1Ex1An1 () (
     replacee (<-> ph (\/ ps (E. x (/\ ch th))))
     substitution (<-> th ta)) 
     (<-> ph (\/ ps (E. x (/\ ch ta))))
  replacee substitution
  ch anbi2i
  BiReplaceBi1Or1Ex1
)


## <title> Substitution </title>
## <table>
##   (<-> ph (\/ ps (E. x (/\ ch (-.  [ th ]   ]    ] )))))
##   (<->                             [ th ]   [ ta ] )
##   (<-> ph (\/ ps (E. x (/\ ch (-.  [    [   [ ta ] )))))
## </table>
thm (BiReplaceBi1Or1Ex1An1Not0 () (
     replacee (<-> ph (\/ ps (E. x (/\ ch (-. th)))))
     substitution (<-> th ta)) 
     (<-> ph (\/ ps (E. x (/\ ch (-. ta)))))
  replacee substitution
  con4biir
    BiReplaceBi1Or1Ex1An1
)

## <title> A composite has no factors above it </title>
thm (dfprime1lem ((A x)) () (-> (-. (prime A)) (-> (-. (<= A (1))) (E. x (/\ (| x A) (/\ (-. (= x (1))) (< x A))))))
  A x df-prime
  ## <d 'Convert to Negative Statement'>
  ## <d 'Contraposition '>
    (prime A) (/\ (-. (<= A (1))) (A. x (-> (| x A) (\/ (= x (1)) (= x A))))) notbi
    mpbi
  ## </d 'Contraposition '>
  
  ## <d>
  ## <d>
    (-. (<= A (1))) (A. x (-> (| x A) (\/ (= x (1)) (= x A)))) anor
    (<= A (1)) notnotr
      BiReplaceBi1Not0Or0
    BiReplaceBi1Not0
  ## </d>
  
  ## <d 'Double Negative '>
    (\/ (<= A (1)) (-. (A. x (-> (| x A) (\/ (= x (1)) (= x A)))))) notnotr
    bitri
  ## </d 'Double Negative '>
  ## </d>
  
  ## <d>
  ## <d>
    x (-> (| x A) (\/ (= x (1)) (= x A))) alex
    BiReplaceBi1Or1Not0
  ## </d>
  
  ## <d 'Double Negative '>
    (E. x (-. (-> (| x A) (\/ (= x (1)) (= x A))))) notnotr
    BiReplaceBi1Or1
  ## </d 'Double Negative '>
  ## </d>
  
  ## <d>
  ## <d>
    (| x A) (\/ (= x (1)) (= x A)) iman
    BiReplaceBi1Or1Ex1Not0
  ## </d>
  
  ## <d 'Double Negative '>
    (/\ (| x A) (-. (\/ (= x (1)) (= x A)))) notnotr
    BiReplaceBi1Or1Ex1
  ## </d 'Double Negative '>
  ## </d>
  
  ## <d>
  ## <d>
    (= x (1)) (= x A) oran
      BiReplaceBi1Or1Ex1An1Not0
  ## </d>
  
  ## <d 'Double Negative '>
    (/\ (-. (= x (1))) (-. (= x A))) notnotr
    BiReplaceBi1Or1Ex1An1
  ## </d>
  ## </d 'Double Negative '>
  ## </d>
  
  
  ## <d 'Convert to Implication'>
  ## <d>
    (-. (prime A)) (\/ (<= A (1)) (E. x (/\ (| x A) (/\ (-. (= x (1))) (-. (= x A)))))) bi1
    ax-mp
  ## </d>
  
  ## <d>
    (<= A (1)) (E. x (/\ (| x A) (/\ (-. (= x (1))) (-. (= x A))))) df-or
    sylib
  ## </d>
  ## </d>

  ## <d 'A Large Number Cannot Divide A'>
  (0) (1) A lttr
  0less1
 
  (< (1) A) anRemove1
  (< (0) A) imbi1i
  mpbi
  
  ## <d>
    (1) A ltcom
  ## </d>
  sylbi2
  
  ## <d>
  ## <d>
    (0) A ltcom
  ## </d>
  sylib


  A x dividesle2  
  syl
  ## </d>
  x gen

  x (-. (<= A (1))) (-> (| x A) (<= x A)) 19.21 
  mpbi

  (-. (prime A)) a1i
  jcad  
  ## <d>
    x (/\ (| x A) (/\ (-. (= x (1))) (-. (= x A)))) (-> (| x A) (<= x A)) 19.29r
    ImpReplaceImp1Imp1
  ## </d>
  ## </d>
  
  ## <d 'Apply Implication'>
  ## <d>
    (| x A) (/\ (-. (= x (1))) (-. (= x A))) (-> (| x A) (<= x A)) anass
    BiReplaceImp1Imp1Ex1
  ## </d>
  
  ## <d 'Commutative Property '>
    (/\ (-. (= x (1))) (-. (= x A))) (-> (| x A) (<= x A)) ancom
    BiReplaceImp1Imp1Ex1An1
  ## </d 'Commutative Property '>
  
  ## <d>
    (| x A) (-> (| x A) (<= x A)) (/\ (-. (= x (1))) (-. (= x A))) anass
    ## <d 'Commutative Property'>
      (/\ (/\ (| x A) (-> (| x A) (<= x A))) (/\ (-. (= x (1))) (-. (= x A)))) (/\ (| x A) (/\ (-> (| x A) (<= x A)) (/\ (-. (= x (1))) (-. (= x A))))) bicom
      mpbi
    ## </d 'Commutative Property'>
    BiReplaceImp1Imp1Ex1
  ## </d>
  
  ## <d>
    (| x A) (<= x A) abai
    ## <d 'Commutative Property'>
      (/\ (| x A) (<= x A)) (/\ (| x A) (-> (| x A) (<= x A))) bicom
      mpbi
    ## </d 'Commutative Property'>
    BiReplaceImp1Imp1Ex1An0
  ## </d>
  
  ## <d>
    (| x A) (<= x A) (/\ (-. (= x (1))) (-. (= x A))) anass
    BiReplaceImp1Imp1Ex1
  ## </d>
  
  ## <d 'Commutative Property '>
    (<= x A) (/\ (-. (= x (1))) (-. (= x A))) ancom
    BiReplaceImp1Imp1Ex1An1
  ## </d 'Commutative Property '>
  
  ## <d>
    (-. (= x (1))) (-. (= x A)) (<= x A) anass
    BiReplaceImp1Imp1Ex1An1
  ## </d>
  ## </d>
  
  ## <d 'Inequality Conversion '>
    x A axlttri2
    ## <d 'Commutative Property'>
      (< x A) (/\ (-. (= x A)) (<= x A)) bicom
      mpbi
    ## </d 'Commutative Property'>
    BiReplaceImp1Imp1Ex1An1An1
  ## </d 'Inequality Conversion '>
)



## <title> Substitution </title>
## <table>
##   (<-> (-. (/\ ph  [ ps ]   ]    ] )) th)
##   (<->             [ ps ]   [ ch ] )
##   (<-> (-. (/\ ph  [    [   [ ch ] )) th)
## </table>
thm (BiReplaceBi0Not0An1 () (
     replacee (<-> (-. (/\ ph ps)) th)
     substitution (<-> ps ch)) 
     (<-> (-. (/\ ph ch)) th)
  replacee
  substitution
ph anbi2i
con4biir
th bibi1i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (-. (< A  [ B ]   ]   ] ))))
##   (=                      [ B ]   [ C ] )
##   (-> ph (-> ps (-. (< A  [   [   [ C ] ))))
## </table>
thm (EqReplaceImp1Imp1Not0Lt1 () (
     replacee (-> ph (-> ps (-. (< A B))))
     substitution (= B C)) 
     (-> ph (-> ps (-. (< A C))))
  replacee
  substitution
A geeq2i
ps imbi2i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (E. x (/\ ch (-. (/\ th  [ ta ]   ]    ] ))))))
##   (<->                                   [ ta ]   [ et ] )
##   (-> ph (-> ps (E. x (/\ ch (-. (/\ th  [    [   [ et ] ))))))
## </table>
thm (BiReplaceImp1Imp1Ex1An1Not0An1 () (
     replacee (-> ph (-> ps (E. x (/\ ch (-. (/\ th ta))))))
     substitution (<-> ta et)) 
     (-> ph (-> ps (E. x (/\ ch (-. (/\ th et))))))
  replacee
  substitution
th anbi2i
con4biir
ch anbi2i
x exbii
ps imbi2i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (E. x (\/  [ ch ]   ]    ]  ta))))
##   (<->                     [ ch ]   [ th ] )
##   (-> ph (-> ps (E. x (\/  [    [   [ th ]  ta))))
## </table>
thm (BiReplaceImp1Imp1Ex1Or0 () (
     replacee (-> ph (-> ps (E. x (\/ ch ta))))
     substitution (<-> ch th)) 
     (-> ph (-> ps (E. x (\/ th ta))))
  replacee
  substitution
ta orbi1i
x exbii
ps imbi2i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (E. x (\/ (/\  [ ch ]   ]    ]  ta) et))))
##   (<->                         [ ch ]   [ th ] )
##   (-> ph (-> ps (E. x (\/ (/\  [    [   [ th ]  ta) et))))
## </table>
thm (BiReplaceImp1Imp1Ex1Or0An0 () (
     replacee (-> ph (-> ps (E. x (\/ (/\ ch ta) et))))
     substitution (<-> ch th)) 
     (-> ph (-> ps (E. x (\/ (/\ th ta) et))))
  replacee
  substitution
ta anbi1i
et orbi1i
x exbii
ps imbi2i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (-> ps  [ ch ]   ]    ] ))
##   (<->            [ ch ]   [ th ] )
##   (<-> ph (-> ps  [    [   [ th ] ))
## </table>
thm (BiReplaceBi1Imp1 () (
     replacee (<-> ph (-> ps ch))
     substitution (<-> ch th)) 
     (<-> ph (-> ps th))
  replacee substitution
  ps imbi2i
  bitri
)

## <title> Substitution </title>
## <table>
##   (-> (-.  [ ph ]   ]    ] ) ch)
##   (<->     [ ph ]   [ ps ] )
##   (-> (-.  [    [   [ ps ] ) ch)
## </table>
thm (BiReplaceImp0Not0 () (
     replacee (-> (-. ph) ch)
     substitution (<-> ph ps)) 
     (-> (-. ps) ch)
  replacee substitution
  con4biir
  sylbi2
)

## <title> Substitution </title>
## <table>
##   (<-> ph (-. (/\ ps  [ ch ]   ]    ] )))
##   (<->                [ ch ]   [ th ] )
##   (<-> ph (-. (/\ ps  [    [   [ th ] )))
## </table>
thm (BiReplaceBi1Not0An1 () (
     replacee (<-> ph (-. (/\ ps ch)))
     substitution (<-> ch th)) 
     (<-> ph (-. (/\ ps th)))
  replacee substitution
  ps anbi2i
  BiReplaceBi1Not0
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (E. x (/\ ch (/\ (/\  [ th ]   ]    ]  et) zi)))))
##   (<->                                [ th ]   [ ta ] )
##   (-> ph (-> ps (E. x (/\ ch (/\ (/\  [    [   [ ta ]  et) zi)))))
## </table>
thm (BiReplaceImp1Imp1Ex1An1An0An0 () (
     replacee (-> ph (-> ps (E. x (/\ ch (/\ (/\ th et) zi)))))
     substitution (<-> th ta)) 
     (-> ph (-> ps (E. x (/\ ch (/\ (/\ ta et) zi)))))
  replacee substitution
  et anbi1i
  BiReplaceImp1Imp1Ex1An1An0
)

## <title> Substitution </title>
## <table>
##   (<-> ph (-. (< A  [ B ]   ]   ] )))
##   (=                [ B ]   [ C ] )
##   (<-> ph (-. (< A  [   [   [ C ] )))
## </table>
thm (EqReplaceBi1Not0Lt1 () (
     replacee (<-> ph (-. (< A B)))
     substitution (= B C)) 
     (<-> ph (-. (< A C)))
  replacee substitution
  A geeq2i
  bitri
)





thm (dfprime1lem2 ((A x)) () (-> (-. (prime A)) (-> (-. (<= A (1))) (E. x (/\ (| x A) (/\ (< (1) x) (< x A))))))
  ## <d>
  (0) x A divideseq1
  notbid
  (-. (<= A (1))) imbi2d
  
  ## <d 'Symmetric Property '>
    (0) x eqcom
    sylbi2
  ## </d 'Symmetric Property '>

  0less1
  
  ## <d 'Commute Inequality '>
    (0) (1) ltcom
    mpbi
  ## </d 'Commute Inequality '>
  A gtTrgt
  A not0divides2
  
  ## <d 'Commute Inequality '>
    (0) A ltcom
    sylbi2
  ## </d 'Commute Inequality '>
  syl
  ## </d>

  ## <d 'Zero is not a divisor'>
  ## <d>
  (-> (-. (<= A (1))) (-. (| x A))) biRemove1
  (= x (0)) imbi2i
  mpbi
  com12
  ## <d 'Negate Both Sides '>
    (= x (0)) (-. (| x A)) con34b
    (| x A) notnotr
    BiReplaceBi1Imp0
    sylib
  ## </d 'Negate Both Sides '>
  ## </d>

  ## <d>
  x gen
  x (-. (<= A (1)))   (-> (| x A) (-. (= x (0)))) 19.21
  mpbi
  ## </d>
  (-. (prime A)) a1i
  ## </d>

  ## <d>
  A x dfprime1lem
  ## </d>
  jcad
      
  ## <d 'Rearrange Terms' >
  ## <d 'Combine Universial and Existence Quantifiers '>
    x (-> (| x A) (-. (= x (0)))) (/\ (| x A) (/\ (-. (= x (1))) (< x A))) 19.29
    ImpReplaceImp1Imp1
  ## </d 'Combine Universial and Existence Quantifiers '>

  ## <d 'Associative Property '>
    (-> (| x A) (-. (= x (0)))) (| x A) (/\ (-. (= x (1))) (< x A)) anass
    ## <d 'Commutative Property'>
      (/\ (/\ (-> (| x A) (-. (= x (0)))) (| x A)) (/\ (-. (= x (1))) (< x A))) (/\ (-> (| x A) (-. (= x (0)))) (/\ (| x A) (/\ (-. (= x (1))) (< x A)))) bicom
      mpbi
    ## </d 'Commutative Property'>
    BiReplaceImp1Imp1Ex1
  ## </d 'Associative Property '>
  
  ## <d 'Commutative Property '>
    (-> (| x A) (-. (= x (0)))) (| x A) ancom
    BiReplaceImp1Imp1Ex1An0
  ## </d 'Commutative Property '>
  ## </d>
  
  ## <d 'Introduce conjunct as antecedent '>
    (| x A) (-. (= x (0))) abai
    ## <d 'Commutative Property'>
      (/\ (| x A) (-. (= x (0)))) (/\ (| x A) (-> (| x A) (-. (= x (0))))) bicom
      mpbi
    ## </d 'Commutative Property'>
    BiReplaceImp1Imp1Ex1An0
  ## </d 'Introduce conjunct as antecedent '>

  ## <d 'Associative Property'>
  ## <d 'Associative Property '>
    (| x A) (-. (= x (0))) (/\ (-. (= x (1))) (< x A)) anass
    BiReplaceImp1Imp1Ex1
  ## </d 'Associative Property '>
  
  ## <d 'Associative Property '>
    (-. (= x (0))) (-. (= x (1))) (< x A) anass
    ## <d 'Commutative Property'>
      (/\ (/\ (-. (= x (0))) (-. (= x (1)))) (< x A)) (/\ (-. (= x (0))) (/\ (-. (= x (1))) (< x A))) bicom
      mpbi
    ## </d 'Commutative Property'>
    BiReplaceImp1Imp1Ex1An1
  ## </d 'Associative Property '>
  ## </d>
  x ge0
  (-. (= x (0)))anRemove1  
  ## <d 'Commutative Property '>
    (-. (< x (0))) (-. (= x (0))) ancom
    bitr3icom
  ## </d 'Commutative Property '>
  
  ## <d 'Inequality Conversion '>
    x (0) axgrtri
    ## <d 'Commutative Property'>
      (-. (<= x (0))) (/\ (-. (= x (0))) (-. (< x (0)))) bicom
      mpbi
    ## </d 'Commutative Property'>
    bitr3icom
  ## </d 'Inequality Conversion '>
  
  ## <d 'x must be greater than 1'>
  ## <d 'Commutative Property '>
    (-. (<= x (0))) (-. (= x (0))) bicom
    mpbi
  ## </d 'Commutative Property '>
  BiReplaceImp1Imp1Ex1An1An0An0
  
  ## <d 'Convert between ≥ and > '>
    x (0) gtge2
    (1) pa_ax3r
      EqReplaceBi1Not0Lt1
    BiReplaceImp1Imp1Ex1An1An0An0
  ## </d 'Convert between ≥ and > '>
  
  ## <d 'Commutative Property '>
    (-. (< x (1))) (-. (= x (1))) ancom
    BiReplaceImp1Imp1Ex1An1An0
  ## </d 'Commutative Property '>
  
  ## <d 'Inequality Conversion '>
    x (1) axgrtri
    ## <d 'Commutative Property'>
      (-. (<= x (1))) (/\ (-. (= x (1))) (-. (< x (1)))) bicom
      mpbi
    ## </d 'Commutative Property'>
    BiReplaceImp1Imp1Ex1An1An0
  ## </d 'Inequality Conversion '>
  ## </d>

  ## <d 'Commute Inequality '>
  ## <d 'Commute Inequality '>
    x (1) lecom
    BiReplaceImp1Imp1Ex1An1An0Not0
  ## </d 'Commute Inequality '>
  
  ## <d 'Double Negative '>
    (< (1) x) notnotr
    BiReplaceImp1Imp1Ex1An1An0
  ## </d 'Double Negative '>
  ## </d>
)

## <title> Substitution </title>
## <table>
##   (-> (/\ (-.  [ ph ]   ]    ] ) ch) th)
##   (<->         [ ph ]   [ ps ] )
##   (-> (/\ (-.  [    [   [ ps ] ) ch) th)
## </table>
thm (BiReplaceImp0An0Not0 () (
     replacee (-> (/\ (-. ph) ch) th)
     substitution (<-> ph ps)) 
     (-> (/\ (-. ps) ch) th)
  replacee substitution
  con4biir
  BiReplaceImp0An0
)


## <title> Substitution </title>
## <table>
##   (-> (/\ (-. (E. x  [ ph ]   ]    ] )) ch) th)
##   (<->               [ ph ]   [ ps ] )
##   (-> (/\ (-. (E. x  [    [   [ ps ] )) ch) th)
## </table>
thm (BiReplaceImp0An0Not0Ex1 () (
     replacee (-> (/\ (-. (E. x ph)) ch) th)
     substitution (<-> ph ps)) 
     (-> (/\ (-. (E. x ps)) ch) th)
  replacee substitution
  x exbii
    BiReplaceImp0An0Not0
)

## <title> Substitution </title>
## <table>
##   (-> (/\ (-. (E. x (-.  [ ph ]   ]    ] ))) ch) th)
##   (<->                   [ ph ]   [ ps ] )
##   (-> (/\ (-. (E. x (-.  [    [   [ ps ] ))) ch) th)
## </table>
thm (BiReplaceImp0An0Not0Ex1Not0 () (
     replacee (-> (/\ (-. (E. x (-. ph))) ch) th)
     substitution (<-> ph ps)) 
     (-> (/\ (-. (E. x (-. ps))) ch) th)
  replacee substitution
  con4biir
  BiReplaceImp0An0Not0Ex1
)

thm (dfprime1lem3 ((A y)) ()  (-> (/\ (A. y (-> (/\ (< (1) y) (< y A)) (-. (| y A)))) (-. (<= A (1)))) (prime A)) 
  A y dfprime1lem2
  ## <d 'Import-Export Theorem '>
    (-. (prime A)) (-. (<= A (1))) (E. y (/\ (| y A) (/\ (< (1) y) (< y A)))) impexp
    ## <d 'Commutative Property'>
      (-> (/\ (-. (prime A)) (-. (<= A (1)))) (E. y (/\ (| y A) (/\ (< (1) y) (< y A))))) (-> (-. (prime A)) (-> (-. (<= A (1))) (E. y (/\ (| y A) (/\ (< (1) y) (< y A)))))) bicom
      mpbi
    ## </d 'Commutative Property'>
    mpbi
  ## </d 'Import-Export Theorem '>

  ## <d 'Negate Both Sides '>
    (/\ (-. (prime A)) (-. (<= A (1)))) (E. y (/\ (| y A) (/\ (< (1) y) (< y A)))) con34b
    mpbi
  ## </d 'Negate Both Sides '>

  ## <d 'DeMorgan's Law '>
    (-. (prime A)) (-. (<= A (1))) anor
    (prime A) notnotr
    BiReplaceBi1Not0Or0
    (<= A (1)) notnotr
      BiReplaceBi1Not0Or1
    BiReplaceImp1Not0
  ## </d 'DeMorgan's Law '>

  ## <d 'Double Negative '>
    (\/ (prime A) (<= A (1))) notnotr
    sylib
  ## </d 'Double Negative '>
  (-. (<= A (1))) anim1i
  ## <d 'Distributive Property '>
    (prime A) (<= A (1)) (-. (<= A (1))) andir
    sylib
  ## </d 'Distributive Property '>

  ## <d 'Definition of AND '>
    (<= A (1)) pm3.24

    (/\ (prime A) (-. (<= A (1)))) orNotRemove2
    (/\ (-. (E. y (/\ (| y A) (/\ (< (1) y) (< y A))))) (-. (<= A (1)))) imbi2i
    mpbi
  ## </d 'Definition of AND '>
  (prime A) (-. (<= A (1))) pm3.26
  syl  
  ## <d 'Definition of AND '>
    (| y A) (/\ (< (1) y) (< y A)) df-an
    BiReplaceImp0An0Not0Ex1
  ## </d 'Definition of AND '>
  
  ## <d 'Negate Both Sides '>
    (| y A) (-. (/\ (< (1) y) (< y A))) con34b
    (/\ (< (1) y) (< y A)) notnotr
    BiReplaceBi1Imp0
      BiReplaceImp0An0Not0Ex1Not0
  ## </d 'Negate Both Sides '>
  
  ## <d 'Definition of ∃ '>
    y (-. (-> (/\ (< (1) y) (< y A)) (-. (| y A)))) df-ex
    (-> (/\ (< (1) y) (< y A)) (-. (| y A))) notnotr
    BiReplaceBi1Not0Al1
    BiReplaceImp0An0Not0
  ## </d 'Definition of ∃ '>
  
  ## <d 'Double Negative '>
    (A. y (-> (/\ (< (1) y) (< y A)) (-. (| y A)))) notnotr
    BiReplaceImp0An0
  ## </d 'Double Negative '>
)



## <title> Substitution </title>
## <table>
##   (-> (/\ (C_  [ S ]   ]   ]  U) ph) ps)
##   (=_          [ S ]   [ T ] )
##   (-> (/\ (C_  [   [   [ T ]  U) ph) ps)
## </table>
thm (SeqReplaceImp0An0Ss0 () (
     replacee (-> (/\ (C_ S U) ph) ps)
     substitution (=_ S T)) 
     (-> (/\ (C_ T U) ph) ps)
  replacee substitution
  U sseq1i
  BiReplaceImp0An0
)


## <title> Substitution </title>
## <table>
##   (-> (/\ (C_ ({|} x  [ ph ]   ]    ] ) S) ch) th)
##   (<->                [ ph ]   [ ps ] )
##   (-> (/\ (C_ ({|} x  [    [   [ ps ] ) S) ch) th)
## </table>
thm (BiReplaceImp0An0Ss0Ab1 () (
     replacee (-> (/\ (C_ ({|} x ph) S) ch) th)
     substitution (<-> ph ps)) 
     (-> (/\ (C_ ({|} x ps) S) ch) th)
  replacee substitution
  x abbi2i
    SeqReplaceImp0An0Ss0
)


## <title> Substitution </title>
## <table>
##   (-> (/\ (C_ ({|} x (/\  [ ph ]   ]    ]  ch)) S) th) ta)
##   (<->                    [ ph ]   [ ps ] )
##   (-> (/\ (C_ ({|} x (/\  [    [   [ ps ]  ch)) S) th) ta)
## </table>
thm (BiReplaceImp0An0Ss0Ab1An0 () (
     replacee (-> (/\ (C_ ({|} x (/\ ph ch)) S) th) ta)
     substitution (<-> ph ps)) 
     (-> (/\ (C_ ({|} x (/\ ps ch)) S) th) ta)
  replacee substitution
  ch anbi1i
    BiReplaceImp0An0Ss0Ab1
)

## <title> One-digit Addition </title>
thm (1plus1 () () (= (+ (1) (1)) (2))
  df-2
  ## <d 'Commutative Property'>
    (2) (+ (1) (1)) eqcom
    mpbi
  ## </d 'Commutative Property'>
)

## <title> Two Successors Adds Two </title>
## <suggest> right('Equivalence', '+2') </suggest>
thm (a2suc () () (= (S (S A)) (+ A (2)))
  ## <d 'Successor Adds One '>
    (S A) a1suc
  ## </d 'Successor Adds One '>
  ## <d 'Successor Adds One '>
    A a1suc
    EqReplaceEq1Add0
  ## </d 'Successor Adds One '>
  ## <d 'Associative Property '>
    A (1) (1) addass
    EqReplaceEq1
  ## </d 'Associative Property '>
  ## <d 'Evaluate'>
    1plus1
    EqReplaceEq1Add1
  ## </d 'Evaluate'>
)

## <title> Substitution </title>
## <table>
##   (-> (/\ (C_ ({|} x (/\ (<=  [ A ]   ]   ]  C) ph)) S) ps) ch)
##   (=                          [ A ]   [ B ] )
##   (-> (/\ (C_ ({|} x (/\ (<=  [   [   [ B ]  C) ph)) S) ps) ch)
## </table>
thm (EqReplaceImp0An0Ss0Ab1An0Le0 () (
     replacee (-> (/\ (C_ ({|} x (/\ (<= A C) ph)) S) ps) ch)
     substitution (= A B)) 
     (-> (/\ (C_ ({|} x (/\ (<= B C) ph)) S) ps) ch)
  replacee substitution
  C leeq1i
  BiReplaceImp0An0Ss0Ab1An0
)

## <title> Substitution </title>
## <table>
##   (-> (/\ (C_ ({|} x (/\ ph  [ ps ]   ]    ] )) S) th) ta)
##   (<->                       [ ps ]   [ ch ] )
##   (-> (/\ (C_ ({|} x (/\ ph  [    [   [ ch ] )) S) th) ta)
## </table>
thm (BiReplaceImp0An0Ss0Ab1An1 () (
     replacee (-> (/\ (C_ ({|} x (/\ ph ps)) S) th) ta)
     substitution (<-> ps ch)) 
     (-> (/\ (C_ ({|} x (/\ ph ch)) S) th) ta)
  replacee substitution
  ph anbi2i
  BiReplaceImp0An0Ss0Ab1
)

## <title> Substitution </title>
## <table>
##   (-> (/\ ph (-.  [ ps ]   ]    ] )) th)
##   (<->            [ ps ]   [ ch ] )
##   (-> (/\ ph (-.  [    [   [ ch ] )) th)
## </table>
thm (BiReplaceImp0An1Not0 () (
     replacee (-> (/\ ph (-. ps)) th)
     substitution (<-> ps ch)) 
     (-> (/\ ph (-. ch)) th)
  replacee substitution
  con4biir
  BiReplaceImp0An1
)

## <title> Substitution </title>
## <table>
##   (<-> ph (<= A  [ B ]   ]   ] ))
##   (=             [ B ]   [ C ] )
##   (<-> ph (<= A  [   [   [ C ] ))
## </table>
thm (EqReplaceBi1Le1 () (
     replacee (<-> ph (<= A B))
     substitution (= B C)) 
     (<-> ph (<= A C))
  replacee
  substitution
A leeq2i
ph bibi2i
mpbi
)


thm (dfprime1lem4 ((A y)) () (-> (/\ (C_ ({...} (2) A) ({|} y (-. (| y (+ A (1)))))) (-. (<= A (0)))) (prime (+ A (1))))
  y (1) (+ A (1)) intervallt-rwff
  y (+ A (1)) divides-rwff1
  not-rwff
  ssImplies
  (-. (<= (+ A (1)) (1))) anbi1i
  y (+ A (1)) dfprime1lem3  
  ImpReplaceBi1
  
  ## <d 'Convert between ≤ and < '>
    (1) y ltle2
      BiReplaceImp0An0Ss0Ab1An0
  ## </d 'Convert between ≤ and < '>
  
  ## <d 'Evaluate'>
      1plus1
      EqReplaceImp0An0Ss0Ab1An0Le0
  ## </d 'Evaluate'>
  
  ## <d 'Convert between ≤ and < '>
    y (+ A (1)) ltle2
      BiReplaceImp0An0Ss0Ab1An1
  ## </d 'Convert between ≤ and < '>
  y A (1) leadd1  
  ## <d 'Commutative Property '>
    (<= y A) (<= (+ y (1)) (+ A (1))) bicom
    mpbi
  ## </d 'Commutative Property '>
  
  BiReplaceImp0An0Ss0Ab1An1
  
  ## <d 'Natural Number Interval Definition '>
    (2) A y df-interval
    ## <d 'Commutative Property'>
      ({...} (2) A) ({|} y (/\ (<= (2) y) (<= y A))) seqcom
      mpbi
    ## </d 'Commutative Property'>
    SeqReplaceImp0An0Ss0
  ## </d 'Natural Number Interval Definition '>
  A (0) (1) leadd1    
  ## <d 'Additive Identity Axiom '>
    (1) pa_ax3r
    EqReplaceBi1Le1
  ## </d 'Additive Identity Axiom '>
  
  ## <d 'Commutative Property '>
    (<= A (0)) (<= (+ A (1)) (1)) bicom
    mpbi
  ## </d 'Commutative Property '>
  BiReplaceImp0An1Not0
)

thm (provePrime ((A y)) (hyp (C_ ({...} (2) A) ({|} y (-. (| y (+ A (1)))))) hyp2 (-. (<= A (0)))) (prime (+ A (1)))
  hyp
  hyp2
  pm3.2i
  A y dfprime1lem4  
  ax-mp
)

# number 60.0
thm (lesuc1 () ()
  (<-> (<= A B) (<= (S A) (S B)))
  A  B  (1)  leadd1
  A  a1suc    (+ B (1))  leeq1i    bitr4i
  B  a1suc    (S A)  leeq2i    bitr4i
)

thm (sucGt () ()  (-. (<= (+ A (1)) (0)))
  (1) (0) A leadd1
  A pa_ax3r
  
    EqReplaceBi1Le1
  
  ## <d>
    (1) A addcom
  ## </d>
  EqReplaceBi1Le0  
  ## <d 'Number is Not Zero'>
    (0) pa_ax1plus
    ## <d 'Evaluate'>
      (1) pa_ax3r
      EqReplaceNot0Eq1
    ## </d 'Evaluate'>
    ## <d 'Commutative Property'>
      (0) (1) eqcom
      mtbi
    ## </d 'Commutative Property'>
  ## </d 'Number is Not Zero'>
  ## <d 'Greater Than Or Equal To Zero'>
    (1) ge0
  ## </d 'Greater Than Or Equal To Zero'>
  axgrtrii
  
  mtbiRemove
  A ge0
  (+ A (1)) geTrgt
  ax-mp
)


thm (suc2Gt () ()  (-. (<= (S (S A)) (1)))
  A sucGt
  A a1suc
  
  ## <d>
    (S A) (+ A (1)) eqcom
  ## </d>
  mpbi
  
  EqReplaceNot0Le0
  (S A) (0) (1) leadd1  
  mtbi
  
  ## <d 'Evaluate'>
    (1) pa_ax3r
    EqReplaceNot0Le1
  ## </d 'Evaluate'>

  (S A) a1suc  
  ## <d>
    (S (S A)) (+ (S A) (1)) eqcom
  ## </d>
  mpbi
  
  EqReplaceNot0Le0
)

# number 61.0
## <summary> Every multitude has either a proper multitude divisor or a prime multitude divisor </summary>
thm (primedivisor.1 ((A x) (A z)) ()
    (\/ (E. z (/\ (< (S (S z)) (S (S A))) (| (S (S z)) (S (S A)))))
        (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S A))))))

# Case 1: A'' is itself prime
x (prime (S (S A))) 19.3  biimpri
  x A tyex
    (= x A) id suceqd suceqd
    (S (S x)) (S (S A)) primeeq biimprd    syl
      (= x A) id suceqd suceqd
      (S (S x)) (S (S A)) (S (S A)) divideseq1   syl  biimprd
    anim12d
      (S (S A)) dividessym   (prime (S (S A))) jctr
    syl5    com12
    x 19.20i
    x (= x A) (/\ (prime (S (S x))) (| (S (S x)) (S (S A)))) 19.22  syl
  mpi
syl

# Case 2: A'' is not prime.
  (S (S A)) x df-prime
  A suc2Gt  
  (A. x (-> (| x (S (S A))) (\/ (= x (1)) (= x (S (S A)))))) anRemove1
  (prime (S (S A))) bibi2i
  mpbi
notbii  biimpi
  (-> (| x (S (S A))) (\/ (= x (1)) (= x (S (S A))))) notnot  biimpri   x 19.20i    con3i   syl
  x (-. (-> (| x (S (S A))) (\/ (= x (1)) (= x (S (S A)))))) df-ex  sylibr
  (| x (S (S A))) (\/ (= x (1)) (= x (S (S A)))) pm4.61   biimpi  x 19.22i   syl

    x (S A) dividesle
      (= x (1)) (= x (S (S A))) ioran  biimpi
    anim12i  ancomd
    (-. (= x (1))) (-. (= x (S (S A)))) (<= x (S (S A)))  anass sylib
    x (S (S A)) df-lt    biimpri  ancoms  (-. (= x (1))) anim2i   syl
    (| x (S (S A)))  (-. (\/ (= x (1)) (= x (S (S A)))))  (/\ (-. (= x (1))) (< x (S (S A))))  pm5.3    mpbi
    (| x (S (S A))) (-. (= x (1))) (< x (S (S A))) anass    biimpri    syl
        (S A)  not0divides    x  (0)  (S (S A))  divideseq1    biimpd    mtoi    con2i
         x 0orpos    ori    syl
         (1)  x  y  df-le    biimpi    y a1suc    y  (1)  addcom    eqtr    x  eqeq1i    biimpri    y  19.22i    syl    syl
         (-. (= x (1)))  anim1i
         y  (= (S y) x)  (-. (= x (1)))  19.41    sylibr
           (S y)  x  (1)  eqeq1    biimpd    con3d    (= (S y) x)  (-. (= x (1)))  (-. (= (S y) (1)))  pm3.31    ax-mp
           (= y (0))  id   suceqd    df-1    syl6eqr    con3i    y 0orpos    ori    syl    syl
               (1)  y  z  df-le    biimpi    z a1suc    z  (1)  addcom    eqtr    y  eqeq1i    biimpri    (= (S z) y)  id    suceqd   syl    eqcomd
           z  19.22i    syl    syl
        (= (S y) x)  (-. (= x (1)))  (E. z (= (S y) (S (S z))))  pm5.3    mpbi    y  19.22i    syl

        z  (= (S y) (S (S z)))  (= (S y) x)  19.41    biimpri    ancoms     y  19.22i   syl
        (S y)  (S (S z))  x  ax-eqtr     z  19.22i    y  19.22i    syl
        y  (E. z (= (S (S z)) x))  ex-nf    syl
        (| x (S (S A)))  (-. (= x (1)))  (E. z (= (S (S z)) x))  pm5.3    mpbi    ancomd
        z  (= (S (S z)) x)  (| x (S (S A)))  19.41    sylibr
          (S (S z))  x  (S (S A))  divideseq1    biimprd    (= (S (S z)) x)  (| x (S (S A)))  (| (S (S z)) (S (S A)))  pm3.31    ax-mp
          (= (S (S z)) x)  (| x (S (S A)))  (| (S (S z)) (S (S A)))  pm5.3    mpbi
        z  19.22i   syl
     (< x (S (S A)))   anim1i    syl
     z  (/\ (= (S (S z)) x) (| (S (S z)) (S (S A))))  (< x (S (S A)))  19.41    sylibr
       (= (S (S z)) x)  (| (S (S z)) (S (S A)))  (< x (S (S A)))  an23    (= (S (S z))  x)  id    (S (S A))  lteq1d    biimprd
          (= (S (S z)) x)  (< x (S (S A)))  (< (S (S z)) (S (S A)))  pm3.31    ax-mp    (| (S (S z)) (S (S A))) anim1i
       sylbi
     z 19.22i    syl
   x  19.22i    syl
   x  (E. z (/\ (< (S (S z)) (S (S A))) (| (S (S z)) (S (S A)))))  ex-nf    syl
nsyl4    orri
)
# number 62.0
# Induction tool
thm (primedivisor.2 ((A x)) ()
    (-> (= y A) (<-> (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S y)))))
                     (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S A)))))))
    (= y A)  id    suceqd    suceqd
    (S (S y))  (S (S A)) (S (S x))  divideseq2    syl
    (prime (S (S x)))  anbi2d
    x exbid
)

# The "divides" relation is transitive
thm (dividestr () ()
  (-> (/\ (| A B) (| B C)) (| A C))
    A  B  x  df-divides    biimpi
        B  C  y  df-divides    biimpi
    anim12i
    x  (= (* A x) B)  (E. y (= (* B y) C))  19.41    sylibr
    y  (= (* B y) C)  (= (* A x) B)  19.41    biimpri    ancoms    x 19.22i    syl
        (* A x)  B  y  muleq1     C  eqeq1d    biimprd
        (= (* A x) B)  (= (* B y) C)  (= (* (* A x) y) C)  pm3.31    ax-mp
        ancoms A  x  y  mulass    syl5eqr    z 19.21ai
            z  (* x y)  tyex
            z  (* x y)  A  muleq2    C  eqeq1d    biimprd    z  19.22i    ax-mp
            z  (= (* A (* x y)) C)  (= (* A z) C)  eximp1    ax-mp
        syl
    y  19.22i    x  19.22i    syl
    19.9d    19.9d
    A  C  z  df-divides    sylibr
)
# number 64.0
thm (primedivisor ((A x)) ()
    (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S A)))))

x' (0)  x  primedivisor.2
  x' (S y)  x  primedivisor.2
    x'  A  x  primedivisor.2

      # Base case
      x  (0)  tyex
        2prime
          df-1    (1)  (S (0))  pa_ax2    mpbi   (1)  a1suc    eqtr3    (S (S (0))) (+ (1) (1)) primeeq    ax-mp
        mpbir
        (= x (0))  id    suceqd    suceqd    (S (S x))  (S (S (0)))  primeeq    syl    biimprd    mpi
          (S (S (0)))  dividessym
          (= x (0))  id    suceqd    suceqd    (S (S x))  (S (S (0)))  (S (S (0))) divideseq1   syl    biimprd    mpi
        jca
      x  19.22i    ax-mp

        # Inductive step
        x' (S y) x primedivisor.1
          (S (S x'))  (S (S y))  lesuc    biimpi
          (S x')  (S y)  lesuc1    sylibr    x'  y  lesuc1    sylibr
          (| (S (S x')) (S (S (S y))))  anim1i
        x'  19.22i    (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S (S y))))))  orim1i    ax-mp
          (<= x' y)  (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S x')))))  (| (S (S x')) (S (S (S y))))  pm3.45
          x'  19.20i  x'  (/\ (<= x' y) (| (S (S x')) (S (S (S y)))))  (/\ (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S x'))))) (| (S (S x')) (S (S (S y))))) 19.22    syl
        (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S (S y))))))   orim1d    mpi
          (S (S x))  (S (S x'))  (S (S (S y)))  dividestr    (prime (S (S x)))  anim2i
          anassrs    x  19.22i
          x  (/\ (prime (S (S x))) (| (S (S x)) (S (S x'))))  (| (S (S x')) (S (S (S y))))  19.41    (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S (S y)))))) imbi1i    mpbi
        x'  19.22i    19.9d
        (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S (S y))))))  orim1i    syl
        (E. x (/\ (prime (S (S x))) (| (S (S x)) (S (S (S y))))))  pm1.2  syl
        sind
)




## <title> Substitution </title>
## <table>
##   (E. x (/\ ph  [ ps ]   ]    ] ))
##   (<->          [ ps ]   [ ch ] )
##   (E. x (/\ ph  [    [   [ ch ] ))
## </table>
thm (BiReplaceEx1An1 () (
     replacee (E. x (/\ ph ps))
     substitution (<-> ps ch)) 
     (E. x (/\ ph ch))
  replacee substitution
  ph anbi2i
  exbiii
)


## <title> Substitution </title>
## <table>
##   (E. x (/\ ph (| A  [ B ]   ]   ] )))
##   (=                 [ B ]   [ C ] )
##   (E. x (/\ ph (| A  [   [   [ C ] )))
## </table>
thm (EqReplaceEx1An1Divs1 () (
     replacee (E. x (/\ ph (| A B)))
     substitution (= B C)) 
     (E. x (/\ ph (| A C)))
  replacee substitution
  A divideseq2i
  BiReplaceEx1An1
)

## <title> Substitution </title>
## <table>
##   (E. x (/\ ph (|  [ A ]   ]   ]  C)))
##   (=               [ A ]   [ B ] )
##   (E. x (/\ ph (|  [   [   [ B ]  C)))
## </table>
thm (EqReplaceEx1An1Divs0 () (
     replacee (E. x (/\ ph (| A C)))
     substitution (= A B)) 
     (E. x (/\ ph (| B C)))
  replacee substitution
  C divideseq1i
  BiReplaceEx1An1
)

## <title> Substitution </title>
## <table>
##   (E. x (/\  [ ph ]   ]    ]  ch))
##   (<->       [ ph ]   [ ps ] )
##   (E. x (/\  [    [   [ ps ]  ch))
## </table>
thm (BiReplaceEx1An0 () (
     replacee (E. x (/\ ph ch))
     substitution (<-> ph ps)) 
     (E. x (/\ ps ch))
  replacee substitution
  ch anbi1i
  exbiii
)


## <title> Substitution </title>
## <table>
##   (E. x (/\ (prime  [ A ]   ]   ] ) ph))
##   (=                [ A ]   [ B ] )
##   (E. x (/\ (prime  [   [   [ B ] ) ph))
## </table>
thm (EqReplaceEx1An0Prime0 () (
     replacee (E. x (/\ (prime A) ph))
     substitution (= A B)) 
     (E. x (/\ (prime B) ph))
  replacee substitution
  primeeqi
  BiReplaceEx1An0
)

thm (primedivisor2.1 ((B y) (A y)) () (<-> ([/] B y (/\ (prime y) (| y A))) (/\ (prime B) (| B A)))
  y B primeeq
  y B A divideseq1
  anbi12d
  sbcie
)

## <title> Numbers above 1 have prime divisors </title>
thm (primedivisor2 ((A y)) () (-> (<= (2) A) (E. y (/\ (prime y) (| y A))))
  (2) A (2) halfminusaddcom  
  ## <d>
    A (2) halfminuscan
    EqReplaceImp1Eq1
  ## </d>
  y divideseq2d
  (prime y) anbi2d
  y exbid

  x (.- A (2)) primedivisor  
  ## <d 'Two Successors Adds Two '>
    (.- A (2)) a2suc
    EqReplaceEx1An1Divs1
  ## </d 'Two Successors Adds Two '>
  ## <d 'Two Successors Adds Two '>
    x a2suc
    EqReplaceEx1An1Divs0
  ## </d 'Two Successors Adds Two '>  
  ## <d 'Two Successors Adds Two '>
    x a2suc
    EqReplaceEx1An0Prime0
  ## </d 'Two Successors Adds Two '>


  x (2) z (/\ (prime z) (| z (+ (.- A (2)) (2)))) y sbcadd
  (+ x (2)) z (+ (.- A (2)) (2)) primedivisor2.1
  sylbi2
  y z (+ (.- A (2)) (2)) primedivisor2.1  
  BiReplaceImp1Ex1
  ImpReplaceEx1


  x (E. y (/\ (prime y) (| y (+ (.- A (2)) (2))))) 19.9    
  mpbi
  
  (E. y (/\ (prime y) (| y A))) biRemove1
  (<= (2) A) imbi2i
  mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (/\  [ ps ]   ]    ]  th))
##   (->         [ ps ]   [ ch ] )
##   (-> ph (/\  [    [   [ ch ]  th))
## </table>
thm (ImpReplaceImp1An0 () (
     replacee (-> ph (/\ ps th))
     substitution (-> ps ch)) 
     (-> ph (/\ ch th))
  replacee substitution
  th anim1i
  syl
)

## <title> Substitution </title>
## <table>
##   (-> ph (/\ ps  [ ch ]   ]    ] ))
##   (<->           [ ch ]   [ th ] )
##   (-> ph (/\ ps  [    [   [ th ] ))
## </table>
thm (BiReplaceImp1An1 () (
     replacee (-> ph (/\ ps ch))
     substitution (<-> ch th)) 
     (-> ph (/\ ps th))
  replacee substitution
  ps anbi2i
  sylib
)


## <title> Substitution </title>
## <table>
##   (-> ph (/\ ps (-.  [ ch ]   ]    ] )))
##   (<->               [ ch ]   [ th ] )
##   (-> ph (/\ ps (-.  [    [   [ th ] )))
## </table>
thm (BiReplaceImp1An1Not0 () (
     replacee (-> ph (/\ ps (-. ch)))
     substitution (<-> ch th)) 
     (-> ph (/\ ps (-. th)))
  replacee substitution
  con4biir
    BiReplaceImp1An1
)


## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps  [ ch ]   ]    ] )))
##   (<->                 [ ch ]   [ th ] )
##   (-> ph (E. x (/\ ps  [    [   [ th ] )))
## </table>
thm (BiReplaceImp1Ex1An1 () (
     replacee (-> ph (E. x (/\ ps ch)))
     substitution (<-> ch th)) 
     (-> ph (E. x (/\ ps th)))
  replacee substitution
  ps anbi2i
    BiReplaceImp1Ex1
)


## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (-.  [ ch ]   ]    ] ))))
##   (<->                     [ ch ]   [ th ] )
##   (-> ph (E. x (/\ ps (-.  [    [   [ th ] ))))
## </table>
thm (BiReplaceImp1Ex1An1Not0 () (
     replacee (-> ph (E. x (/\ ps (-. ch))))
     substitution (<-> ch th)) 
     (-> ph (E. x (/\ ps (-. th))))
  replacee substitution
  con4biir
    BiReplaceImp1Ex1An1
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\  [ ps ]   ]    ]  th)))
##   (<->              [ ps ]   [ ch ] )
##   (-> ph (E. x (/\  [    [   [ ch ]  th)))
## </table>
thm (BiReplaceImp1Ex1An0 () (
     replacee (-> ph (E. x (/\ ps th)))
     substitution (<-> ps ch)) 
     (-> ph (E. x (/\ ch th)))
  replacee substitution
  th anbi1i
  BiReplaceImp1Ex1
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (/\  [ ch ]   ]    ]  ta))))
##   (<->                     [ ch ]   [ th ] )
##   (-> ph (E. x (/\ ps (/\  [    [   [ th ]  ta))))
## </table>
thm (BiReplaceImp1Ex1An1An0 () (
     replacee (-> ph (E. x (/\ ps (/\ ch ta))))
     substitution (<-> ch th)) 
     (-> ph (E. x (/\ ps (/\ th ta))))
  replacee substitution
  ta anbi1i
  BiReplaceImp1Ex1An1
)


## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (/\ (/\ ch  [ th ]   ]    ] ) et))))
##   (<->                            [ th ]   [ ta ] )
##   (-> ph (E. x (/\ ps (/\ (/\ ch  [    [   [ ta ] ) et))))
## </table>
thm (BiReplaceImp1Ex1An1An0An1 () (
     replacee (-> ph (E. x (/\ ps (/\ (/\ ch th) et))))
     substitution (<-> th ta)) 
     (-> ph (E. x (/\ ps (/\ (/\ ch ta) et))))
  replacee substitution
  ch anbi2i
    BiReplaceImp1Ex1An1An0
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x  [ ps ]   ]    ] ))
##   (->           [ ps ]   [ ch ] )
##   (-> ph (E. x  [    [   [ ch ] ))
## </table>
thm (ImpReplaceImp1Ex1 () (
     replacee (-> ph (E. x ps))
     substitution (-> ps ch)) 
     (-> ph (E. x ch))
  replacee substitution
  x 19.22i
  syl
)


## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps  [ ch ]   ]    ] )))
##   (->                  [ ch ]   [ th ] )
##   (-> ph (E. x (/\ ps  [    [   [ th ] )))
## </table>
thm (ImpReplaceImp1Ex1An1 () (
     replacee (-> ph (E. x (/\ ps ch)))
     substitution (-> ch th)) 
     (-> ph (E. x (/\ ps th)))
  replacee substitution
  ps anim2i
    ImpReplaceImp1Ex1
)


## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (/\  [ ch ]   ]    ]  ta))))
##   (->                      [ ch ]   [ th ] )
##   (-> ph (E. x (/\ ps (/\  [    [   [ th ]  ta))))
## </table>
thm (ImpReplaceImp1Ex1An1An0 () (
     replacee (-> ph (E. x (/\ ps (/\ ch ta))))
     substitution (-> ch th)) 
     (-> ph (E. x (/\ ps (/\ th ta))))
  replacee substitution
  ta anim1i
    ImpReplaceImp1Ex1An1
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (/\ (/\  [ ch ]   ]    ]  ta) et))))
##   (->                          [ ch ]   [ th ] )
##   (-> ph (E. x (/\ ps (/\ (/\  [    [   [ th ]  ta) et))))
## </table>
thm (ImpReplaceImp1Ex1An1An0An0 () (
     replacee (-> ph (E. x (/\ ps (/\ (/\ ch ta) et))))
     substitution (-> ch th)) 
     (-> ph (E. x (/\ ps (/\ (/\ th ta) et))))
  replacee substitution
  ta anim1i
  ImpReplaceImp1Ex1An1An0
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ (/\  [ ps ]   ]    ]  th) ta)))
##   (<->                  [ ps ]   [ ch ] )
##   (-> ph (E. x (/\ (/\  [    [   [ ch ]  th) ta)))
## </table>
thm (BiReplaceImp1Ex1An0An0 () (
     replacee (-> ph (E. x (/\ (/\ ps th) ta)))
     substitution (<-> ps ch)) 
     (-> ph (E. x (/\ (/\ ch th) ta)))
  replacee substitution
  th anbi1i
  BiReplaceImp1Ex1An0
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (/\ ch  [ th ]   ]    ] ))))
##   (->                         [ th ]   [ ta ] )
##   (-> ph (E. x (/\ ps (/\ ch  [    [   [ ta ] ))))
## </table>
thm (ImpReplaceImp1Ex1An1An1 () (
     replacee (-> ph (E. x (/\ ps (/\ ch th))))
     substitution (-> th ta)) 
     (-> ph (E. x (/\ ps (/\ ch ta))))
  replacee substitution
  ch anim2i
  ImpReplaceImp1Ex1An1
)


## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (/\ ch (/\ th  [ ta ]   ]    ] )))))
##   (->                                [ ta ]   [ et ] )
##   (-> ph (E. x (/\ ps (/\ ch (/\ th  [    [   [ et ] )))))
## </table>
thm (ImpReplaceImp1Ex1An1An1An1 () (
     replacee (-> ph (E. x (/\ ps (/\ ch (/\ th ta)))))
     substitution (-> ta et)) 
     (-> ph (E. x (/\ ps (/\ ch (/\ th et)))))
  replacee substitution
  th anim2i
    ImpReplaceImp1Ex1An1An1
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (/\ ch  [ th ]   ]    ] ))))
##   (<->                        [ th ]   [ ta ] )
##   (-> ph (E. x (/\ ps (/\ ch  [    [   [ ta ] ))))
## </table>
thm (BiReplaceImp1Ex1An1An1 () (
     replacee (-> ph (E. x (/\ ps (/\ ch th))))
     substitution (<-> th ta)) 
     (-> ph (E. x (/\ ps (/\ ch ta))))
  replacee substitution
  ch anbi2i
  BiReplaceImp1Ex1An1
)


## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (/\ ch (/\ th  [ ta ]   ]    ] )))))
##   (<->                               [ ta ]   [ et ] )
##   (-> ph (E. x (/\ ps (/\ ch (/\ th  [    [   [ et ] )))))
## </table>
thm (BiReplaceImp1Ex1An1An1An1 () (
     replacee (-> ph (E. x (/\ ps (/\ ch (/\ th ta)))))
     substitution (<-> ta et)) 
     (-> ph (E. x (/\ ps (/\ ch (/\ th et)))))
  replacee substitution
  th anbi2i
    BiReplaceImp1Ex1An1An1
)


## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (/\ ch (/\ th (E. y  [ ta ]   ]    ] ))))))
##   (<->                                     [ ta ]   [ et ] )
##   (-> ph (E. x (/\ ps (/\ ch (/\ th (E. y  [    [   [ et ] ))))))
## </table>
thm (BiReplaceImp1Ex1An1An1An1Ex1 () (
     replacee (-> ph (E. x (/\ ps (/\ ch (/\ th (E. y ta))))))
     substitution (<-> ta et)) 
     (-> ph (E. x (/\ ps (/\ ch (/\ th (E. y et))))))
  replacee substitution
  y exbii
    BiReplaceImp1Ex1An1An1An1
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (/\ ch (/\ th (E. y (/\  [ ta ]   ]    ]  zi)))))))
##   (<->                                         [ ta ]   [ et ] )
##   (-> ph (E. x (/\ ps (/\ ch (/\ th (E. y (/\  [    [   [ et ]  zi)))))))
## </table>
thm (BiReplaceImp1Ex1An1An1An1Ex1An0 () (
     replacee (-> ph (E. x (/\ ps (/\ ch (/\ th (E. y (/\ ta zi)))))))
     substitution (<-> ta et)) 
     (-> ph (E. x (/\ ps (/\ ch (/\ th (E. y (/\ et zi)))))))
  replacee substitution
  zi anbi1i
  BiReplaceImp1Ex1An1An1An1Ex1
)

## <title> Substitution </title>
## <table>
##   (-> ph (/\ (E. x  [ ps ]   ]    ] ) th))
##   (->               [ ps ]   [ ch ] )
##   (-> ph (/\ (E. x  [    [   [ ch ] ) th))
## </table>
thm (ImpReplaceImp1An0Ex1 () (
     replacee (-> ph (/\ (E. x ps) th))
     substitution (-> ps ch)) 
     (-> ph (/\ (E. x ch) th))
  replacee substitution
  x 19.22i
  ImpReplaceImp1An0
)


## <title> Substitution </title>
## <table>
##   (-> ph (/\ (E. x (/\ ps  [ ch ]   ]    ] )) ta))
##   (->                      [ ch ]   [ th ] )
##   (-> ph (/\ (E. x (/\ ps  [    [   [ th ] )) ta))
## </table>
thm (ImpReplaceImp1An0Ex1An1 () (
     replacee (-> ph (/\ (E. x (/\ ps ch)) ta))
     substitution (-> ch th)) 
     (-> ph (/\ (E. x (/\ ps th)) ta))
  replacee substitution
  ps anim2i
    ImpReplaceImp1An0Ex1
)

## <title> Substitution </title>
## <table>
##   (-> ph (/\ (E. x  [ ps ]   ]    ] ) th))
##   (<->              [ ps ]   [ ch ] )
##   (-> ph (/\ (E. x  [    [   [ ch ] ) th))
## </table>
thm (BiReplaceImp1An0Ex1 () (
     replacee (-> ph (/\ (E. x ps) th))
     substitution (<-> ps ch)) 
     (-> ph (/\ (E. x ch) th))
  replacee substitution
  x exbii
  BiReplaceImp1An0
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (/\ ch (-.  [ th ]   ]    ] )))))
##   (<->                            [ th ]   [ ta ] )
##   (-> ph (E. x (/\ ps (/\ ch (-.  [    [   [ ta ] )))))
## </table>
thm (BiReplaceImp1Ex1An1An1Not0 () (
     replacee (-> ph (E. x (/\ ps (/\ ch (-. th)))))
     substitution (<-> th ta)) 
     (-> ph (E. x (/\ ps (/\ ch (-. ta)))))
  replacee substitution
  con4biir
  BiReplaceImp1Ex1An1An1
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (A. y  [ ch ]   ]    ] ))))
##   (->                        [ ch ]   [ th ] )
##   (-> ph (E. x (/\ ps (A. y  [    [   [ th ] ))))
## </table>
thm (ImpReplaceImp1Ex1An1Al1 () (
     replacee (-> ph (E. x (/\ ps (A. y ch))))
     substitution (-> ch th)) 
     (-> ph (E. x (/\ ps (A. y th))))
  replacee substitution
  y 19.20i
  ImpReplaceImp1Ex1An1
)


## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (A. y (/\  [ ch ]   ]    ]  ta)))))
##   (->                            [ ch ]   [ th ] )
##   (-> ph (E. x (/\ ps (A. y (/\  [    [   [ th ]  ta)))))
## </table>
thm (ImpReplaceImp1Ex1An1Al1An0 () (
     replacee (-> ph (E. x (/\ ps (A. y (/\ ch ta)))))
     substitution (-> ch th)) 
     (-> ph (E. x (/\ ps (A. y (/\ th ta)))))
  replacee substitution
  ta anim1i
    ImpReplaceImp1Ex1An1Al1
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (A. y  [ ch ]   ]    ] ))))
##   (<->                       [ ch ]   [ th ] )
##   (-> ph (E. x (/\ ps (A. y  [    [   [ th ] ))))
## </table>
thm (BiReplaceImp1Ex1An1Al1 () (
     replacee (-> ph (E. x (/\ ps (A. y ch))))
     substitution (<-> ch th)) 
     (-> ph (E. x (/\ ps (A. y th))))
  replacee substitution
  y albii
  BiReplaceImp1Ex1An1
)


## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (A. y (/\  [ ch ]   ]    ]  ta)))))
##   (<->                           [ ch ]   [ th ] )
##   (-> ph (E. x (/\ ps (A. y (/\  [    [   [ th ]  ta)))))
## </table>
thm (BiReplaceImp1Ex1An1Al1An0 () (
     replacee (-> ph (E. x (/\ ps (A. y (/\ ch ta)))))
     substitution (<-> ch th)) 
     (-> ph (E. x (/\ ps (A. y (/\ th ta)))))
  replacee substitution
  ta anbi1i
    BiReplaceImp1Ex1An1Al1
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (A. y (/\ (-.  [ ch ]   ]    ] ) ta)))))
##   (<->                               [ ch ]   [ th ] )
##   (-> ph (E. x (/\ ps (A. y (/\ (-.  [    [   [ th ] ) ta)))))
## </table>
thm (BiReplaceImp1Ex1An1Al1An0Not0 () (
     replacee (-> ph (E. x (/\ ps (A. y (/\ (-. ch) ta)))))
     substitution (<-> ch th)) 
     (-> ph (E. x (/\ ps (A. y (/\ (-. th) ta)))))
  replacee substitution
  con4biir
  BiReplaceImp1Ex1An1Al1An0
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (A. y (\/  [ ch ]   ]    ]  ta)))))
##   (<->                           [ ch ]   [ th ] )
##   (-> ph (E. x (/\ ps (A. y (\/  [    [   [ th ]  ta)))))
## </table>
thm (BiReplaceImp1Ex1An1Al1Or0 () (
     replacee (-> ph (E. x (/\ ps (A. y (\/ ch ta)))))
     substitution (<-> ch th)) 
     (-> ph (E. x (/\ ps (A. y (\/ th ta)))))
  replacee substitution
  ta orbi1i
  BiReplaceImp1Ex1An1Al1
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (A. y (\/  [ ch ]   ]    ]  ta)))))
##   (->                            [ ch ]   [ th ] )
##   (-> ph (E. x (/\ ps (A. y (\/  [    [   [ th ]  ta)))))
## </table>
thm (ImpReplaceImp1Ex1An1Al1Or0 () (
     replacee (-> ph (E. x (/\ ps (A. y (\/ ch ta)))))
     substitution (-> ch th)) 
     (-> ph (E. x (/\ ps (A. y (\/ th ta)))))
  replacee substitution
  ta orim1i
  ImpReplaceImp1Ex1An1Al1
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (A. y (\/ ch  [ th ]   ]    ] )))))
##   (->                               [ th ]   [ ta ] )
##   (-> ph (E. x (/\ ps (A. y (\/ ch  [    [   [ ta ] )))))
## </table>
thm (ImpReplaceImp1Ex1An1Al1Or1 () (
     replacee (-> ph (E. x (/\ ps (A. y (\/ ch th)))))
     substitution (-> th ta)) 
     (-> ph (E. x (/\ ps (A. y (\/ ch ta)))))
  replacee substitution
  ch orim2i
  ImpReplaceImp1Ex1An1Al1
)

## <title> Substitution </title>
## <table>
##   (<-> ph (-. (/\  [ ps ]   ]    ]  th)))
##   (<->             [ ps ]   [ ch ] )
##   (<-> ph (-. (/\  [    [   [ ch ]  th)))
## </table>
thm (BiReplaceBi1Not0An0 () (
     replacee (<-> ph (-. (/\ ps th)))
     substitution (<-> ps ch)) 
     (<-> ph (-. (/\ ch th)))
  replacee substitution
  th anbi1i
  BiReplaceBi1Not0
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (-. (E. y  [ ch ]   ]    ] )))))
##   (<->                           [ ch ]   [ th ] )
##   (-> ph (E. x (/\ ps (-. (E. y  [    [   [ th ] )))))
## </table>
thm (BiReplaceImp1Ex1An1Not0Ex1 () (
     replacee (-> ph (E. x (/\ ps (-. (E. y ch)))))
     substitution (<-> ch th)) 
     (-> ph (E. x (/\ ps (-. (E. y th)))))
  replacee substitution
  y exbii
  BiReplaceImp1Ex1An1Not0
)


## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (-. (E. y (-.  [ ch ]   ]    ] ))))))
##   (<->                               [ ch ]   [ th ] )
##   (-> ph (E. x (/\ ps (-. (E. y (-.  [    [   [ th ] ))))))
## </table>
thm (BiReplaceImp1Ex1An1Not0Ex1Not0 () (
     replacee (-> ph (E. x (/\ ps (-. (E. y (-. ch))))))
     substitution (<-> ch th)) 
     (-> ph (E. x (/\ ps (-. (E. y (-. th))))))
  replacee substitution
  con4biir
    BiReplaceImp1Ex1An1Not0Ex1
)

thm (hasPrimeDivisor () ()  (-> (/\ (-. (prime x)) (/\ (-. (<= x (1))) (-. (E. y (/\ (| y x) (prime y)))))) (E. z (/\ (< z x) (-. (E. y (/\ (| y z) (prime y)))))))
  (/\ (-. (prime x)) (/\ (-. (<= x (1))) (-. (E. y (/\ (| y x) (prime y)))))) id
  
  ## <d 'Associative Property '>
    (-. (prime x)) (-. (<= x (1))) (-. (E. y (/\ (| y x) (prime y)))) anass
    ## <d 'Commutative Property'>
      (/\ (/\ (-. (prime x)) (-. (<= x (1)))) (-. (E. y (/\ (| y x) (prime y))))) (/\ (-. (prime x)) (/\ (-. (<= x (1))) (-. (E. y (/\ (| y x) (prime y)))))) bicom
      mpbi
    ## </d 'Commutative Property'>
    sylib
  ## </d 'Associative Property '>
  x z dfprime1lem2    
  ## <d 'Import-Export Theorem '>
    (-. (prime x)) (-. (<= x (1))) (E. z (/\ (| z x) (/\ (< (1) z) (< z x)))) impexp
    ## <d 'Commutative Property'>
      (-> (/\ (-. (prime x)) (-. (<= x (1)))) (E. z (/\ (| z x) (/\ (< (1) z) (< z x))))) (-> (-. (prime x)) (-> (-. (<= x (1))) (E. z (/\ (| z x) (/\ (< (1) z) (< z x)))))) bicom
      mpbi
    ## </d 'Commutative Property'>
    mpbi
  ## </d 'Import-Export Theorem '>
  
  ImpReplaceImp1An0
  (< (1) z) (< z x) pm3.27
  
  ImpReplaceImp1An0Ex1An1

  ## <d 'Commutative Property '>
    (| z x) (< z x) ancom
    BiReplaceImp1An0Ex1
  ## </d 'Commutative Property '>
  (-. (E. y (/\ (| y x) (prime y)))) z alnfi  
  (E. z (/\ (< z x) (| z x))) anim2i
  
  syl
  
  ## <d 'Combine Universial and Existence Quantifiers '>
    z (/\ (< z x) (| z x)) (-. (E. y (/\ (| y x) (prime y)))) 19.29r
    syl
  ## </d 'Combine Universial and Existence Quantifiers '>
  
  ## <d 'Associative Property '>
    (< z x) (| z x) (-. (E. y (/\ (| y x) (prime y)))) anass
    BiReplaceImp1Ex1
  ## </d 'Associative Property '>

  (| z x) y alnfi  
  ImpReplaceImp1Ex1An1An0
  
  ## <d 'Definition of ∃ '>
    y (/\ (| y x) (prime y)) df-ex
      BiReplaceImp1Ex1An1An1Not0
  ## </d 'Definition of ∃ '>
  
  ## <d 'Double Negative '>
    (A. y (-. (/\ (| y x) (prime y)))) notnotr
    BiReplaceImp1Ex1An1An1
  ## </d 'Double Negative '>
  
  ## <d 'Distributive Property '>
    y (| z x) (-. (/\ (| y x) (prime y))) 19.26
    ## <d 'Commutative Property'>
      (A. y (/\ (| z x) (-. (/\ (| y x) (prime y))))) (/\ (A. y (| z x)) (A. y (-. (/\ (| y x) (prime y))))) bicom
      mpbi
    ## </d 'Commutative Property'>
    BiReplaceImp1Ex1An1
  ## </d 'Distributive Property '>

  y z x dividestr  
  ## <d 'Commutative Property '>
    (| y z) (| z x) ancom
    sylbi2
  ## </d 'Commutative Property '>
  
  ## <d 'Import-Export Theorem '>
    (| z x) (| y z) (| y x) impexp
    mpbi
  ## </d 'Import-Export Theorem '>
  
    ImpReplaceImp1Ex1An1Al1An0
  
  ## <d 'Negate Both Sides '>
    (| y z) (| y x) con34b
      BiReplaceImp1Ex1An1Al1An0
  ## </d 'Negate Both Sides '>
  
  ## <d 'Commutative Property '>
    (-> (-. (| y x)) (-. (| y z))) (-. (/\ (| y x) (prime y))) ancom
    BiReplaceImp1Ex1An1Al1
  ## </d 'Commutative Property '>
  
  ## <d 'DeMorgan's Law '>
    (| y x) (prime y) anor
      BiReplaceImp1Ex1An1Al1An0Not0
  ## </d 'DeMorgan's Law '>
  
  ## <d 'Double Negative '>
    (\/ (-. (| y x)) (-. (prime y))) notnotr
    BiReplaceImp1Ex1An1Al1An0
  ## </d 'Double Negative '>
  
  ## <d 'Distributive Property '>
    (-. (| y x)) (-. (prime y)) (-> (-. (| y x)) (-. (| y z))) andir
    BiReplaceImp1Ex1An1Al1
  ## </d 'Distributive Property '>
  
  ## <d 'Introduce conjunct as antecedent '>
    (-. (| y x)) (-. (| y z)) abai
    ## <d 'Commutative Property'>
      (/\ (-. (| y x)) (-. (| y z))) (/\ (-. (| y x)) (-> (-. (| y x)) (-. (| y z)))) bicom
      mpbi
    ## </d 'Commutative Property'>
      BiReplaceImp1Ex1An1Al1Or0
  ## </d 'Introduce conjunct as antecedent '>
  (-. (| y x)) (-. (| y z)) pm3.27
  
    ImpReplaceImp1Ex1An1Al1Or0
   (-. (prime y)) (-> (-. (| y x)) (-. (| y z))) pm3.26
  
    ImpReplaceImp1Ex1An1Al1Or1
  
  ## <d 'Definition of ∃ '>
    y (\/ (-. (| y z)) (-. (prime y))) alex
    BiReplaceImp1Ex1An1
  ## </d 'Definition of ∃ '>
  
  ## <d 'DeMorgan's Law '>
    (-. (| y z)) (-. (prime y)) oran
    (| y z) notnotr
      BiReplaceBi1Not0An0
    (prime y) notnotr
    BiReplaceBi1Not0An1
      BiReplaceImp1Ex1An1Not0Ex1Not0
  ## </d 'DeMorgan's Law '>
  
  ## <d 'Double Negative '>
    (/\ (| y z) (prime y)) notnotr
    BiReplaceImp1Ex1An1Not0Ex1
  ## </d 'Double Negative '>
)

# number 66.0
thm (dividesadd.1 () ()
    (-> (| (S A) (+ (* (S A) B) C)) (| (S A) C))
    (S A)  (+ (* (S A) B) C)  x  df-divides    biimpi
        (* (S A) B)  C  addge01t
        ( = (* (S A) x) (+ (* (S A) B) C))  id  (* (S A) B)  leeq2d    biimprd    mpi
        (S A)  B  mulcom    (* (S A) x)  leeq1i    sylib
        (S A)  x  mulcom    (* B (S A))  leeq2i    sylib
        B  A  x  lemul4    syl
        B  x  y  df-le    sylib
        (+ B y)  x  (S A)  muleq2    eqcomd   y  19.22i    syl
        ancri
        y  (= (* (S A) x) (* (S A) (+ B y)))  (= (* (S A) x) (+ (* (S A) B) C))  19.41    sylibr
          (* (S A) x)  (* (S A) (+ B y))  (+ (* (S A) B) C)  ax-eqtr
          (S A)  B  y  distr    (+ (* (S A) B) C)  eqeq1i    sylib
          (* (S A) B)  (* (S A) y)  C  addcan2    biimpi    syl

        y  19.22i    syl
        (S A)  C  y  df-divides    sylibr

    x  19.22i   syl    x  (| (S A) C) 19.9    sylib
)
# number 67.0
thm (divides1 () ()
     (-. (| (S (S A)) (1)))
  A  pa_ax1    df-1  (S (S A))  leeq2i      (S A)  (0)  lesuc1    bitr4i    (S A)  eq0le0    bitr4i    biimpi   eqcomd  con3i  ax-mp
    (S (S A))  (1)  x  df-divides    biimpi
        x  z  lefoo
          0ne1
            x  (0)  (S (S A))  muleq2    (S (S A)) pa_ax5    syl6eq
            (1) eqeq1d    biimpd    con3d
          mpi    (E. z (= (+ (1) z) x))  orim1i
        ax-mp
        (= (* (S (S A)) x) (1))  (E. z (= (+ (1) z) x))  imor    biimpri    ax-mp
        ancli
        (+ (1) z)  x  (S (S A)) muleq2    (1)  eqeq1d    biimprd    z  19.22i    (= (* (S (S A)) x) (1))  anim2i    syl
        ancomd    z  (-> (= (* (S (S A)) x) (1)) (= (* (S (S A)) (+ (1) z)) (1)))  (= (* (S (S A)) x) (1))  19.41    sylibr
        (= (* (S (S A)) x) (1))  (= (* (S (S A)) (+ (1) z)) (1))  pm3.35    ancoms    z  19.22i    syl
    x  19.22i    syl    x  (E. z (= (* (S (S A)) (+ (1) z)) (1)))  19.9    sylib
      x  (* (S (S A)) z) tyex
       x  (* (S (S A)) z)  (S (S A)) addeq2    (1)  eqeq1d    biimprd
        (S (S A))  (1)  z  distr    (1)  eqeq1i   biimpi
        (S (S A))  mulid    (* (S (S A)) z)  addeq1i      syl5eqr
       syl5com
      x  19.22d    mpi
      (S (S A))  (1)  x  df-le    biimpri    syl
    z  19.22i    syl    z  (<= (S (S A)) (1)) 19.9    sylib
    con3i
  ax-mp
)
# number 67.0



## <title> Substitution </title>
## <table>
##   (-. (|  [ A ]   ]   ]  C))
##   (=      [ A ]   [ B ] )
##   (-. (|  [   [   [ B ]  C))
## </table>
thm (EqReplaceNot0Divs0 () (
     replacee (-. (| A C))
     substitution (= A B)) 
     (-. (| B C))
  replacee substitution
  C divideseq1i
  mtbi
)

## <title> Substitution </title>
## <table>
##   (-. (| (+  [ A ]   ]   ]  C) D))
##   (=         [ A ]   [ B ] )
##   (-. (| (+  [   [   [ B ]  C) D))
## </table>
thm (EqReplaceNot0Divs0Add0 () (
     replacee (-. (| (+ A C) D))
     substitution (= A B)) 
     (-. (| (+ B C) D))
  replacee substitution
  C addeq1i
  EqReplaceNot0Divs0
)

## <title> Substitution </title>
## <table>
##   (-. (| (+ A  [ B ]   ]   ] ) D))
##   (=           [ B ]   [ C ] )
##   (-. (| (+ A  [   [   [ C ] ) D))
## </table>
thm (EqReplaceNot0Divs0Add1 () (
     replacee (-. (| (+ A B) D))
     substitution (= B C)) 
     (-. (| (+ A C) D))
  replacee substitution
  A addeq2i
  EqReplaceNot0Divs0
)


thm (divides1ge2 () () (-> (<= (2) B) (-. (| B (1))))
  (2) B x df-le  
  ## <d 'Commutative Property '>
    (2) x addcom
    EqReplaceBi1Ex1Eq0
  ## </d 'Commutative Property '>

  (+ x (2)) B (1) divideseq1
  notbid
  x divides1  
  ## <d 'Successor Adds One '>
    (S x) a1suc
    EqReplaceNot0Divs0
  ## </d 'Successor Adds One '>
  ## <d 'Successor Adds One '>
    x a1suc
    EqReplaceNot0Divs0Add0
  ## </d 'Successor Adds One '>
  
  ## <d 'Associative Property '>
    x (1) (1) addass
    EqReplaceNot0Divs0
  ## </d 'Associative Property '>  
  ## <d 'Evaluate'>
    1plus1
    EqReplaceNot0Divs0Add1
  ## </d 'Evaluate'>  
  (-. (| B (1))) biRemove1
  (= (+ x (2)) B) imbi2i
  mpbi  
  ImpReplaceBi1Ex1
  x (-. (| B (1))) 19.9  
  sylib
)

## <title> A prime number cannot divide 1 </title>
thm (divides1prime () () (-> (prime A) (-. (| A (1))))
  A x df-prime
  
  ## <d>
    (-. (<= A (1))) (A. x (-> (| x A) (\/ (= x (1)) (= x A)))) pm3.26    
    ImpReplaceBi1
  ## </d>
    
    ## <d 'Commute Inequality '>
      A (1) lecom
      BiReplaceImp1Not0
        (< (1) A) notnotr
        sylib
  ## </d>
      
      ## <d 'Convert between ≤ and < '>
        (1) A ltle2
        sylib
        1plus1
        EqReplaceImp1Le0
      ## </d 'Evaluate'>
  A divides1ge2      
      syl
)

# number 68.0
thm (dividesadd.2 () ()
  (-> (| (S A) B) (-> (| (S A) (+ B C)) (| (S A) C)))
    (S A)  B  x  df-divides    biimpi
        (* (S A) x)  B  C  addeq1
        (+ (* (S A) x) C)  (+ B C)  (S A)  divideseq2    biimprd    syl
         A  x  C  dividesadd.1    syl6
    x  19.22i    syl
    x  (-> (| (S A) (+ B C)) (| (S A) C))  ex-nf    syl
)
# number 69.0
thm (suceqi () (h (= A B))  (= (S A) (S B))
    h    (= A B)  id    suceqd    ax-mp
)
# number 70.0
thm (infprime.1 ((A x)) () (E. x (/\ (< (S (S A)) (S (S x))) (prime (S (S x)))))
    y  v  (S A)  exfactorial
      v  (-> (<= (S v) (S (S A))) (| (S v) (S (S y))))  (S x)  a4sbc  x  19.21ai  y  19.22i  ax-mp
        (= v (S x))  id  suceqd  (S (S A))  leeq1d
        (= v (S x))  id  suceqd  (S v) (S (S x))  (S (S y))  divideseq1  syl  imbi12d
      sbcie  x albii
    y  exbii mpbi

        x  divides1
        (S x) (S (S y)) (1)  dividesadd.2     con3d    mpi
            (<= (S (S x)) (S (S A))) imim2i    con2d   (S (S x))  (S (S A))  lenltt   biimpri
        con1i    syl6
     x  19.20i       y  19.22i    ax-mp
        x  (+ y (1))  primedivisor
            (S y)  (1)  pa_ax4r    y  (1)  pa_ax4r    suceqi    eqtr
            (+ (S (S y)) (1))  (S (S (+ y (1))))  (S (S x))  divideseq2    ax-mp    biimpri
            (prime (S (S x)))  anim2i
        x  19.22i    ax-mp
        y  gen
    pm3.2i
    y  (A. x (-> (| (S (S x)) (+ (S (S y)) (1))) (< (S (S A)) (S (S x)))))  (A. y (E. x (/\ (prime (S (S x))) (| (S (S x)) (+ (S (S y)) (1))))))  19.41    mpbir
    y  (E. x (/\ (prime (S (S x))) (| (S (S x)) (+ (S (S y)) (1)))))  ax-4    (A. x (-> (| (S (S x)) (+ (S (S y)) (1))) (< (S (S A)) (S (S x)))))  anim2i    y  19.22i    ax-mp
    x  (-> (| (S (S x)) (+ (S (S y)) (1))) (< (S (S A)) (S (S x))))  (/\ (prime (S (S x))) (| (S (S x)) (+ (S (S y)) (1))))  19.29    y  19.22i    ax-mp

            (| (S (S x)) (+ (S (S y)) (1)))  (< (S (S A)) (S (S x)))  pm2.27    (prime (S (S x)))  anim2i     (-> (| (S (S x)) (+ (S (S y)) (1))) (< (S (S A)) (S (S x))))  anim2i
                (prime (S (S x)))  (-> (-> (| (S (S x)) (+ (S (S y)) (1))) (< (S (S A)) (S (S x)))) (< (S (S A)) (S (S x))))  ancom    biimpi    (-> (| (S (S x)) (+ (S (S y)) (1))) (< (S (S A)) (S (S x))))  anim2i
            (-> (| (S (S x)) (+ (S (S y)) (1))) (< (S (S A)) (S (S x))))  (-> (-> (| (S (S x)) (+ (S (S y)) (1))) (< (S (S A)) (S (S x)))) (< (S (S A)) (S (S x))))  (prime (S (S x)))    anass    sylibr    syl
            (-> (| (S (S x)) (+ (S (S y)) (1))) (< (S (S A)) (S (S x))))  (< (S (S A)) (S (S x)))  pm3.35    (prime (S (S x)))  anim1i    syl
    x  19.22i    y  19.22i    ax-mp
    y  (E. x (/\ (< (S (S A)) (S (S x))) (prime (S (S x)))))  19.9    mpbi
)

## <title> Primes are infinite </title>
thm (infprime ((A x)) () (E. x (/\ (< A x) (prime x)))

y  A  infprime.1
 (/\ (< (S (S A)) (S (S y))) (prime (S (S y))))  x  alnfi
  x  (S (S y))  tyex
    (= x (S (S y)))  id    (S (S A))  lteq2d    biimprd
    x  (S (S y)) primeeq    biimprd  anim12d
  x  19.22i    ax-mp
  x  (/\ (< (S (S A)) (S (S y))) (prime (S (S y))))  (/\ (< (S (S A)) x) (prime x))  eximp1    ax-mp
 syl
y  19.22i    ax-mp
y  (E. x (/\ (< (S (S A)) x) (prime x)))  19.9  mpbi

    (+ A (1)) (1) addge01t
    A  (+ (+ A (1)) (1))  nnltp1let    mpbir
    A  a1suc    suceqi    (+ A (1))  a1suc    eqtr    A  lteq2i    mpbir
    A  (S (S A))  x  lttr  mpan
    (prime x)  anim1i
x  19.22i    ax-mp
)

## <title> Existential uniqueness of sqrt </title>
thm (sqrteu ((A x)) () (E! x (/\ (<= (* x x) A) (< A (* (S x) (S x)))))
    y  A  sqrt
        y  A  x  sqrtuniq    ex    y  x  eqcom    syl6ib
            y  x  y  x  muleq12    anidms    A  leeq1d   eqcoms
                x  y  eqcom    biimpi   suceqd    x  y  eqcom   biimpi suceqd    muleq12d    A  lteq2d
            anbi12d    biimpd    com12
        impbid    x  19.21ai
        y  19.22i    ax-mp
        x  (/\ (<= (* x x) A) (< A (* (S x) (S x))))  y  df-eu    biimpri
    ax-mp
)

# number 74.0
thm (df-sqrt-just ((A x) (A y)) ()
(= (iota ({|} x (/\ (<= (* x x) A) (< A (* (S x) (S x))))))
   (iota ({|} y (/\ (<= (* y y) A) (< A (* (S y) (S y)))))))
    y  x  y  x  muleq12    anidms    A  leeq1d   eqcoms
    x  y  eqcom    biimpi   suceqd    x  y  eqcom   biimpi suceqd    muleq12d    A  lteq2d
    anbi12d    bicomd    #  rwffi    abid
   abeq    ({|} x (/\ (<= (* x x) A) (< A (* (S x) (S x)))))  ({|} y (/\ (<= (* y y) A) (< A (* (S y) (S y)))))  ax-iotaeq     ax-mp
)

defthm  (df-sqrt nat (sqrt A) ((A x)) ()
  (= (sqrt A)  (iota ({|} x (/\ (<= (* x x) A) (< A (* (S x) (S x)))))))
  y  A  x  df-sqrt-just)



# number 76.0
thm (syl6seqr ()
  (hyp1 (-> ph (=_ S T))
   hyp2 (=_ U T))
  (-> ph (=_ S U))
  hyp1    S  T  x  df-seq    sylib
  x  (<-> (e. x S) (e. x T))  ax-4    syl
      hyp2    U  T  x  df-seq    mpbi    a4i
  syl6bbr
  x  19.21ai
  S  U  x  df-seq       sylibr
)

# number 77.0
thm (sqrteq () () (-> (= A B) (= (sqrt A) (sqrt B)))
  (= A B)  id    (* x x)  leeq2d
  (= A B)  id    (* (S x) (S x))  lteq1d    anbi12d
  x  19.21ai
  x  (/\ (<= (* x x) A) (< A (* (S x) (S x))))  (/\ (<= (* x x) B) (< B (* (S x) (S x))))  abbi2    syl
  ({|} x (/\ (<= (* x x) A) (< A (* (S x) (S x)))))  ({|} x (/\ (<= (* x x) B) (< B (* (S x) (S x)))))  ax-iotaeq    syl

  B  x  df-sqrt  syl6eqr
  A  x  df-sqrt  syl5eq
)

# number 86.0
thm (df-fun-just ((S x y x' y')) ()
  (<-> (/\ (A. x  (E! y  (e. (<,> x  y ) S))) (A. x (-> (e. x S) (E. y (E. z (= x (<,> y z)))))))
       (/\ (A. x' (E! y' (e. (<,> x' y') S))) (A. x' (-> (e. x' S) (E. y' (E. z' (= x' (<,> y' z'))))))))
  x  x'  y'  opeq1    (<,> x y')  (<,> x' y')  S  ax-eleq1  syl    y'  eubid
    y  y'  x  opeq2     (<,> x y)  (<,> x y')  S  ax-eleq1    syl    eualpha
  syl5bb
  alpha

 x  x'  S  ax-eleq1
  x  x'  (<,>  y' z')  eqeq1  z'  exbid  y'  exbid
   y  y'  z  opeq1   x  eqeq2d  z  exbid
     z  z'  y'  opeq2    x  eqeq2d   exalpha
   syl6bb    exalpha
  syl5bb
 imbi12d  alpha
anbi12i
)


defthm (df-fun wff (fun S) ((S x y))  ()  (<-> (fun S) (/\ (A. x  (E! y  (e. (<,> x  y ) S))) (A. x (-> (e. x S) (E. y (E. z (= x (<,> y z))))))))
x' y' S z'  x y z df-fun-just)


# number 87.0
thm (df-min-just ((S x) (S y) (S x') (S y')) ()
  (= (iota ({|} x (/\ (e. x S) (A. y (-> (e. y S) (<= x y))))))
     (iota ({|} x' (/\ (e. x' S) (A. y' (-> (e. y' S) (<= x' y')))))))
x  x'  S  ax-eleq1
  (= x x')  id    y  leeq1d    (e. y S)  imbi2d   y  19.21ai
  y  (-> (e. y S) (<= x y))  (-> (e. y S) (<= x' y))  19.15    syl
    y  y'  S  ax-eleq1
      (= y y')  id    x'  leeq2d
    imbi12d   alpha
  syl6bb
anbi12d
abeq
({|} x (/\ (e. x S) (A. y (-> (e. y S) (<= x y)))))  ({|} x' (/\ (e. x' S) (A. y' (-> (e. y' S) (<= x' y')))))    ax-iotaeq    ax-mp
)


defthm  (df-min nat (min S) ((S x) (S y)) ()
        (= (min S) (iota ({|} x (/\ (e. x S) (A. y (-> (e. y S) (<= x y)))))))
          x' S y' x y df-min-just)

# number 88.0
## <table>
##   (-> (=_ <r> S <g> T) (= (min <r> S) (min <g> T)))
## </table>
thm (minseq () () (-> (=_ S T) (= (min S) (min T)))
  S  T  x  df-seq    biimpi    x  (<-> (e. x S) (e. x T))  ax-4    syl
    S  T  y  df-seq    biimpi    y  (<-> (e. y S) (e. y T))  ax-4    syl
    (<= x y)  imbi1d
    y  19.21ai
    19.15d
  anbi12d
  x  19.21ai
  x  (/\ (e. x S) (A. y (-> (e. y S) (<= x y))))  (/\ (e. x T) (A. y (-> (e. y T) (<= x y))))  abbi2    syl
  ({|} x (/\ (e. x S) (A. y (-> (e. y S) (<= x y)))))  ({|} x (/\ (e. x T) (A. y (-> (e. y T) (<= x y)))))  ax-iotaeq    syl

  S  x  y  df-min    syl5eq
  T  x  y  df-min    syl6eqr
)

thm (minseqi () (hyp (=_ S T)) (= (min S) (min T))
  hyp
  S T minseq
  ax-mp
)

thm (minex.1 () ()
  (-> (= y A)
    (<->
      (-> (e. y S) (/\ (e. (min S) S)
                                (<= (min S) y)))
      (-> (e. A S) (/\ (e. (min S) S)
                                 (<= (min S) A)))))

y  A  S  ax-eleq1
  (= y A)  id    (min S)  leeq2d    (e. (min S) S) anbi2d
  imbi12d
)

# number 102.0
thm (minex.2.1 ((A w) (S w) (B w)) ()
  (-> (/\ (e. B S) (A. w (-> (e. w S) (<= A w)))) (<= A B))

w  (e. B S)  (-> (e. w S) (<= A w))  alan1    biimpri

w  B  tyex

  B  w  S ax-eleq1
    (= B w) id    A leeq2d
  imbi12d
  eqcoms
  biimprd
  imp3a
  ancomsd
w  19.22i    ax-mp
w  (/\ (e. B S) (-> (e. w S) (<= A w)))  (<= A B)  eximp1    ax-mp

syl
w  (<= A B)  ex-nf   syl
)

# number 103.0
thm (anim3 () () (-> (/\ ph (-> ps ch)) (-> ps (/\ ph ch)))

 ph  ps  ch  pm5.33   biimpi  ph  (-> (/\ ph ps) ch)  pm3.27 syl
 ph  ps  ch  impexp  sylib
  com23
 ph  ps  ch  pm5.33   biimpi  ph  (-> (/\ ph ps) ch) pm3.26  syl
   jctild
  ph  (-> ph ch)  pm3.26
  ph  ch  pm3.35       jca
 syl6
)

thm (minex.2.2 ((S w) (A w)) () (-> (/\ (e. A S) (A. w (-> (e. w S) (<= A w)))) (= A (min S)))
    x  A  S  ax-eleq1
      (= x A)  id    w  leeq1d    (e. w S)  imbi2d   w  19.21ai
      w  (-> (e. w S) (<= x w))  (-> (e. w S) (<= A w))  19.15    syl
    anbi12d    biimprcd
      (e. A S)  (A. w (-> (e. w S) (<= A w)))  ancom  (/\ (e. x S) (A. w (-> (e. w S) (<= x w))))  anbi2i (e. x S)  (A. w (-> (e. w S) (<= x w)))  (A. w (-> (e. w S) (<= A w)))  (e. A S)  an4    bitri       biimpi
      A  S  w x minex.2.1   ancoms    (/\ (e. x S) (A. w (-> (e. w S) (<= A w))))  anim2i   syl
      x  S  w A minex.2.1  (<= x A)  anim1i    syl
      A  x  lesym   sylibr    eqcomd       expcom
    impbid

    x  19.21ai
    x  (= x A)  (/\ (e. x S) (A. w (-> (e. w S) (<= x w))))  abbi2    syl
    ({|} x (= x A))  ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w)))))  ax-iotaeq    syl
    S  x  w  df-min     syl6eqr
    A x  df-sn  ({} A)  ({|} x (= x A))  ax-iotaeq    ax-mp       syl5eq
    A  ax-iota    syl5eqr
)

thm (minex2.2 ((S w)) () (-> (/\ (e. w' S) (A. w (-> (e. w S) (<= w' w)))) (= w' (min S)))
    x  w'  S  ax-eleq1
      (= x w')  id    w  leeq1d    (e. w S)  imbi2d   w  19.21ai
      w  (-> (e. w S) (<= x w))  (-> (e. w S) (<= w' w))  19.15    syl
    anbi12d    biimprcd
      (e. w' S)  (A. w (-> (e. w S) (<= w' w)))  ancom  (/\ (e. x S) (A. w (-> (e. w S) (<= x w))))  anbi2i (e. x S)  (A. w (-> (e. w S) (<= x w)))  (A. w (-> (e. w S) (<= w' w)))  (e. w' S)  an4    bitri       biimpi
      w'  S  w x minex.2.1   ancoms    (/\ (e. x S) (A. w (-> (e. w S) (<= w' w))))  anim2i   syl
      x  S  w w' minex.2.1  (<= x w')  anim1i    syl
      w'  x  lesym   sylibr    eqcomd       expcom
    impbid

    x  19.21ai
    x  (= x w')  (/\ (e. x S) (A. w (-> (e. w S) (<= x w))))  abbi2    syl
    ({|} x (= x w'))  ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w)))))  ax-iotaeq    syl
    S  x  w  df-min     syl6eqr
    w' x  df-sn  ({} w')  ({|} x (= x w'))  ax-iotaeq    ax-mp       syl5eq
    w'  ax-iota    syl5eqr
)

thm (minex.2 ((S w)) ()
    (-> (A. w (-> (<= w z)
      (-> (e. w S) (/\ (e. (min S) S)
                                (<= (min S) w)))))
      (-> (e. (S z) S) (/\ (e. (min S) S)
                                (<= (min S) (S z)))))
### Please excuse this bit of time-travel.
(<= w z) (e. w S)  (/\ (e. (min S) S) (<= (min S) w))  imdistan  biimpi
  (<= w z)  (/\ (e. (min S) S) (<= (min S) w))  ancom  biimpi z  (1)  addge01t    z  a1suc  z  leeq2i   mpbir
w  z  (S z)  letr  ancoms  mpan  (/\ (e. (min S) S) (<= (min S) w))  anim2i  syl  syl6  ancomsd
w 19.20i
###


# Case 1:  z' is in fact  min S.  This one is easy.
#  S  y  z  df-min    (S z)  eqeq2i    biimpi  (e. (S z) S)  a1d
(S z)  (min S)  S  ax-eleq1  biimpd
    (S z)  leid    (= (S z) (min S)) id  (S z)  leeq1d    mpbii    (e. (S z) S)  a1d
jcad
# Tack this on for later
(-> (e. (S z) S) (E. w (/\ (e. w S) (<= w z))))  orcd

# Case 2: z' is in S but NOT the min.
# What follows would be a lot more readable without all the mandhyps!
  S  x  w  df-min  (S z)  eqeq2i  notbii   biimpi
  ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w)))))  ({} (S z))  ax-iotaeq    (S z)  ax-iota   syl6eq   eqcomd   con3i    syl
  ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w)))))  ({} (S z))  w'  df-seq  notbii    biimpi   syl
  (<-> (e. w' ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w)))))) (e. w' ({} (S z))))  notnot    biimpri    w'  19.20i   con3i    syl
  w'  (-. (<-> (e. w' ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w)))))) (e. w' ({} (S z)))))  df-ex    biimpri    syl
  w'  (S z)  elsnc    (e. w' ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w))))))  bibi2i    notbii   w'  exbii    sylib
    x  w'  S   ax-eleq1
      (= x  w')  id    w  leeq1d    (e. w S)  imbi2d     w  19.21ai    w  (-> (e. w S) (<= x w))  (-> (e. w S) (<= w' w)) 19.15   syl
  anbi12d    elab    (= w' (S z))  bibi1i    notbii  w'  exbii  sylib
  (/\ (e. w' S) (A. w (-> (e. w S) (<= w' w))))  (= w' (S z))  xor     w'  exbii    sylib
    # We now have z' != min S -> (case A) \/ (case B).  Let's reduce case B to something we like.
    w'  (S z)  S  ax-eleq1
      (= w' (S z))  id  w  leeq1d   (e. w S)  imbi2d     w  19.21ai    19.15d       anbi12d    notbid  biimpd
      (e. (S z) S)  (A. w (-> (e. w S) (<= (S z) w)))  pm3.13    syl6   imp
      (e. (S z) S)  (-. (A. w (-> (e. w S) (<= (S z) w))))  imor    sylibr
        (-> (e. w S) (<= (S z) w))  notnot2  w  19.20i  con3i  w  (-. (-> (e. w S) (<= (S z) w)))  df-ex      sylibr
        (e. w S)  (<= (S z) w)  pm4.61    biimpi  (S z)  w  lenltt       con2bii    biimpri   w  z  lesuc    sylib  (e. w S)  anim2i    syl   w  19.22i    syl
      syl6
    (/\ (/\ (e. w' S) (A. w (-> (e. w S) (<= w' w)))) (-. (= w' (S z))))  orim2i    w'  19.22i       w'  (/\ (/\ (e. w' S) (A. w (-> (e. w S) (<= w' w)))) (-. (= w' (S z))))  (-> (e. (S z) S) (E. w (/\ (e. w S) (<= w z))))  exor2    sylib  syl
    # Okay, now let's work with case A.  First show that w' is in fact min S.
    w'  S  w  minex.2.2
    # Ok, now work out the consequences of w' = min S
    (/\ (e. w' S) (A. w (-> (e. w S) (<= w' w))))  (= w' (min S))  anidmdbi    mpbir
    (e. w' S)  (A. w (-> (e. w S) (<= w' w)))  (/\ (= w' (min S)) (= w' (min S)))  pm5.3    mpbi
    (e. w' S)  (= w' (min S))  (= w' (min S))  anass    sylibr
    w'  (min S)  S ax-eleq1   biimpac    (= w' (min S))  anim1i    syl
    pm4.71ri  biimpi   (e. w' S)  (A. w (-> (e. w S) (<= w' w)))  pm3.27   (/\ (e. (min S) S) (= w' (min S)))  anim2i      syl
    (e. (min S) S)  (= w' (min S))  (A. w (-> (e. w S) (<= w' w)))  anass  sylib
      (= w' (min S))  id    w leeq1d  (e. w S)  imbi2d    w  19.21ai    19.15d    biimpd   imp
    (S z) S  w  (min S)  minex.2.1     impexpi    syl       (e. (min S) S)  anim2i    syl
    (e. (min S) S)  (e. (S z) S)  (<= (min S) (S z))  anim3  syl
  (-. (= w' (S z))) adantr   w'  exani   (-> (e. (S z) S) (E. w (/\ (e. w S) (<= w z))))  orim1i  syl

# Great, now we can join up the two cases!
pm2.61i
# Pull out the common hypothesis
(e. (S z) S)  (/\ (e. (min S) S) (<= (min S) (S z)))  (E. w (/\ (e. w S) (<= w z)))  pm4.78    mpbi

# Almost there; just need to apply the IHOP to case 2B.

# Introduce the new antecedent and polish up the new conclusion
  w  (/\ (e. w S) (<= w z))  (/\ (/\ (e. (min S) S) (<= (min S) w)) (<= w (S z))) 19.22
    (e. (min S) S)  (<= (min S) w)  (<= w (S z))  anass     (min S)  w  (S z)  letr   (e. (min S) S)  anim2i    sylbi  w 19.22i
    w  (/\ (e. (min S) S) (<= (min S) (S z)))  ex-nf  syl
  syl6
(/\ (e. (min S) S) (<= (min S) (S z)))  orim2d     mpan9
(/\ (e. (min S) S) (<= (min S) (S z)))  pm1.2    syl
impexpi

syl
)

## <title> The minimum of a nonempty set exists </title>
thm (minex () ()     (-> (e. A S) (/\ (e. (min S) S)
                                (<= (min S) A)))
  x  (0)  S  minex.1
    x  (S y)  S  minex.1
      x  A  S  minex.1
        (0)  x  addge01t x  pa_ax3r    (0)  leeq2i    mpbi  (e. x S)  a1i   x  gen
        (0)  S  x  minex.2.2  ancoms  mpan
          (0)  (min S)  S  ax-eleq1  biimpd    com12                a2i
            (0)  leid    (= (0) (min S))  id   (0) leeq1d  mpbii    (e. (0) S) imim2i
        jcad    ax-mp
          x  y  S  minex.2
  sind
)

## <title> Minimum of a nonempty set is in the set </title>
thm (mincl ((S x)) ()
  (-> (E. x (e. x S)) (e. (min S) S))
  x S minex pm3.26d x 19.23ai
)

# Equality deduction for set minimum
thm (minseqd () (h (-> ph (=_ S T)))
  (-> ph (= (min S) (min T)))
  h S T minseq syl
)

## <summary> If any number satisfies a predicate, the minimum does </summary>
thm (minel ((ps x)) (
  h1 (rwff x ph)
  h2 (-> (= x (min ({|} x ph))) (<-> ph ps))
  ) (-> (E. x ph) ps)

  h1 abid x exbii
  x ({|} x ph) mincl sylbir
  h2 elab sylib
)

## <summary> Another way of specifying the value of minimum </summary>
thm (minval ((ps x) (A x))
  (h1 (rwff x ph)
   h2 (-> (= x A) (<-> ph ps)))
  (-> (/\ ps (A. x (-> ph (<= A x)))) (= A (min ({|} x ph))))

  h2 elab
  A ({|} x ph) minex sylbir
    x (min ({|} x ph)) ({|} x ph) ax-eleq1
    h1 abid syl5bbr
      (= x (min ({|} x ph))) id A leeq2d
    imbi12d
    cla4g
  anim12i
    (e. (min ({|} x ph)) ({|} x ph)) (<= A (min ({|} x ph))) pm3.35
    (<= (min ({|} x ph)) A) anim1i
    an1rs
  syl
  A (min ({|} x ph)) lesym sylibr
)

## <suggest> right('Simplify', 'min') </suggest>
thm (minsetval ((S x) (A x)) () (-> (/\ (e. A S) (A. x (-> (e. x S) (<= A x)))) (= A (min ({|} x (e. x S)))))
  x y S ax-eleq1
  rwffi
  x A S ax-eleq1
  minval
)

thm (minsn () () (= (min ({} A)) A)
  x ({} A) mincl
 (min ({} A)) A elsnc
  sylib
  x A tyex
  x A ({} A) ax-eleq1  
  ImpReplaceEx1
  A A elsnc
  A eqid  
  mpbirRemove  
  (e. x ({} A)) biRemove2
  x exbii
  mpbi  
  ax-mpRemove
)

## <summary>
##   Combines <a href="minsn">minsn</a> and <a href="snid">snid</a> into the form
##   <a href="minun">minun</a> expects.
## </summary>
thm (minsn2 () () (/\ (= A (min ({} A))) (e. A ({} A)))
  A minsn
  eqcomi
  A snid
  pm3.2i
)

thm (minex2() () (-> (e. A S) (<= (min S) A))
  A S minex  
  ## <d ''Remove Left Side of AND' '>
    (e. (min S) S) (<= (min S) A) pm3.27
    syl
  ## </d ''Remove Left Side of AND' '>
)

## <title> Minimum of a Union </title>
thm (minun() () (-> (/\ (e. (min S) S) (<= (min S) (min T))) (= (min S) (min (u. S T))))
  (min S) S minex
  ## <d ''Remove Right Side of AND' '>
    (e. (min S) S) (<= (min S) (min S)) pm3.26
    syl
  ## </d ''Remove Right Side of AND' '>
  (min S) S T unc
  syl

  y S minex2
  (<= (min S) (min T)) a1i
  y T minex2
  (<= (min S) (min T)) a1i
  (min S) (min T) y letr    
  ## <d 'Import-Export Theorem '>
    (<= (min S) (min T)) (<= (min T) y) (<= (min S) y) impexp
    mpbi
  ## </d 'Import-Export Theorem '>
  syld
  jaod
  y S T elun bicomi  
  BiReplaceImp1Imp0
  y 19.21ai
  anim12i  
  ## <d>
    (min S) (u. S T) y minsetval
    syl
  ## </d>
  y (u. S T) removeab
  minseqi  
  EqReplaceImp1Eq1
)



## <title> Substitution </title>
## <table>
##   (-> (/\ (e.  [ A ]   ]   ]  S) ph) ps)
##   (=           [ A ]   [ B ] )
##   (-> (/\ (e.  [   [   [ B ]  S) ph) ps)
## </table>
thm (EqReplaceImp0An0El0 () (
     replacee (-> (/\ (e. A S) ph) ps)
     substitution (= A B)) 
     (-> (/\ (e. B S) ph) ps)
  replacee substitution
  S eleq1i
  BiReplaceImp0An0
)

## <title> Substitution </title>
## <table>
##   (-> (/\ ph (<=  [ A ]   ]   ]  C)) ps)
##   (=              [ A ]   [ B ] )
##   (-> (/\ ph (<=  [   [   [ B ]  C)) ps)
## </table>
thm (EqReplaceImp0An1Le0 () (
     replacee (-> (/\ ph (<= A C)) ps)
     substitution (= A B)) 
     (-> (/\ ph (<= B C)) ps)
  replacee substitution
  C leeq1i
  BiReplaceImp0An1
)

thm (minuni () (hyp1 (/\ (= A (min S)) (e. A S)) hyp2 (<= A (min T))) (/\ (= A (min (u. S T))) (e. A (u. S T)))
  hyp1  
  ## <d ''Remove Left Side of AND' '>
    (= A (min S)) (e. A S) pm3.27
    ax-mp
  ## </d ''Remove Left Side of AND' '>
  hyp2
  pm3.2i

  S T minun
  hyp1
  ## <d ''Remove Right Side of AND' '>
    (= A (min S)) (e. A S) pm3.26
    ax-mp
  ## </d ''Remove Right Side of AND' '>
  eqcomi
  
  EqReplaceImp0An0El0

  hyp1
  ## <d ''Remove Right Side of AND' '>
    (= A (min S)) (e. A S) pm3.26
    ax-mp
  ## </d ''Remove Right Side of AND' '>
  eqcomi  
  EqReplaceImp0An1Le0

  hyp1
  ## <d ''Remove Right Side of AND' '>
    (= A (min S)) (e. A S) pm3.26
    ax-mp
  ## </d ''Remove Right Side of AND' '>
  eqcomi  
  EqReplaceImp1Eq0
  ax-mp

  hyp1  
  ## <d ''Remove Left Side of AND' '>
    (= A (min S)) (e. A S) pm3.27
    ax-mp
  ## </d ''Remove Left Side of AND' '>
  A S T unc ax-mp
  pm3.2i
)

# number 89.0
thm (df-mod-just ((A x y x' y') (B x y x' y')) ()
  (= (min ({|} x (E. y (= (+ (* B y) x) A))))
     (min ({|} x' (E. y' (= (+ (* B y') x') A)))))
  x  x'  (* B y)  addeq2    A  eqeq1d     y  exbid
    y  y'  B  muleq2    x'  addeq1d    A  eqeq1d    exalpha
  syl6bb
  abeq
  ({|} x (E. y (= (+ (* B y) x) A)))  ({|} x' (E. y' (= (+ (* B y') x') A)))  minseq    ax-mp
)


defthm  (df-mod nat (mod A B) ((A x y) (B x y)) ()
        (= (mod A B) (min ({|} x (E. y (= (+ (* B y) x) A)))))
          x'  y'  B  A  x  y df-mod-just)

thm (modeq1 () () (-> (= A B) (= (mod A C) (mod B C)))
  A B (+ (* C y) x) eqeq2 y exbid
  x abbi2d minseqd
    A C x y df-mod
      B C x y df-mod
  3eqtr4g
)

# number 90.1

# (lincom A B C) means that C is a linear (integer) combination of A and B.
thm (df-lincom-just (
(A v w x y v' w' x' y')
(B v w x y v' w' x' y')
(C v w x y v' w' x' y')
(C' v' w' x' y')) ()
(-> (= C C') (<->
                (E. v (E. w (E. x (E. y (= (+ (* v A) (* w B))
                                            (+ (+ (* x A) (* y B)) C))))))
              (E. v' (E. w' (E. x' (E. y' (= (+ (* v' A) (* w' B))
                                           (+ (+ (* x' A) (* y' B)) C'))))))))
  C  C'  (+ (* x' A) (* y' B))  addeq2    (+ (* v' A) (* w' B))  eqeq2d  y'  exbid  x'  exbid  w'  exbid  v'  exbid
    v  v'  A  muleq1  (* w' B)  addeq1d  (+ (+ (* x' A) (* y' B)) C)  eqeq1d    y'  exbid  x'  exbid  w'  exbid
      w  w'  B  muleq1    (* v A)  addeq2d    (+ (+ (* x' A) (* y' B)) C)  eqeq1d    y'  exbid    x'  exbid
        x  x'  A  muleq1    (* y' B)  addeq1d    C  addeq1d    (+ (* v A) (* w B))  eqeq2d  y'  exbid
            y  y'  B  muleq1    (* x A)  addeq2d    C  addeq1d    (+ (* v A) (* w B))  eqeq2d    exalpha
        syl5bb    exalpha
      syl5bb    exalpha
    syl5bb    exalpha
  syl5bb
)

defthm (df-lincom wff (lincom A B C) (
(A v w x y)
(B v w x y)
(C v w x y)
) ()
(<-> (lincom A B C) (E. v (E. w (E. x (E. y (= (+ (* v A) (* w B))
                                            (+ (+ (* x A) (* y B)) C)))))))
  C  eqid
  C  C  v' w' x' y' A B v w x y df-lincom-just
  ax-mp
)

# number 90.2
thm (exan ((ph y) (ps x))
  (h1 (E. x ph)
   h2 (E. y ps))
  (E. x (E. y (/\ ph ps)))
  h1  h2    pm3.2i
  x  ph  (E. y ps)  19.41   mpbir
  y  ph  ps  19.41l   x  exbii   mpbir
)
# number 90.3
thm (lincomd () (h (-> ph
  (= (+ (* A A') (* B B')) (+ (+ (* C A') (* D B')) C'))))
  (-> ph (lincom A' B' C'))
h
  v  A  tyex   w  B  tyex   x  C  tyex   y  D  tyex
  exan  exan  y  (= w B)  (/\ (= x C) (= y D))  19.41r  x  exbii  w  exbii mpbir
  exan  x  (= v A)  (E. y (/\ (= w B) (/\ (= x C) (= y D))))  19.41r  w  exbii v exbii mpbir
  y  (= v A)  (/\ (= w B) (/\ (= x C) (= y D)))  19.41r  x  exbii w  exbii v  exbii mpbir

# Doing arithmetic
  y D B'  muleq1
  (* x A')  addeq2d
  x  C  A'  muleq1  (* D B')  addeq1d  sylan9eq    ancoms
  C'  addeq1d    (+ (* v A') (* w B'))  eqeq2d
  w  B  B'  muleq1  (* v A')  addeq2d   (+ (+ (* C A') (* D B')) C')  eqeq1d  sylan9bbr
  v  A  A'  muleq1  (* B B')  addeq1d (+ (+ (* C A') (* D B')) C')  eqeq1d   sylan9bbr
  biimprd    com12
  y  19.22d  x  19.22d  w  19.22d  v  19.22d  mpi
  A'  B'  C'  v  w  x  y  df-lincom  sylibr
syl
)
# number 90.4
thm (lincomeq3 () () (-> (= A B) (<-> (lincom C D A) (lincom C D B)))
  A  B   v  w  x  y   C  D  v'  w'  x'  y'  df-lincom-just
  C  D  A  v  w  x  y  df-lincom    syl5bb
  C  D  B  v'  w'  x'  y'  df-lincom    syl6bbr
)
# number 90.5
#!thm (df-gcd-just.1 ((A v w x y v' w' x' y' ) (B v w x y v' w' x' y')) ()
#!(-> (= z z') (<->  (/\ (-. (= z (0)))
#!                (E. v (E. w (E. x (E. y (= (+ (* v A) (* w B))
#!                                            (+ (+ (* x A) (* y B)) z)))))))
#! (/\ (-. (= z' (0)))
#!              (E. v' (E. w' (E. x' (E. y' (= (+ (* v' A) (* w' B))
#!                                           (+ (+ (* x' A) (* y' B)) z')))))))))
#!z  z'  (0)  eqeq1   notbid
#!
#!  z  z'  (+ (* x' A) (* y' B))  addeq2    (+ (* v' A) (* w' B))  eqeq2d  y'  exbid  x'  exbid  w'  exbid  v'  exbid
#!    v  v'  A  muleq1  (* w' B)  addeq1d  (+ (+ (* x' A) (* y' B)) z)  eqeq1d    y'  exbid  x'  exbid  w'  exbid
#!      w  w'  B  muleq1    (* v A)  addeq2d    (+ (+ (* x' A) (* y' B)) z)  eqeq1d    y'  exbid    x'  exbid
#!        x  x'  A  muleq1    (* y' B)  addeq1d    z  addeq1d    (+ (* v A) (* w B))  eqeq2d  y'  exbid
#!            y  y'  B  muleq1    (* x A)  addeq2d    z  addeq1d    (+ (* v A) (* w B))  eqeq2d    exalpha
#!        syl5bb    exalpha
#!      syl5bb    exalpha
#!    syl5bb    exalpha
#!  syl5bb
#!
#!anbi12d
#!)
# number 91.0
thm (df-gcd-just ((A z z') (B z z')) ()
(= (min ({|} z (/\ (-. (= z (0))) (lincom A B z))))
   (min ({|} z' (/\ (-. (= z' (0))) (lincom A B z')))))
  z  z'  (0)  eqeq1 notbid
    z  z'  v w x y A B v' w' x' y' df-lincom-just
    A  B  z  v  w  x  y  df-lincom     syl5bb
    A  B  z'  v'  w' x'  y'  df-lincom     syl6bbr
  anbi12d
  abeq
  ({|} z (/\ (-. (= z (0))) (lincom A B z)))  ({|} z' (/\ (-. (= z' (0))) (lincom A B z')))  minseq  ax-mp
)

## <title> Def. Greatest Common Denominator </title>
defthm  (df-gcd nat (gcd A B) ((A z) (B z)) ()
        (= (gcd A B) (min ({|} z (/\ (-. (= z (0)))
                (lincom A B z)))))
          z'  A B z df-gcd-just)

# number 107.0
thm (modle1 () () (<= (mod A B) A)
    y  (0)  tyex
      y  (0)  B  muleq2
    B  pa_ax5  syl6eq  A  addeq1d    A  pa_ax3r  syl6eq   y  19.22i    ax-mp
    x  A  (* B y)  addeq2  A  eqeq1d   y  exbid
    ({|} x  (E. y (= (+ (* B y) x) A)))  seqid     elab2
  biimpri  ax-mp
  A  ({|} x  (E. y (= (+ (* B y) x) A)))  minex  ax-mp
  pm3.27i
      A  B  x  y  df-mod    A  leeq1i  mpbir
)

# number 108.0
thm (modex ((A y) (B y)) () (E. y (= (+ (* B y) (mod A B)) A))
    y  (0)  tyex
      y  (0)  B  muleq2
    B  pa_ax5  syl6eq  A  addeq1d    A  pa_ax3r  syl6eq   y  19.22i    ax-mp
    x  A  (* B y)  addeq2  A  eqeq1d   y  exbid
    ({|} x  (E. y (= (+ (* B y) x) A)))  seqid     elab2
  biimpri  ax-mp
  A  ({|} x  (E. y (= (+ (* B y) x) A)))  minex  ax-mp
  pm3.26i
  A  B  x  y  df-mod    (mod A B)  (min ({|} x (E. y (= (+ (* B y) x) A))))  ({|} x (E. y (= (+ (* B y) x) A)))  ax-eleq1  ax-mp
mpbir

    x  (mod A B)  (* B y)  addeq2  A  eqeq1d   y  exbid
    ({|} x  (E. y (= (+ (* B y) x) A)))  seqid     elab2
mpbi
)
# number 109.0
thm (modmin ((A x) (B x) (C x)) () (-> (E. x (= (+ (* A x) B) C)) (<= (mod C A) B))

    y B (* A x) addeq2 C eqeq1d x exbid
    ({|} y (E. x (= (+ (* A x) y) C))) seqid elab2   biimpri
    B  ({|} y (E. x (= (+ (* A x) y) C)))  minex  syl  pm3.27d
          C  A  y  x  df-mod    B  leeq1i  biimpri  syl
)

# number 110.0
thm (modlt2 () () (< (mod A (S B)) (S B))
B  pa_ax1
  (S B)  (mod A (S B)) x  df-le   biimpi
    y  (S B)  A modex
      (+ (S B) x)  (mod A (S B))  (* (S B) y)  addeq2   A  eqeq1d  biimprd     y 19.22d
    mpi
      (S B)  y  pa_ax6   x  addeq1i   (* (S B) y)  (S B)  x  addass  (+ (* (S B) (S y)) x)  eqeq2i   mpbi
      A  eqeq1i  biimpri
        (= (+ (* (S B) (S y)) x) A)  z  alnfi
          z  (S y)  tyex
          z  (S y)  (S B)  muleq2  x  addeq1d    A  eqeq1d    biimprd   z  19.22i    ax-mp
          z  (= (+ (* (S B) (S y)) x) A)  (= (+ (* (S B) z) x) A)  eximp1    ax-mp
        syl
      syl
      z  (S B)  x  A  modmin    syl
    y  19.22i  syl     y  (<= (mod A (S B)) x)  ex-nf    syl
      x  (S B)  addge02t      (= (+ (S B) x) (mod A (S B)))  id    x  leeq2d   biimpd  mpi
    jca
    (mod A (S B))  x  lesym    biimpri  syl   eqcoms  ancli    eqcoms
    (mod A (S B))  (+ (S B) x)  x  ax-eqtr    syl
    x  pa_ax3r  syl6eqr
    (S B)  x  (0)  addcan    sylib  eqcomd
  x  19.22i    syl  x  (= (0) (S B))  ex-nf  syl
  con3i
ax-mp
(S B)  (mod A (S B))  lenltt  biimpri  con1i  ax-mp
)

# number 111.0
thm (exey ((ph y) (ps x))
  () (-> (/\ (E. x ph) (E. y ps)) (E. x (E. y (/\ ph ps))))
  x  ph  (E. y ps)  19.41   biimpri
  y  ph  ps  19.41l   x  exbii   sylibr
)
# number 111.5
# A' is in the set minned by (gcd A' B).

thm (gcddiv1.1 ((A z)) ()
  (e. (S A) ({|} z (/\ (-. (= z (0))) (lincom (S A) B z))))
  z  (S A)  tyex
  A  pa_ax1  z  (S A)  (0)  eqeq2  biimpd  con3d  mpi  (0)  z  eqcom biimpri  con3i  syl
# Juggling quantifiers
  v  (1)  tyex   w  (0)  tyex   x  (0)  tyex   y  (0)  tyex
  exan  exan  y  (= w (0))  (/\ (= x (0)) (= y (0)))  19.41r  x  exbii  w  exbii mpbir
  exan  x  (= v (1))  (E. y (/\ (= w (0)) (/\ (= x (0)) (= y (0)))))  19.41r  w  exbii v exbii mpbir
  y  (= v (1))  (/\ (= w (0)) (/\ (= x (0)) (= y (0))))  19.41r  x  exbii w  exbii v  exbii mpbir

# Doing arithmetic
  y (0) B  muleq1  B  pa_ax5r  syl6eq
  (* x (S A))  addeq2d  (* x (S A))  pa_ax3  syl6eq
  x  (0)  (S A)  muleq1  (S A)  pa_ax5r  syl6eq  sylan9eq    ancoms
  z  addeq1d  z  pa_ax3r  syl6eq  (+ (* v (S A)) (* w B))  eqeq2d
  w  (0)  B  muleq1  B  pa_ax5r  syl6eq  (* v (S A))  addeq2d  (* v (S A))  pa_ax3  syl6eq  z  eqeq1d  sylan9bbr
  v  (1)  (S A)  muleq1  (S A)  (1)  mulcom  (S A)  mulid  eqtr3  syl6eq  z  eqeq1d   sylan9bbr
  biimprd    com12    eqcoms
  y  19.22d  x  19.22d  w  19.22d  v  19.22d  mpi
  (S A)  B  z  v  w  x  y  df-lincom  sylibr
  jca
  ancli
  z  19.22i  ax-mp
  (S A)  z  (/\ (-. (= z (0))) (lincom (S A) B z))  sbc5    mpbir
  (S A)  z  (/\ (-. (= z (0))) (lincom (S A) B z))  ax-elab    mpbir
)
# number 111.6
thm (gcddiv1.2 ((A z) (B z)) () (-> (= (gcd (S A) B) z) (/\ (-. (= z (0))) (lincom (S A) B z)))
 A z B  gcddiv1.1
  (S A)  ({|} z (/\ (-. (= z (0))) (lincom (S A) B z))) minex  ax-mp  pm3.26i

    (S A) B z  df-gcd
    (gcd (S A) B)  (min ({|} z (/\ (-. (= z (0))) (lincom (S A) B z))))  ({|} z (/\ (-. (= z (0))) (lincom (S A) B z)))  ax-eleq1  ax-mp
  mpbir
  (gcd (S A) B)  z  ({|} z (/\ (-. (= z (0))) (lincom (S A) B z)))  ax-eleq1  mpbii
    z z' (0) eqeq1 notbid
      z  z'  (S A) B  lincomeq3
  anbi12d  rwffi  abid    sylib
)

# Equality theorem for mod
thm (modeq2 () () (-> (= A B) (= (mod C A) (mod C B)))
  A  B  y  muleq1  x  addeq1d   C  eqeq1d   y  exbid x  19.21ai
  x  (E. y (= (+ (* A y) x) C))  (E. y (= (+ (* B y) x) C))  abbi2  syl
  ({|} x (E. y (= (+ (* A y) x) C)))  ({|} x (E. y (= (+ (* B y) x) C)))  minseq  syl
  C  A  x  y  df-mod  syl5eq
  C  B  x  y  df-mod  syl6eqr
)

thm (modeq1i () (
     hyp1 (= A B))
     (= (mod A C) (mod B C))
  hyp1
  A B C modeq1
  ax-mp
)

thm (modeq1d () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (mod A C) (mod B C)))
  hyp1
  A B C modeq1
  syl
)

thm (modeq2i () (
     hyp1 (= A B))
     (= (mod C A) (mod C B))
  hyp1
  A B C modeq2
  ax-mp
)

thm (modeq2d () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (mod C A) (mod C B)))
  hyp1
  A B C modeq2
  syl
)


## <title> Substitution </title>
## <table>
##   (<  [ A ]   ]   ]  C)
##   (=  [ A ]   [ B ] )
##   (<  [   [   [ B ]  C)
## </table>
thm (EqReplaceLt0 () (
     replacee (< A C)
     substitution (= A B)) 
     (< B C)
  replacee substitution
  C lteq1i
  mpbi
)

## <title> Substitution </title>
## <table>
##   (< (mod A  [ B ]   ]   ] ) D)
##   (=         [ B ]   [ C ] )
##   (< (mod A  [   [   [ C ] ) D)
## </table>
thm (EqReplaceLt0Mod1 () (
     replacee (< (mod A B) D)
     substitution (= B C)) 
     (< (mod A C) D)
  replacee substitution
  A modeq2i
  EqReplaceLt0
)

## <title> Substitution </title>
## <table>
##   (< A  [ B ]   ]   ] )
##   (=    [ B ]   [ C ] )
##   (< A  [   [   [ C ] )
## </table>
thm (EqReplaceLt1 () (
     replacee (< A B)
     substitution (= B C)) 
     (< A C)
  replacee substitution
  A lteq2i
  mpbi
)

thm (modlt () () (-> (< (0) B) (< (mod A B) B))
  (1) B (1) halfminusaddcom  
  ## <d>
    B (1) halfminuscan
    EqReplaceImp1Eq1
  ## </d>
  A modeq2d
  (1) B (1) halfminusaddcom  
  ## <d>
    B (1) halfminuscan
    EqReplaceImp1Eq1
  ## </d>
  (mod A (+ (.- B (1)) (1))) lteq2d
  A (.- B (1)) modlt2  
  ## <d 'Successor Adds One '>
    (.- B (1)) a1suc
    EqReplaceLt1
  ## </d 'Successor Adds One '>
  ## <d 'Successor Adds One '>
    (.- B (1)) a1suc
    EqReplaceLt0Mod1
  ## </d 'Successor Adds One '>  
  (< (mod A (+ (.- B (1)) (1))) B) biRemove1
  (<= (1) B) imbi2i
  mpbi
  jca  
  (mod A (+ (.- B (1)) (1))) (mod A B) B lteq1  
  ImpReplaceImp1An0
  ## <d 'Commutative Property '>
    (<-> (< (mod A (+ (.- B (1)) (1))) B) (< (mod A B) B)) (< (mod A (+ (.- B (1)) (1))) B) ancom
    sylib
  ## </d 'Commutative Property '>  
  ## <d>
    (< (mod A (+ (.- B (1)) (1))) B) (< (mod A B) B) mpbi-inline
    syl
  ## </d>
  (0) B ltle2  
  ## <d 'Additive Identity Axiom '>
    (1) pa_ax3r
    EqReplaceBi1Le0
  ## </d 'Additive Identity Axiom '>
  
  ## <d 'Commutative Property '>
    (< (0) B) (<= (1) B) bicom
    mpbi
  ## </d 'Commutative Property '>
  
  sylbi2
)

## <title> Divides and modulo equivalence </title>
## <summary> Divides relation is equivalent to zero remainder </summary>
thm (dividesmod () () (<-> (| A B) (= (mod B A) (0)))
  A  B  x  df-divides
    (* A x)  pa_ax3  B  eqeq1i  x  exbii  bitr4i
  x  A  (0)  B  modmin  sylbi     (mod B A)  eq0le0      sylibr

    x  A  B   modex
    (mod B A)  (0)  (* A x)  addeq2  B  eqeq1d   (* A x)  pa_ax3  B  eqeq1i   syl6bb  x exbid    mpbii
    A  B  x  df-divides  sylibr

    impbii
)

# number 112.0
thm (gcddiv1 () () (| (gcd (S A) B) (S A))
# For later.
z  (gcd (S A) B) tyex
z  leid  (= (gcd (S A) B) z)  id  z  leeq2d   biimprd  mpi   z  (gcd (S A) B)  lenltt    sylib

  A B z gcddiv1.2
  pm3.27d    (S A)  B  z  v  w  x  y  df-lincom  sylib

   v'  z  (S A)  modex

  # Now we show that (mod A' z) is in the set minned by GCD(A',B)
    (+ (* v (S A)) (* w B)) (+ (+ (* x (S A)) (* y B)) z)  v'  muleq2
    v'  (+ (* x (S A)) (* y B))  z  distr  syl6eq
    v'  (* v (S A))  (* w B)  distr  syl5eqr
    v'  v  (S A)  mulass  (* v' (* w B))  addeq1i  syl5eq
    v'  w  B  mulass  (* (* v' v) (S A))  addeq2i  syl5eq
    v'  (* x (S A))  (* y B)  distr  (* v' z)  addeq1i  syl6eq
    v'  x  (S A)  mulass  (* v' (* y B))  addeq1i  (* v' z)  addeq1i  syl6eqr
    v'  y  B  mulass     (* (* v' x) (S A))  addeq2i  (* v' z)  addeq1i  syl6eqr
    (+ (* (* v' v) (S A)) (* (* v' w) B))  (+ (+ (* (* v' x) (S A)) (* (* v' y) B)) (* v' z))  (+ (* z v') (mod (S A) z)) (S A)  addeq12  ex  syl  imp
    # Now, cancel out those z terms
    (* z v')  (mod (S A) z)  addcom   (+ (* (* v' v) (S A)) (* (* v' w) B))  addeq2i  syl5eqr
    (+ (* (* v' v) (S A)) (* (* v' w) B))  (mod (S A) z)  (* z v')  addass  syl5eq
    (+ (* (* v' x) (S A)) (* (* v' y) B))  (* v' z)  (S A)  addass  syl6eq
    (* v' z)  (S A)  addcom  (+ (* (* v' x) (S A)) (* (* v' y) B))  addeq2i    syl6eq
    (+ (* (* v' x) (S A)) (* (* v' y) B))  (S A)  (* v' z)  addass  syl6eqr
    v'  z  mulcom    (+ (+ (* (* v' x) (S A)) (* (* v' y) B)) (S A))  addeq2i    syl6eq
    (+ (+ (* (* v' v) (S A)) (* (* v' w) B)) (mod (S A) z))  (* z v')  (+ (+ (* (* v' x) (S A)) (* (* v' y) B)) (S A))  addcan  sylib
    # Group up the A' terms
    (* (* v' x) (S A))  (* (* v' y) B)  (S A)  addass  syl6eq
    (* (* v' y) B)  (S A)  addcom  (* (* v' x) (S A))  addeq2i  syl6eq
    (* (* v' x) (S A))  (S A)  (* (* v' y) B)  addass  syl6eqr
    (* v' x) (1) (S A)  distl    (1)  (S A)  mulcom  (S A) mulid  eqtr  (* (* v' x) (S A))  addeq2i  eqtr    (* (* v' y) B)  addeq1i  syl6eqr
    eqcomd
    lincomd
 # Bam!  Now time to sweep away all those pesky quantifiers.
  ancoms    ex    v'  19.22i  ax-mp
  v'  (-> (= (+ (* v (S A)) (* w B)) (+ (+ (* x (S A)) (* y B)) z)) (lincom (S A) B (mod (S A) z)))  ex-nf  ax-mp
  y  19.22i  x  19.22i  w  19.22i  v  19.22i  syl
  v  (E. w (E. x (E. y (lincom (S A) B (mod (S A) z)))))  ex-nf  syl
  w  (E. x (E. y (lincom (S A) B (mod (S A) z))))  ex-nf syl
  x  (E. y (lincom (S A) B (mod (S A) z)))  ex-nf syl
  y (lincom (S A) B (mod (S A) z))  ex-nf syl
  # This means that either (mod A' z) is 0, or it's in the set minned by gcd.
    (-. (= (mod (S A) z) (0)))  biantrud   biimpd    imp
      x  (mod (S A) z)  (0)  eqeq1  notbid    x  (mod (S A) z)  (S A)  B  lincomeq3   anbi12d  sbcie  sylibr
    (mod (S A) z)  x  (/\ (-. (= x (0))) (lincom (S A) B x))  ax-elab      sylibr
  (mod (S A) z)  ({|} x (/\ (-. (= x (0))) (lincom (S A) B x)))   minex  syl  pm3.27d
(S A)  B  x  df-gcd  (mod (S A) z)  leeq1i  sylibr
  # But gcd A' B <= mod A' z is impossible:
    A  B  z  gcddiv1.2  pm3.26d
    z  y  lefoo       ori      syl    y  a1suc   (1)  y  addcom  eqtr4 z  eqeq1i  biimpri   y  19.22i  syl
      (S A)  y  modlt2
        (S y)  z  (S A) modeq2    (S y)  lteq1d  mpbii
      (= (S y) z)  id  (mod (S A) z)  lteq2d   biimpd    mpd
    y  19.22i  syl  y  (< (mod (S A) z) z)  ex-nf  syl
  (-. (= (mod (S A) z) (0)))  adantr    jca
  (gcd (S A) B)  (mod (S A) z)  z  lelttr   syl
  ex  con3d
mpd
(= (mod (S A) z) (0))  notnot  sylibr
(gcd (S A) B)  z  (S A)  modeq2  (0)  eqeq1d  biimprd  mpd
(gcd (S A) B)  (S A)  dividesmod  sylibr  eqcoms  z  exani  ax-mp
)

# number 114.0
#!# (sequence-set-just A S) will mean that S is a set of pairs defining an
#!# injection from [0,A] to N.
#!thm (df-sequence-set-just ((A v w) (S v w)) ()
#!(<->
#!    (/\ (A. v (-> (e. v S) (<= (head v) A)))
#!        (A. v (-> (<= v A) (E! w (e. (<,> v w) S)))))
#!    (/\ (A. v' (-> (e. v' S) (<= (head v') A)))
#!        (A. v' (-> (<= v' A) (E! w' (e. (<,> v' w') S))))))
#!
#!  v  v'  S  ax-eleq1
#!  v  v'  headeq  A  leeq1d     imbi12d
#!
#!    (= v v')  id  A  leeq1d
#!      v  v'  w opeq1
#!      (<,> v w)  (<,> v' w)  S  ax-eleq1  syl

# number 115.0
thm (divideseq12 () () (-> (/\ (= A B) (= C D))  (-> (| A C) (| B D)))
   (= A B) z alnfi

  A B z muleq1    (= (* A z) C) anim1i
    (* A z) C (* B z) ax-eqtr   eqcomd   ancoms
    syl    ex

    z gen  z (= A B) (-> (= (* A z) C) (= (* B z) C)) ax-alim   ax-mp
  syl
    z (= (* A z) C) (= (* B z) C) 19.22
  syl

  C  D  (* B z)  eqeq2  z  exbid    biimpd
   anim12i
 (E. z (= (* A z) C))  (E. z (= (* B z) C))  (E. z (= (* B z) D))  pm3.33    syl
A  C  z  df-divides  syl5ib
B  D  z  df-divides  syl6ibr
)

thm (modval.1 () ()
  (-> (/\ (= (+ (* (S B) D) C) A) (= (+ (* (S B) D') C') A))
   (<-> (< D' D) (< C C')))

  (+ (* (S B) D) C) A eqcom (+ (* (S B) D') C') A eqcom anbi12i
  A (+ (* (S B) D) C) (+ (* (S B) D') C') ax-eqtr sylbi

  (* (S B) D) C (* (S B) D') C' leadd12 syl

    (S B) D mulcom (* (S B) D') leeq1i
    (S B) D' mulcom (* D (S B)) leeq2i bitri
    D B D' lemul5 bitri
  syl5bbr

  D D' lenltt C' C lenltt bibi12i sylib
  con4bid
)

thm (modval.2 () ()
  (-> (/\ (= (+ (* (S B) D) C) A) (= (+ (* (S B) D') C') A))
    (-> (< C C') (<= (+ (S B) C) C')))
  B D C A D' C' modval.1
  biimprd
  D' D nnltp1let syl6ib

  (+ D' (1)) D (S B) lemul2 syl6

    (S B) D' (1) distr
    (S B) mulid (* (S B) D') addeq2i eqtr
    (* (S B) D) leeq1i
  syl6ib
  #(* (S B) D) pa_ax3 (+ (* (S B) D') (S B)) leeq2i syl6ibr
  #(S B) (0) (* (S B) D') leadd2 syl6ibr

  (+ (* (S B) D') (S B)) (* (S B) D) C leadd1 syl6ib

    # Note: the next two lines are copied from modval.1, should be refactored
    (+ (* (S B) D) C) A eqcom (+ (* (S B) D') C') A eqcom anbi12i
    A (+ (* (S B) D) C) (+ (* (S B) D') C') ax-eqtr sylbi
    (+ (+ (* (S B) D') (S B)) C) leeq2d
  sylibd

  (* (S B) D') (S B) C addass (+ (* (S B) D') C') leeq1i syl6ib
  (+ (S B) C) C' (* (S B) D') leadd2 syl6ibr
)

thm (modval.3 () ()
  (-> (/\ (= (+ (* B D) C) A) (= (+ (* B D') C') A)) (-> (< C C') (<= (+ B C) C')))
    (0) B C addeq1 C pa_ax3r syl5eqr C' leeq1d
    C C' df-lt pm3.26bi syl5bi
    (/\ (= (+ (* B D) C) A) (= (+ (* B D') C') A)) a1d
  (0) B eqcom B eq0le0 bitri B (0) lenltt bitri con2bii
  (0) B nnltp1let (1) pa_ax3r B leeq1i bitri
  bitr3i

  (.- B (1)) D C A D' C' modval.2

  (1) B halfminus (.- B (1)) a1suc syl5eq D muleq1d C addeq1d A eqeq1d
    (1) B halfminus (.- B (1)) a1suc syl5eq D' muleq1d C' addeq1d A eqeq1d
  anbi12d

  (1) B halfminus (.- B (1)) a1suc syl5eq C addeq1d C' leeq1d
  (< C C') imbi2d
  imbi12d
  mpbii
  sylbi

  pm2.61i
)

## <summary> Main theorem giving mod its value </summary>
thm (modval ((A y) (B y) (C y)) ()
  (-> (/\ (< C B) (E. y (= (+ (* B y) C) A))) (= C (mod A B)))

  (< C B) (E. y (= (+ (* B y) C) A)) pm3.27
    y y' B muleq2 C addeq1d A eqeq1d exalpha

    B y x A y' C modval.3
      B x addge01t B (+ B x) C letr mpan
    syl6
    con3d
    B C lenltt con2bii syl5ib
    C x lenltt syl6ibr
    ex y 19.23ai com12
    y' 19.23ai
    sylbi com3r
    imp x 19.21ai
  jca

    x z (* B y) addeq2 A eqeq1d y exbid rwffi
      x C (* B y) addeq2 A eqeq1d y exbid
    minval
  syl
  A B x y df-mod C eqeq2i sylibr
)

## <title> Modulo Value </title>
thm (modvali () (hyp (< C B)  hyp2 (= (+ (* B D) C) A)) (= (mod A B) C) 
  hyp
  y D tyex
  y D B muleq2 
  (* B y) (* B D) C addeq1  
  syl
  ImpReplaceEx1
  hyp2
  EqReplaceEx1Eq1
  pm3.2i
  C B y A modval  
  ax-mp
  
  ## <d>
    C (mod A B) eqcom
  ## </d>
  mpbi
)

# Identity law for modulo
thm (modid () ()
  (-> (< A B) (= (mod A B) A))
  x (0) tyex
    x (0) B muleq2 B pa_ax5 syl6eq
    A addeq1d A pa_ax3r syl6eq
    x 19.22i
  ax-mp
  A B x A modval mpan2 eqcomd
)

# Definition of division using set minimum instead of iota
thm (df-div-just ((A x y) (B x y)) ()
  (= (min ({|} x (= (+ (* B x) (mod A B)) A)))
    (min ({|} y (= (+ (* B y) (mod A B)) A))))
  x y B muleq2 (mod A B) addeq1d A eqeq1d abeq
  ({|} x (= (+ (* B x) (mod A B)) A)) ({|} y (= (+ (* B y) (mod A B)) A)) minseq ax-mp
)

defthm (df-div nat (div A B) ((A x) (B x)) ()
  (= (div A B) (min ({|} x (= (+ (* B x) (mod A B)) A))))
  y B A x df-div-just
)

## <title> Equivalence for div </title> ##
thm (diveq1 () () (-> (= A C) (= (div A B) (div C B)))
  A C B modeq1
  (* B x) addeq2d
  (= A C) id
  eqeq12d
  x abbi2d
  minseqd
  A B x df-div eqcomi  
  EqReplaceImp1Eq0
  C B x df-div eqcomi  
  EqReplaceImp1Eq1
)

thm (diveq2 () () (-> (= B C) (= (div A B) (div A C)))
  B C x muleq1
  B C A modeq2
  addeq12d
  A eqeq1d
  x abbi2d
  minseqd
  A B x df-div eqcomi  
  EqReplaceImp1Eq0
  A C x df-div eqcomi  
  EqReplaceImp1Eq1
)

thm (diveq12 () () (-> (/\ (= A B) (= C D)) (= (div A C) (div B D)))
  A B C diveq1
  C D B diveq2
  anim12i  
  ## <d 'Transitive Property '>
    (div A C) (div B C) (div B D) eqtr1
    syl
  ## </d 'Transitive Property '>
)

## <title> Divide both sides of an equation </title>
## <table>
##   (=      [ A    ]       [ C  )
##   (= (div [ A B) ]  (div [ C B))
## </table>
thm (diveq1i () (
     hyp1 (= A C))
     (= (div A B) (div C B))
  hyp1
  A C B diveq1
  ax-mp
)

thm (diveq1d () (
     hyp1 (-> ph (= A C)))
     (-> ph (= (div A B) (div C B)))
  hyp1
  A C B diveq1
  syl
)

thm (diveq2i () (
     hyp1 (= A B))
     (= (div C A) (div C B))
  hyp1
  A B C diveq2
  ax-mp
)

thm (diveq2d () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (div C A) (div C B)))
  hyp1
  A B C diveq2
  syl
)



## <summary> Main theorem about division </summary>
thm (div () () (= (+ (* B (div A B)) (mod A B)) A)
   x B A modex
    x y B muleq2 (mod A B) addeq1d A eqeq1d rwffi
    A B x df-div x eqeq2i biimpri x (div A B) B muleq2 syl (mod A B) addeq1d A eqeq1d
    minel
  ax-mp
)

thm (muldiv () ()
  (-> (< (0) B) (= (div (* B A) B) A))

  (* B (div (* B A) B)) pa_ax3
    B dividessym B B A dividesmul ax-mp
    B (* B A) dividesmod mpbi
    (* B (div (* B A) B)) addeq2i
    B (* B A) div eqtr3
  eqtr3
  B (div (* B A) B) A mulcant2 mpbii
)




## <title> Substitution </title>
## <table>
##   (-> ph (< A  [ B ]   ]   ] ))
##   (=           [ B ]   [ C ] )
##   (-> ph (< A  [   [   [ C ] ))
## </table>
thm (EqReplaceImp1Lt1 () (
     replacee (-> ph (< A B))
     substitution (= B C)) 
     (-> ph (< A C))
  replacee substitution
  A lteq2i
  sylib
)



thm (notDivides2 ((B x) (A x)) () (-> (/\ (-. (| A B)) (-. (<= A (0)))) (E. x (/\ (< (* A x) B) (< B (* A (+ x (1)))))))
  x (div B A) tyex
  (div B A) x A muleq2
  B lteq1d
  (div B A) x (1) addeq1
  A muleq2d
  B lteq2d
  anbi12d
  (/\ (-. (| A B)) (< (0) A)) imbi2d


  A B dividesmod  
  ## <d 'Negate Both Sides '>
    (| A B) (= (mod B A) (0)) notbi
    mpbi
  ## </d 'Negate Both Sides '>
  
  ## <d 'All nonzero natural numbers are positive '>
    (mod B A) 0inequalities2  
    bitri
  ## </d 'All nonzero natural numbers are positive '>    
      
      ## <d 'Commute Inequality '>
        (mod B A) (0) lecom        
        BiReplaceBi1Not0
        ## <d 'Double Negative '>
          (< (0) (mod B A)) notnotr
          bitri
        ## </d 'Double Negative '>
      ## </d 'Commute Inequality '>

 (0) (mod B A) (* A (div B A))  ltadd2    
        
        ## <d 'Additive Identity Axiom '>
          (* A (div B A)) pa_ax3
          EqReplaceBi1Lt0
        ## </d 'Additive Identity Axiom '>
        
  bitri
  A B div        
  EqReplaceBi1Lt1        
        ## <d 'Infer Left to Right '>
          (-. (| A B)) (< (* A (div B A)) B) bi1
          ax-mp
        ## </d 'Infer Left to Right '>

  A B modlt
 (mod B A) A (* A (div B A))  ltadd2    
  sylib

  A B div
  EqReplaceImp1Lt0
  A mulid
  (* A (div B A)) addeq2i eqcomi        
        ## <d 'Distributive Property '>
          A (div B A) (1) distr
          ## <d 'Commutative Property'>
            (* A (+ (div B A) (1))) (+ (* A (div B A)) (* A (1))) eqcom
            mpbi
          ## </d 'Commutative Property'>
          EqReplaceEq1
        ## </d 'Distributive Property '>
        
        EqReplaceImp1Lt1
  pm3.2i        
  ## <d 'Praeclarum Theorema '>
    (-. (| A B)) (< (* A (div B A)) B) (< (0) A) (< B (* A (+ (div B A) (1)))) prth
    ax-mp
  ## </d 'Praeclarum Theorema '>

  
  (-> (/\ (-. (| A B)) (< (0) A)) (/\ (< (* A x) B) (< B (* A (+ x (1)))))) biRemove1
  (= (div B A) x) imbi2i
  mpbi
  
  ## <d 'Symmetric Property '>
    (div B A) x eqcom
    sylbi2
  ## </d 'Symmetric Property '>
  
  ImpReplaceEx1

  (/\ (-. (| A B)) (< (0) A)) x (/\ (< (* A x) B) (< B (* A (+ x (1)))))
  imex bicomi  
  mpbi
  
  ## <d 'Commute Inequality '>
    (0) A ltcom
    BiReplaceImp0An1
  ## </d 'Commute Inequality '>
)

## <title> One-Digit Inequality </title>
thm (0notEqual2 () () (-. (= (0) (2)))
  (1) pa_ax1plus
  ## <d 'Evaluate'>
    1plus1
    EqReplaceNot0Eq1
  ## </d 'Evaluate'>
)

## <title> One-Digit Inequality </title>
thm (0less2 () () (< (0) (2))
  0notEqual2
  ## <d 'Less Than Or Equal To Zero'>
    (2) 0le
  ## </d 'Less Than Or Equal To Zero'>
  axlttri2i
)

## <title> One-Digit Inequality </title>
thm (2notEqual0 () () (-. (= (2) (0)))
  ## <d 'Number is Not Zero'>
    0notEqual2
    ## <d 'Commutative Property'>
      (0) (2) eqcom
      mtbi
    ## </d 'Commutative Property'>
  ## </d 'Number is Not Zero'>
)

## <title> One-Digit Inequality </title>
thm (2greater0 () () (-. (<= (2) (0)))
  2notEqual0
  ## <d 'Greater Than Or Equal To Zero'>
    (2) ge0
  ## </d 'Greater Than Or Equal To Zero'>
  axgrtrii
)

## <title> Substitution </title>
## <table>
##   (<-> ph (<= (+ A  [ B ]   ]   ] ) D))
##   (=                [ B ]   [ C ] )
##   (<-> ph (<= (+ A  [   [   [ C ] ) D))
## </table>
thm (EqReplaceBi1Le0Add1 () (
     replacee (<-> ph (<= (+ A B) D))
     substitution (= B C)) 
     (<-> ph (<= (+ A C) D))
  replacee substitution
  A addeq2i
  EqReplaceBi1Le0
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ (<=  [ A ]   ]   ]  C) ps)))
##   (=                    [ A ]   [ B ] )
##   (-> ph (E. x (/\ (<=  [   [   [ B ]  C) ps)))
## </table>
thm (EqReplaceImp1Ex1An0Le0 () (
     replacee (-> ph (E. x (/\ (<= A C) ps)))
     substitution (= A B)) 
     (-> ph (E. x (/\ (<= B C) ps)))
  replacee substitution
  C leeq1i
  BiReplaceImp1Ex1An0
)


## <title> Substitution </title>
## <table>
##   (E. x (-> ph  [ ps ]   ]    ] ))
##   (<->          [ ps ]   [ ch ] )
##   (E. x (-> ph  [    [   [ ch ] ))
## </table>
thm (BiReplaceEx1Imp1 () (
     replacee (E. x (-> ph ps))
     substitution (<-> ps ch)) 
     (E. x (-> ph ch))
  replacee substitution
  ph imbi2i
  exbiii
)

thm (sbc-oddSuccessor ((B x) (C x) (A x)) () (<-> ([/] B x (= (* C x) A)) (= (* C B) A)) 
  x B C muleq2
  A eqeq1d
  sbcie
)

## <title> An odd number has an even number above it </title>
thm (oddsuccessor () () (-> (-. (| (2) A)) (| (2) (+ A (1))))
  (2) A x notDivides2
  2greater0

  (-. (| (2) A)) anRemove2
  (E. x (/\ (< (* (2) x) A) (< A (* (2) (+ x (1)))))) imbi1i
  mpbi
  (* (2) x) A (1) ltadd1

  ## <d 'Convert between ≤ and < '>
    (+ (* (2) x) (1)) (+ A (1)) ltle2
    bitri
  ## </d 'Convert between ≤ and < '>
  ## <d 'Associative Property '>
    (* (2) x) (1) (1) addass
    EqReplaceBi1Le0
  ## </d 'Associative Property '>
  ## <d 'Evaluate'>
    1plus1
    EqReplaceBi1Le0Add1
  ## </d 'Evaluate'>
  BiReplaceImp1Ex1An0

  A (* (2) (+ x (1))) (1) ltadd1
  ## <d 'Convert between ≤ and < '>
    (+ A (1)) (* (2) (+ x (1))) lePlus1
    bitri
  ## </d 'Convert between ≤ and < '>
  BiReplaceImp1Ex1An1

  (2) x (1) distr eqcomi
  ## <d 'Commutative Property '>
    (2) (1) mulcom
    (2) mulidr
    EqReplaceEq1
    EqReplaceEq0Add1
  ## </d 'Commutative Property '>

  EqReplaceImp1Ex1An0Le0

  ## <d>
    (* (2) (+ x (1))) (+ A (1)) lesym
    ## <d 'Commutative Property'>
      (= (* (2) (+ x (1))) (+ A (1))) (/\ (<= (* (2) (+ x (1))) (+ A (1))) (<= (+ A (1)) (* (2) (+ x (1))))) bicom
      mpbi
    ## </d 'Commutative Property'>
    BiReplaceImp1Ex1
  ## </d>

  x (1) y (= (* (2) y) (+ A (1)))  z sbcadd
  (+ x (1)) y (2) (+ A (1)) sbc-oddSuccessor    
  sylbi2
  z y (2) (+ A (1)) sbc-oddSuccessor    
  BiReplaceImp1Ex1  
  ImpReplaceImp1Ex1

  x (E. z (= (* (2) z) (+ A (1)))) 19.9  
  sylib
  
  ## <d 'Divides Definition '>
    (2) (+ A (1)) z df-divides
    ## <d 'Commutative Property'>
      (| (2) (+ A (1))) (E. z (= (* (2) z) (+ A (1)))) bicom
      mpbi
    ## </d 'Commutative Property'>
    sylib
  ## </d 'Divides Definition '>
)

## <title> Substitution </title>
## <table>
##   (-> ph (| A  [ B ]   ]   ] ))
##   (=           [ B ]   [ C ] )
##   (-> ph (| A  [   [   [ C ] ))
## </table>
thm (EqReplaceImp1Divs1 () (
     replacee (-> ph (| A B))
     substitution (= B C)) 
     (-> ph (| A C))
  replacee substitution
  A divideseq2i
  sylib
)


## <title> x(x+1) is even </title>
thm (evenxxplus1 () () (| (2) (* A (+ A (1))))
  (2) A (+ A (1)) dividesmul
  A oddsuccessor
  (2) (+ A (1)) A dividesmul  
  syl  
  ## <d 'Commutative Property '>
    (+ A (1)) A mulcom
    EqReplaceImp1Divs1
  ## </d 'Commutative Property '>
  pm2.61i
)

## <title> Substitution </title>
## <table>
##   (<-> ph (= A  [ B ]   ]   ] ))
##   (=            [ B ]   [ C ] )
##   (<-> ph (= A  [   [   [ C ] ))
## </table>
thm (EqReplaceBi1Eq1 () (
     replacee (<-> ph (= A B))
     substitution (= B C)) 
     (<-> ph (= A C))
  replacee
  substitution
A eqeq2i
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (= A (min ({|} x  [ ph ]   ]    ] )))
##   (<->              [ ph ]   [ ps ] )
##   (= A (min ({|} x  [    [   [ ps ] )))
## </table>
thm (BiReplaceEq1Min0Ab1 () (
     replacee (= A (min ({|} x ph)))
     substitution (<-> ph ps)) 
     (= A (min ({|} x ps)))
  replacee
  substitution
x abbi2i
minseqi
A eqeq2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (= A (min  [ S ]   ]   ] ))
##   (=_        [ S ]   [ T ] )
##   (= A (min  [   [   [ T ] ))
## </table>
thm (SeqReplaceEq1Min0 () (
     replacee (= A (min S))
     substitution (=_ S T)) 
     (= A (min T))
  replacee
  substitution
minseqi
A eqeq2i
mpbi
)

thm (divval () (hyp (-. (<= B (0))) hyp2 (= (+ (* B C) (mod A B)) A)) (= (div A B) C)
  A B x df-div
  hyp
(0) B ltcom  
  
  ## <d>
    (< (0) B) (-. (<= B (0))) bicom
  ## </d>
  mpbi
  mpbi

  B x C mulcant2
  ax-mp

  (* B x) (mod A B) (* B C) addcan

  ## <d>
    (= (+ (* B x) (mod A B)) (+ (* B C) (mod A B))) (= (* B x) (* B C)) bicom
  ## </d>
  mpbi
  bitr3icom
  ## <d>
    (= (+ (* B x) (mod A B)) (+ (* B C) (mod A B))) (= x C) bicom
  ## </d>
  mpbi
  hyp2
  EqReplaceBi1Eq1

  ## <d>
    (= x C) (= (+ (* B x) (mod A B)) A) bicom
  ## </d>
  mpbi

  BiReplaceEq1Min0Ab1
  C x df-sn
  ## <d>
    ({} C) ({|} x (= x C)) seqcom
  ## </d>
  mpbi

  SeqReplaceEq1Min0

  C minsn
  EqReplaceEq1
)

# == Godel's Beta Function ==

## <summary> A development of Godel's Beta Function, following Shoenfield(1967).  </summary> 
thm (df-beta-just ((A x x') (B x x')) ()
(=  (min ({|} x (| (S (* (S (<,> B x)) (tail A))) (head A))))
    (min ({|} x' (| (S (* (S (<,> B x')) (tail A))) (head A)))))


    x  x'  B  opeq2  suceqd  (tail A)  muleq1d  suceqd
    (S (* (S (<,> B x)) (tail A)))  (S (* (S (<,> B x')) (tail A)))  (head A)  divideseq1  syl
  abeq
  ({|} x (| (S (* (S (<,> B x)) (tail A))) (head A)))  ({|} x' (| (S (* (S (<,> B x')) (tail A))) (head A)))   minseq  ax-mp
)
defthm  (df-beta nat (beta A B) ((A x ) (B x )) ()
        (= (beta A B) (min ({|} x (| (S (* (S (<,> B x)) (tail A))) (head A)))))
          x' B A x df-beta-just)

# number 116.1
thm (maxex.1 ((A x y)) ()
(-> (= x' A)  (<->
    (-> (fun S)
      (E. x (A. y (-> (/\ (< (head y) x') (e. y S)) (<= (tail y) x)))))
    (-> (fun S)
      (E. x (A. y (-> (/\ (< (head y) A) (e. y S)) (<= (tail y) x)))))))
  (= x' A)  id  (head y)  lteq2d
  (e. y S)  anbi1d
  (<= (tail y) x)  imbi1d  y  19.21ai  19.15d
   x exbid
    (fun S)  imbi2d
)
# number 116.15
thm (fun1 ((A x y) (S x y)) () (-> (fun S) (E. x (A. y (-> (/\ (= (head y) A) (e. y S)) (= y x)))))
S  y  v  w   df-fun  biimpi
  y  A  v  opeq1  (<,> y v)  (<,> A v)  S  ax-eleq1  syl  v  eubid  cla4g
v  (e. (<,> A v) S)  v'  df-eu  sylib

  (A. y (-> (e. y S) (E. v (E. w (= y (<,> v w))))))  anim1i  syl
  y  (-> (e. y S) (E. v (E. w (= y (<,> v w)))))  ax-4
    (<,> v w)  y  headeq    v  w  headop   syl5eqr  v (head y)  w  opeq1  syl   ancri
  (<,> v w)  (<,> (head y) w)  y  ax-eqtr  syl  eqcoms   w  19.22i  v  19.22i  syl6
  imp  19.9d  w  v  (head y)  opeq2  y  eqeq1d  exalpha  sylib

    (head y)  A  v  opeq1  y  eqeq1d  v  exbid  biimpd   anim12i
  (E. v (= (<,> (head y) v) y))  (E. v (= (<,> A v) y))   pm3.35  syl  ex  ex  imp3a
   ancrd   (E. v (= (<,> A v) y))  (e. y S)  (= (head y) A)  anass syl6ibr  imp   pm3.26d
   v  (= (<,> A v) y)  (e. y S)  19.41 sylibr
     (<,> A v)  y  S  ax-eleq1  biimprd  imp    ancri
   (e. (<,> A v) S)  (= (<,> A v) y)  (e. y S)  anass  sylibr pm3.26d  v  19.22i  syl
  ex  y  19.21ai
(E. v' (A. v (<-> (e. (<,> A v) S) (= v v'))))  anim2i  syl
v'  (A. v (<-> (e. (<,> A v) S) (= v v')))  (A. y (-> (/\ (e. y S) (= (head y) A)) (E. v (/\ (e. (<,> A v) S) (= (<,> A v) y)))))  19.41  sylibr

y  (A. v (<-> (e. (<,> A v) S) (= v v')))  (-> (/\ (e. y S) (= (head y) A)) (E. v (/\ (e. (<,> A v) S) (= (<,> A v) y))))    alan1
v'  exbii  sylibr

(A. v (<-> (e. (<,> A v) S) (= v v')))  (/\ (e. y S) (= (head y) A))  (E. v (/\ (e. (<,> A v) S) (= (<,> A v) y)))  anim3

v  (<-> (e. (<,> A v) S) (= v v'))  (/\ (e. (<,> A v) S) (= (<,> A v) y))  19.29      syl6

(<-> (e. (<,> A v) S) (= v v'))  (e. (<,> A v) S) (= (<,> A v) y)  anass  biimpri    (e. (<,> A v) S)  (= v v')  bi1   (e. (<,> A v) S)  anim1i  ancomd   (e. (<,> A v) S)  (= v v')  pm3.35    syl  (= (<,> A v) y)  anim1i  syl  v  19.22i  syl6

v  v'  A  opeq2  y  eqeq1d  biimpd  imp  v  19.22i  syl6

v  (= (<,> A v') y)  ex-nf  syl6

y  19.20i  v'  19.22i  syl

# (E. v' (A. y (-> (/\ (e. y S) (= (head y) A)) (= (<,> A v') y))))  x  alnfi
  x  (<,> A v')  tyex
  x  (<,> A v')  y  eqeq1  (/\ (e. y S) (= (head y) A))  imbi2d   y  19.21ai   19.15d  biimprd  x 19.22i  ax-mp
  v'  gen
jctil

v'  (E. x (-> (A. y (-> (/\ (e. y S) (= (head y) A)) (= (<,> A v') y))) (A. y (-> (/\ (e. y S) (= (head y) A)) (= x y)))))  (A. y (-> (/\ (e. y S) (= (head y) A)) (= (<,> A v') y)))  19.29    syl

 x  (-> (A. y (-> (/\ (e. y S) (= (head y) A)) (= (<,> A v') y))) (A. y (-> (/\ (e. y S) (= (head y) A)) (= x y))))  (A. y (-> (/\ (e. y S) (= (head y) A)) (= (<,> A v') y)))  19.41    biimpri  v'  19.22i  syl

 (A. y (-> (/\ (e. y S) (= (head y) A)) (= (<,> A v') y)))  (A. y (-> (/\ (e. y S) (= (head y) A)) (= x y)))  pm3.35    ancoms  x  19.22i  v'  19.22i  syl

v'  (E. x (A. y (-> (/\ (e. y S) (= (head y) A)) (= x y))))  ex-nf  syl

(e. y S)  (= (head y) A)  ancom  x  y  eqcom  imbi12i  y  albii  x  exbii  sylib
)

## <title> Substitution </title>
## <table>
##   (E. x (/\  [ ph ]   ]    ]  ch))
##   (->        [ ph ]   [ ps ] )
##   (E. x (/\  [    [   [ ps ]  ch))
## </table>
thm (ImpReplaceEx1An0 () (
     replacee (E. x (/\ ph ch))
     substitution (-> ph ps)) 
     (E. x (/\ ps ch))
  replacee substitution
  ch anim1i
  ImpReplaceEx1
)

## <title> Substitution </title>
## <table>
##   (E. x (/\ ph  [ ps ]   ]    ] ))
##   (->           [ ps ]   [ ch ] )
##   (E. x (/\ ph  [    [   [ ch ] ))
## </table>
thm (ImpReplaceEx1An1 () (
     replacee (E. x (/\ ph ps))
     substitution (-> ps ch)) 
     (E. x (/\ ph ch))
  replacee substitution
  ph anim2i
  ImpReplaceEx1
)

## <title> Substitution </title>
## <table>
##   (E. x (-> ph (/\ ps  [ ch ]   ]    ] )))
##   (<->                 [ ch ]   [ th ] )
##   (E. x (-> ph (/\ ps  [    [   [ th ] )))
## </table>
thm (BiReplaceEx1Imp1An1 () (
     replacee (E. x (-> ph (/\ ps ch)))
     substitution (<-> ch th)) 
     (E. x (-> ph (/\ ps th)))
  replacee substitution
  ps anbi2i
  BiReplaceEx1Imp1
)

## <title> Substitution </title>
## <table>
##   (E. x (-> ph (/\  [ ps ]   ]    ]  th)))
##   (<->              [ ps ]   [ ch ] )
##   (E. x (-> ph (/\  [    [   [ ch ]  th)))
## </table>
thm (BiReplaceEx1Imp1An0 () (
     replacee (E. x (-> ph (/\ ps th)))
     substitution (<-> ps ch)) 
     (E. x (-> ph (/\ ch th)))
  replacee substitution
  th anbi1i
  BiReplaceEx1Imp1
)

## <title> Substitution </title>
## <table>
##   (E. x (-> ph  [ ps ]   ]    ] ))
##   (->           [ ps ]   [ ch ] )
##   (E. x (-> ph  [    [   [ ch ] ))
## </table>
thm (ImpReplaceEx1Imp1 () (
     replacee (E. x (-> ph ps))
     substitution (-> ps ch)) 
     (E. x (-> ph ch))
  replacee substitution
  ph imim2i
  ImpReplaceEx1
)

thm (singleQualifier ((A x) (S x) (B x) (A y) (S y) (B y)) (hyp (E. x (A. y (-> (e. y S) (= y x))))) (-> (/\ (e. A S) (e. B S)) (= A B))
  hyp
  (A. y (-> (e. y S) (= y x)))  anidm
  bicomi  
  exbiii

  y A S ax-eleq1
  y A x eqeq1
  imbi12d
  cla4g  
  ImpReplaceEx1An0

  y B S ax-eleq1
  y B x eqeq1
  imbi12d
  cla4g  
  ImpReplaceEx1An1
  
  ## <d 'Praeclarum Theorema '>
    (e. A S) (= A x) (e. B S) (= B x) prth
    ImpReplaceEx1
  ## </d 'Praeclarum Theorema '>
  
  ## <d 'Symmetric Property '>
    B x eqcom
    BiReplaceEx1Imp1An1
  ## </d 'Symmetric Property '>
  
  ## <d 'Symmetric Property '>
    A x eqcom
    BiReplaceEx1Imp1An0
  ## </d 'Symmetric Property '>
  
  ## <d 'Transitive Property '>
    x A B ax-eqtr
    ImpReplaceEx1Imp1
  ## </d 'Transitive Property '>
  x (-> (/\ (e. A S) (e. B S)) (= A B)) 19.9
  
  mpbi
)

## <summary> Similiar to singleQualifier, but applied to fun1.  </summary> 
thm (fun1.1 () (hyp (fun S)) (-> (/\ (/\ (= (head B) A) (e. B S)) (/\ (= (head C) A) (e. C S))) (= B C))
  hyp
  S x y A fun1
  ax-mp
  (A. y (-> (/\ (= (head y) A) (e. y S)) (= y x))) anidm
  bicomi  
  exbiii

  y B headeq
  A eqeq1d
  y B S ax-eleq1
  anbi12d
  y B x eqeq1
  imbi12d
  cla4g
  ImpReplaceEx1An0

  y C headeq
  A eqeq1d
  y C S ax-eleq1
  anbi12d
  y C x eqeq1
  imbi12d
  cla4g
  ImpReplaceEx1An1

  ## <d 'Praeclarum Theorema '>
    (/\ (= (head B) A) (e. B S)) (= B x) (/\ (= (head C) A) (e. C S)) (= C x) prth
    ImpReplaceEx1
  ## </d 'Praeclarum Theorema '>
  
  ## <d 'Commute Equality '>
    B x eqcom
    BiReplaceEx1Imp1An0
  ## </d 'Commute Equality '>
  
  ## <d 'Commute Equality'>
    C x eqcom
    BiReplaceEx1Imp1An1
  ## </d 'Commute Equality '>
  
  ## <d 'Transitive Property '>
    x B C ax-eqtr
    ImpReplaceEx1Imp1
  ## </d 'Transitive Property '>
  x (-> (/\ (/\ (= (head B) A) (e. B S)) (/\ (= (head C) A) (e. C S))) (= B C)) 19.9
  
  mpbi
)

thm (maxex.2 ((S x y)) ()
(-> (-> (fun S)

      (E. x (A. y (-> (/\ (< (head y) z) (e. y S)) (<= (tail y) x)))))
    (-> (fun S)
      (E. x (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) x))))))

(head y)  z  lesuc    biimpi    (head y)  z  lefoo3      sylib
(head y)  z  nnltp1let    (= (head y) z)  orbi2i  sylibr

(e. y S)  anim1i
(= (head y) z)  (< (head y) z)  (e. y S)  andir    sylib

(fun S)  jctl    ancomd
 (fun S)  (/\ (< (head y) (S z)) (e. y S))  (\/ (/\ (= (head y) z) (e. y S)) (/\ (< (head y) z) (e. y S)))  anim3    syl
(fun S)  (/\ (= (head y) z) (e. y S))  (/\ (< (head y) z) (e. y S))  andi  syl6ib
(fun S)  (/\ (= (head y) z) (e. y S))  pm3.27  (/\ (fun S) (/\ (< (head y) z) (e. y S)))  orim1i  syl6
y  19.21ai  w  19.21ai

S  w  y  z  fun1  jca

 w  (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (\/ (/\ (= (head y) z) (e. y S)) (/\ (fun S) (/\ (< (head y) z) (e. y S))))))  (A. y (-> (/\ (= (head y) z) (e. y S)) (= y w)))  19.29    syl

# Please excuse this illegible mess.  Just pulling an implication in from the end and applying
# it to the first half of the disjunction.

  (/\ (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (\/ (/\ (= (head y) z) (e. y S)) (/\ (fun S) (/\ (< (head y) z) (e. y S)))))) (A. y (-> (/\ (= (head y) z) (e. y S)) (= y w))))  y  alnfi
  y  (-> (/\ (< (head y) (S z)) (e. y S)) (\/ (/\ (= (head y) z) (e. y S)) (/\ (fun S) (/\ (< (head y) z) (e. y S)))))  ax-4  y  (-> (/\ (= (head y) z) (e. y S)) (= y w))  ax-4  anim12i    y  19.20i  syl

 (-> (/\ (= (head y) z) (e. y S)) (= y w)) (/\ (< (head y) (S z)) (e. y S)) (\/ (/\ (= (head y) z) (e. y S)) (/\ (fun S) (/\ (< (head y) z) (e. y S)))) anim3    ancoms
 (-> (/\ (= (head y) z) (e. y S)) (= y w))  (/\ (= (head y) z) (e. y S))  (/\ (fun S) (/\ (< (head y) z) (e. y S)))  andi  syl6ib
 (/\ (= (head y) z) (e. y S))  (= y w)  pm3.35  ancoms  (/\ (-> (/\ (= (head y) z) (e. y S)) (= y w)) (/\ (fun S) (/\ (< (head y) z) (e. y S))))  orim1i
 (-> (/\ (= (head y) z) (e. y S)) (= y w))  (/\ (fun S) (/\ (< (head y) z) (e. y S)))  pm3.27  (= y w)  orim2i  syl  syl6
 y  19.20i  syl
 w  19.22i  syl


   (fun S)  x  (A. y (-> (/\ (< (head y) z) (e. y S)) (<= (tail y) x)))  imex
   y  (fun S)  (-> (/\ (< (head y) z) (e. y S)) (<= (tail y) x))  19.21  x  exbii  bitr4i
    (fun S)  (/\ (< (head y) z) (e. y S))   (<= (tail y) x)  pm3.31  y  19.20i x  19.22i    sylbi
  anim12i    ancoms
  w  (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (\/ (= y w) (/\ (fun S) (/\ (< (head y) z) (e. y S)))))) x  (A. y (-> (/\ (fun S) (/\ (< (head y) z) (e. y S))) (<= (tail y) x)))  exey    syl
  y  (-> (/\ (< (head y) (S z)) (e. y S)) (\/ (= y w) (/\ (fun S) (/\ (< (head y) z) (e. y S)))))  (-> (/\ (fun S) (/\ (< (head y) z) (e. y S))) (<= (tail y) x))  alan12   x  19.22i  w  19.22i  syl

  # Once again, pulling an implication in and applying it to part of the disjunction.
  (-> (/\ (fun S) (/\ (< (head y) z) (e. y S))) (<= (tail y) x))  (/\ (< (head y) (S z)) (e. y S))  (\/ (= y w) (/\ (fun S) (/\ (< (head y) z) (e. y S))))  anim3    ancoms     (-> (/\ (fun S) (/\ (< (head y) z) (e. y S))) (<= (tail y) x))  (= y w)  (/\ (fun S) (/\ (< (head y) z) (e. y S)))  andi   syl6ib  (-> (/\ (fun S) (/\ (< (head y) z) (e. y S))) (<= (tail y) x))  (= y w)  pm3.27  (/\ (-> (/\ (fun S) (/\ (< (head y) z) (e. y S))) (<= (tail y) x)) (/\ (fun S) (/\ (< (head y) z) (e. y S))))  orim1i  syl6  (/\ (fun S) (/\ (< (head y) z) (e. y S)))  (<= (tail y) x)  pm3.35 ancoms  (= y w)  orim2i  syl6
    (tail w)  x  addge01t      y  w  taileq  (+ (tail w) x) leeq1d  mpbiri
      x  (tail w)  addge01t  x  (tail w)  addcom  x  leeq2i  mpbi  (tail y)  x  (+ (tail w) x)  letr  ancoms  ex  ax-mp
    jaoi  (/\ (< (head y) (S z)) (e. y S))  imim2i
  syl
y  19.20i  x  19.22i  w  19.22i  syl

    v  (+ (tail w) x)  tyex
    (= v (+ (tail w) x))  id    (tail y)  leeq2d  biimprd  (/\ (< (head y) (S z)) (e. y S))  imim2d  y  19.21ai  v  19.22i  ax-mp
     x  gen  w  gen

#  w  (A. x (E. v (-> (-> ph (<= (tail y) (+ (tail w) x))) (-> ph (<= (tail y) v)))))  (E. x (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x)))))  19.29    x  (E. v (-> (-> ph (<= (tail y) (+ (tail w) x))) (-> ph (<= (tail y) v))))  (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x))))  19.29  w  19.22i  syl  ex  ax-mp    syl

  w  (A. x (E. v (A. y (-> (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x))) (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) v))))))  (E. x (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x)))))  19.29    x  (E. v (A. y (-> (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x))) (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) v)))))  (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x))))    19.29  w  19.22i  syl  ex  ax-mp    syl

  v  (A. y (-> (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x))) (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) v))))  (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x))))   19.41   biimpri    y (-> (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x))) (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) v)))  (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x)))  alan12  (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) (+ (tail w) x)))  (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) v))  pm3.35  ancoms  y  19.20i  syl  v  19.22i  syl  x  19.22i  w  19.22i  syl


  w  (E. x (E. v (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) v)))))  ex-nf  syl
  x  (E. v (A. y (-> (/\ (< (head y) (S z)) (e. y S)) (<= (tail y) v))))  ex-nf  syl
  (= v x)  id    (tail y)  leeq2d  (/\ (< (head y) (S z)) (e. y S))  imbi2d  y  19.21ai    19.15d  exalpha  sylib
ex
)

thm (maxex ((A x y) (S x y)) ()
  (-> (fun S)
      (E. x (A. y (-> (/\ (< (head y) A) (e. y S)) (<= (tail y) x)))))
  x' (0) S  x  y    maxex.1
    x' y' S  x  y    maxex.1
      x' (S y') S  x  y    maxex.1
       x'  A  S  x  y  maxex.1
# Base case is trivial
         (head y)  nn0nlt0     (<= (tail y) x)  pm2.21i  (e. y S)  adantr
         y  gen   x  19.8ai    (fun S) a1i
           S  x  y  y'  maxex.2

  finds
)

thm (df-relprim-just ((A x x') (B x x')) ()
  (<-> (A. x (-> (| B (* A x)) (| B x)))
       (A. x' (-> (| B (* A x')) (| B x'))))
  x  x'  A  muleq2   (* A x)  (* A x')  B  divideseq2  syl
  x  x'  B  divideseq2
  imbi12d
  alpha
)

# Definition of "relatively prime"
defthm  (df-relprim wff (relprim A B) ((A x) (B x)) ()
        (<-> (relprim A B) (A. x (-> (| B (* A x)) (| B x))))
          x' B A x df-relprim-just)

# number 120.0
# Induction tool for relprimex
thm (relprimex.1 ((C y z)) ()
(-> (= x' C)
    (<->
(-> (A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y))))
     (E. z (/\ (A. y (-> (/\ (< (S (S y)) x') (e. (S (S y)) S))     (| (S (S y)) z)))
               (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z)))))))
(-> (A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y))))
     (E. z (/\ (A. y (-> (/\ (< (S (S y)) C) (e. (S (S y)) S))     (| (S (S y)) z)))
               (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z)))))))))
  (= x' C)  id  (S (S y))  lteq2d
  (e. (S (S y)) S)  anbi1d
  (| (S (S y)) z)  imbi1d
  y  19.21ai  19.15d
  (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z))))  anbi1d
  z  exbid
  (A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y))))  imbi2d

)
# number 122.0
# base case for relprimex
thm (relprimex.2 () ()
 (-> (A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y))))
     (E. z (/\ (A. y (-> (/\ (< (S (S y)) (0)) (e. (S (S y)) S))     (| (S (S y)) z)))
               (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z)))))))

z  (1)  tyex
  (S (S y))  nn0nlt0
  (| (S (S y)) z)  pm2.21i
  (e. (S (S y)) S)  adantr
  y  gen
    y  divides1    z  (1)  (S (S y)) divideseq2  notbid  biimprd  mpi
    (e. (S (S y)) T)  a1d  y 19.21ai
  jctilb
  z  19.22i
ax-mp
(A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y))))  a1i
)

# Equality theorem for relative primeness, second argument
thm (relprimeq2 () () (-> (= A B) (<-> (relprim C A) (relprim C B)))
  A  B  (* C x)  divideseq1
  A  B  x  divideseq1
  imbi12d
  x  19.21ai  19.15d
  C  A  x  df-relprim  syl5bb
  C  B  x  df-relprim  syl6bbr
)

# Equality theorem for relative primeness, first argument
thm (relprimeq1 () () (-> (= A B) (<-> (relprim A C) (relprim B C)))
  A  B   x  muleq1  (* A x)  (* B x)  C  divideseq2    syl    (| C x)  imbi1d
  x  19.21ai  19.15d
  A  C  x  df-relprim  syl5bb
  B  C  x  df-relprim  syl6bbr
)

# induction step for relprimex
thm (relprimex.3 ((S x y z) (T x y z) (A x y z)) ()
(->
 (-> (A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y))))
     (E. z (/\ (A. y (-> (/\ (< (S (S y)) A) (e. (S (S y)) S))    (| (S (S y)) z)))
               (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z)))))))
 (-> (A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y))))
     (E. z (/\ (A. y (-> (/\ (< (S (S y)) (S A)) (e. (S (S y)) S)) (| (S (S y)) z)))
               (A. y (-> (e. (S (S y)) T)  (-. (| (S (S y)) z)))))))
)


# Case 1: A is in S.  Now we take z from the IHOP and use z*A as the new z.
  (e. (S (S y)) S)  (< (S (S y)) A)  ancom    biimpi    (| (S (S y)) z)  imim1i
    A  dividessym     A  A  z  dividesmul    ax-mp    (S (S y)) A  (* A z)  divideseq1   mpbiri
    z  A  mulcom    (* z A)  (* A z)  (S (S y))  divideseq2  ax-mp    sylibr
    (e. (S (S y)) S)  adantl  (-> (/\ (e. (S (S y)) S) (< (S (S y)) A)) (| (S (S y)) z))  a1i
      (S (S y))  z  A  dividesmul    (/\ (e. (S (S y)) S) (< (S (S y)) A))  imim2i
    jaod
    (e. (S (S y)) S) (= (S (S y)) A) (< (S (S y)) A)  andi      biimpi   ancoms  syl5
      (S (S y))  A  lesuc    biimpi (S (S y))  A  lefoo3    sylib
      (S (S y))  A  nnltp1let    (= (S (S y)) A)  orbi2i    sylibr
    (e. (S (S y)) S) anim1i    syl5
  syl
  y  19.20i
  (/\ (e. A S) (A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y)))))  a1i
    x  A  S  ax-eleq1  (e. y T)  anbi1d
    x  A  y  relprimeq1    imbi12d     (e. A S)  (e. y T)  (relprim A y)  impexp    (= x A)  a1i    bitrd
    y  19.21ai  19.15d  cla4g y
    (e. A S)  (-> (e. y T) (relprim A y))  19.21    sylib    com12    imp
    y  (S (S z)) T  ax-eleq1    y  (S (S z))  A  relprimeq2  imbi12d    cla4g   z  19.21ai
      (= z y)  id    suceqd    suceqd   (S (S z)) (S (S y))  T  ax-eleq1   syl
      (= z y)  id    suceqd    suceqd   (S (S z)) (S (S y))  A  relprimeq2    syl  imbi12d  cla4g
    syl syl
    A  (S (S y))  z  df-relprim  syl6ib
    z  (-> (| (S (S y)) (* A z)) (| (S (S y)) z))  ax-4    syl6
    imp    A  z  mulcom  (* A z)  (* z A)  (S (S y))  divideseq2  ax-mp  syl5ibr
    con3d     ex     a2d    y 19.21ai
    y  (->  (e. (S (S y)) T) (-. (| (S (S y)) z)))  (-> (e. (S (S y)) T) (-. (| (S (S y)) (* z A))))  ax-alim   syl
  anim12d
  z  19.22d
  ex  a2d
  # Need to alpha-switch z -> z * A
  imp  imp
   (/\ (A. y (-> (/\ (< (S (S y)) (S A)) (e. (S (S y)) S)) (| (S (S y)) (* z A)))) (A. y (->  (e. (S (S y)) T) (-. (| (S (S y)) (* z A))))))  z'  alnfi
    z'  (* z A)  tyex
      z'  (* z A)  (S (S y))  divideseq2    (/\ (< (S (S y)) (S A)) (e. (S (S y)) S))  imbi2d    y  19.21ai  19.15d
        z'  (* z A)  (S (S y))  divideseq2    notbid  (e. (S (S y)) T)  imbi2d    y  19.21ai    19.15d
      anbi12d  biimprd
    z'  19.22i    ax-mp
    z'  (/\ (A. y (-> (/\ (< (S (S y)) (S A)) (e. (S (S y)) S)) (| (S (S y)) (* z A)))) (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) (* z A))))))  (/\ (A. y (-> (/\ (< (S (S y)) (S A)) (e. (S (S y)) S)) (| (S (S y)) z'))) (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z')))))  eximp1  ax-mp
   syl
   z    19.22i
   19.9d
     z'  z  (S (S y))  divideseq2  (/\ (< (S (S y)) (S A)) (e. (S (S y)) S))  imbi2d
     y  19.21ai    19.15d
       z'  z  (S (S y))  divideseq2  notbid    (e. (S (S y)) T)  imbi2d
       y  19.21ai    19.15d
     anbi12d
   exalpha    sylib
  syl
  ex  ex
# Case 2: A is not in S.  This is easy, because the x from the IHOP works again;
# but ugly, because of all the mandhyps.
  (S (S y))  A  S  ax-eleq1  notbid  biimprd     com12    con2d
    (S (S y))  A  lesuc    biimpi (S (S y))  A  lefoo3    sylib
    (S (S y))  A  nnltp1let    (= (S (S y)) A)  orbi2i    sylibr   ord
  syl9
  (e. (S (S y)) S)  (< (S (S y)) A)  ancr     (< (S (S y)) (S A))  imim2i  (-. (e. A S))  imim2i  ax-mp
  imp3a
  (| (S (S y)) z)  imim1d
  y  19.21ai
  y  (-> (/\ (< (S (S y)) A) (e. (S (S y)) S)) (| (S (S y)) z))  (-> (/\ (< (S (S y)) (S A)) (e. (S (S y)) S)) (| (S (S y)) z))  ax-alim      syl
  (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z))))  anim1d
  z  19.21ai
  z  (/\ (A. y (-> (/\ (< (S (S y)) A) (e. (S (S y)) S)) (| (S (S y)) z))) (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z)))))  (/\ (A. y (-> (/\ (< (S (S y)) (S A)) (e. (S (S y)) S)) (| (S (S y)) z))) (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z)))))  19.22    syl
  (A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y))))  imim2d

# Unify cases 1 and 2.
pm2.61i
)
# number 127.0
## <summary>
##   A development of Godel's Beta Function, following Shoenfield(1967).
##   Suppose everything in S is relatively prime to everything in T.
##   Then there's a number x divisible by everything in (1,A) & S and by nothing in (1, B) & T.
##   We prove this by induction on A.
## </summary> 
thm (relprimex ((S x y z) (T x y z) (A y z)) ()
 (-> (A. x (A. y (-> (/\ (e. x S) (e. y T)) (relprim x y))))
     (E. z (/\ (A. y (-> (/\ (< (S (S y)) A) (e. (S (S y)) S))     (| (S (S y)) z)))
               (A. y (-> (e. (S (S y)) T) (-. (| (S (S y)) z)))))))
  x' (0)  x  y  S   T   z relprimex.1
    x' y'  x   y  S   T   z relprimex.1
      x' (S y')  x  y  S   T  z  relprimex.1
        x' A  x  y  S   T  z relprimex.1
          x  y  S  T  z  relprimex.2
            x  y  S  T  z  y'     relprimex.3
  finds
)

# number 128.0
thm (relprimcom () () (-> (relprim A (S B)) (relprim (S B) A))
A  (* (S B) y)  x  df-divides
    A  (S B)  x  df-relprim    biimpi    x  (-> (| (S B) (* A x)) (| (S B) x))  ax-4  syl
    (S B)  (* A x)  y  df-divides  syl5ibr
    (= (* (S B) y) (* A x))  y  19.8a    syl5
    (S B)  x  z  df-divides  syl6ib
    ancrd
    z  (= (* (S B) z) x)  (= (* (S B) y) (* A x))  19.41    syl6ibr
    (* (S B) z)  x  A  muleq2  eqcomd
    (* (S B) y)  (* A x)  eqcom   biimpi anim12i
    (* A x)  (* A (* (S B) z))  (* (S B) y)   ax-eqtr    syl
    A  (S B)  z  mulass  syl5eq
    A  (S B)  mulcom    z  muleq1i  syl5eqr
    (S B)  A  z  mulass   (* (S B) y)  eqeq1i        B  (* A z)  y  mulcan2   sylbi  syl  z  19.22i  syl6
  A  y  z  df-divides    syl6ibr    com12    eqcoms
x  19.22i  sylbi  19.9d  com12
y  19.21ai

(S B)  A  y  df-relprim  sylibr
)

# number 128.5
thm (beta.1.1 () () (relprim (S A) (S (* B (S A))))
  (* B (S A))  x  pa_ax6r
  (S A)  B  mulcom  x  muleq1i
  (S A)  B  x  mulass  eqtr3  x  addeq1i  eqtr

  (* (S (* B (S A))) x)  (+ (* (S A) (* B x)) x)  (S A)  divideseq2  ax-mp
  A  (* B x)  x  dividesadd.1  sylbi  x  gen
  (S (* B (S A)))  (S A)  x  df-relprim  mpbir
  (S (* B (S A)))  A  relprimcom  ax-mp
)

# number 128.6
thm (dividesmul12 () () (-> (| A B) (| (* A C) (* B C)))
  A  B  x  df-divides
    (* A x)  B  C  muleq1
      A  x  C  mulass    x  C  mulcom  (* x C)  (* C x)  A  muleq2  ax-mp  eqtr
      A  C  x  mulass  eqtr4 (* B C)  eqeq1i  sylib
    x  19.22i  sylbi
  (* A C)  (* B C)  x  df-divides  sylibr
)
# number 129.0
## <summary> A development of Godel's Beta Function, following Shoenfield(1967). k=A', z=B', j=C </summary>
thm (beta.1 () () (-> (| (S A) (S B)) (relprim (S (* (+ C (S A)) (S B))) (S (* C (S B)))))
    (* (+ C (S A)) (S B))  x  pa_ax6r
    C  (S A)  (S B)  distl  x  muleq1i  x  addeq1i  eqtr
    (* C (S B))  (* (S A) (S B))  x  distl  x  addeq1i  eqtr
    (* (* C (S B)) x)  (* (* (S A) (S B)) x)  x  addass  (* (* (S A) (S B)) x)  x  addcom  (* (* C (S B)) x)  addeq2i    eqtr   (* (* C (S B)) x)  x  (* (* (S A) (S B)) x)  addass  eqtr4  eqtr
    (* C (S B))  x  pa_ax6r  (* (* (S A) (S B)) x)  addeq1i  eqtr4
    (* (S (* (+ C (S A)) (S B))) x)  (+ (* (S (* C (S B))) x) (* (* (S A) (S B)) x))  (S (* C (S B)))  divideseq2  ax-mp
    (* C (S B))  x  (* (* (S A) (S B)) x)  dividesadd.1    sylbi
    (S A)  (S B)  mulcom  x  muleq1i  (S B)  (S A)  x  mulass  eqtr  (* (* (S A) (S B)) x)  (* (S B) (* (S A) x))  (S (* C (S B)))  divideseq2  ax-mp  sylib

      B  C  beta.1.1  (S B)  (S (* C (S B)))  y  df-relprim  mpbi
        y  (* (S A) x)  (S B)  muleq2    (* (S B) y)  (* (S B) (* (S A) x))  (S (* C (S B)))  divideseq2  syl
  y  (* (S A) x)  (S (* C (S B)))  divideseq2    imbi12d    cla4g    ax-mp   syl
  (S A)  (S B)  x  dividesmul12  anim12i
  (S (* C (S B)))  (* (S A) x)  (* (S B) x)  dividestr  syl
  B  C  beta.1.1  (S B)  (S (* C (S B)))  x  df-relprim  mpbi   a4i  syl
  ex  com12   x  19.21ai

  (S (* (+ C (S A)) (S B))) (S (* C (S B)))  x  df-relprim  sylibr
)

# number 131.0
thm (sucsuc ((A x)) () (<-> (E. x (= A (S (S x)))) (< (1) A))
  x  pa_ax1
  (S x)  eq0le0    biimpri   eqcomd  con3i   ax-mp
  (S x)  (0)  lesuc1     notbii  mpbi
  (S (S x))  (S (0))  lenltt   notbii  mpbi     notnotri
  df-1  (S (S x)) lteq1i  mpbir
  (= A (S (S x)))  id   (1)  lteq2d   mpbiri
  x  19.22i  x  (< (1) A)  ex-nf  syl


     (1)  A  axlttri   (= (1) A)  (< A (1))  ioran  bitri
     A  (1)  nnltp1let
       A  eq0le0   A  (0)  (1)  leadd1    bitri    (1)  pa_ax3r  (+ A (1))  leeq2i  bitri  bitr4i
     notbii
     A  z  lefoo     ori    sylbi
   (-. (= (1) A))  anim2i   sylbi
       z  (0)  (1)  addeq2  (1)  pa_ax3  syl6eq  A  eqeq1d  biimpd  com12  imp  con3i
     (= (+ (1) z) A)  (= z (0))  ianor  sylib   z  19.21ai
     (E. z (= (+ (1) z) A))  anim1i   syl
     z  (\/ (-. (= (+ (1) z) A)) (-. (= z (0))))  (= (+ (1) z) A)  19.29      syl
      (= (+ (1) z) A)  pm3.24     (= (+ (1) z) A)  (-. (= (+ (1) z) A))  ancom  notbii  mpbi
       (-. (= (+ (1) z) A))  (-. (= z (0)))  (= (+ (1) z) A)  andir
       (/\ (-. (= (+ (1) z) A)) (= (+ (1) z) A))  (/\ (-. (= z (0))) (= (+ (1) z) A))  df-or  bitri  biimpi
      mpi
      z  x  lefoo    ori  (= (+ (1) z) A)  anim1i  syl
      x  (= (+ (1) x) z)  (= (+ (1) z) A)  19.41      sylibr
    z  19.22i  syl
      x  a1suc    x  (1)  addcom  eqtr  z  eqeq1i  biimpri    suceqd  eqcomd
      z  a1suc    z  (1)  addcom  eqtr  A  eqeq1i  biimpri    anim12i
      (S z)  (S (S x))  A  ax-eqtr  syl  eqcomd
    x  19.22i  z  19.22i  syl  z  (E. x (= A (S (S x))))  ex-nf  syl

   impbii
)
# number 133.0
## <summary> Like relprimex, but without the class abstraction </summary>
thm (relprimex2 ((A x z) (ps x z) (ph v z)) (h1 (rwff x ph) h2 (rwff v ps))
 (-> (A. x (A. v (-> (/\ ph  ps) (relprim x v))))
     (E. z (/\ (A. x (-> (/\ (< (1) x) (/\ (< x A) ph)) (| x z)))
               (A. v (-> (/\ (< (1) v) ps) (-. (| v z)))))))

h1  abid  h2  abid    anbi12i  (relprim x v) imbi1i  v  albii  x  albii  biimpri
  v  y  ({|} v ps)  ax-eleq1    (e. x ({|} x ph))  anbi2d
  v  y  x  relprimeq2    imbi12d
  alpha
x  albii  sylib

  x  y  ({|} x ph) ({|} v ps)  z  A  relprimex  syl
    y  x   sucsuc  biimpri
      (= x (S (S y)))  id    A  lteq1d
      x  (S (S y))  ({|} x ph)  ax-eleq1    h1  abid     syl5bbr    anbi12d
      x  (S (S y))  z  divideseq1    imbi12d  biimprd
    y  19.22i  syl
    (A. y (-> (/\ (< (S (S y)) A) (e. (S (S y)) ({|} x ph))) (| (S (S y)) z)))  anim2i
    y  (-> (/\ (< (S (S y)) A) (e. (S (S y)) ({|} x ph))) (| (S (S y)) z))  (-> (-> (/\ (< (S (S y)) A) (e. (S (S y)) ({|} x ph))) (| (S (S y)) z)) (-> (/\ (< x A) ph) (| x z)))  19.29    syl
    (-> (/\ (< (S (S y)) A) (e. (S (S y)) ({|} x ph))) (| (S (S y)) z))  (-> (/\ (< x A) ph) (| x z))  pm3.35    y  19.22i  syl
    y  (-> (/\ (< x A) ph) (| x z))  ex-nf  syl
    expimpd
    x  19.21ai

    y  v   sucsuc  biimpri
      v  (S (S y))  ({|} v ps)  ax-eleq1    h2  abid     syl5bbr
      v  (S (S y))  z  divideseq1  notbid   imbi12d  biimprd
    y  19.22i  syl
    (A. y (-> (e. (S (S y)) ({|} v ps)) (-. (| (S (S y)) z))))  anim2i
    y  (-> (e. (S (S y)) ({|} v ps)) (-. (| (S (S y)) z)))  (-> (-> (e. (S (S y)) ({|} v ps)) (-. (| (S (S y)) z))) (-> ps (-. (| v z))))  19.29    syl
    (-> (e. (S (S y)) ({|} v ps)) (-. (| (S (S y)) z)))  (-> ps (-. (| v z)))  pm3.35    y  19.22i  syl
    y  (-> ps (-. (| v z)))  ex-nf  syl
    expimpd
    v  19.21ai

    anim12i
  z  19.22i  syl

)

# number 134.5
thm (beta.2.1 ((A w x y)) ()   (E. w (A. x (A. y (-> (/\ (<= y x) (/\ (-. (= x y)) (/\ (< x A) (< y A))))
                                          (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))))))

  y  x  v df-le
    v  (0)  y  addeq2    y  pa_ax3  syl6eq  x  eqeq1d  biimpd  com12  imp  eqcomd  ex  con3d
    v  z  lefoo   ori    syl6  z  a1suc  (1)  z  addcom eqtr4   v  eqeq1i  z  exbii  syl6ibr
    anc2li  z  (= (+ y v) x)  (= (S z) v)  19.41r  syl6ibr
    (S z) v  y  addeq2  x  eqeq1d  biimprd  com12  imp
    (+ y (S z))  x  (S (S w))  muleq1  suceqd
     (S (* (+ y (S z)) (S (S w))))   (S (* x (S (S w))))  (S (* y (S (S w))))  relprimeq1  syl
      x  A  df-lt  biimpi  pm3.26d     A  y  addge01t   x A  (+ A y)  letr  mpan2    syl
      (= (+ y (S z)) x)  id (+ A y)  leeq1d    biimprd   com12  syl  com12
      y  (S z)  addcom  (+ A y)    leeq1i  syl6ib
      (S z)  A  y  leadd1      syl6ibr
      A  (1)  addge01t  A  a1suc  A  leeq2i  mpbir  (S z)  A  (S A) letr  mpan2   syl6
     jca
    syl
    (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w))))))  (< x A)  (<= (S z) (S A))  anim3    syl
  z  19.22i  syl6    v  19.22i  v  (-> (-. (= x y)) (E. z (-> (< x A) (/\ (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))) (<= (S z) (S A))))))  ex-nf  syl
sylbi
(< x A)  z  (/\ (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))) (<= (S z) (S A)))  imex  syl6ibr
imp imp

(/\ (/\ (<= y x) (-. (= x y))) (< x A))  z  (/\ (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))) (<= (S z) (S A)))  imex  mpbi

y  gen  x  gen  w  gen
  w  z  A  exfactorial
  z (S w)  y  beta.1  (<= (S z) (S A))  imim2i  z  19.20i  y 19.21ai  x  19.21ai    w  19.22i  ax-mp
pm3.2i


w  (A. x (A. y (E. z (-> (/\ (/\ (<= y x) (-. (= x y))) (< x A)) (/\ (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))) (<= (S z) (S A)))))))  (A. x (A. y (A. z (-> (<= (S z) (S A)) (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w)))))))))    19.29     ax-mp

x  (A. y (E. z (-> (/\ (/\ (<= y x) (-. (= x y))) (< x A)) (/\ (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))) (<= (S z) (S A))))))  (A. y (A. z (-> (<= (S z) (S A)) (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))))))  alan12  y  (E. z (-> (/\ (/\ (<= y x) (-. (= x y))) (< x A)) (/\ (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))) (<= (S z) (S A)))))  (A. z (-> (<= (S z) (S A)) (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w)))))))  alan12   x  19.20i  syl  w  19.22i  ax-mp


z  (-> (<= (S z) (S A)) (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))))  (-> (/\ (/\ (<= y x) (-. (= x y))) (< x A)) (/\ (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))) (<= (S z) (S A))))  19.29  ancoms    y  19.20i  x  19.20i  w  19.22i    ax-mp

(-> (<= (S z) (S A)) (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))))  (/\ (/\ (<= y x) (-. (= x y))) (< x A))  (/\ (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))) (<= (S z) (S A)))  anim3

(/\ (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))) (<= (S z) (S A)))  (-> (<= (S z) (S A)) (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))))  ancom  biimpri  (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w))))))  (<= (S z) (S A))  (-> (<= (S z) (S A)) (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))))  anass  sylib  (<= (S z) (S A))  (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w)))))  pm3.35   (<-> (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w))))) (relprim (S (* x (S (S w)))) (S (* y (S (S w))))))  anim2i   syl   (/\ (/\ (<= y x) (-. (= x y))) (< x A))  imim2i  syl

(relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w)))))  (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))  bi1  (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w)))))  anim2i   (relprim (S (* (+ y (S z)) (S (S w)))) (S (* y (S (S w)))))  (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))  pm3.35  syl  ancoms  syl6

z  19.22i

z  (-> (/\ (/\ (<= y x) (-. (= x y))) (< x A)) (relprim (S (* x (S (S w)))) (S (* y (S (S w))))))  ex-nf  syl   y  19.20i  x  19.20i  w  19.22i  ax-mp

(/\ (/\ (<= y x) (-. (= x y))) (< x A))  (< y A)  pm3.26

# To avoid time-travel, we'll use contrapositives...
con3i

(<= y x)  (-. (= x y))  (< x A)  anass  (< y A)  anbi1i  notbii sylib
(<= y x)  (/\ (-. (= x y)) (< x A))  (< y A)  anass  notbii  sylib
(-. (= x y))  (< x A)  (< y A)  anass  (<= y x)  anbi2i  notbii  sylib

con4i

(relprim (S (* x (S (S w)))) (S (* y (S (S w)))))  imim1i  y  19.20i  x  19.20i  w  19.22i  ax-mp
)
# number 135.0
thm (beta.2 ((A w x y)) ()   (E. w (A. x (A. y (->  (/\ (-. (= x y)) (/\ (< x A) (< y A)))
                                          (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))))))


w  x  y  A beta.2.1

(= x z)  id  y  leeq2d    x  z  y  eqeq1  notbid   (= x z)  id   A  lteq1d    (< y A)  anbi1d    anbi12d  anbi12d
x  z  (S (S w)) muleq1   suceqd
(S (* x (S (S w))))  (S (* z (S (S w))))  (S (* y (S (S w))))  relprimeq1 syl  imbi12d
y  19.21ai   y  (-> (/\ (<= y x) (/\ (-. (= x y)) (/\ (< x A) (< y A)))) (relprim (S (* x (S (S w)))) (S (* y (S (S w))))))  (-> (/\ (<= y z) (/\ (-. (= z y)) (/\ (< z A) (< y A)))) (relprim (S (* z (S (S w)))) (S (* y (S (S w))))))  19.15  syl
alpha

(= y x)  id  z  leeq1d   y  x  z  eqeq2  notbid    (= y x)  id  A  lteq1d    (< z A)  anbi2d  anbi12d  anbi12d

y  x  (S (S w)) muleq1   suceqd
(S (* y (S (S w))))  (S (* x (S (S w))))  (S (* z (S (S w))))  relprimeq2 syl  imbi12d
alpha  z  albii  bitri

(= z y)  id  x  leeq2d    z  y  x  eqeq1  notbid   (= z y)  id   A  lteq1d    (< x A)  anbi1d    anbi12d  anbi12d
z  y  (S (S w)) muleq1   suceqd
(S (* z (S (S w))))  (S (* y (S (S w))))  (S (* x (S (S w))))  relprimeq1 syl  imbi12d
x  19.21ai   x  (-> (/\ (<= x z) (/\ (-. (= z x)) (/\ (< z A) (< x A)))) (relprim (S (* z (S (S w)))) (S (* x (S (S w))))))  (-> (/\ (<= x y) (/\ (-. (= y x)) (/\ (< y A) (< x A)))) (relprim (S (* y (S (S w)))) (S (* x (S (S w))))))  19.15  syl
alpha
bitri

y  x  (-> (/\ (<= x y) (/\ (-. (= y x)) (/\ (< y A) (< x A)))) (relprim (S (* y (S (S w)))) (S (* x (S (S w))))))  ax-7  sylbi


(S (* y (S (S w))))  (* x (S (S w)))  relprimcom  (/\ (<= x y) (/\ (-. (= y x)) (/\ (< y A) (< x A))))  imim2i  y  19.20i  x  19.20i  syl

y  x  eqcom  notbii   (< y A)  (< x A)  ancom   anbi12i  (<= x y)  anbi2i  (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))  imbi1i  y  albii  x  albii  sylib

ancri

x  (A. y (-> (/\ (<= x y) (/\ (-. (= x y)) (/\ (< x A) (< y A)))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))))  (A. y (-> (/\ (<= y x) (/\ (-. (= x y)) (/\ (< x A) (< y A)))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))))  alan12  syl

y  (-> (/\ (<= x y) (/\ (-. (= x y)) (/\ (< x A) (< y A)))) (relprim (S (* x (S (S w)))) (S (* y (S (S w))))))  (-> (/\ (<= y x) (/\ (-. (= x y)) (/\ (< x A) (< y A)))) (relprim (S (* x (S (S w)))) (S (* y (S (S w))))))  alan12  x  19.20i  syl



    (<= x y)  (/\ (-. (= x y)) (/\ (< x A) (< y A)))  (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))  impexp    (<= y x)  (/\ (-. (= x y)) (/\ (< x A) (< y A)))  (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))  impexp  anbi12i
      x  y  letot  ori   (-> (/\ (-. (= x y)) (/\ (< x A) (< y A))) (relprim (S (* x (S (S w)))) (S (* y (S (S w))))))  imim1i  (-> (<= x y) (-> (/\ (-. (= x y)) (/\ (< x A) (< y A))) (relprim (S (* x (S (S w)))) (S (* y (S (S w)))))))  anim2i
      (<= x y)  (-> (/\ (-. (= x y)) (/\ (< x A) (< y A))) (relprim (S (* x (S (S w)))) (S (* y (S (S w))))))  pm4.83   biimpi  syl
    sylbi
    y  19.20i  x  19.20i  syl

w  19.22i  ax-mp
)
# number 135.1
thm (beta.2s ((A w x y)) ()   (E. w (A. x (A. y (->  (/\ (-. (= x y)) (/\ (< x A) (< y A)))
                                          (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w)))))))))

  v  (S x)  tyex  x  gen
    z  (S y)  tyex  y gen

pm3.2i
  y  (A. x (E. v (= v (S x))))  (E. z (= z (S y)))  alan1  biimpri   ax-mp
  x  (E. v (= v (S x)))  (E. z (= z (S y)))  alan2  y  albii mpbir
  v  (= v (S x))  z  (= z (S y))  exey  x  19.20i  y  19.20i  ax-mp
   z  (S y)  v  eqeq2  v  (S x)  (S y)  eqeq1  sylan9bb      notbid  ancoms
    (= v (S x))  id  (S A)  lteq1d
     (= z (S y))  id  (S A)  lteq1d  bi2anan9
       A x  lenltt   con2bii  A  x  lesuc1  notbii   (S A)  (S x)  lenltt   con2bii  bitr4i    bitri
       A y  lenltt   con2bii  A  y  lesuc1  notbii   (S A)  (S y)  lenltt   con2bii  bitr4i    bitri  anbi12i
     syl6bbr
   anbi12d
     v  (S x)  (S (S w)) muleq1  suceqd  (S (* v (S (S w)))) (S (* (S x) (S (S w)))) (S (* z (S (S w)))) relprimeq1  syl
     z  (S y)  (S (S w)) muleq1  suceqd  (S (* z (S (S w)))) (S (* (S y) (S (S w)))) (S (* (S x) (S (S w)))) relprimeq2  syl
   sylan9bb
  imbi12d

  z  19.22i  v  19.22i  x  19.20i  y  19.20i  ax-mp
  w  gen

    w  v  z (S A)  beta.2
  pm3.2i

  w  (A. y (A. x (E. v (E. z (<-> (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w)))))) (-> (/\ (-. (= (S x) (S y))) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w)))))))))))  (A. v (A. z (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w))))))))  19.29  ax-mp

  x  (E. v (E. z (<-> (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w)))))) (-> (/\ (-. (= (S x) (S y))) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w)))))))))  (A. v (A. z (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w))))))))  alan2  y  albii  y  (A. x (E. v (E. z (<-> (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w)))))) (-> (/\ (-. (= (S x) (S y))) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w))))))))))  (A. v (A. z (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w))))))))  alan2   bitri  w  exbii  mpbir

 v  (A. z (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w)))))))  (E. z (<-> (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w)))))) (-> (/\ (-. (= (S x) (S y))) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w))))))))  19.29  ancoms  z  (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w))))))  (<-> (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w)))))) (-> (/\ (-. (= (S x) (S y))) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w)))))))  19.29  v  19.22i  syl  x  19.20i  y  19.20i  w  19.22i  ax-mp

  (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w))))))  (-> (/\ (-. (= (S x) (S y))) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w))))))  bi1    (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w))))))  anim2i  (-> (/\ (-. (= v z)) (/\ (< v (S A)) (< z (S A)))) (relprim (S (* v (S (S w)))) (S (* z (S (S w))))))  (-> (/\ (-. (= (S x) (S y))) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w))))))  pm3.35  syl   z 19.22i  v  19.22i  x  19.20i  y  19.20i  w  19.22i  ax-mp

  v  (E. z (-> (/\ (-. (= (S x) (S y))) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w)))))))  ex-nf    z  (-> (/\ (-. (= (S x) (S y))) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w))))))  ex-nf  syl  x  19.20i  y  19.20i  w  19.22i  ax-mp

  x  y  pa_ax2  notbii (/\ (< x A) (< y A))  anbi1i  (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w)))))  imbi1i  biimpri  x  19.20i  y  19.20i  w  19.22i  ax-mp

  y  x  (-> (/\ (-. (= x y)) (/\ (< x A) (< y A))) (relprim (S (* (S x) (S (S w)))) (S (* (S y) (S (S w))))))  ax-7  w  19.22i  ax-mp

)
# number 137.5
thm (beta.3.1 () (
h1 (<-> ph (E. x' (/\ ps (= x (S (* (S x') (S A))))))))
(-> ph (< (1) x))
h1

A  pa_ax1  (S A)  0orpos  ori  con1i    eqcomd  con1i  ax-mp
(1)  (S A)  (S x')  lemul2  ax-mp
x'  pa_ax1  (S x')  0orpos  ori  con1i    eqcomd  con1i  ax-mp
(1)  (S x')  (1)  lemul2  ax-mp
(1)  (S x')  mulcom  (* (1) (1))  leeq2i  mpbi
(* (1) (1))  (* (S x') (1))  (* (S x') (S A))  letr  mpan  ax-mp
(1)  mulid  (* (S x') (S A))  leeq1i  mpbi
(1)  (* (S x') (S A))  lesuc  mpbir

(= x (S (* (S x') (S A))))  id  (1) lteq2d  biimprd  mpi  ps  adantl

x'  19.22i  x'  (< (1) x)  ex-nf  syl

sylbi
)

# number 137.6
thm (lesuc12 () () (<-> (<= A B) (<= (S A) (S B)))
A  B   (1)  leadd1  A  a1suc  (+ B (1)) leeq1i  bitr4i  B  a1suc  (S A)  leeq2i  bitr4i
)

# number 138.0
## <summary> A development of Godel's Beta Function, following Shoenfield(1967). </summary>
thm (beta.3 ((A w x y x' y' z') (B w x y x' y') (ph y z') (ps x z') (S x y x' y')) (
h1 (<-> ph (E. x' (/\ (/\ (<= x' A) (e. x' S))  (= x (S (* (S x') (S (S w))))))))
h2 (<-> ps (E. y' (/\ (/\ (<= y' B) (-. (e. y' S))) (= y (S (* (S y') (S (S w)))))))))
(E. w (E. z' (/\ (A. x (-> ph (| x z'))) (A. y (-> ps (-. (| y z')))))))

  h1  h2  anbi12i  biimpi
  x'  (/\ (/\ (<= x' A) (e. x' S)) (= x (S (* (S x') (S (S w))))))  (E. y' (/\ (/\ (<= y' B) (-. (e. y' S))) (= y (S (* (S y') (S (S w)))))))   19.41  sylibr
  y'  (/\ (/\ (<= y' B) (-. (e. y' S))) (= y (S (* (S y') (S (S w))))))  (/\ (/\ (<= x' A) (e. x' S)) (= x (S (* (S x') (S (S w))))))  19.41  biimpri  ancoms  x'  19.22i  syl

  (/\ (<= y' B) (-. (e. y' S)))  (= y (S (* (S y') (S (S w)))))  (/\ (<= x' A) (e. x' S))  (= x (S (* (S x') (S (S w)))))  an4
  y'  exbii  x'  exbii  sylib


  (<= y' B) (-. (e. y' S)) (<= x' A) (e. x' S)  an4

  B  A  addge01t   (+ B A)  leid  (+ B A)  (+ B A)  lesuc  mpbir    B  (+ B A)  (S (+ B A))  lelttr  mpan2  ax-mp  y'  B  (S (+ B A))  lelttr  mpan2
  A  B addge01t  A  B  addcom  A  leeq2i  mpbi  (+ B A)  leid  (+ B A)  (+ B A)  lesuc  mpbir    A  (+ B A)  (S (+ B A))  lelttr  mpan2  ax-mp  x'  A  (S (+ B A))  lelttr  mpan2  anim12i  ancomd

    (e. x' S)  (e. y' S)  xor    biimpri  orcs
      x'  y'  S  ax-eleq1  con3i   syl       ancoms
    anim12i
  sylbi  ancomd

    y  (S (* (S y') (S (S w))))  x  relprimeq2   x  (S (* (S x') (S (S w))))  (S (* (S y') (S (S w))))  relprimeq1   sylan9bb    biimprd
  anim12i
y'  19.22i  x'  19.22i  syl  y  gen  x  gen  w  gen

###

  w  x'  y'  (S (+ B A))  beta.2s
pm3.2i

w  (A. x (A. y (-> (/\ ph ps) (E. x' (E. y' (/\ (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (-> (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))) (relprim x y)))))))) (A. x' (A. y' (-> (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w)))))))) 19.29    ax-mp

y  (-> (/\ ph ps) (E. x' (E. y' (/\ (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (-> (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))) (relprim x y))))))  (A. x' (A. y' (-> (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))))))  alan2  x  albii  x  (A. y (-> (/\ ph ps) (E. x' (E. y' (/\ (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (-> (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))) (relprim x y)))))))  (A. x' (A. y' (-> (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))))))  alan2    bitri  biimpri  (A. x' (A. y' (-> (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))))))  (/\ ph ps)  (E. x' (E. y' (/\ (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (-> (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))) (relprim x y)))))  anim3  ancoms  y  19.20i  x  19.20i  syl  w  19.22i  ax-mp

x'  (A. y' (-> (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w)))))))  (E. y' (/\ (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (-> (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))) (relprim x y))))  19.29  ancoms  y'  (-> (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))))  (/\ (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (-> (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))) (relprim x y)))  19.29   x'  19.22i  syl ancoms  (/\ ph ps)  imim2i y  19.20i  x  19.20i   w  19.22i  ax-mp

(-> (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A))))) (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))))  (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A)))))  (-> (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))) (relprim x y))  anass  biimpri (/\ (-. (= x' y')) (/\ (< x' (S (+ B A))) (< y' (S (+ B A)))))  (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w)))))  pm3.35  ancoms  (-> (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w))))) (relprim x y))  anim1i   syl  (relprim (S (* (S x') (S (S w)))) (S (* (S y') (S (S w)))))  (relprim x y)  pm3.35  syl

y'  19.22i  x'  19.22i  (/\ ph ps)  imim2i  y  19.20i  x  19.20i w  19.22i  ax-mp

x'  (E. y' (relprim x y))  ex-nf  y'  (relprim x y)  ex-nf    syl  (/\ ph ps) imim2i  y  19.20i  x 19.20i  w 19.22i  ax-mp


   x  v  (S (* (S x') (S (S w))))  eqeq1  (/\ (<= x' A) (e. x' S))  anbi2d  x'  exbid  h1  syl5bb rwffi
   y  v  (S (* (S y') (S (S w))))  eqeq1  (/\ (<= y' B) (-. (e. y' S)))  anbi2d  y'  exbid  h2  syl5bb rwffi

   z'  (S (S (* (S (S w)) (S A))))  relprimex2  w  19.22i
ax-mp

h1  beta.3.1    ancri  (< x (S (S (* (S (S w)) (S A)))))  anim2i  (< x (S (S (* (S (S w)) (S A)))))  (< (1) x)  ph  anass  (< x (S (S (* (S (S w)) (S A)))))  (< (1) x)  ancom  ph  anbi1i  bitr3i  sylib  (< (1) x)  (< x (S (S (* (S (S w)) (S A)))))  ph  anass  sylib  (| x z')  imim1i  x  19.20i

h2  beta.3.1    ancri  (-. (| y z'))  imim1i  y  19.20i

anim12i  z'  19.22i  w  19.22i  ax-mp

h1  biimpi
(<= x' A)  (e. x' S)  (= x (S (* (S x') (S (S w)))))  an23  biimpi  pm3.26d
x'  A  lesuc12
   (S x')  (S A)  (S (S w))  lemul2  sylbi  (S x') (S (S w))  mulcom  (* (S (S w)) (S A))  leeq1i  sylibr  (* (S x') (S (S w)))  (* (S (S w)) (S A))  lesuc12  sylib
     (= x (S (* (S x') (S (S w)))))  id  (S (* (S (S w)) (S A)))  leeq1d  biimprd
   mpan9
  syl
  x'  19.22i  syl  x'  (<= x (S (* (S (S w)) (S A))))  ex-nf  syl
  x  (S (* (S (S w)) (S A)))  lesuc  sylibr


  ancri  (| x z')  imim1i
  x  19.20i  (A. y (-> ps (-. (| y z'))))  anim1i  z'  19.22i  w  19.22i  ax-mp

)
# number 139.5
thm (beta.4.1 ((ph x) (B x) (A x x')) ()  # ph and B contain x' but not x.
  (-> (A. x (-> (E. x' (/\ ph (= x B))) (| x A)))
      (A. x' (-> ph (| B A))))

  x  B  tyex
    (/\ ph (= x B))  x'  19.8a  (| x A)  imim1i
    ph  (= x B)  (| x A)  impexp  biimpi  (= x B)  (| x A)  ancr  syl6  syl
    x  B  A  divideseq1  biimpd  imp  ancoms  syl8
    com13  com23

  x  19.22i  ax-mp
  (E. x (-> (-> (E. x' (/\ ph (= x B))) (| x A)) (-> ph (| B A))))  (A. x (-> (E. x' (/\ ph (= x B))) (| x A)))   pm3.2  ax-mp

  x  (-> (E. x' (/\ ph (= x B))) (| x A))  (-> (-> (E. x' (/\ ph (= x B))) (| x A)) (-> ph (| B A)))  19.29  ancoms  syl

  (-> (E. x' (/\ ph (= x B))) (| x A))  (-> ph (| B A))  pm3.35  x  19.22i  syl
  x  (-> ph (| B A))  ex-nf  syl
  x'  19.21ai
)
# number 139.6
thm (beta.4.2 ((ph x) (B x) (A x x')) ()  # ph and B contain x' but not x.
  (-> (A. x (-> (E. x' (/\ ph (= x B))) (-. (| x A))))
      (A. x' (-> ph (-. (| B A)))))

  x  B  tyex
    (/\ ph (= x B))  x'  19.8a  (-. (| x A))  imim1i
    ph  (= x B)  (-. (| x A))  impexp  biimpi  (= x B)  (-. (| x A))  ancr  syl6  syl
    x  B  A  divideseq1   notbid  biimpd  imp  ancoms  syl8
    com13  com23

  x  19.22i  ax-mp
  (E. x (-> (-> (E. x' (/\ ph (= x B))) (-. (| x A))) (-> ph (-. (| B A)))))  (A. x (-> (E. x' (/\ ph (= x B))) (-. (| x A))))   pm3.2  ax-mp

  x  (-> (E. x' (/\ ph (= x B))) (-. (| x A)))  (-> (-> (E. x' (/\ ph (= x B))) (-. (| x A))) (-> ph (-. (| B A))))  19.29  ancoms  syl

  (-> (E. x' (/\ ph (= x B))) (-. (| x A)))  (-> ph (-. (| B A)))  pm3.35  x  19.22i  syl
  x  (-> ph (-. (| B A)))  ex-nf  syl
  x'  19.21ai
)
# number 140.0
thm (beta.4 ((A x' z) (S x' z)) ()
    (E. z (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (tail z))) (head z))))))

(E. x' (/\ (/\ (<= x' A) (e. x' S))  (= x (S (* (S x') (S (S w)))))))  biid
  (E. y' (/\ (/\ (<= y' A) (-. (e. y' S))) (= y (S (* (S y') (S (S w)))))))  biid
z' beta.3

# exalpha y' -> x'
  (= y' x')  id  A  leeq1d  y'  x'  S  ax-eleq1  notbid anbi12d
  (= y' x')  id  suceqd  (S (S w))  muleq1d  suceqd  y  eqeq2d  anbi12d  exalpha
  (-. (| y z'))  imbi1i  y  albii  (A. x (-> (E. x' (/\ (/\ (<= x' A) (e. x' S)) (= x (S (* (S x') (S (S w))))))) (| x z')))  anbi2i  z'  exbii  w  exbii
mpbi

# alpha y -> x
  y  x  (S (* (S x') (S (S w))))  eqeq1  (/\ (<= x' A) (-. (e. x' S)))  anbi2d  x'  exbid
  y  x  z'  divideseq1  notbid  imbi12d  alpha
  (A. x (-> (E. x' (/\ (/\ (<= x' A) (e. x' S)) (= x (S (* (S x') (S (S w))))))) (| x z')))  anbi2i  z'  exbii  w  exbii
mpbi

# Eliminate dummies
x  x'  (/\ (<= x' A) (e. x' S))  (S (* (S x') (S (S w))))  z'  beta.4.1
x  x'  (/\ (<= x' A) (-. (e. x' S)))  (S (* (S x') (S (S w))))  z'  beta.4.2  anim12i  z'  19.22i  w  19.22i  ax-mp


# Consolidate  quantifiers
  x'  (-> (/\ (<= x' A) (e. x' S)) (| (S (* (S x') (S (S w)))) z'))  (-> (/\ (<= x' A) (-. (e. x' S))) (-. (| (S (* (S x') (S (S w)))) z')))   alan12  z'  19.22i  w  19.22i
ax-mp

  (<= x' A)  (e. x' S)  (| (S (* (S x') (S (S w)))) z')  impexp  biimpi
  (<= x' A)  (-. (e. x' S))  (-. (| (S (* (S x') (S (S w)))) z'))  impexp  biimpi
  anim12i (<= x' A)  (-> (e. x' S) (| (S (* (S x') (S (S w)))) z'))  (-> (-. (e. x' S)) (-. (| (S (* (S x') (S (S w)))) z')))  pm4.76    sylib
  (e. x' S)  (| (S (* (S x') (S (S w)))) z')  ax-3   (-> (e. x' S) (| (S (* (S x') (S (S w)))) z'))  anim2i  syl6
  (e. x' S)  (| (S (* (S x') (S (S w)))) z')  dfbi2    syl6ibr
x'  19.20i  z'  19.22i  w  19.22i  ax-mp

###  Combine w and z' into z
    z  (<,> z' (S (S w))) tyex
      z  (<,> z' (S (S w)))  headeq  z'  (S (S w))  headop  syl6eq
      (head z)  z'  (S (* (S x') (tail z)))  divideseq2  syl
        z  (<,> z' (S (S w)))  taileq  z'  (S (S w))  tailop  syl6eq
        (tail z)  (S (S w))  (S x')  muleq2  syl  suceqd
        (S (* (S x') (tail z)))  (S (* (S x') (S (S w))))  z'  divideseq1  syl
      bitrd
      (e. x' S)  bibi2d  (<= x' A)  imbi2d  biimprd  x'  19.21ai
      x'  (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (S (S w)))) z')))  (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (tail z))) (head z))))  ax-alim  syl
    z  19.22i  ax-mp  z'  gen  w  gen
  pm3.2i

  w  (A. z' (E. z (-> (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (S (S w)))) z')))) (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (tail z))) (head z))))))))  (E. z' (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (S (S w)))) z')))))  19.29  ancoms  z'  (E. z (-> (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (S (S w)))) z')))) (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (tail z))) (head z)))))))  (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (S (S w)))) z'))))  19.29  w  19.22i  syl  ax-mp

  z  (-> (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (S (S w)))) z')))) (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (tail z))) (head z))))))  (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (S (S w)))) z'))))  19.41  biimpri  z'  19.22i  w  19.22i  ax-mp

  (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (S (S w)))) z'))))  (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (tail z))) (head z)))))  pm3.35 ancoms  z  19.22i  z'  19.22i  w  19.22i  ax-mp

  w  (E. z' (E. z (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (tail z))) (head z)))))))  ex-nf  ax-mp

  z'  (E. z (A. x' (-> (<= x' A) (<-> (e. x' S) (| (S (* (S x') (tail z))) (head z))))))  ex-nf  ax-mp
)

## <summary>
##   An ordering theorem on ordered pairs. Note that this breaks the abstraction somewhat,
##   but if necessary we could define a special ordering rather than reusing <=.
## </summary>
thm (leop12 () () (-> (/\ (<= A C) (<= B D)) (<= (<,> A B) (<,> C D)))
  A  C  B   leadd1
  B  D  C   leadd2  anbi12i  (+ A B)  (+ C B)  (+ C D)  letr  sylbi
  (+ A B) (+ C D)  (+ A B)  (+ C D) lemul3     anidms     syl
  (* (+ A B) (+ A B))  (* (+ C D) (+ C D))  B  leadd1  sylib
  B  D  (* (+ C D) (+ C D)) leadd2  biimpi  (<= A C)   adantl  jca
  (+ (* (+ A B) (+ A B)) B)  (+ (* (+ C D) (+ C D)) B)  (+ (* (+ C D) (+ C D)) D)  letr  syl
  A  B  df-op  (+ (* (+ C D) (+ C D)) D)  leeq1i  sylibr
  C  D  df-op  (<,> A B)  leeq2i  sylibr
)

# number 143.0
thm (maxex2 ((A v w) (S v w)) ()
  (-> (fun S)
      (E. v (A. w (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v))))))

S  v  w  A  maxex
  (/\ (< (head w) A) (e. w S))  (<= (tail w) v)  ancr
  (head w)  A  df-lt  biimpi  pm3.26d  (e. w S)  adantr   (<= (tail w) v)  anim2i  syl6
  (head w)  A  (tail w)  v  leop12  ancoms   syl6

    S  w  x  y  df-fun  biimpi  pm3.27d  w  (-> (e. w S) (E. x (E. y (= w (<,> x y)))))  ax-4  syl
      w  (<,> x y)  headeq  x  y  headop  syl6eq    w  (<,> x y)  taileq  x  y  tailop  syl6eq    jca
      (head w)  x  (tail w)  y  opth1  syl  eqcomd  eqcoms  ancri  (<,> x y)  (<,> (head w) (tail w))  w  ax-eqtr  syl  eqcoms
      y  19.22i  x  19.22i  x  (E. y (= (<,> (head w) (tail w)) w))  ex-nf  syl  y  (= (<,> (head w) (tail w)) w)  ex-nf  syl
    syl6
    imp  (<,> A v)  leeq1d  biimpd  ancoms  ex  com13  com23
  syl6

  (< (head w) A)  (e. w S)  (-> (e. w S) (-> (fun S) (<= w (<,> A v))))  impexp   biimpi  (e. w S)  (-> (fun S) (<= w (<,> A v)))  pm2.43    syl6  syl
  imp3a  com23  com12  w  19.21ai
  w  (-> (/\ (< (head w) A) (e. w S)) (<= (tail w) v))  (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v)))  ax-alim  syl
  v  19.21ai  v  (A. w (-> (/\ (< (head w) A) (e. w S)) (<= (tail w) v)))  (A. w (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v))))  19.22  syl
mpd
)



# number 146.0
## <summary>
##   A development of Godel's Beta Function, following Shoenfield(1967).
##   If S is a functional set defining a sequence {S(0), S(1), ..., S(A), ...}:
##   Then there exists a z such that for all x in [0,A], we have:
##   beta(z, x) = S(x).
##   This allows us to encode finite sequences in a quantifiable way,
##   which is necessary to deal with recursive functions.
## </summary>
thm (beta ((S x z) (A x z)) ()
  (-> (fun S)
      (E. z (A. x (-> (< x A) (e. (<,> x (beta z x)) S)))))
     S  v  w  A  maxex2
       z  w  (<,> A v)  S  beta.4
    v  gen  jctil
     v  (E. z (A. w (-> (<= w (<,> A v)) (<-> (e. w S) (| (S (* (S w) (tail z))) (head z))))))  (A. w (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v))))  19.29  syl
     z  (A. w (-> (<= w (<,> A v)) (<-> (e. w S) (| (S (* (S w) (tail z))) (head z)))))  (A. w (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v))))  19.41  v  exbii sylibr
     w  (-> (<= w (<,> A v)) (<-> (e. w S) (| (S (* (S w) (tail z))) (head z))))  (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v)))  alan12  z  19.22i  v  19.22i  syl


  (/\ (< (head w) A) (e. w S))  (<= w (<,> A v))  (<-> (e. w S) (| (S (* (S w) (tail z))) (head z)))
pm3.33    ancoms
  (e. w S)  (| (S (* (S w) (tail z))) (head z))  bi1  (/\ (< (head w) A) (e. w S))  imim2i     (< (head w) A)  (e. w S)  (-> (e. w S) (| (S (* (S w) (tail z))) (head z)))  impexp  biimpi  syl  (e. w S) (| (S (* (S w) (tail z))) (head z))  pm2.43  syl6   syl
  w  19.20i

    w  (<,> x y)  tyex
      w  (<,> x y)  headeq  x  y  headop  syl6eq  A  lteq1d
        w  (<,> x y)  S  ax-eleq1
          (= w (<,> x y))  id  suceqd  (tail z)  muleq1d  suceqd
          (S (* (S w) (tail z)))  (S (* (S (<,> x y)) (tail z)))  (head z)  divideseq1  syl
        imbi12d
      imbi12d  biimpd
    w  19.22i  ax-mp  y  gen  x  gen
  jctir
  x  (A. w (-> (< (head w) A) (-> (e. w S) (| (S (* (S w) (tail z))) (head z)))))
     (A. y (E. w (-> (-> (< (head w) A) (-> (e. w S) (| (S (* (S w) (tail z))) (head z)))) (-> (< x A) (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z))))))) alan1  sylibr
  y  (A. w (-> (< (head w) A) (-> (e. w S) (| (S (* (S w) (tail z))) (head z)))))  (E. w (-> (-> (< (head w) A) (-> (e. w S) (| (S (* (S w) (tail z))) (head z)))) (-> (< x A) (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z))))))  alan1  biimpri  x  19.20i syl

  w  (-> (< (head w) A) (-> (e. w S) (| (S (* (S w) (tail z))) (head z))))  (-> (-> (< (head w) A) (-> (e. w S) (| (S (* (S w) (tail z))) (head z)))) (-> (< x A) (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z)))))  19.29  y  19.20i  x  19.20i    syl
  (-> (< (head w) A) (-> (e. w S) (| (S (* (S w) (tail z))) (head z))))  (-> (< x A) (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z))))  pm3.35  w  19.22i  y  19.20i  x  19.20i  syl
  w  (-> (< x A) (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z))))  ex-nf  y 19.20i x 19.20i syl
  y  (< x A)  (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z)))  ax-alim  (< x A)  y  alnfi  syl5    x  19.20i  syl

    S  x  y  z  df-fun  biimpi  pm3.26d
      y  (e. (<,> x y) S)  euex  x  19.20i  syl
  anim12i
  x  (-> (< x A) (A. y (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z)))))  (E. y (e. (<,> x y) S))  alan12  syl
     (E. y (e. (<,> x y) S))  (< x A)  (A. y (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z))))  anim3   ancoms    y  (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z)))  (e. (<,> x y) S)  19.29   ancoms syl6
  (e. (<,> x y) S)  pm4.24   biimpi  (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z)))  anim2i  (-> (e. (<,> x y) S) (| (S (* (S (<,> x y)) (tail z))) (head z)))  (e. (<,> x y) S)  (e. (<,> x y) S)  anass sylibr

   (e. (<,> x y) S)  (| (S (* (S (<,> x y)) (tail z))) (head z))  pm3.35  ancoms  (e. (<,> x y) S) anim1i  syl

 y  19.22i

syl6  x  19.20i  syl

    w  (<,> x y)  tyex
    (A. w (/\ (-> (<= w (<,> A v)) (<-> (e. w S) (| (S (* (S w) (tail z))) (head z)))) (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v)))
))  (fun S)  pm3.26  (-> (<= w (<,> A v)) (<-> (e. w S) (| (S (* (S w) (tail z))) (head z))))  (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v))) pm3.27  w  19.20i  syl   (E. w (= w (<,> x y)))  biantrurd   biimpd  mpi
    w  (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v)))  (= w (<,> x y))  19.29  syl
      w  (<,> x y)  headeq   x  y  headop  syl6eq  A  lteq1d
      w  (<,> x y)  S  ax-eleq1  anbi12d
      (= w (<,> x y))  id  (<,> A v)  leeq1d    imbi12d  biimpd  com12  imp
    w  19.22i  syl  w  (-> (/\ (< x A) (e. (<,> x y) S)) (<= (<,> x y) (<,> A v)))  ex-nf  syl
    (< x A)  (e. (<,> x y) S) (<= (<,> x y) (<,> A v))  impexp  biimpi  syl
    imp  y  19.21ai  ex  x  19.21ai
  jca
  x  (-> (< x A) (E. y (/\ (| (S (* (S (<,> x y)) (tail z))) (head z)) (e. (<,> x y) S))))  (-> (< x A) (A. y (-> (e. (<,> x y) S) (<= (<,> x y) (<,> A v)))))  alan12  syl
  (< x A)  (E. y (/\ (| (S (* (S (<,> x y)) (tail z))) (head z)) (e. (<,> x y) S)))  (A. y (-> (e. (<,> x y) S) (<= (<,> x y) (<,> A v))))  pm3.43    x  19.20i  syl
    y  (-> (e. (<,> x y) S) (<= (<,> x y) (<,> A v)))  (/\ (| (S (* (S (<,> x y)) (tail z))) (head z)) (e. (<,> x y) S))  19.29  ancoms
    (| (S (* (S (<,> x y)) (tail z))) (head z))  (e. (<,> x y) S)  (-> (e. (<,> x y) S) (<= (<,> x y) (<,> A v)))  anass  (e. (<,> x y) S)  (<= (<,> x y) (<,> A v))  pm3.35  (| (S (* (S (<,> x y)) (tail z))) (head z))  anim2i sylbi  ancoms
  y  19.22i  syl
(< x A)  imim2i  x  19.20i  syl




  y  y'  x  opeq2  suceqd  (tail z)  muleq1d  suceqd   (S (* (S (<,> x y)) (tail z)))  (S (* (S (<,> x y')) (tail z)))  (head z) divideseq1  syl  rwffi  abid  biimpri
  y  ({|} y (| (S (* (S (<,> x y)) (tail z))) (head z)))  minex  syl
    z  x  y df-beta  (beta z x)  (min ({|} y (| (S (* (S (<,> x y)) (tail z))) (head z))))  ({|} y (| (S (* (S (<,> x y)) (tail z))) (head z)))  ax-eleq1  ax-mp
  (<= (min ({|} y (| (S (* (S (<,> x y)) (tail z))) (head z)))) y)  anbi1i  sylibr
  z  x  y df-beta   y  leeq1i  (e. (beta z x) ({|} y (| (S (* (S (<,> x y)) (tail z))) (head z))))  anbi2i  sylibr
    (beta z x)  y (| (S (* (S (<,> x y)) (tail z))) (head z))  ax-elab  (beta z x)  y  (| (S (* (S (<,> x y)) (tail z))) (head z))  sbc5  bitri
    y  (beta z x)  x  opeq2  suceqd  (tail z)  muleq1d  suceqd   (S (* (S (<,> x y)) (tail z)))  (S (* (S (<,> x (beta z x))) (tail z)))  (head z) divideseq1  syl  biimpd  imp  y  19.22i  sylbi  y  (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  ex-nf  syl   (<= (beta z x) y)  anim1i
  syl
  x  leid  x  x  (beta z x)  y  leop12  mpan  (<,> x (beta z x))  (<,> x y)  (<,> A v)  letr  ex  syl  (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  anim2i  syl
  (<= (<,> x y) (<,> A v))  anim1i  (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  (-> (<= (<,> x y) (<,> A v)) (<= (<,> x (beta z x)) (<,> A v)))  (<= (<,> x y) (<,> A v))  anass sylib
  (<= (<,> x y) (<,> A v))  (<= (<,> x (beta z x)) (<,> A v))  pm3.35  ancoms  (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  anim2i  syl
  y  19.22i    y  (/\ (| (S (* (S (<,> x (beta z x))) (tail z))) (head z)) (<= (<,> x (beta z x)) (<,> A v)))  ex-nf syl
(< x A)  imim2i  x  19.20i  syl

  (-> (<= w (<,> A v)) (<-> (e. w S) (| (S (* (S w) (tail z))) (head z))))  (-> (/\ (< (head w) A) (e. w S)) (<= w (<,> A v)))  pm3.26  w  19.20i
    (= w (<,> x (beta z x)))  id  (<,> A v)  leeq1d
      w  (<,> x (beta z x))  S  ax-eleq1
        (= w (<,> x (beta z x)))  id  suceqd  (tail z)  muleq1d  suceqd
        (S (* (S w) (tail z)))  (S (* (S (<,> x (beta z x))) (tail z)))  (head z)  divideseq1  syl
      bibi12d
    imbi12d
    cla4g   x  19.21ai
  syl
  (fun S)  adantr
jca

x  (-> (< x A) (/\ (| (S (* (S (<,> x (beta z x))) (tail z))) (head z)) (<= (<,> x (beta z x)) (<,> A v))))
   (-> (<= (<,> x (beta z x)) (<,> A v)) (<-> (e. (<,> x (beta z x)) S) (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))))  alan12  syl


     (-> (<= (<,> x (beta z x)) (<,> A v)) (<-> (e. (<,> x (beta z x)) S) (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))))  (< x A)  (/\ (| (S (* (S (<,> x (beta z x))) (tail z))) (head z)) (<= (<,> x (beta z x)) (<,> A v))) anim3  ancoms   (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  (<= (<,> x (beta z x)) (<,> A v))  ancom  (-> (<= (<,> x (beta z x)) (<,> A v)) (<-> (e. (<,> x (beta z x)) S) (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))))  anbi2i  syl6ib  (-> (<= (<,> x (beta z x)) (<,> A v)) (<-> (e. (<,> x (beta z x)) S) (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))))  (<= (<,> x (beta z x)) (<,> A v))  (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  anass  syl6ibr  (<= (<,> x (beta z x)) (<,> A v))  (<-> (e. (<,> x (beta z x)) S) (| (S (* (S (<,> x (beta z x))) (tail z))) (head z)))  pm3.35  ancoms   (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  anim1i  syl6   (e. (<,> x (beta z x)) S)  (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  bi2  (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  anim1i  syl6  (| (S (* (S (<,> x (beta z x))) (tail z))) (head z))  (e. (<,> x (beta z x)) S)  pm3.35  ancoms  syl6
   x  19.20i  syl


ex  z  19.22i  v  19.22i  syl

v  (E. z (-> (fun S) (A. x (-> (< x A) (e. (<,> x (beta z x)) S)))))  ex-nf    syl
z  (fun S)  (A. x (-> (< x A) (e. (<,> x (beta z x)) S)))  eximp1  syl
(fun S)  z  alnfi     syl5       pm2.43i


)

# Equality theorem for beta, first argument
thm (betaeq1 () () (-> (= A B) (= (beta A C) (beta B C)))
  A  B  headeq   (head A)  (head B)  (S (* (S (<,> C x)) (tail A)))  divideseq2  syl
   A  B  taileq  (tail A)  (tail B)  (S (<,> C x))  muleq2  syl  suceqd
   (S (* (S (<,> C x)) (tail A)))  (S (* (S (<,> C x)) (tail B)))  (head B)  divideseq1  syl
  bitrd    x  19.21ai
  x (| (S (* (S (<,> C x)) (tail A))) (head A))  (| (S (* (S (<,> C x)) (tail B))) (head B))  abbi2   syl
  ({|} x (| (S (* (S (<,> C x)) (tail A))) (head A)))  ({|} x (| (S (* (S (<,> C x)) (tail B))) (head B)))  minseq    syl


  B  C  x  df-beta    syl6eqr
  A  C  x  df-beta    syl5eq
)

# Equality theorem for beta, second argument
thm (betaeq2 () () (-> (= A B) (= (beta C A) (beta C B)))
  A  B  x  opeq1  suceqd  (tail C)  muleq1d  suceqd
  (S (* (S (<,> A x)) (tail C)))  (S (* (S (<,> B x)) (tail C)))  (head C)  divideseq1  syl
  x  19.21ai
  x  (| (S (* (S (<,> A x)) (tail C))) (head C))  (| (S (* (S (<,> B x)) (tail C))) (head C))  abbi2  syl
  ({|} x (| (S (* (S (<,> A x)) (tail C))) (head C)))  ({|} x (| (S (* (S (<,> B x)) (tail C))) (head C)))  minseq  syl
  C  A  x  df-beta  syl5eq
  C  B  x  df-beta  syl6eqr
)

# number 152.0
thm (recursive.2.1 ((A x)) () (E. x (= (beta x (0)) A))

# The constant map is a function
  w  A  tyeu
   ph  id
    y  (<,> x w)  (<,> z A)  eqeq1  z  exbid  elab
    x  w  z A  opth  z exbii  z  (= x z)  (= w A)  19.41  bitri   bitri
    z  x  tyex   x  z  eqcom  z  exbii  mpbir  mpbiran
    (-> ph ph)  a1i  w  eubid
   ax-mp
  mpbir
  x  gen
    (e. x ({|} y (E. z (= y (<,> z A)))))  v alnfi
    y  x  (<,> z A)  eqeq1  z  exbid  elab  w  z  A  opeq1  x  eqeq2d  exalpha  bitr4i  v  gen  v  (e. x ({|} y (E. z (= y (<,> z A)))))  (E. w (= x (<,> w A)))  19.15  ax-mp  biimpi  syl
    v  A  tyex   v  A  w  opeq2  x  eqeq2d  w  exbid    biimprd   v 19.22i    ax-mp     jctir
    v  (E. w (= x (<,> w A)))  (-> (E. w (= x (<,> w A))) (E. w (= x (<,> w v))))  19.29  syl
    (E. w (= x (<,> w A)))  (E. w (= x (<,> w v)))  pm3.35  v  19.22i  syl
    v  w  (= x (<,> w v))  excom  sylib
    x  gen
  pm3.2i

  ({|} y (E. z (= y (<,> z A))))  x  w  v   df-fun  mpbir

# Apply beta
  ({|} y (E. z (= y (<,> z A))))  x v (S (0)) beta
    v  (0)  tyex
    (0)  leid   (0)  (0)  lesuc   mpbir     (= v (0)) id (S (0)) lteq1d   mpbiri
      v  (0)  x  betaeq2
      (= v (0))  id  jca  ancomd
      v  (beta x v)  (0)  (beta x (0))  opth  sylibr
      (<,> v (beta x v))  (<,> (0) (beta x (0)))  ({|} y (E. z (= y (<,> z A))))  ax-eleq1  syl
      (< v (S (0)))  imbi2d  biimpd
    com23  mpd
    v  19.22i  ax-mp
    x  gen
  jctir
  x  (E. v (-> (-> (< v (S (0))) (e. (<,> v (beta x v)) ({|} y (E. z (= y (<,> z A)))))) (e. (<,> (0) (beta x (0))) ({|} y (E. z (= y (<,> z A)))))))  (A. v (-> (< v (S (0))) (e. (<,> v (beta x v)) ({|} y (E. z (= y (<,> z A)))))))  19.29  ancoms  syl
    v  (-> (< v (S (0))) (e. (<,> v (beta x v)) ({|} y (E. z (= y (<,> z A))))))  (-> (-> (< v (S (0))) (e. (<,> v (beta x v)) ({|} y (E. z (= y (<,> z A)))))) (e. (<,> (0) (beta x (0))) ({|} y (E. z (= y (<,> z A))))))   19.29  ancoms
    (-> (< v (S (0))) (e. (<,> v (beta x v)) ({|} y (E. z (= y (<,> z A))))))  (e. (<,> (0) (beta x (0))) ({|} y (E. z (= y (<,> z A)))))    pm3.35  v  19.22i  syl
  x  19.22i  syl
  v  (e. (<,> (0) (beta x (0))) ({|} y (E. z (= y (<,> z A)))))  ex-nf  x  19.22i  syl

  y  (<,> (0) (beta x (0)))  (<,> z A) eqeq1  (0)  (beta x (0))  z  A  opth    syl6bb  z  exbid    elab  (= (0) z)  (= (beta x (0)) A)  pm3.27  z  19.22i  sylbi  z  (= (beta x (0)) A)  ex-nf  syl  x  19.22i  syl


ax-mp
)

# == Lambda and function application ==

## <summary>
##   Definition of the lambda operator, which creates a functional set from an
##   expression in one variable.
## </summary>
thm (df-lambda-just ((A x x')) ()
  (=_ ({|} x (E. y (= x (<,> y A)))) ({|} x' (E. y (= x' (<,> y A)))))
  x  x'  (<,> y A) eqeq1  y  exbid
#  y  y'  A  opeq1  x'  eqeq2d % exalpha  syl6bb
  abeq
)

defthm  (df-lambda set (lambda y A) ((A x)) ()
        (=_ (lambda y A) ({|} x (E. y (= x (<,> y A)))))
          x' y A x df-lambda-just)

# number 155.5
#!thm (eusbceq ((A x) (B x)) (h1 (rwff y (= x A))) (E! x ([/] B y (= x A)))
#!   x A tyeu x (= x A) z df-eu mpbi
#!   B  y  y  (= x A)  dfsbcq
#!   h1  y (= x A)  df-rwff  mpbi a4i
#!   syl6bbr (= x z) bibi1d x 19.21ai 19.15d z exbid
#!
#!
#!  x ([/] B y (= x A)) z df-eu
#!  syl5bb
#!  mpbiri
#!  eqcoms vtocle
#!)
# number 156.0

## <title> Lambda constructs are functions </title>
thm (funlambda ((A y) (B x)) (h1 (-> (= x y) (= A B))) (fun (lambda x A))
#(A. y (E! v (e. (<,> y v) (lambda x A))))
v  B  tyeu  z eqid
 x  A  w  df-lambda    (<,> y v)  eleq2i
 w  (<,> y v)  (<,> x A)  eqeq1    x  exbid  elab   bitri
 y  v  x  A  opth  x  exbii  bitri
  h1  eqcoms eqcomd v  eqeq2d  biimprd  imp  x  19.22i  x  (= v B)  ex-nf  syl
    x  y  tyex
    h1 eqcoms eqcomd v  eqeq2d  biimpd  com12  ancld  com12  eqcoms  com12 x  19.22d  mpi
  impbii
 bitri     (= z z)  a1i  v eubid  ax-mp
mpbir
v  x  y  opeq2  (<,> y v)  (<,> y x)  (lambda x A)  ax-eleq1  syl  eualpha  mpbi
y gen

    x  A  y  df-lambda    y  eleq2i
    y  y'  (<,> x A) eqeq1  x  exbid  rwffi  abid  bitri  biimpi
    w  A  tyex    w  A  x  opeq2  y  eqeq2d   biimprd  w  19.22i  ax-mp  x  gen  jctil
    x  (E. w (-> (= y (<,> x A)) (= y (<,> x w))))  (= y (<,> x A))  19.29   syl
    w  (-> (= y (<,> x A)) (= y (<,> x w)))  (= y (<,> x A))   19.41  x  exbii  sylibr
    (= y (<,> x A))  (= y (<,> x w))  pm3.35  ancoms  w  19.22i  x  19.22i  syl
    y  gen
  pm3.2i

  (lambda x A)  y  x  w  df-fun  mpbir
)

# number 156.5
thm (piecewisefun.1 ((A x) (S x) (T x)) () (<-> (e. A ({|} x (\/ (/\ ([/] (head x) x ph)  (e. x S)) (/\ (-. ([/] (head x) x ph)) (e. x T))))
) (\/ (/\ ([/] (head A) x ph)  (e. A S)) (/\ (-. ([/] (head A) x ph)) (e. A T))))
x  A  S  ax-eleq1  ([/] (head x) x ph)  anbi2d
  x  A  T  ax-eleq1  (-. ([/] (head x) x ph))  anbi2d
orbi12d
  x  A  headeq
  (head x)  (head A)  x  ph  dfsbcq  syl
  (e. A S) anbi1d
    x  A  headeq
    (head x)  (head A)  x  ph  dfsbcq  syl  notbid
    (e. A T) anbi1d
  orbi12d
bitrd
elab
)

# number 157.0
## <summary>
##   Given two functions S, T and a discriminator ph, we can assemble a piecewise
##   function which mimics S when ph is true and T otherwise.
## </summary>
thm (piecewisefun ((S x') (T x')) () (-> (/\ (fun S) (fun T)) (fun ({|} x' (\/ (/\ ([/] (head x') x' ph)  (e. x' S))
                                                                         (/\ (-. ([/] (head x') x' ph)) (e. x' T))))))

([/] x x' ph)  exmid
  x  y  headop    (head (<,> x y))  x  x' ph  dfsbcq  ax-mp  bicomi
    ([/] (head (<,> x y)) x' ph)   (e. (<,> x y) S)   ibar  (/\ (-. ([/] (head (<,> x y)) x' ph)) (e. (<,> x y) T)) orbi1d
      (-. ([/] (head (<,> x y)) x' ph))  (e. (<,> x y) T)  pm3.26  con2i    (-. (/\ (-. ([/] (head (<,> x y)) x' ph)) (e. (<,> x y) T)))  (e. (<,> x y) S)  pm5.5    syl
        (/\ (-. ([/] (head (<,> x y)) x' ph)) (e. (<,> x y) T))  (e. (<,> x y) S)  df-or  (/\ (-. ([/] (head (<,> x y)) x' ph)) (e. (<,> x y) T))  (e. (<,> x y) S)  orcom  bitr3i
      syl5bbr
    bitr3d
      (<,> x y) x' ph S T piecewisefun.1
    syl5bb
   sylbi  y  eubid
   S  x  y  z  df-fun  biimpi  pm3.26d  x  (E! y (e. (<,> x y) S))  ax-4  syl     syl5bir

     x  y  headop    (head (<,> x y))  x  x' ph  dfsbcq  ax-mp  notbii bicomi
       (-. ([/] (head (<,> x y)) x' ph))   (e. (<,> x y) T)   ibar  (/\ ([/] (head (<,> x y)) x' ph) (e. (<,> x y) S)) orbi1d
         ([/] (head (<,> x y)) x' ph)  (e. (<,> x y) S)  pm3.26  con3i    (-. (/\ ([/] (head (<,> x y)) x' ph) (e. (<,> x y) S)))  (e. (<,> x y) T)  pm5.5    syl
           (/\ ([/] (head (<,> x y)) x' ph) (e. (<,> x y) S))  (e. (<,> x y) T)  df-or  (/\ ([/] (head (<,> x y)) x' ph) (e. (<,> x y) S))  (e. (<,> x y) T)  orcom  bitr3i
         syl5bbr
       bitr3d
       (/\ ([/] (head (<,> x y)) x' ph) (e. (<,> x y) S))  (/\ (-. ([/] (head (<,> x y)) x' ph)) (e. (<,> x y) T))  orcom  syl5bb
         (<,> x y) x' ph S T piecewisefun.1
       syl5bb
      sylbi  y  eubid
    T  x  y  z  df-fun  biimpi  pm3.26d  x  (E! y (e. (<,> x y) T))  ax-4  syl     syl5bir
  jaoa
ax-mp
x  19.21ai


x x' ph S T piecewisefun.1   biimpi
  ([/] (head x) x' ph)  (e. x S)  pm3.27  (-. ([/] (head x) x' ph))  (e. x T)  pm3.27  orim12i  syl
  S  x  y  z  df-fun  biimpi  pm3.27d  x  (-> (e. x S) (E. y (E. z (= x (<,> y z)))))  ax-4  syl
    T  x  y  z  df-fun  biimpi  pm3.27d  x  (-> (e. x T) (E. y (E. z (= x (<,> y z)))))  ax-4  syl
  jaao
mpan9    ancoms  ex   x  19.21ai

  ({|} x' (\/ (/\ ([/] (head x') x' ph)  (e. x' S))  (/\ (-. ([/] (head x') x' ph)) (e. x' T))))  x  y  z  df-fun  biimpri
ex  com12  syl


mpd

)
# number 157.5
## <summary>
##   Definition of "apply" to apply a function (reperesented by a set S) to an
##   input.
## </summary>
thm (df-apply-just ((A y) (S y) (A z) (S z)) ()
  (= (iota ({|} z (e. (<,> A z) S)))
     (iota ({|} y (e. (<,> A y) S))))
   z  y  A  opeq2     (<,> A z)  (<,> A y)  S  ax-eleq1    syl   abeq     ({|} z (e. (<,> A z) S))  ({|} y (e. (<,> A y) S))  ax-iotaeq    ax-mp)

# Definition of function application
defthm  (df-apply nat (apply S A) ( (A z) (S z)) ()
  (= (apply S A) (iota ({|} z (e. (<,> A z) S))))
  y A S z df-apply-just)

## <title> Equivalence for apply </title> ##
thm (applyseq1 () () (-> (=_ S T) (= (apply S A) (apply T A)))
  S T (<,> A z) eleq2
  z abbi2d
  iotaseqd
  S A z df-apply  
  ## <d 'Symmetric Property '>
    (apply S A) (iota ({|} z (e. (<,> A z) S))) eqcom
    mpbi
  ## </d 'Symmetric Property '>
  EqReplaceImp1Eq0
  T A z df-apply    
  ## <d 'Symmetric Property '>
    (apply T A) (iota ({|} z (e. (<,> A z) T))) eqcom
    mpbi
  ## </d 'Symmetric Property '>
  EqReplaceImp1Eq1
)

thm (applyseq1i () (
     hyp1 (=_ S T))
     (= (apply S A) (apply T A))
  hyp1
  S T A applyseq1
  ax-mp
)

thm (applyseq1d () (
     hyp1 (-> ph (=_ S T)))
     (-> ph (= (apply S A) (apply T A)))
  hyp1
  S T A applyseq1
  syl
)

## <title> Equivalence for apply </title> ##
thm (applyeq2 () () (-> (= A B) (= (apply S A) (apply S B)))
  A B z opeq1
  S eleq1d
  z abbi2d
  iotaseqd
  S A z df-apply
  ## <d 'Commutative Property'>
    (apply S A) (iota ({|} z (e. (<,> A z) S))) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq0
  S B z df-apply
  ## <d 'Commutative Property'>
    (apply S B) (iota ({|} z (e. (<,> B z) S))) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq1
)


thm (applyeq2i () (
     hyp1 (= A B))
     (= (apply S A) (apply S B))
  hyp1
  A B S applyeq2
  ax-mp
)

thm (applyeq2d () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (apply S A) (apply S B)))
  hyp1
  A B S applyeq2
  syl
)

# Equality identity for fun
thm (funseq () () (-> (=_ S T) (<-> (fun S) (fun T)))
  S  T  (<,> x y)  eleq2  y eubid
  x  19.21ai  x  (E! y (e. (<,> x y) S))  (E! y (e. (<,> x y) T)) 19.15  syl
    S  T  x  eleq2  (E. y (E. z (= x (<,> y z))))  imbi1d
    x  19.21ai  x  (-> (e. x S) (E. y (E. z (= x (<,> y z)))))  (-> (e. x T) (E. y (E. z (= x (<,> y z)))))  19.15  syl
  anbi12d
  S  x  y  z  df-fun  syl5bb
  T  x  y  z  df-fun  syl6bbr
)
thm (funseqi () (
     hyp1 (=_ S T))
     (<-> (fun S) (fun T))
  hyp1
  S T funseq
  ax-mp
)

thm (funseqd () (
     hyp1 (-> ph (=_ S T)))
     (-> ph (<-> (fun S) (fun T)))
  hyp1
  S T funseq
  syl
)

## <summary> Asserts that membership in functional set of a lambda works the way you'd expect. </summary>
thm (ellambda ((A y) (B y) (C x)) (h1 (-> (= x y) (= B C)))
     (<-> (e. (<,> x A) (lambda x B)) (= A B))
  x  B  z  df-lambda  (<,> x A) eleq2i
    h1  B  C  x  opeq2  syl  z  eqeq2d
    x  y  C  opeq1  z  eqeq2d  bitrd  exalpha
    z  gen  z  (E. x (= z (<,> x B)))  (E. y (= z (<,> y C)))  abbi2  ax-mp
  (<,> x A)  eleq2i  bitri
  z  (<,> x A)  (<,> y C)  eqeq1  y  exbid  elab  bitri
    x  A  y  C  opth  y  exbii bitri
      h1  (= A C)  anim1i
        C  B  A ax-eqtr  ex  eqcoms  com12  eqcoms  com12  imp  syl  y  19.22i  y  (= B A)  ex-nf  syl
          y  x  tyex  h1     ancli    eqcoms
        B  A  C ax-eqtr  ex  (= x y)  anim2d   mpan9    ancoms  ex  y  19.22d  mpi
      impbii
    bitri
  B  A  eqcom  bitri
)

# number 159.5
## <summary> apply actually works (assuming S is a function). </summary>
thm (funapply () () (-> (fun S) (e. (<,> A (apply S A)) S))
#      y  x  (e. (<,> A x) S)  ax-elab
  S  w  x  z  df-fun  biimpi     pm3.26d
  w  (E! x (e. (<,> w x) S))  A  a4sbc    syl
  w  A  x  opeq1    (<,> w x)  (<,> A x)  S  ax-eleq1  syl  x  eubid    sbcie   sylib
  x  (e. (<,> A x) S)   iotacl2  syl
  S  A  x  df-apply  (apply S A)  (iota ({|} x (e. (<,> A x) S)))  ({|} x (e. (<,> A x) S))  ax-eleq1  ax-mp  sylibr
  (apply S A)  x  (e. (<,> A x) S)  ax-elab    sylib
    x  (apply S A)  A  opeq2   (<,> A x)  (<,> A (apply S A))  S  ax-eleq1  syl
  sbcie  sylib
)

thm (applylambda.1 ((B x) (A y)) (hyp (-> (= x y) (= A B))) (= (apply (lambda x A) x) A)
  hyp funlambda
  (lambda x A) x funapply
  ax-mp
  hyp
  (apply (lambda x A) x) ellambda    
  mpbi
)

thm (applylambda.2 ((B x) (A y)) (hyp (-> (= x y) (= A B))) (-> (= x C) (= (apply (lambda x A) C) A))
  x C (lambda x A) applyeq2
  A eqeq1d
  hyp
  applylambda.1
  (= (apply (lambda x A) C) A) biRemove1
  (= x C) imbi2i
  mpbi
)

## <title> Apply the function </title>
thm (applylambda ((D x) (A x) (C x) (B y)) (hyp (-> (= x y) (= B D)) hyp2 (-> (= x A) (= B C))) (= (apply (lambda x B) A) C)
  hyp
  A applylambda.2
  hyp2
  eqtrd
  vtocle
)

## <title> Apply a constant function </title>
thm (applylambdaconst ((A x) (B x)) () (= (apply (lambda x A) B) A)
  A eqid (= x y) a1i
  A eqid (= x B) a1i
  applylambda
)

## <title> Apply the identity function </title>
thm (applyfunid ((A x)) () (= (apply (lambda x x) A) A)
  (= x y) id
  (= x A) id
  applylambda
)

# First equality identity for lambda.
thm (lambdaeq1 ((A y) (B x)) (h1 (-> (= x y) (= A B)))
  (=_ (lambda x A) (lambda y B))
 x eqid
  x  A  z  df-lambda
  (= x x) a1i
    h1    A  B  x  opeq2    syl
    x  y  B  opeq1    eqtrd
    z  eqeq2d
    exalpha    bicomi
    z  gen
      z  (E. y (= z (<,> y B)))  (E. x (= z (<,> x A)))  abbi2
    ax-mp
  syl6seqr
    y  B  z  df-lambda
  syl6seqr
 ax-mp
)

# Second equality identity for lambda
thm (lambdaeq2 () () (-> (A. x (= A B)) (=_ (lambda x A) (lambda x B)))
    A  B  x  opeq2    y  eqeq2d    x  19.20i
    x  (= y (<,> x A))  (= y (<,> x B))  19.18    syl
    y  19.21ai
    y  (E. x (= y (<,> x A)))  (E. x (= y (<,> x B)))  abbi2    syl
    x  B  y  df-lambda    syl6seqr
    ({|} y (E. x (= y (<,> x A))))  (lambda x B)  seqcom   sylib
    x  A  y  df-lambda    syl6seqr
    (lambda x B)  (lambda x A)  seqcom    sylib
)

thm (lambdaeq2i () (
     hyp1 (A. x (= B C)))
     (=_ (lambda x B) (lambda x C))
  hyp1
  x B C lambdaeq2
  ax-mp
)

thm (lambdaeq2d () (
     hyp1 (-> ph (A. x (= B C))))
     (-> ph (=_ (lambda x B) (lambda x C)))
  hyp1
  x B C lambdaeq2
  syl
)

# == Recursive functions ==

# Definition of recursion, using a predicate.
# (recursep S A B C) will mean that S^A(B) = C
thm (df-recursep-just ( (A y) (S y) (A x) (S x) (A z) (C z) (B z) (S z) (A w) (C w) (B w) (S w)) ()
  (<-> (E. z (/\ (= (beta z (0)) B) (/\ (= (beta z A) C)
                    (A. y (-> (< y A) (e. (<,> (beta z y) (beta z (S y))) S))))))
       (E. w (/\ (= (beta w (0)) B) (/\ (= (beta w A) C)
                    (A. x (-> (< x A) (e. (<,> (beta w x) (beta w (S x))) S)))))))
  z  w  (0)  betaeq1  B  eqeq1d
    z  w  A  betaeq1  C  eqeq1d
      z  w  y  betaeq1   (beta z y)  (beta w y)  (beta z (S y))  opeq1  syl
      z  w  (S y)  betaeq1  (beta z (S y))  (beta w (S y))  (beta w y)  opeq2  syl   eqtrd
      (<,> (beta z y) (beta z (S y)))  (<,> (beta w y) (beta w (S y)))  S  ax-eleq1  syl
      (< y A)  imbi2d     y  19.21ai    19.15d
       (= y x)  id  A  lteq1d
        y  x  w  betaeq2   (beta w y)  (beta w x)  (beta w (S y))  opeq1  syl
        y  x  pa_ax2  biimpi    (S y)  (S x)  w  betaeq2  syl    (beta w (S y))  (beta w (S x))  (beta w x)  opeq2  syl   eqtrd
        (<,> (beta w y) (beta w (S y)))  (<,> (beta w x) (beta w (S x)))  S  ax-eleq1    syl
       imbi12d  alpha
     syl6bb
   anbi12d
  anbi12d
exalpha)

## <title> Definition of Recursive Predicate </title>
## <suggest> right('Define', 'rec') left('Simplify', 'rec') </suggest>
defthm  (df-recursep wff (recursep S A B C) ((A y) (S y) (A z) (S z) (B z) (C z)) ()
  (<-> (recursep S A B C)  (E. z (/\ (= (beta z (0)) B) (/\ (= (beta z A) C)
                    (A. y (-> (< y A) (e. (<,> (beta z y) (beta z (S y))) S)))))))
  w B A C x S z y df-recursep-just)

# number 157.7
# Fourth equality identity for recursep.
thm (recursepeq4 () () (-> (= A B) (<-> (recursep S C D A) (recursep S C D B)))
  A  B  (beta x C)  eqeq2  (A. y (-> (< y C) (e. (<,> (beta x y) (beta x (S y))) S)))  anbi1d  (= (beta x (0)) D)  anbi2d  x  exbid
    S  C  D  A  x  y  df-recursep
  syl5bb
    S  C  D  B  x  y  df-recursep
  syl6bbr
)

# number 160.0
thm (recursive.3.1 ((A y) (ph y) (S y) (A z) (C z) (B z) (S z) (A v) (S v) (B v) (C v) (C y))
(h2 (<-> ph (/\ (A. y (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))))  (/\ (= (beta v (0)) B) (/\ (= (beta v A) C) (A. y (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S))))))))
(-> (fun S)
  (->  (recursep S  A  B  C)
       (recursep S (S A) B (apply S C))))

S  A  B  C  v  y  df-recursep  biimpi


  y  y'  v  betaeq2  funlambda
    (apply S C)  eqid  (= y y') a1i  funlambda
      (lambda y (beta v y))  (lambda y (apply S C))  x (<= x A) piecewisefun
        ({|} x (\/ (/\ ([/] (head x) x (<= x A)) (e. x (lambda y (beta v y)))) (/\ (-. ([/] (head x) x (<= x A))) (e. x (lambda y (apply S C))))))  seqid
        ({|} x (\/ (/\ ([/] (head x) x (<= x A)) (e. x (lambda y (beta v y)))) (/\ (-. ([/] (head x) x (<= x A))) (e. x (lambda y (apply S C))))))  ({|} x (\/ (/\ ([/] (head x) x (<= x A)) (e. x (lambda y (beta v y)))) (/\ (-. ([/] (head x) x (<= x A))) (e. x (lambda y (apply S C))))))  funseq  ax-mp
      sylibr
    mpan2
  ax-mp
({|} x (\/ (/\ ([/] (head x) x (<= x A)) (e. x (lambda y (beta v y)))) (/\ (-. ([/] (head x) x (<= x A))) (e. x (lambda y (apply S C))))))  z  y  (S (S A))  beta  ax-mp

  (<,> y (beta z y))  x  headeq  (head (<,> y (beta z y))) (head x) x  (<= x A) dfsbcq    syl
  (<,> y (beta z y))  x  (lambda y (beta v y))  ax-eleq1   anbi12d
      (<,> y (beta z y))  x  headeq  (head (<,> y (beta z y))) (head x) x  (<= x A) dfsbcq    syl  notbid
      (<,> y (beta z y))  x  (lambda y (apply S C))  ax-eleq1   anbi12d
  orbi12d
  eqcoms  bicomd
          ({|} x (\/ (/\ ([/] (head x) x (<= x A)) (e. x (lambda y (beta v y)))) (/\ (-. ([/] (head x) x (<= x A))) (e. x (lambda y (apply S C))))))  seqid
  elab2
    y  (beta z y)  headop  (head (<,> y (beta z y)))  y  x (<= x A)  dfsbcq  ax-mp
    (= x y)  id  A  leeq1d  sbcie  bitri
      y  y'  v  betaeq2  (beta z y) ellambda
    anbi12i
      y  (beta z y)  headop  (head (<,> y (beta z y)))  y  x (<= x A)  dfsbcq  ax-mp
      (= x y)  id  A  leeq1d  sbcie  bitri  notbii
        (apply S C)  eqid (= y y')  a1i  (beta z y)  ellambda
      anbi12i
    orbi12i
  bitri
(< y (S (S A)))  imbi2i  y  albii  z  exbii  mpbi

   y  (S A)  lesuc
      y  A lenltt   con2bii     A  y  nnltp1let  bitr3i   A  a1suc  y  leeq1i  bitr4i  (= (beta z y) (apply S C)) anbi1i  (/\ (<= y A) (= (beta z y) (beta v y)))  orbi2i
   imbi12i
  y  (S A)  lesym    biimpri  ex  (= (beta z y) (apply S C))  anim1d  (/\ (<= y A) (= (beta z y) (beta v y)))  orim2d  a2i
  sylbi
 y  19.20i  z  19.22i  ax-mp
 v  gen
jctil

v  (E. z (A. y (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C)))))))  (/\ (= (beta v (0)) B) (/\ (= (beta v A) C) (A. y (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S)))))  19.29    syl

z  (A. y (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))))  (/\ (= (beta v (0)) B) (/\ (= (beta v A) C) (A. y (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S)))))  19.41    biimpri  v  19.22i    syl

# For cleanliness and my own sanity, I'm using h2 to store this big predicate in phi.
h2    z  exbii  v  exbii  sylibr

# Phi has everything we need to assert the viability of z for proving (recursep S A' B (apply S C)).
# To reassemble this assertion, we'll go step by step.
# 1. Prove phi -> beta z 0 = B
# 2. Prove phi -> beta z A' = (apply S C)
# 3. Prove phi -> (A. y y<A' -> <beta z y, beta z y'> e. S)
# 4. Join it all together and clean up the quantifiers.

# Step 1.
h2  biimpi
  (A. y (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))))  (= (beta v (0)) B)  (/\ (= (beta v A) C) (A. y (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S))))  anass  sylibr
  pm3.26d
    (= y (0))  id  (S A)  leeq1d
      (= y (0))  id  A  leeq1d
        y  (0)  z  betaeq2    y  (0)  v  betaeq2  eqeq12d
      anbi12d
        y  (0)  (S A)  eqeq1
          y  (0)  z  betaeq2    (apply S C)  eqeq1d
        anbi12d
      orbi12d
    imbi12d
  cla4g
  (= (beta v (0)) B)  anim1i
syl
  A  pa_ax1    (= (0) (S A))  (= (beta z (0)) (apply S C))  pm3.26    con3i    ax-mp
  (/\ (= (0) (S A)) (= (beta z (0)) (apply S C)))  (/\ (<= (0) A) (= (beta z (0)) (beta v (0))))  orel2   ax-mp
  (<= (0) (S A))  imim2i  (= (beta v (0)) B)  anim1i
syl
  (0)  (S A)  addge01t     (S A)  pa_ax3r    (0) leeq2i  mpbi     (<= (0) (S A))  (/\ (<= (0) A) (= (beta z (0)) (beta v (0))))  pm2.27    ax-mp    (= (beta v (0)) B)   anim1i
syl
(<= (0) A)  (= (beta z (0)) (beta v (0)))  (= (beta v (0)) B)  anass    sylib
pm3.27d
  (beta v (0))  B  (beta z (0))  ax-eqtr  ancoms  (beta v (0))  (beta z (0))  eqcom  (= (beta v (0)) B)  anbi1i    (= B (beta z (0)))  imbi1i   mpbi
syl  eqcomd
(fun S)  adantl


# Step 2: phi -> beta z A' = (apply S C)
h2  biimpi  pm3.26d
    (= y (S A))  id  (S A)  leeq1d
      (= y (S A))  id  A  leeq1d
        y  (S A)  z  betaeq2    y  (S A)  v  betaeq2  eqeq12d
      anbi12d
        y  (S A)  (S A)  eqeq1
          y  (S A)  z  betaeq2    (apply S C)  eqeq1d
        anbi12d
      orbi12d
    imbi12d
  cla4g
syl

(S A)  leid   (<= (S A) (S A))  (\/ (/\ (<= (S A) A) (= (beta z (S A)) (beta v (S A)))) (/\ (= (S A) (S A)) (= (beta z (S A)) (apply S C))))  pm2.27    ax-mp    syl

A  leid    A  A  lesuc  mpbir   (S A)  A  lenltt    biimpi    con2i  ax-mp    (-. (= (beta z (S A)) (beta v (S A))))  orci  (<= (S A) A)  (= (beta z (S A)) (beta v (S A)))  pm3.14   ax-mp    (/\ (<= (S A) A) (= (beta z (S A)) (beta v (S A))))  (/\ (= (S A) (S A)) (= (beta z (S A)) (apply S C)))  orel1  ax-mp    syl

pm3.27d  (fun S)  adantl

# Step 3, the hard one: phi -> (A. y y<A' -> <beta z y, beta z y'> e. S)
# We'll do this in two steps.  Case 3a: y = A, and Case 3b: y < A
h2  biimpi

# scrub unneeded clauses
(= (beta v A) C)  (A. y (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S)))  pm3.26  (= (beta v (0)) B)  adantl   (A. y (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))))  anim2i  syl

# move quantifier up
y  (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C)))))  (= (beta v A) C)  alan2   biimpri   syl
# lemme just stick this here for later
 S  C  funapply

# collapse case clause for y=A to prove (beta z y) = C
  A  (1)  addge01t    A  a1suc    A  leeq2i  mpbir   (= y A)  id   (S A)  leeq1d   biimprd   mpi    (<= y (S A))  (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))   pm2.27  syl
    0ne1  A  (0)  (1)  addcan2  A  pa_ax3  (+ A (1)) eqeq1i   bitr3i   A  a1suc   A  eqeq2i  bitr4i  notbii  mpbi
    y  A  (S A)  eqeq1  biimpd   con3d    mpi
    (-. (= (beta z y) (apply S C)))  orcd  (= y (S A))  (= (beta z y) (apply S C))  pm3.14  syl   (/\ (= y (S A)) (= (beta z y) (apply S C)))  (/\ (<= y A) (= (beta z y) (beta v y)))  orel2  syl
  syld
  (= (beta v A) C)  anim1d
  (<= y A)  (= (beta z y) (beta v y))  pm3.27  (= (beta v A) C)  anim1i  syl6
  y  A  v  betaeq2   (beta z y)   eqeq2d  (beta z y)  (beta v A)  eqcom  syl6bb    (= (beta v A) C)  anbi1d    biimpd  (beta v A)  (beta z y)  C  ax-eqtr  syl6  syld
com12  y  19.20i
y  (-> (= y A) (= (beta z y) C))  ax-4    syl
# Now to prove that y=A also implies (beta z y') = (apply S C).
# Need to up the index by one.  alpha-switch y to x, then substitute (S y) in for x.

  (= y x)  id  (S A)  leeq1d
    (= y x)  id  A  leeq1d
      y  x  z  betaeq2    y  x  v  betaeq2  eqeq12d
    anbi12d
      y  x  (S A)  eqeq1
        y  x  z  betaeq2    (apply S C)  eqeq1d
      anbi12d
    orbi12d
  imbi12d
  (= (beta v A) C)  anbi1d
  alpha  biimpi

    (= x (S y))  id  (S A)  leeq1d
      (= x (S y))  id  A  leeq1d
        x  (S y)  z  betaeq2    x  (S y)  v  betaeq2  eqeq12d
      anbi12d
        x  (S y)  (S A)  eqeq1
          x  (S y)  z  betaeq2    (apply S C)  eqeq1d
        anbi12d
      orbi12d
    imbi12d
    (= (beta v A) C)  anbi1d
    cla4g
  syl
  pm3.26d
# remove bounding guard
  (S A)   leid  y  A  pa_ax2  biimpi    (S A)  leeq1d    mpbiri    (<= (S y) (S A))  (\/ (/\ (<= (S y) A) (= (beta z (S y)) (beta v (S y)))) (/\ (= (S y) (S A)) (= (beta z (S y)) (apply S C))))  pm2.27    syl   com12    syl
# collapse case clause again
    A  leid    A  A  lesuc  mpbir   (S A)  A  lenltt    biimpi    con2i    ax-mp
    y  A  pa_ax2  biimpi    A  leeq1d    notbid    mpbiri
    (-. (= (beta z (S y)) (beta v (S y))))  orcd  (<= (S y) A)  (= (beta z (S y)) (beta v (S y)))  pm3.14   syl  (/\ (<= (S y) A) (= (beta z (S y)) (beta v (S y))))  (/\ (= (S y) (S A)) (= (beta z (S y)) (apply S C)))  orel1  syl
  a2i    syl
  imp    pm3.27d    ex
# Join up the y and the y' case to get the OP
jcad
# too lazy to go prove opeq12
 (beta z y)  C  (beta z (S y))  opeq1    eqcomd    (beta z (S y))  (apply S C)  C  opeq2    anim12i    (<,> C (beta z (S y)))  (<,> (beta z y) (beta z (S y)))  (<,> C (apply S C))    ax-eqtr   syl    syl6
 (<,> (beta z y) (beta z (S y)))  (<,> C (apply S C))  S  ax-eleq1  syl6
# it's later
imp  biimprd   mpan9    ex  exp3a  com12   syl    imp
#### Finally done with case 3a!

# Now, case 3b, y < A.  Proceeds similarly at first.
h2  biimpi

# scrub unneeded clauses
(= (beta v (0)) B)  (/\ (= (beta v A) C) (A. y (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S))))  pm3.27    (= (beta v A) C)  (A. y (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S)))  pm3.27    syl    (A. y (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))))  anim2i    syl

# Join quantifiers
y  (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C)))))  (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S))  alan12   syl

# Drop quantifier for y=y.
y  (/\ (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))) (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S)))  ax-4    syl

# unite common assertion.
  # must be easier way to prove y<A -> y <= A'.... need more coffee?
  A  leid    A  A  lesuc    mpbir
  y  A  df-lt    biimpi    pm3.26d    y  A  (S A)  lelttr    ex    syl   mpi
  y  (S A)  df-lt    sylib    pm3.26d
  # continually sloppy but getting the job done
  (<= y (S A))  (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))  pm2.27    syl   com12    (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S))  anim1i    syl
  (< y A)  (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))  (e. (<,> (beta v y) (beta v (S y))) S)  jcab    sylibr

# collapse case clause
    A  leid    A  A  lesuc    mpbir
    y  A  df-lt    biimpi    pm3.26d    y  A  (S A)  lelttr    ex    syl   mpi
    y  (S A)    df-lt    sylib    pm3.27d
    (-. (= (beta z y) (apply S C)))  orcd    (= y (S A))  (= (beta z y) (apply S C))  pm3.14   syl    (/\ (= y (S A)) (= (beta z y) (apply S C)))  (/\ (<= y A) (= (beta z y) (beta v y)))  orel2  syl
    (e. (<,> (beta v y) (beta v (S y))) S)  anim1d
  a2i    syl
# clean up the result a bit
  (<= y A)  (= (beta z y) (beta v y))  (e. (<,> (beta v y) (beta v (S y))) S)  anass    biimpi    pm3.27d    syl6
  (beta z y)  (beta v y)  (beta v (S y))  opeq1    (<,> (beta z y) (beta v (S y)))  (<,> (beta v y) (beta v (S y)))  S  ax-eleq1    syl    biimprd    imp    syl6
  imp
# Start over to get back the quantifier we dropped, since now we want y=y'
    h2  biimpi

# scrub unneeded clauses(*)
    (= (beta v (0)) B)  (/\ (= (beta v A) C) (A. y (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S))))  pm3.27    (= (beta v A) C)  (A. y (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S)))  pm3.27    syl    (A. y (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C))))))  anim2i    syl

# Join quantifiers
    y  (-> (<= y (S A)) (\/ (/\ (<= y A) (= (beta z y) (beta v y))) (/\ (= y (S A)) (= (beta z y) (apply S C)))))  (-> (< y A) (e. (<,> (beta v y) (beta v (S y))) S))  alan12   syl

# alpha-change y->x, then substitute y' for x.
      (= y x)  id  (S A)  leeq1d
        (= y x)  id  A  leeq1d
          y  x  z  betaeq2    y  x  v  betaeq2  eqeq12d
        anbi12d
          y  x  (S A)  eqeq1
            y  x  z  betaeq2    (apply S C)  eqeq1d
          anbi12d
        orbi12d
      imbi12d
        (= y x)  id    A  lteq1d
        y  x  v  betaeq2    (= y x)  id    suceqd    (S y)  (S x)  v  betaeq2    syl    jca
        # opeq12 again
        (beta v y)  (beta v x)  (beta v (S y))  opeq1    eqcomd    (beta v (S y))  (beta v (S x))  (beta v x)  opeq2    anim12i    (<,> (beta v x) (beta v (S y)))  (<,> (beta v y) (beta v (S y)))  (<,> (beta v x) (beta v (S x)))    ax-eqtr   syl    syl
        (<,> (beta v y) (beta v (S y)))  (<,> (beta v x) (beta v (S x)))  S  ax-eleq1    syl
       imbi12d
      anbi12d    alpha
    sylib

      (= x (S y))  id  (S A)  leeq1d
        (= x (S y))  id  A  leeq1d
          x  (S y)  z  betaeq2    x  (S y)  v  betaeq2  eqeq12d
        anbi12d
          x  (S y)  (S A)  eqeq1
            x  (S y)  z  betaeq2    (apply S C)  eqeq1d
          anbi12d
        orbi12d
      imbi12d
        (= x (S y))  id    A  lteq1d
        x  (S y)  v  betaeq2    (= x (S y))  id    suceqd    (S x)  (S (S y))  v  betaeq2    syl    jca
        # opeq12 again
        (beta v x)  (beta v (S y))  (beta v (S x))  opeq1    eqcomd    (beta v (S x))  (beta v (S (S y)))  (beta v (S y))  opeq2    anim12i    (<,> (beta v (S y)) (beta v (S x)))  (<,> (beta v x) (beta v (S x)))  (<,> (beta v (S y)) (beta v (S (S y))))    ax-eqtr   syl    syl
        (<,> (beta v x) (beta v (S x)))  (<,> (beta v (S y)) (beta v (S (S y))))  S  ax-eleq1    syl
       imbi12d
      anbi12d    cla4g
    syl

    # *aw crap, i just realized that I don't actually need that extra clause and the above could've been MUCH simpler.  But too lazy to redo it now.
    pm3.26d
# normalize bound
    y  A  df-lt    biimpi    pm3.26d    y  A  lesuc12  sylib
    (<= (S y) (S A))  (\/ (/\ (<= (S y) A) (= (beta z (S y)) (beta v (S y)))) (/\ (= (S y) (S A)) (= (beta z (S y)) (apply S C))))  pm2.27    syl   com12    syl
# collapse case yet again
      y  A  df-lt    biimpi    pm3.27d    y  A  pa_ax2    notbii    sylib
      (-. (= (beta z (S y)) (apply S C)))  orcd    (= (S y) (S A))  (= (beta z (S y)) (apply S C))  pm3.14   syl    (/\ (= (S y) (S A)) (= (beta z (S y)) (apply S C)))  (/\ (<= (S y) A) (= (beta z (S y)) (beta v (S y))))  orel2  syl
    a2i    syl
    imp    pm3.27d
# join it up
    (beta z (S y))  (beta v (S y))  (beta z y)  opeq2    syl
    (<,> (beta z y) (beta z (S y)))  (<,> (beta z y) (beta v (S y)))  S  ax-eleq1    syl
  mpbird
  ex    (fun S)  a1d    imp
#### Done with case 3b!
# Now join the two together
jaod
y  A  lefoo3    y  A  nnltp1let    (= y A)  orbi2i    bitr4i    syl5ib
# I honestly can no longer remember *why* I wanted to prove phi -> (A. y y<A' -> <beta z y, beta z y'> e. S) , but now I can:
y  A  lesuc    syl5ib    y  19.21ai    ancoms
#################### END OF STEP 3!! ####################
# Step 4 should be easy by comparison....
jca    jca
(/\ (= (beta z (0)) B) (/\ (= (beta z (S A)) (apply S C)) (A. y (-> (< y (S A)) (e. (<,> (beta z y) (beta z (S y))) S)))))  z  19.8a    syl
S  (S A)  B  (apply S C)  z  y  df-recursep    sylibr
ancoms    ex    z  19.22i    v    19.22i    syl
v  (E. z (-> (fun S) (recursep S (S A) B (apply S C))))  ex-nf    syl
z  (-> (fun S) (recursep S (S A) B (apply S C)))  ex-nf    syl
com12
)
# number 161.0
thm (recursive.3 ((A x) (S x))
  ()
  (->  (-> (fun S) (E. x (recursep S    w  A x)))
       (-> (fun S) (E. x (recursep S (S w) A x))))
  (/\ (A. y (-> (<= y (S w)) (\/ (/\ (<= y w) (= (beta z y) (beta v y))) (/\ (= y (S w)) (= (beta z y) (apply S x)))))) (/\ (= (beta v (0)) A) (/\ (= (beta v w) x) (A. y (-> (< y w) (e. (<,> (beta v y) (beta v (S y))) S))))))  biid  recursive.3.1  x  19.21ai
  x  (recursep S w A x)  (recursep S (S w) A (apply S x))  19.22    syl    a2i
  imp

    v  (apply S x)  tyex
    v  (apply S x)  S  (S w)  A  recursepeq4    v  19.22i    ax-mp
    (recursep S (S w) A v)  (recursep S (S w) A (apply S x))  bi2    v  19.22i    ax-mp
    x  gen
  jctil
  x  (E. v (-> (recursep S (S w) A (apply S x)) (recursep S (S w) A v)))  (recursep S (S w) A (apply S x))  19.29    syl
  v  (-> (recursep S (S w) A (apply S x)) (recursep S (S w) A v))  (recursep S (S w) A (apply S x))  19.41  biimpri    x  19.22i    syl
  (recursep S (S w) A (apply S x))  (recursep S (S w) A v)  pm3.35    ancoms      v  19.22i    x  19.22i    syl
  x  (E. v (recursep S (S w) A v))  ex-nf    syl
  x  v  S  (S w)  A  recursepeq4    exalpha    sylibr
  ex
)

thm (recursive.1 ((B x)) ()
  (-> (= w B)
     (<-> (-> (fun S) (E. x (recursep S w A x)))
          (-> (fun S) (E. x (recursep S B A x)))))

  w  B  z  betaeq2
  x  eqeq1d
    (= w B)  id  y  lteq2d
    (e. (<,> (beta z y) (beta z (S y))) S)  imbi1d
    y  19.21ai     19.15d
  anbi12d
  (= (beta z (0)) A)  anbi2d
  z  exbid
  x  exbid
  (fun S) imbi2d

    S w A x z y df-recursep    x  exbii   (fun S)  imbi2i   syl5rbb
    S B A x z y df-recursep    x  exbii   (fun S)  imbi2i   syl5rbb
)

# Base case
thm (recursive.2 ((A x z)) () (-> (fun S) (E! x (E. z (/\ (= (beta z (0)) A) (/\ (= (beta z (0)) x)
                    (A. y (-> (< y (0)) (e. (<,> (beta x y) (beta x (S y))) S))))))))
x  A  tyeu
  v  eqid
z  A  recursive.2.1
  x  A  (beta z (0)) eqeq2   (= (beta z (0)) A)  anbi2d   (= (beta z (0)) A)  anidm    syl6bb
    y nn0nlt0   (e. (<,> (beta x y) (beta x (S y))) S)  pm2.21i    y gen
   (= (beta z (0)) x)  biantru
   (= (beta z (0)) A)  anbi2i
  syl5bbr
  z  exbid
mpbiri
  (= (beta z (0)) A)  (= (beta z (0)) x)  (A. y (-> (< y (0)) (e. (<,> (beta x y) (beta x (S y))) S)))  anass  bicomi
  (beta z (0))  A  x  ax-eqtr  eqcomd  (A. y (-> (< y (0)) (e. (<,> (beta x y) (beta x (S y))) S)))  adantr  sylbi
  z  19.22i  z  (= x A)  ex-nf  syl
impbii
 (= v v)  a1i  x  eubid  ax-mp  mpbi
(fun S) a1i
)

# Base case
thm (recursive.2a ((A x)) () (-> (fun S) (E. x (recursep S (0) A x)))
x  A  tyex
  v  eqid
z  A  recursive.2.1
  x  A  (beta z (0)) eqeq2   (= (beta z (0)) A)  anbi2d   (= (beta z (0)) A)  anidm    syl6bb
    y nn0nlt0   (e. (<,> (beta z y) (beta z (S y))) S)  pm2.21i    y gen
   (= (beta z (0)) x)  biantru
   (= (beta z (0)) A)  anbi2i
  syl5bbr
  z  exbid
mpbiri
  (= (beta z (0)) A)  (= (beta z (0)) x)  (A. y (-> (< y (0)) (e. (<,> (beta z y) (beta z (S y))) S)))  anass  bicomi
  (beta z (0))  A  x  ax-eqtr  eqcomd  (A. y (-> (< y (0)) (e. (<,> (beta z y) (beta z (S y))) S)))  adantr  sylbi
  z  19.22i  z  (= x A)  ex-nf  syl
impbii
 (= v v)  a1i  x  exbid  ax-mp  mpbi
(fun S) a1i

  S  (0)  A  x  z  y  df-recursep    x  exbii     (fun S)  imbi2i   mpbir
)

## <summary> Existence of the result of a recursion operation. </summary>
thm (recursive ((A w) (S w) (B w)) () (-> (fun S) (E. w (recursep S A B w)))

   x  (0)    S  w  B  recursive.1
   x  y      S  w  B  recursive.1
   x  (S y)  S  w  B  recursive.1
   x  A      S  w  B  recursive.1
   S  w  B  recursive.2a
   S  w  y  B  recursive.3
finds
)

# number 166.0
thm (recursep-uniq.1 () () (-> (fun S) (<-> (recursep S (0) A B) (= A B)))

#  v  eqid
z  A  recursive.2.1
  B  A  (beta z (0)) eqeq2   (= (beta z (0)) A)  anbi2d   (= (beta z (0)) A)  anidm    syl6bb
    y nn0nlt0   (e. (<,> (beta z y) (beta z (S y))) S)  pm2.21i    y gen
   (= (beta z (0)) B)  biantru
   (= (beta z (0)) A)  anbi2i
  syl5bbr
  z  exbid
mpbiri
  (= (beta z (0)) A)  (= (beta z (0)) B)  (A. y (-> (< y (0)) (e. (<,> (beta z y) (beta z (S y))) S)))  anass  bicomi
  (beta z (0))  A  B  ax-eqtr  eqcomd  (A. y (-> (< y (0)) (e. (<,> (beta z y) (beta z (S y))) S)))  adantr  sylbi
  z  19.22i  z  (= B A)  ex-nf  syl
impbii

  S  (0)  A  B  z  y  df-recursep

bitr4i
bicomi
B  A  eqcom  bitri
(fun S)  a1i
)

## <summary> Recursing "one more time" works as expected. </summary>
thm (recursepsuc ((A x) (B x) (C x) (S x)) ()
 # (-> (fun S)
     (-> (recursep S (S A) B C) (E. x (/\ (recursep S A B x) (e. (<,> x C) S))))
 #)

  x  (beta y A)  tyex    y  gen
    S  (S A)  B  C  y  z  df-recursep    biimpi
      A  leid    A  A  lesuc    mpbir
      z  A  (S A)  lttr    impexpi    ax-mp
      (e. (<,> (beta y z) (beta y (S z))) S)  imim1i    z  19.20i    #y  gen
      (= (beta y (S A)) C)  adantl    (=  (beta y A) x)  anim2i    ex    (= (beta y (0)) B)  anim2d    com12
      imp  (/\ (= (beta y (0)) B) (/\ (= (beta y A) x) (A. z (-> (< z A) (e. (<,> (beta y z) (beta y (S z))) S)))))  y  19.8a    syl
      S  A  B  x  y  z  df-recursep    sylibr

       A  leid    A  A  lesuc    mpbir
        (= z A)  id   (S A)  lteq1d
          z  A  y   betaeq2
          (= z A)  id    suceqd    (S z)  (S A)  y  betaeq2    syl    jca
          (beta y z)  (beta y (S z))  (beta y A)  (beta y (S A))  opth  sylibr
          (<,> (beta y z) (beta y (S z)))  (<,> (beta y A) (beta y (S A)))  S  ax-eleq1    syl
        imbi12d
        cla4g
       mpi
       (= (beta y (S A)) C)  anim2i
         (beta y A)  (beta y (S A))  x  C  opth    biimpri
         (<,> (beta y A) (beta y (S A)))  (<,> x C)  S  ax-eleq1    syl   biimpd
       ex    imp3a    com12
     syl
     (= (beta y (0)) B)  adantl
     imp
   jca
   ex
   com12     eqcoms     com12
   x  19.21ai
 y  19.22i    syl
 jctilb
y  (E. x (= x (beta y A)))  (A. x (-> (= x (beta y A)) (/\ (recursep S A B x) (e. (<,> x C) S))))  19.29  syl
x  (-> (= x (beta y A)) (/\ (recursep S A B x) (e. (<,> x C) S)))  (= x (beta y A)) 19.29    ancoms    y  19.22i    syl
(= x (beta y A))  (/\ (recursep S A B x) (e. (<,> x C) S))  pm3.35  ancoms    x  19.22i   y  19.22i   syl
y  (E. x (/\ (recursep S A B x) (e. (<,> x C) S)))  ex-nf    syl
)
# number 168.0


thm (recursep-uniq.2 ((S z z') (A z z')) ()
  (-> (fun S) (-> (A. z (A. z' (-> (/\ (recursep S y A z) (recursep S y A z')) (= z z'))))
      (A. z (A. z' (-> (/\ (recursep S (S y) A z) (recursep S (S y) A z')) (= z z'))))))

  S  y  A  z  x  recursepsuc
    S  y  A  z'  x'  recursepsuc
  anim12i
  x  (/\ (recursep S y A x) (e. (<,> x z) S))  x'  (/\ (recursep S y A x') (e. (<,> x' z') S))  exey    syl  (recursep S y A x)  (e. (<,> x z) S)  (recursep S y A x')  (e. (<,> x' z') S)  an4    biimpi    x'  19.22i    x  19.22i    syl

    # need to alpha-swap the hypothesis
    z'  x'  S  y  A  recursepeq4
      (recursep S y A z)  anbi2d
      z'  x'  z  eqeq2    imbi12d   alpha
      (= z x) a1i
        z  x  S  y  A  recursepeq4
        (recursep S y A x')  anbi1d
        z  x  x'  eqeq1    imbi12d
        x'  19.21ai
        x'  (-> (/\ (recursep S y A z) (recursep S y A x')) (= z x'))  (-> (/\ (recursep S y A x) (recursep S y A x')) (= x x'))  19.15    syl
      bitrd
      alpha    biimpi
      (/\ (recursep S y A x) (recursep S y A x'))  (= x x')  (/\ (e. (<,> x z) S) (e. (<,> x' z') S))  pm3.45    x'  19.20i    x  19.20i   syl
    anim12i
      x  (A. x' (-> (/\ (/\ (recursep S y A x) (recursep S y A x')) (/\ (e. (<,> x z) S) (e. (<,> x' z') S))) (/\ (= x x') (/\ (e. (<,> x z) S) (e. (<,> x' z') S)))))  (E. x' (/\ (/\ (recursep S y A x) (recursep S y A x')) (/\ (e. (<,> x z) S) (e. (<,> x' z') S))))  19.29    ancoms
      x' (-> (/\ (/\ (recursep S y A x) (recursep S y A x')) (/\ (e. (<,> x z) S) (e. (<,> x' z') S))) (/\ (= x x') (/\ (e. (<,> x z) S) (e. (<,> x' z') S))))  (/\ (/\ (recursep S y A x) (recursep S y A x')) (/\ (e. (<,> x z) S) (e. (<,> x' z') S)))  19.29    x  19.22i    syl
    syl
      (/\ (/\ (recursep S y A x) (recursep S y A x')) (/\ (e. (<,> x z) S) (e. (<,> x' z') S)))  (/\ (= x x') (/\ (e. (<,> x z) S) (e. (<,> x' z') S)))  pm3.35    ancoms
    x'  19.22i    x  19.22i    syl
    ancoms  ex
    x  x'  z  opeq1   (<,> x z)  (<,> x' z)  S   ax-eleq1    syl    biimpd    imp    (e. (<,> x' z') S)  anim1i    anasss  x'  19.22i    x  19.22i      x  (E. x' (/\ (e. (<,> x' z) S) (e. (<,> x' z') S)))  ex-nf   syl   syl6
    imp
      S  x'  z  w  df-fun    biimpi    pm3.26d
      x'  (E! z (e. (<,> x' z) S))  ax-4    syl
      z  (e. (<,> x' z) S)  w  df-eu    sylib
      z z'  x'  opeq2    (<,> x' z)  (<,> x' z')  S  ax-eleq1    syl    z  z'  w  eqeq1  bibi12d   cla4g
      biimpd
      z  (<-> (e. (<,> x' z) S) (= z w))  ax-4    biimpd    jca
      (e. (<,> x' z') S)  (= z' w)  (e. (<,> x' z) S)  (= z w)  prth    syl
      w  z  z'  ax-eqtr    ex    eqcoms    com12  eqcoms    imp    syl6
      w    19.22i    w  (-> (/\ (e. (<,> x' z') S) (e. (<,> x' z) S)) (= z z'))  ex-nf    syl
    syl
    com12    ancoms    com12
    x'  19.22d    x'  (= z z')  ex-nf    syl6
  anim12i
  (E. x' (/\ (e. (<,> x' z) S) (e. (<,> x' z') S)))  (= z z')  pm3.35    syl
  ancoms    anassrs    ex
  z'  19.21ai    z  19.21ai    ex
)

# Second equality identitiy for recursep.
thm (recursepeq2 () () (-> (= A B) (<-> (recursep S A C D) (recursep S B C D)))

    A  B  x  betaeq2    D  eqeq1d
      (= A B)  id y  lteq2d    (e. (<,> (beta x y) (beta x (S y))) S)  imbi1d
      y  19.21ai
      y  (-> (< y A) (e. (<,> (beta x y) (beta x (S y))) S))  (-> (< y B) (e. (<,> (beta x y) (beta x (S y))) S))  19.15    syl
    anbi12d
    (= (beta x (0)) C)  anbi2d
    x  exbid
      S A C D x y df-recursep
    syl5bb
     S B C D x y df-recursep
    syl6bbr
)

# number 170.0
thm (recursep-uniq.3 ((B z z')) () (-> (= x B) (<->
  (-> (fun S) (A. z (A. z' (-> (/\ (recursep S x A z) (recursep S x A z')) (= z z')))))
  (-> (fun S) (A. z (A. z' (-> (/\ (recursep S B A z) (recursep S B A z')) (= z z')))))
))
  x  B  S  A  z  recursepeq2
    x  B  S  A  z'  recursepeq2
  anbi12d
  (= z z')  imbi1d
  z'  19.21ai  19.15d    z  19.21ai    19.15d
  (fun S)  imbi2d
)

## <summary> Uniqueness of the result of a recursion operation. </summary> 
thm (recursep-uniq () () (-> (fun S) (-> (/\ (recursep S A B C)  (recursep S A B D)) (= C D)))

  x  (0)  S  z  z'  B  recursep-uniq.3
    x  y  S  z  z'  B  recursep-uniq.3
  x  (S y)  S  z  z'  B  recursep-uniq.3
    x  A  S  z  z'  B  recursep-uniq.3

  S  B  z   recursep-uniq.1
    S   B  z'  recursep-uniq.1
  anbi12d    biimpd
  B  z  z'  ax-eqtr    syl6
  z'  19.21ai  z  19.21ai

  S  z  z'  y  B  recursep-uniq.2  a2i

finds

  z  C  S  A  B  recursepeq4
  (recursep S A B z')  anbi1d
  (= z C)  id    z'  eqeq1d    imbi12d
  z'  19.21ai  19.15d
  cla4g
syl

   z'  D  S  A  B  recursepeq4
  (recursep S A B C)  anbi2d
  (= z' D)  id    C  eqeq2d    imbi12d
  cla4g
syl
)

# First equality identity of recursep.
thm (recursepeq1 () () (-> (=_ S T) (<-> (recursep S A B C) (recursep T A B C)))
    S  T  (<,> (beta x y) (beta x (S y)))  eleq2
    (< y A)  imbi2d
    y  19.21ai
    19.15d
    (= (beta x A) C)  anbi2d
    (= (beta x (0)) B)  anbi2d
    x  exbid
      S  A  B  C  x  y  df-recursep
    syl5bb
      T  A  B  C  x  y  df-recursep
    syl6bbr
)

## <title> Recursing zero times does nothing </title>
## <suggest> full('Simplify', 'T') </suggest>
thm (recursep0 () () (recursep S (0) A A)

  A  eqid
z  A  recursive.2.1
  A  A  (beta z (0)) eqeq2   (= (beta z (0)) A)  anbi2d   (= (beta z (0)) A)  anidm    syl6bb
    y nn0nlt0   (e. (<,> (beta z y) (beta z (S y))) S)  pm2.21i    y gen
   (= (beta z (0)) A)  biantru
   (= (beta z (0)) A)  anbi2i
  syl5bbr
  z  exbid
mpbiri
 ax-mp
 S  (0)  A  A  z  y  df-recursep
 mpbir
)

# number 174.0
## <summary>
##   There exists a unique answer to recursing the function S exactly B times
##   starting at A.
## </summary>
thm (eurecursep ((S x) (A x) (B x)) () (-> (fun S) (E! x (recursep S A B x)))
  S x A B recursive
    S A B x y recursep-uniq y 19.21ai x 19.21ai
  jca
  x y S A B recursepeq4 eu4 sylibr
)

thm (df-recurse-just ((A x z) (B x z) (S x) (S z)) () (=
        (iota ({|} x (recursep S A B x)))
        (iota ({|} z (recursep S A B z))))
  x z S A B recursepeq4
  abeq

  ({|} x (recursep S A B x)) 
  ({|} z (recursep S A B z)) ax-iotaeq  
  ax-mp
)

## <title> Definition of Recursive Function </title>
## <suggest> right('Define', 're') left('Simplify', 're') </suggest>
defthm (df-recurse nat (recurse S A B) ((A x) (B x) (S x)) ()
  (= (recurse S A B) (iota ({|} x (recursep S A B x))))
  x' S A B x df-recurse-just)

# First equality identity for recurse
thm (recurseseq1 () () (-> (=_ S T) (= (recurse S A B) (recurse T A B)))
  S T A B x recursepeq1
  x abbi2d
  ({|} x (recursep S A B x)) 
  ({|} x (recursep T A B x)) 
  ax-iotaeq   
  syl
  
  ## <d 'Definition of Recursive Function '>
    S A B x df-recurse
    ## <d 'Commutative Property'>
      (recurse S A B) (iota ({|} x (recursep S A B x))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq0
  ## </d 'Definition of Recursive Function '>
  
  ## <d 'Definition of Recursive Function '>
    T A B x df-recurse
    ## <d 'Commutative Property'>
      (recurse T A B) (iota ({|} x (recursep T A B x))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq1
  ## </d 'Definition of Recursive Function '>
)

# Second equality identity for recurse
thm (recurseeq2 () () (-> (= A B) (= (recurse S A C) (recurse S B C)))
  A B S C w recursepeq2
  w abbi2d
  ({|} w (recursep S A C w))
  ({|} w (recursep S B C w)) ax-iotaeq
  syl

  ## <d 'Definition of Recursive Function '>
    S A C w df-recurse
    ## <d 'Commutative Property'>
      (recurse S A C) (iota ({|} w (recursep S A C w))) eqcom
      mpbi
    ## </d 'Commutative Property'>
      EqReplaceImp1Eq0
  ## </d 'Definition of Recursive Function '>

  ## <d 'Definition of Recursive Function '>
    S B C w df-recurse
    ## <d 'Commutative Property'>
      (recurse S B C) (iota ({|} w (recursep S B C w))) eqcom
      mpbi
    ## </d 'Commutative Property'>
      EqReplaceImp1Eq1
  ## </d 'Definition of Recursive Function '>
)

## <title> Equivalence for recursep </title> ##
thm (recursepseq1 () () (-> (=_ S T) (<-> (recursep S A B C) (recursep T A B C)))
  S T (<,> (beta z y) (beta z (S y))) eleq2
  (< y A) imbi2d
  y albi2d
  (= (beta z A) C) anbi2d
  (= (beta z (0)) B) anbi2d
  z exbid
  S A B C z y df-recursep
  ## <d 'Commutative Property'>
    (recursep S A B C) (E. z (/\ (= (beta z (0)) B) (/\ (= (beta z A) C) (A. y (-> (< y A) (e. (<,> (beta z y) (beta z (S y))) S)))))) bicom
    mpbi
  ## </d 'Commutative Property'>
  BiReplaceImp1Bi0
  T A B C z y df-recursep
  ## <d 'Commutative Property'>
    (recursep T A B C) (E. z (/\ (= (beta z (0)) B) (/\ (= (beta z A) C) (A. y (-> (< y A) (e. (<,> (beta z y) (beta z (S y))) T)))))) bicom
    mpbi
  ## </d 'Commutative Property'>
  BiReplaceImp1Bi1
)
thm (recursepseq1i () (
     hyp1 (=_ S T))
     (<-> (recursep S A B C) (recursep T A B C))
  hyp1
  S T A B C recursepseq1
  ax-mp
)

thm (recursepseq1d () (
     hyp1 (-> ph (=_ S T)))
     (-> ph (<-> (recursep S A B C) (recursep T A B C)))
  hyp1
  S T A B C recursepseq1
  syl
)

thm (recursepeq2i () (
     hyp1 (= A B))
     (<-> (recursep S A C D) (recursep S B C D))
  hyp1
  A B S C D recursepeq2
  ax-mp
)

thm (recursepeq2d () (
     hyp1 (-> ph (= A B)))
     (-> ph (<-> (recursep S A C D) (recursep S B C D)))
  hyp1
  A B S C D recursepeq2
  syl
)

## <title> Equivalence for recursep </title> ##
thm (recursepeq3 () () (-> (= B D) (<-> (recursep S A B C) (recursep S A D C)))
  B D (beta z (0)) eqeq2
  (/\ (= (beta z A) C) (A. y (-> (< y A) (e. (<,> (beta z y) (beta z (S y))) S)))) anbi1d
  z exbid
  S A B C z y df-recursep
  ## <d 'Commutative Property'>
    (recursep S A B C) (E. z (/\ (= (beta z (0)) B) (/\ (= (beta z A) C) (A. y (-> (< y A) (e. (<,> (beta z y) (beta z (S y))) S)))))) bicom
    mpbi
  ## </d 'Commutative Property'>
  BiReplaceImp1Bi0
  S A D C z y df-recursep
  ## <d 'Commutative Property'>
    (recursep S A D C) (E. z (/\ (= (beta z (0)) D) (/\ (= (beta z A) C) (A. y (-> (< y A) (e. (<,> (beta z y) (beta z (S y))) S)))))) bicom
    mpbi
  ## </d 'Commutative Property'>
  BiReplaceImp1Bi1
)


thm (recursepeq3i () (
     hyp1 (= B D))
     (<-> (recursep S A B C) (recursep S A D C))
  hyp1
  B D S A C recursepeq3
  ax-mp
)

thm (recursepeq3d () (
     hyp1 (-> ph (= B D)))
     (-> ph (<-> (recursep S A B C) (recursep S A D C)))
  hyp1
  B D S A C recursepeq3
  syl
)

thm (recursepeq4i () (
     hyp1 (= A B))
     (<-> (recursep S C D A) (recursep S C D B))
  hyp1
  A B S C D recursepeq4
  ax-mp
)

thm (recursepeq4d () (
     hyp1 (-> ph (= A B)))
     (-> ph (<-> (recursep S C D A) (recursep S C D B)))
  hyp1
  A B S C D recursepeq4
  syl
)



thm (recurseseq1i () (
     hyp1 (=_ S T))
     (= (recurse S A B) (recurse T A B))
  hyp1
  S T A B recurseseq1
  ax-mp
)

thm (recurseseq1d () (
     hyp1 (-> ph (=_ S T)))
     (-> ph (= (recurse S A B) (recurse T A B)))
  hyp1
  S T A B recurseseq1
  syl
)

thm (recurseeq2i () (
     hyp1 (= A B))
     (= (recurse S A C) (recurse S B C))
  hyp1
  A B S C recurseeq2
  ax-mp
)

thm (recurseeq2d () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (recurse S A C) (recurse S B C)))
  hyp1
  A B S C recurseeq2
  syl
)

## <title> Equivalence for recurse </title> ##
thm (recurseeq3 () () (-> (= B C) (= (recurse S A B) (recurse S A C)))
  B C S A x recursepeq3
  x abbi2d
  iotaseqd
  S A B x df-recurse
  ## <d 'Commutative Property'>
    (recurse S A B) (iota ({|} x (recursep S A B x))) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq0
  S A C x df-recurse
  ## <d 'Commutative Property'>
    (recurse S A C) (iota ({|} x (recursep S A C x))) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq1
)


thm (recurseeq3i () (
     hyp1 (= B C))
     (= (recurse S A B) (recurse S A C))
  hyp1
  B C S A recurseeq3
  ax-mp
)

thm (recurseeq3d () (
     hyp1 (-> ph (= B C)))
     (-> ph (= (recurse S A B) (recurse S A C)))
  hyp1
  B C S A recurseeq3
  syl
)

thm (recurseeq23 () () (-> (/\ (= A B) (= C D)) (= (recurse S A C) (recurse S B D)))
  A B S C recurseeq2
  C D S B recurseeq3
  pm3.2i  
  
  ## <d 'Praeclarum Theorema '>
    (= A B) (= (recurse S A C) (recurse S B C)) (= C D) (= (recurse S B C) (recurse S B D)) prth
    ax-mp
  ## </d 'Praeclarum Theorema '>
  
  ## <d 'Symmetric Property '>
    (recurse S A C) (recurse S B C) eqcom
    BiReplaceImp1An0
  ## </d 'Symmetric Property '>
  
  ## <d 'Transitive Property '>
    (recurse S B C) (recurse S A C) (recurse S B D) ax-eqtr
    syl
  ## </d 'Transitive Property '>
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (iota  [ S ]   ]   ] )))
##   (=_                [ S ]   [ T ] )
##   (-> ph (= A (iota  [   [   [ T ] )))
## </table>
thm (SeqReplaceImp1Eq1Iota0 () (
     replacee (-> ph (= A (iota S)))
     substitution (=_ S T)) 
     (-> ph (= A (iota T)))
  replacee substitution
  iotaseqi
  EqReplaceImp1Eq1
)

## <title> Convert a recurse predicate to recurse </title>
thm (recurseNoPred () (hyp (fun S)) (-> (recursep S A B C) (= (recurse S A B) C))
  hyp
  S A B C x recursep-uniq
  ax-mp  
  ## <d 'Import-Export Theorem '>
    (recursep S A B C) (recursep S A B x) (= C x) impexp
    mpbi
  ## </d 'Import-Export Theorem '>
  
  ## <d 'Symmetric Property '>
    C x eqcom
    BiReplaceImp1Imp1
  ## </d 'Symmetric Property '>

  C x S A B recursepeq4
  
  ## <d 'Symmetric Property '>
    C x eqcom
    sylbi2
  ## </d 'Symmetric Property '>
  
  ## <d 'Infer Left to Right '>
    (recursep S A B C) (recursep S A B x) bi1
    syl
  ## </d 'Infer Left to Right '>
  
  ## <d 'Import-Export Theorem '>
    (= x C) (recursep S A B C) (recursep S A B x) impexp
    ## <d 'Commutative Property'>
      (-> (/\ (= x C) (recursep S A B C)) (recursep S A B x)) (-> (= x C) (-> (recursep S A B C) (recursep S A B x))) bicom
      mpbi
    ## </d 'Commutative Property'>
    mpbi
  ## </d 'Import-Export Theorem '>
  
  ## <d 'Commutative Property '>
    (= x C) (recursep S A B C) ancom
    sylbi2
  ## </d 'Commutative Property '>
  
  ## <d 'Import-Export Theorem '>
    (recursep S A B C) (= x C) (recursep S A B x) impexp
    mpbi
  ## </d 'Import-Export Theorem '>
  impbid
  x abbi2d
  iotaseqd  
  ## <d 'Definition of Recursive Function '>
    S A B x df-recurse
    ## <d 'Commutative Property'>
      (recurse S A B) (iota ({|} x (recursep S A B x))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq0
  ## </d 'Definition of Recursive Function '>
  
  ## <d>
    C x df-sn
    ## <d 'Commutative Property'>
      ({} C) ({|} x (= x C)) seqcom
      mpbi
    ## </d 'Commutative Property'>
    SeqReplaceImp1Eq1Iota0
  ## </d>
  
  ## <d 'Iota Axiom '>
    C ax-iota
    EqReplaceImp1Eq1
  ## </d 'Iota Axiom '>
)

## <title> Substitution </title>
## <table>
##   (-> (recursep S  [ A ]   ]   ]  C D) ph)
##   (=               [ A ]   [ B ] )
##   (-> (recursep S  [   [   [ B ]  C D) ph)
## </table>
thm (EqReplaceImp0Recursep1 () (
     replacee (-> (recursep S A C D) ph)
     substitution (= A B)) 
     (-> (recursep S B C D) ph)
  replacee substitution
  S C D recursepeq2i
  sylbi2
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\  [ ps ]   ]    ]  th)))
##   (->               [ ps ]   [ ch ] )
##   (-> ph (E. x (/\  [    [   [ ch ]  th)))
## </table>
thm (ImpReplaceImp1Ex1An0 () (
     replacee (-> ph (E. x (/\ ps th)))
     substitution (-> ps ch)) 
     (-> ph (E. x (/\ ch th)))
  replacee substitution
  th anim1i
  ImpReplaceImp1Ex1
)

## <title> Applying a Function 0 Times </title>
thm (recurse0 () (hyp (fun S)) (= (recurse S (0) A) A)
  S A recursep0
  hyp
  (0) A A recurseNoPred
  ax-mp
)


## <title> Recursion Applies a Function Multiple Times </title>
thm (recursesuc () (hyp (fun S)) (= (recurse S (+ A (1)) B) (apply S (recurse S A B)))
  hyp
  S y (+ A (1)) B eurecursep
  ax-mp
  
  ## <d 'Unique Existence Implies Existence '>
    y (recursep S (+ A (1)) B y) euex
    ax-mp
  ## </d 'Unique Existence Implies Existence '>


  S A B y x recursepsuc  
  ## <d 'Successor Adds One '>
    A a1suc
    EqReplaceImp0Recursep1
  ## </d 'Successor Adds One '>
#  A x y opeq1
  hyp
  A B x recurseNoPred
  
  ImpReplaceImp1Ex1An0
  (recurse S A B) x y opeq1  
  ImpReplaceImp1Ex1An0
  (<,> (recurse S A B) y) (<,> x y) S ax-eleq1
  
  ImpReplaceImp1Ex1An0
  (e. (<,> x y) S) (e. (<,> (recurse S A B) y) S) pm5.36  
  ## <d 'Commutative Property '>
    (e. (<,> x y) S) (<-> (e. (<,> x y) S) (e. (<,> (recurse S A B) y) S)) ancom
    bitr3icom
  ## </d 'Commutative Property '>
  
  ## <d 'Commutative Property '>
    (e. (<,> x y) S) (e. (<,> (recurse S A B) y) S) bicom
    BiReplaceBi0An0
  ## </d 'Commutative Property '>
  BiReplaceImp1Ex1
  
  ## <d>
    (e. (<,> (recurse S A B) y) S) (<-> (e. (<,> x y) S) (e. (<,> (recurse S A B) y) S)) pm3.26
    ImpReplaceImp1Ex1
  ## </d>
  x (e. (<,> (recurse S A B) y) S) 19.9  
  sylib

  (recurse S A B) y headop
  (e. (<,> (recurse S A B) y) S) anRemove1 bicomi  
  sylib

  (recurse S A B) (apply S (recurse S A B)) headop
  hyp
  S (recurse S A B) funapply
  ax-mp
  pm3.2i

  (/\ (= (head (<,> (recurse S A B) y)) (recurse S A B)) (e. (<,> (recurse S A B) y) S)) anRemove1 bicomi
  sylib
  hyp
  (<,> (recurse S A B) (apply S (recurse S A B))) (recurse S A B) (<,> (recurse S A B) y) fun1.1  
  syl  
  (<,> (recurse S A B) (apply S (recurse S A B))) (<,> (recurse S A B) y) taileq
  
  ## <d 'Apply Tail Operator '>
    (recurse S A B) (apply S (recurse S A B)) tailop
    EqReplaceImp1Eq0
  ## </d 'Apply Tail Operator '>
  
  ## <d 'Apply Tail Operator '>
    (recurse S A B) y tailop
    EqReplaceImp1Eq1
  ## </d 'Apply Tail Operator '>
  syl
  (apply S (recurse S A B)) y S (+ A (1)) B recursepeq4  
  syl
   
  ## <d 'Implication & Biconditional '>
    (recursep S (+ A (1)) B y) (recursep S (+ A (1)) B (apply S (recurse S A B))) ibibr
    ## <d 'Commutative Property'>
      (-> (recursep S (+ A (1)) B y) (recursep S (+ A (1)) B (apply S (recurse S A B)))) (-> (recursep S (+ A (1)) B y) (<-> (recursep S (+ A (1)) B (apply S (recurse S A B))) (recursep S (+ A (1)) B y))) bicom
      mpbi
    ## </d 'Commutative Property'>
    mpbi
  ## </d 'Implication & Biconditional '>
  
  ImpReplaceEx1
  y (recursep S (+ A (1)) B (apply S (recurse S A B))) 19.9  
  mpbi
  hyp
  (+ A (1)) B (apply S (recurse S A B))  recurseNoPred    
  ax-mp
)

## <title> Substitution </title>
## <table>
##   (= (recurse S  [ A ]   ]   ]  C) D)
##   (=             [ A ]   [ B ] )
##   (= (recurse S  [   [   [ B ]  C) D)
## </table>
thm (EqReplaceEq0Recurse1 () (
     replacee (= (recurse S A C) D)
     substitution (= A B)) 
     (= (recurse S B C) D)
  replacee substitution
  S C recurseeq2i
  EqReplaceEq0
)

## <title> Substitution </title>
## <table>
##   (= A (apply S  [ B ]   ]   ] ))
##   (=             [ B ]   [ C ] )
##   (= A (apply S  [   [   [ C ] ))
## </table>
thm (EqReplaceEq1Apply1 () (
     replacee (= A (apply S B))
     substitution (= B C)) 
     (= A (apply S C))
  replacee substitution
  S applyeq2i
  EqReplaceEq1
)


## <title> Applying a Function Once </title>
thm (recurse1 () (hyp (fun S)) (= (recurse S (1) A) (apply S A))
  hyp
  (0) A recursesuc  
  ## <d 'Additive Identity Axiom '>
    (1) pa_ax3r
    EqReplaceEq0Recurse1
  ## </d 'Additive Identity Axiom '>
  hyp
  A recurse0  
  EqReplaceEq1Apply1
)

thm (recurseadd.1 ((A x) (S x) (B x) (C x)) () (<-> ([/] A x (= (recurse S x (recurse S B C)) (recurse S (+ x B) C))) (= (recurse S A (recurse S B C)) (recurse S (+ A B) C)))
  x A S (recurse S B C) recurseeq2
  x A B addeq1
  S C recurseeq2d
  eqeq12d
  sbcie
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (recurse S  [ B ]   ]   ]  D)))
##   (=                      [ B ]   [ C ] )
##   (-> ph (= A (recurse S  [   [   [ C ]  D)))
## </table>
thm (EqReplaceImp1Eq1Recurse1 () (
     replacee (-> ph (= A (recurse S B D)))
     substitution (= B C)) 
     (-> ph (= A (recurse S C D)))
  replacee substitution
  S D recurseeq2i
  EqReplaceImp1Eq1
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (recurse S (+ B  [ C ]   ]   ] ) A')))
##   (=                           [ C ]   [ D ] )
##   (-> ph (= A (recurse S (+ B  [   [   [ D ] ) A')))
## </table>
thm (EqReplaceImp1Eq1Recurse1Add1 () (
     replacee (-> ph (= A (recurse S (+ B C) A')))
     substitution (= C D)) 
     (-> ph (= A (recurse S (+ B D) A')))
  replacee substitution
  B addeq2i
  EqReplaceImp1Eq1Recurse1
)

thm (recurseadd () (hyp (fun S)) (= (recurse S A (recurse S B C)) (recurse S (+ A B) C))
  hyp
  (recurse S B C) recurse0 eqcomi
  B pa_ax3r eqcomi
  EqReplaceEq0Recurse1 eqcomi
  (0) x S B C recurseadd.1 bicomi
  mpbi

  (recurse S y (recurse S B C)) (recurse S (+ y B) C) S applyeq2
  hyp
  y (recurse S B C) recursesuc eqcomi
  EqReplaceImp1Eq0
  hyp
  (+ y B) C recursesuc eqcomi
  EqReplaceImp1Eq1

  ## <d 'Associative Property '>
    y B (1) addass
    EqReplaceImp1Eq1Recurse1
  ## </d 'Associative Property '>

  ## <d 'Commutative Property '>
    B (1) addcom
    EqReplaceImp1Eq1Recurse1Add1
  ## </d 'Commutative Property '>

  ## <d 'Associative Property '>
    y (1) B addass
    ## <d 'Commutative Property'>
      (+ (+ y (1)) B) (+ y (+ (1) B)) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq1Recurse1
  ## </d 'Associative Property '>
  y x S B C recurseadd.1 bicomi
  sylbi2
  (+ y (1)) x S B C recurseadd.1 bicomi
  sylib
  A induction
  A x S B C recurseadd.1  
  mpbi
)

## <title> Definition of One Fibonacci Step </title> ##
## <summary>
##   The Fibonacci step is used to define the Fibonacci sequence. Its behavior
##   is best described using by the theorem <a href="fibonacci-step-op">fibonacci-step-op</a>.
##   From two Fibonacci numbers, it compute the next pair of Fibonacci numbers.
## </summary>
defthm (df-fibonacci-step nat (fibonacci-step A) () () (= (fibonacci-step A) (<,> (tail A) (+ (head A) (tail A))))
  (<,> (tail A) (+ (head A) (tail A))) eqid
)

## <title> Equivalence for fibonacci-step </title> ##
thm (fibonacci-stepeq () () (-> (= A B) (= (fibonacci-step A) (fibonacci-step B)))
  A B taileq
  A B headeq
  A B taileq
  addeq12d
  opeq12d
  A df-fibonacci-step eqcomi
  EqReplaceImp1Eq0
  B df-fibonacci-step eqcomi  
  EqReplaceImp1Eq1
)



## <title> Substitution </title>
## <table>
##   (= A (<,>  [ B ]   ]   ]  D))
##   (=         [ B ]   [ C ] )
##   (= A (<,>  [   [   [ C ]  D))
## </table>
thm (EqReplaceEq1Op0 () (
     replacee (= A (<,> B D))
     substitution (= B C)) 
     (= A (<,> C D))
  replacee substitution
  D opeq1i
  EqReplaceEq1
)

## <title> Substitution </title>
## <table>
##   (= A (<,> B  [ C ]   ]   ] ))
##   (=           [ C ]   [ D ] )
##   (= A (<,> B  [   [   [ D ] ))
## </table>
thm (EqReplaceEq1Op1 () (
     replacee (= A (<,> B C))
     substitution (= C D)) 
     (= A (<,> B D))
  replacee substitution
  B opeq2i
  EqReplaceEq1
)

## <title> Substitution </title>
## <table>
##   (= A (<,> B (+  [ C ]   ]   ]  A')))
##   (=              [ C ]   [ D ] )
##   (= A (<,> B (+  [   [   [ D ]  A')))
## </table>
thm (EqReplaceEq1Op1Add0 () (
     replacee (= A (<,> B (+ C A')))
     substitution (= C D)) 
     (= A (<,> B (+ D A')))
  replacee substitution
  A' addeq1i
  EqReplaceEq1Op1
)

## <title> Substitution </title>
## <table>
##   (= A (<,> B (+ C  [ D ]   ]    ] )))
##   (=                [ D ]   [ A' ] )
##   (= A (<,> B (+ C  [   [   [ A' ] )))
## </table>
thm (EqReplaceEq1Op1Add1 () (
     replacee (= A (<,> B (+ C D)))
     substitution (= D A')) 
     (= A (<,> B (+ C A')))
  replacee substitution
  C addeq2i
  EqReplaceEq1Op1
)

## <title> Fibonacci Step Acting an Ordered Pair </title>
## <summary>
##   Demonstrates that if A and B are two Fibonacci numbers, Fibonacci step
##   computes the next pair of Fibonacci numbers which includes B.
##</summary>
thm (fibonacci-step-op () () (= (fibonacci-step (<,> A B)) (<,> B (+ A B)))
  (<,> A B) df-fibonacci-step  
  ## <d 'Apply Tail Operator '>
    A B tailop
    EqReplaceEq1Op0
  ## </d 'Apply Tail Operator '>
  ## <d 'Apply Head Operator '>
    A B headop
    EqReplaceEq1Op1Add0
  ## </d 'Apply Head Operator '>
  ## <d 'Apply Tail Operator '>
    A B tailop
    EqReplaceEq1Op1Add1
  ## </d 'Apply Tail Operator '>
)

## <title> Definition of the Fibonacci Sequence </title>
## <summary> Defines the A-th number in the Fibonacci Sequence </summary>
defthm (df-fibonacci nat (fibonacci A) () () (= (fibonacci A) (head (recurse (lambda y (fibonacci-step y)) A (<,> (0) (1)))))
  x y fibonacci-stepeq
  lambdaeq1
  A (<,> (0) (1)) recurseseq1i
  headeqi
)

## <title> Substitution </title>
## <table>
##   (= A (head  [ B ]   ]   ] ))
##   (=          [ B ]   [ C ] )
##   (= A (head  [   [   [ C ] ))
## </table>
thm (EqReplaceEq1Head0 () (
     replacee (= A (head B))
     substitution (= B C)) 
     (= A (head C))
  replacee substitution
  headeqi
  EqReplaceEq1
)

thm (fibonacci0 () () (= (fibonacci (0)) (0))
  (0) x df-fibonacci
  x y fibonacci-stepeq
  funlambda
  (<,> (0) (1)) recurse0    
    EqReplaceEq1Head0
    
    ## <d 'Apply Head Operator '>
      (0) (1) headop
      EqReplaceEq1
    ## </d 'Apply Head Operator '>
)

# Summation. Big Sigma.
thm (df-sum-step-just () () (-> (= A B) (= (<,> (+ (head A) (1)) (+ (tail A) (apply S (head A)))) (<,> (+ (head B) (1)) (+ (tail B) (apply S (head B))))))
  A B headeq
  (1) addeq1d
  A B taileq
  A B headeq
  S applyeq2d
  addeq12d
  opeq12d
)

defthm (df-sum-step set (sum-step S) ((S y)) () (=_ (sum-step S) (lambda y (<,> (+ (head y) (1)) (+ (tail y) (apply S (head y))))))
  x y S df-sum-step-just lambdaeq1
)

thm (sum-stepseq () () (-> (=_ S T) (=_ (sum-step S) (sum-step T)))
  (=_ S T)  x  alnfi
  S T (head x) applyseq1
  (tail x) addeq2d
  (+ (head x) (1)) opeq2d
  x 19.20i
  syl
  lambdaeq2d
  S x df-sum-step seqcomi
  SeqReplaceImp1Seq0
  T x df-sum-step seqcomi  
  SeqReplaceImp1Seq1
)

thm (sum-stepseqi () (
     hyp1 (=_ S T))
     (=_ (sum-step S) (sum-step T))
  hyp1
  S T sum-stepseq
  ax-mp
)

thm (sum-stepseqd () (
     hyp1 (-> ph (=_ S T)))
     (-> ph (=_ (sum-step S) (sum-step T)))
  hyp1
  S T sum-stepseq
  syl
)

## <title> Substitution </title>
## <table>
##   (-> ph (= (apply  [ S ]   ]   ]  A) B))
##   (=_               [ S ]   [ T ] )
##   (-> ph (= (apply  [   [   [ T ]  A) B))
## </table>
thm (SeqReplaceImp1Eq0Apply0 () (
     replacee (-> ph (= (apply S A) B))
     substitution (=_ S T)) 
     (-> ph (= (apply T A) B))
  replacee substitution
  A applyseq1i
  EqReplaceImp1Eq0
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (<,>  [ B ]   ]   ]  D)))
##   (=                [ B ]   [ C ] )
##   (-> ph (= A (<,>  [   [   [ C ]  D)))
## </table>
thm (EqReplaceImp1Eq1Op0 () (
     replacee (-> ph (= A (<,> B D)))
     substitution (= B C)) 
     (-> ph (= A (<,> C D)))
  replacee substitution
  D opeq1i
  EqReplaceImp1Eq1
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (<,> (+  [ B ]   ]   ]  D) A')))
##   (=                   [ B ]   [ C ] )
##   (-> ph (= A (<,> (+  [   [   [ C ]  D) A')))
## </table>
thm (EqReplaceImp1Eq1Op0Add0 () (
     replacee (-> ph (= A (<,> (+ B D) A')))
     substitution (= B C)) 
     (-> ph (= A (<,> (+ C D) A')))
  replacee substitution
  D addeq1i
  EqReplaceImp1Eq1Op0
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (<,> B  [ C ]   ]   ] )))
##   (=                  [ C ]   [ D ] )
##   (-> ph (= A (<,> B  [   [   [ D ] )))
## </table>
thm (EqReplaceImp1Eq1Op1 () (
     replacee (-> ph (= A (<,> B C)))
     substitution (= C D)) 
     (-> ph (= A (<,> B D)))
  replacee substitution
  B opeq2i
  EqReplaceImp1Eq1
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (<,> B (+  [ C ]   ]   ]  A'))))
##   (=                     [ C ]   [ D ] )
##   (-> ph (= A (<,> B (+  [   [   [ D ]  A'))))
## </table>
thm (EqReplaceImp1Eq1Op1Add0 () (
     replacee (-> ph (= A (<,> B (+ C A'))))
     substitution (= C D)) 
     (-> ph (= A (<,> B (+ D A'))))
  replacee substitution
  A' addeq1i
  EqReplaceImp1Eq1Op1
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (<,> B (+ C  [ D ]   ]    ] ))))
##   (=                       [ D ]   [ A' ] )
##   (-> ph (= A (<,> B (+ C  [   [   [ A' ] ))))
## </table>
thm (EqReplaceImp1Eq1Op1Add1 () (
     replacee (-> ph (= A (<,> B (+ C D))))
     substitution (= D A')) 
     (-> ph (= A (<,> B (+ C A'))))
  replacee substitution
  C addeq2i
  EqReplaceImp1Eq1Op1
)


## <title> Substitution </title>
## <table>
##   (-> ph (= A (<,> B (+ C (apply S  [ D ]   ]    ] )))))
##   (=                                [ D ]   [ A' ] )
##   (-> ph (= A (<,> B (+ C (apply S  [   [   [ A' ] )))))
## </table>
thm (EqReplaceImp1Eq1Op1Add1Apply1 () (
     replacee (-> ph (= A (<,> B (+ C (apply S D)))))
     substitution (= D A')) 
     (-> ph (= A (<,> B (+ C (apply S A')))))
  replacee substitution
  S applyeq2i
  EqReplaceImp1Eq1Op1Add1
)

## <title> Substitution </title>
## <table>
##   (= (apply  [ S ]   ]   ]  A) B)
##   (=_        [ S ]   [ T ] )
##   (= (apply  [   [   [ T ]  A) B)
## </table>
thm (SeqReplaceEq0Apply0 () (
     replacee (= (apply S A) B)
     substitution (=_ S T)) 
     (= (apply T A) B)
  replacee substitution
  A applyseq1i
  EqReplaceEq0
)

thm (sumrecurrence () () (= (apply (sum-step S) (<,> A B)) (<,> (+ A (1)) (+ B (apply S A))))
  x y S df-sum-step-just
  x (<,> A B) S df-sum-step-just
  ## <d 'Apply Head Operator '>
    A B headop
    EqReplaceImp1Eq1Op0Add0
  ## </d 'Apply Head Operator '>

  ## <d 'Apply Tail Operator '>
    A B tailop
    EqReplaceImp1Eq1Op1Add0
  ## </d 'Apply Tail Operator '>

  ## <d 'Apply Head Operator '>
    A B headop
    EqReplaceImp1Eq1Op1Add1Apply1
  ## </d 'Apply Head Operator '>
  applylambda
    S x df-sum-step

  ## <d 'Commutative Property '>
    (sum-step S) (lambda x (<,> (+ (head x) (1)) (+ (tail x) (apply S (head x))))) seqcom
    mpbi
  ## </d 'Commutative Property '>
  
  SeqReplaceEq0Apply0
)

thm (fun-sum-step () () (fun (sum-step S))
  x y S df-sum-step-just
  funlambda
  S x df-sum-step  
  ## <d 'Commutative Property '>
    (sum-step S) (lambda x (<,> (+ (head x) (1)) (+ (tail x) (apply S (head x))))) seqcom
    mpbi
  ## </d 'Commutative Property '>  
  funseqi
  mpbi
)

thm (head-sum-step.1 () () (= (head (apply (sum-step S) A)) (+ (head A) (1)))
  x y S df-sum-step-just
  x A S df-sum-step-just
  applylambda
  S x df-sum-step
  ## <d 'Commutative Property '>
    (sum-step S) (lambda x (<,> (+ (head x) (1)) (+ (tail x) (apply S (head x))))) seqcom
    mpbi
  ## </d 'Commutative Property '>
  SeqReplaceEq0Apply0
  headeqi
  
  ## <d 'Apply Head Operator '>
    (+ (head A) (1)) (+ (tail A) (apply S (head A))) headop
    EqReplaceEq1
  ## </d 'Apply Head Operator '>
)

thm (head-sum-step.2 () () (-> (= C D) (<-> (= (head (recurse (sum-step S) C (<,> A B))) (+ A C)) (= (head (recurse (sum-step S) D (<,> A B))) (+ A D)))) 
  C D (sum-step S) (<,> A B) recurseeq2
  headeqd
  (= C D) id
  A addeq2d
  eqeq12d
)

## <title> Substitution </title>
## <table>
##   (-> ph (<-> (=  [ A ]   ]   ]  C) ps))
##   (=              [ A ]   [ B ] )
##   (-> ph (<-> (=  [   [   [ B ]  C) ps))
## </table>
thm (EqReplaceImp1Bi0Eq0 () (
     replacee (-> ph (<-> (= A C) ps))
     substitution (= A B)) 
     (-> ph (<-> (= B C) ps))
  replacee substitution
  C eqeq1i
  BiReplaceImp1Bi0
)

thm (head-sum-step () () (= (head (recurse (sum-step S) C (<,> A B))) (+ A C))
  x (0) S A B head-sum-step.2
  x y S A B head-sum-step.2
  x (+ y (1)) S A B head-sum-step.2
  x C S A B head-sum-step.2

  S fun-sum-step
  (<,> A B) recurse0
  headeqi
  
  ## <d 'Apply Head Operator '>
    A B headop
    EqReplaceEq1
  ## </d 'Apply Head Operator '>
  A pa_ax3
  eqcomi
  eqtr

  (head (recurse (sum-step S) y (<,> A B))) (+ A y) (1) addeq1
  (head (recurse (sum-step S) (+ y (1)) (<,> A B))) eqeq2d

  S fun-sum-step
  y (<,> A B) recursesuc
  headeqi
  S (recurse (sum-step S) y (<,> A B)) head-sum-step.1  
  EqReplaceEq1
  
  (= (head (recurse (sum-step S) (+ y (1)) (<,> A B))) (+ (+ A y) (1))) biRemove1
  (= (head (recurse (sum-step S) y (<,> A B))) (+ A y)) imbi2i
  mpbi
  
  ## <d 'Associative Property '>
    A y (1) addass
    EqReplaceImp1Eq1
  ## </d 'Associative Property '>
  findplus1
)

thm (tail-sum-step.1 () () (= (tail (apply (sum-step S) A)) (+ (tail A) (apply S (head A))))
  x y S df-sum-step-just
  x A S df-sum-step-just
  applylambda
  S x df-sum-step
  ## <d 'Commutative Property '>
    (sum-step S) (lambda x (<,> (+ (head x) (1)) (+ (tail x) (apply S (head x))))) seqcom
    mpbi
  ## </d 'Commutative Property '>
  SeqReplaceEq0Apply0
  taileqi  
  ## <d 'Apply Tail Operator '>
    (+ (head A) (1)) (+ (tail A) (apply S (head A))) tailop
    EqReplaceEq1
  ## </d 'Apply Tail Operator '>
)

## <title> Substitution </title>
## <table>
##   (= A (+ B (apply S  [ C ]   ]   ] )))
##   (=                  [ C ]   [ D ] )
##   (= A (+ B (apply S  [   [   [ D ] )))
## </table>
thm (EqReplaceEq1Add1Apply1 () (
     replacee (= A (+ B (apply S C)))
     substitution (= C D)) 
     (= A (+ B (apply S D)))
  replacee substitution
  S applyeq2i
  EqReplaceEq1Add1
)

## <suggest> right('Equivalence', 'rec') </suggest>
thm (tail-sum-step () () (= (tail (recurse (sum-step S) (+ B (1)) (<,> A C))) (+ (tail (recurse (sum-step S) B (<,> A C))) (apply S (+ A B))))
  S fun-sum-step
  B (<,> A C) recursesuc
  taileqi  
  S (recurse (sum-step S) B (<,> A C)) tail-sum-step.1  
  EqReplaceEq1
  S B A C head-sum-step
  EqReplaceEq1Add1Apply1
)

# Sum a sequence of numbers from a function. Capital Sigma.
## <suggest> right('Define', 'Σ') left('Simplify', 'Σ') </suggest>
defthm (df-sum nat (sum A B S) () () (= (sum A B S) (tail (recurse (sum-step S) (.- (+ B (1)) A) (<,> A (0)))))
		(tail (recurse (sum-step S) (.- (+ B (1)) A) (<,> A (0)))) eqid
)

defthm (df-applyset set ({.|} S T) ((S y) (T y) (S z) (T z)) () (=_ ({.|} S T) ({|} y (E. z (/\ (= y (apply S z)) (e. z T)))))
  x y (apply S z) eqeq1
  (e. z T) anbi1d
  z exbid
  z w S applyeq2
  x eqeq2d
  z w T ax-eleq1
  anbi12d
  exalpha  
  BiReplaceImp1Bi0
  abeq
)

## <title> Equivalence for {.|} </title> ##
thm (applysetseq1 () () (-> (=_ S U) (=_ ({.|} S T) ({.|} U T)))
  S U z applyseq1
  y eqeq2d
  (e. z T) anbi1d
  z exbid
  y abbi2d
  S T y z df-applyset
  ## <d 'Commutative Property'>
    ({.|} S T) ({|} y (E. z (/\ (= y (apply S z)) (e. z T)))) seqcom
    mpbi
  ## </d 'Commutative Property'>
  SeqReplaceImp1Seq0
  U T y z df-applyset
  ## <d 'Commutative Property'>
    ({.|} U T) ({|} y (E. z (/\ (= y (apply U z)) (e. z T)))) seqcom
    mpbi
  ## </d 'Commutative Property'>
  SeqReplaceImp1Seq1
)

thm (applysetseq1i () (
     hyp1 (=_ S U))
     (=_ ({.|} S T) ({.|} U T))
  hyp1
  S U T applysetseq1
  ax-mp
)

thm (applysetseq1d () (
     hyp1 (-> ph (=_ S U)))
     (-> ph (=_ ({.|} S T) ({.|} U T)))
  hyp1
  S U T applysetseq1
  syl
)

## <title> Equivalence for {.|} </title> ##
thm (applysetseq2 () () (-> (=_ T U) (=_ ({.|} S T) ({.|} S U)))
  T U z eleq2
  (= y (apply S z)) anbi2d
  z exbid
  y abbi2d
  S T y z df-applyset
  ## <d 'Commutative Property'>
    ({.|} S T) ({|} y (E. z (/\ (= y (apply S z)) (e. z T)))) seqcom
    mpbi
  ## </d 'Commutative Property'>
  SeqReplaceImp1Seq0
  S U y z df-applyset
  ## <d 'Commutative Property'>
    ({.|} S U) ({|} y (E. z (/\ (= y (apply S z)) (e. z U)))) seqcom
    mpbi
  ## </d 'Commutative Property'>
  SeqReplaceImp1Seq1
)

thm (applysetseq2i () (
     hyp1 (=_ T U))
     (=_ ({.|} S T) ({.|} S U))
  hyp1
  T U S applysetseq2
  ax-mp
)

thm (applysetseq2d () (
     hyp1 (-> ph (=_ T U)))
     (-> ph (=_ ({.|} S T) ({.|} S U)))
  hyp1
  T U S applysetseq2
  syl
)

thm (applysetseq12 () () (-> (/\ (=_ S T) (=_ U V)) (=_ ({.|} S U) ({.|} T V)))
  S T U applysetseq1
  U V T applysetseq2
  pm3.2i  
  ## <d 'Praeclarum Theorema '>
    (=_ S T) (=_ ({.|} S U) ({.|} T U)) (=_ U V) (=_ ({.|} T U) ({.|} T V)) prth
    ax-mp
  ## </d 'Praeclarum Theorema '>
  
  ## <d 'Transitive Property '>
    ({.|} S U) ({.|} T U) ({.|} T V) seqtr
    syl
  ## </d 'Transitive Property '>
)

## <title> Substitution </title>
## <table>
##   (e. A  [ S ]   ]   ] )
##   (=_    [ S ]   [ T ] )
##   (e. A  [   [   [ T ] )
## </table>
thm (SeqReplaceEl1 () (
     replacee (e. A S)
     substitution (=_ S T)) 
     (e. A T)
  replacee substitution
  A eleq2i
  mpbi
)

thm (elapplyset ((S y) (T y) (A y)) () (<-> (e. A ({.|} S T)) (E. y (/\ (= A (apply S y)) (e. y T))))
  S T x y df-applyset
  A eleq2i  
  ## <d>
    A x (E. y (/\ (= x (apply S y)) (e. y T))) ax-elab
    bitri
  ## </d>
  x A (apply S y) eqeq1
  (e. y T)
  anbi1d
  y exbid
  sbcie  
  bitri
)

thm (elappliedset () () (-> (e. A T) (e. (apply S A) ({.|} S T)))
  A x S applyeq2  
  ## <d 'Symmetric Property '>
    A x eqcom
    sylbi2
  ## </d 'Symmetric Property '>
  (e. A T) a1i
  x A T ax-eleq1  
  ## <d 'Infer Right to Left '>
    (e. x T) (e. A T) bi2
    syl
  ## </d 'Infer Right to Left '>
  com12
  jcad
  x 19.22d
  x A tyex  
  (E. x (/\ (= (apply S A) (apply S x)) (e. x T))) impRemove1
  (e. A T) imbi2i
  mpbi

  (apply S A) S T x elapplyset bicomi  
  sylib
)



## <title> Substitution </title>
## <table>
##   (<-> ph (A. x (-.  [ ps ]   ]    ] )))
##   (<->               [ ps ]   [ ch ] )
##   (<-> ph (A. x (-.  [    [   [ ch ] )))
## </table>
thm (BiReplaceBi1Al1Not0 () (
     replacee (<-> ph (A. x (-. ps)))
     substitution (<-> ps ch)) 
     (<-> ph (A. x (-. ch)))
  replacee substitution
  con4biir
  BiReplaceBi1Al1
)

## <title> Substitution </title>
## <table>
##   (<-> ph (A. x (-> ps (-.  [ ch ]   ]    ] ))))
##   (<->                      [ ch ]   [ th ] )
##   (<-> ph (A. x (-> ps (-.  [    [   [ th ] ))))
## </table>
thm (BiReplaceBi1Al1Imp1Not0 () (
     replacee (<-> ph (A. x (-> ps (-. ch))))
     substitution (<-> ch th)) 
     (<-> ph (A. x (-> ps (-. th))))
  replacee substitution
  con4biir
  BiReplaceBi1Al1Imp1
)

thm (notelapplyset ((S x) (T x) (A x)) () (<-> (-. (e. A ({.|} S T))) (A. x (-> (e. x T) (-. (= (apply S x) A))))) 
  A S T x elapplyset
  ## <d 'Negate Both Sides '>
    (e. A ({.|} S T)) (E. x (/\ (= A (apply S x)) (e. x T))) notbi
    mpbi
  ## </d 'Negate Both Sides '>
  
  ## <d 'Definition of ∃ '>
    x (/\ (= A (apply S x)) (e. x T)) df-ex
    BiReplaceBi1Not0
    (A. x (-. (/\ (= A (apply S x)) (e. x T)))) notnotr
    bitri
  ## </d 'Double Negative '>
  
  ## <d 'Definition of AND '>
    (= A (apply S x)) (e. x T) df-an
    BiReplaceBi1Al1Not0
  ## </d 'Definition of AND '>
  
  ## <d 'Double Negative '>
    (-> (= A (apply S x)) (-. (e. x T))) notnotr
    BiReplaceBi1Al1
  ## </d 'Double Negative '>
  
  ## <d 'Negate Both Sides '>
    (= A (apply S x)) (-. (e. x T)) con34b
    (e. x T) notnotr
    BiReplaceBi1Imp0
    BiReplaceBi1Al1
  ## </d 'Negate Both Sides '>
  
  ## <d 'Symmetric Property '>
    A (apply S x) eqcom
    BiReplaceBi1Al1Imp1Not0
  ## </d 'Symmetric Property '>
)

## <title> Equivalence for sum </title> ##
thm (sumeq1 () () (-> (= A C) (= (sum A B S) (sum C B S)))
  A C (+ B (1)) halfminuseq2
  A C (0) opeq1
  jca
  (.- (+ B (1)) A) (.- (+ B (1)) C) (<,> A (0)) (<,> C (0)) (sum-step S) recurseeq23   
  syl
  taileqd
    
  ## <d>
    A B S df-sum
    ## <d 'Commutative Property'>
      (sum A B S) (tail (recurse (sum-step S) (.- (+ B (1)) A) (<,> A (0)))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq0
  ## </d>
  
  ## <d>
    C B S df-sum
    ## <d 'Commutative Property'>
      (sum C B S) (tail (recurse (sum-step S) (.- (+ B (1)) C) (<,> C (0)))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq1
  ## </d>
)

thm (sumeq1i () (
     hyp1 (= A C))
     (= (sum A B S) (sum C B S))
  hyp1
  A C B S sumeq1
  ax-mp
)

thm (sumeq1d () (
     hyp1 (-> ph (= A C)))
     (-> ph (= (sum A B S) (sum C B S)))
  hyp1
  A C B S sumeq1
  syl
)

## <title> Equivalence for sum </title> ##
thm (sumeq2 () () (-> (= B C) (= (sum A B S) (sum A C S)))
  B C (1) addeq1
  A halfminuseq1d
  (sum-step S) (<,> A (0)) recurseeq2d
  taileqd
  A B S df-sum
  ## <d 'Commutative Property'>
    (sum A B S) (tail (recurse (sum-step S) (.- (+ B (1)) A) (<,> A (0)))) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq0
  A C S df-sum
  ## <d 'Commutative Property'>
    (sum A C S) (tail (recurse (sum-step S) (.- (+ C (1)) A) (<,> A (0)))) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq1
)

thm (sumeq2i () (
     hyp1 (= B C))
     (= (sum A B S) (sum A C S))
  hyp1
  B C A S sumeq2
  ax-mp
)

## <title> Equivalence for sum </title> ##
thm (sumseq3 () () (-> (=_ S T) (= (sum A B S) (sum A B T)))
  S T sum-stepseq
  (.- (+ B (1)) A) (<,> A (0)) recurseseq1d
  taileqd
  A B S df-sum
  ## <d 'Commutative Property'>
    (sum A B S) (tail (recurse (sum-step S) (.- (+ B (1)) A) (<,> A (0)))) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq0
  A B T df-sum
  ## <d 'Commutative Property'>
    (sum A B T) (tail (recurse (sum-step T) (.- (+ B (1)) A) (<,> A (0)))) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq1
)


thm (sumeq2d () (
     hyp1 (-> ph (= B C)))
     (-> ph (= (sum A B S) (sum A C S)))
  hyp1
  B C A S sumeq2
  syl
)

thm (sumseq3i () (
     hyp1 (=_ S T))
     (= (sum A B S) (sum A B T))
  hyp1
  S T A B sumseq3
  ax-mp
)

thm (sumseq3d () (
     hyp1 (-> ph (=_ S T)))
     (-> ph (= (sum A B S) (sum A B T)))
  hyp1
  S T A B sumseq3
  syl
)

thm (sumeq23 () () (-> (/\ (= A B) (=_ S T)) (= (sum C A S) (sum C B T)))
  A B C S sumeq2
  S T C B sumseq3
  pm3.2i  
  ## <d 'Praeclarum Theorema '>
    (= A B) (= (sum C A S) (sum C B S)) (=_ S T) (= (sum C B S) (sum C B T)) prth
    ax-mp
  ## </d 'Praeclarum Theorema '>
  
  ## <d 'Transitive Property '>
    (sum C A S) (sum C B S) (sum C B T) eqtr1
    syl
  ## </d 'Transitive Property '>
)

## <title> Substitution </title>
## <table>
##   (= A (tail  [ B ]   ]   ] ))
##   (=          [ B ]   [ C ] )
##   (= A (tail  [   [   [ C ] ))
## </table>
thm (EqReplaceEq1Tail0 () (
     replacee (= A (tail B))
     substitution (= B C)) 
     (= A (tail C))
  replacee substitution
  taileqi
  EqReplaceEq1
)


## <title> Substitution </title>
## <table>
##   (= A (tail (recurse S  [ B ]   ]   ]  D)))
##   (=                     [ B ]   [ C ] )
##   (= A (tail (recurse S  [   [   [ C ]  D)))
## </table>
thm (EqReplaceEq1Tail0Recurse1 () (
     replacee (= A (tail (recurse S B D)))
     substitution (= B C)) 
     (= A (tail (recurse S C D)))
  replacee substitution
  S D recurseeq2i
  EqReplaceEq1Tail0
)


## <title> Substitution </title>
## <table>
##   (= A (tail (recurse S (+  [ B ]   ]   ]  D) A')))
##   (=                        [ B ]   [ C ] )
##   (= A (tail (recurse S (+  [   [   [ C ]  D) A')))
## </table>
thm (EqReplaceEq1Tail0Recurse1Add0 () (
     replacee (= A (tail (recurse S (+ B D) A')))
     substitution (= B C)) 
     (= A (tail (recurse S (+ C D) A')))
  replacee substitution
  D addeq1i
  EqReplaceEq1Tail0Recurse1
)


## <title> Substitution </title>
## <table>
##   (= A (+ (tail  [ B ]   ]   ] ) D))
##   (=             [ B ]   [ C ] )
##   (= A (+ (tail  [   [   [ C ] ) D))
## </table>
thm (EqReplaceEq1Add0Tail0 () (
     replacee (= A (+ (tail B) D))
     substitution (= B C)) 
     (= A (+ (tail C) D))
  replacee substitution
  taileqi
  EqReplaceEq1Add0
)



## <title> Substitution </title>
## <table>
##   (= (tail  [ A ]   ]   ] ) C)
##   (=        [ A ]   [ B ] )
##   (= (tail  [   [   [ B ] ) C)
## </table>
thm (EqReplaceEq0Tail0 () (
     replacee (= (tail A) C)
     substitution (= A B)) 
     (= (tail B) C)
  replacee substitution
  taileqi
  EqReplaceEq0
)


## <title> Substitution </title>
## <table>
##   (= (tail (recurse S  [ A ]   ]   ]  C)) D)
##   (=                   [ A ]   [ B ] )
##   (= (tail (recurse S  [   [   [ B ]  C)) D)
## </table>
thm (EqReplaceEq0Tail0Recurse1 () (
     replacee (= (tail (recurse S A C)) D)
     substitution (= A B)) 
     (= (tail (recurse S B C)) D)
  replacee substitution
  S C recurseeq2i
  EqReplaceEq0Tail0
)

## <title> Sum a sequence of One Number </title>
thm (sum1 () () (= (sum A A S) (apply S A))
  A A S df-sum
  A leid
  A A (1) halfminusaddcom
  ax-mp
  eqcomi  
  
  ## <d 'A number minus itself is zero '>
    A halfminusid
    EqReplaceEq1Add0
  ## </d 'A number minus itself is zero '>
  
  ## <d 'Additive Identity Axiom '>
    (1) pa_ax3r
    EqReplaceEq1
  ## </d 'Additive Identity Axiom '>
  EqReplaceEq1Tail0Recurse1

  S (0) A (0) tail-sum-step  
  ## <d 'Additive Identity Axiom '>
    (1) pa_ax3r
    EqReplaceEq0Tail0Recurse1
  ## </d 'Additive Identity Axiom '>
  
  EqReplaceEq1
  
  ## <d 'Additive Identity Axiom '>
    A pa_ax3
    EqReplaceEq1Add1Apply1
  ## </d 'Additive Identity Axiom '>
  S fun-sum-step
  (<,> A (0)) recurse0    
  EqReplaceEq1Add0Tail0
  
  ## <d 'Apply Tail Operator '>
    A (0) tailop
    EqReplaceEq1Add0
  ## </d 'Apply Tail Operator '>
  
  ## <d 'Additive Identity Axiom '>
    (apply S A) pa_ax3r
    EqReplaceEq1
  ## </d 'Additive Identity Axiom '>
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (tail  [ B ]   ]   ] )))
##   (=                 [ B ]   [ C ] )
##   (-> ph (= A (tail  [   [   [ C ] )))
## </table>
thm (EqReplaceImp1Eq1Tail0 () (
     replacee (-> ph (= A (tail B)))
     substitution (= B C)) 
     (-> ph (= A (tail C)))
  replacee substitution
  taileqi
  EqReplaceImp1Eq1
)

## <title> Sum of an empty sequence </title>
thm (sum0 () () (-> (< B A) (= (sum A B S) (0)))
  ## <d 'Convert between ≤ and < '>
    B A ltle2
  ## </d 'Convert between ≤ and < '>
  (+ B (1)) A halfminus-neg  
  ImpReplaceBi1
  (sum-step S) (<,> A (0)) recurseeq2d
  taileqd  
  ## <d>
    A B S df-sum
    ## <d 'Commutative Property'>
      (sum A B S) (tail (recurse (sum-step S) (.- (+ B (1)) A) (<,> A (0)))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq0
  ## </d>
  S fun-sum-step (<,> A (0)) recurse0  
  EqReplaceImp1Eq1Tail0
  
  ## <d 'Apply Tail Operator '>
    A (0) tailop
    EqReplaceImp1Eq1
  ## </d 'Apply Tail Operator '>
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (+  [ B ]   ]   ]  D)))
##   (=              [ B ]   [ C ] )
##   (-> ph (= A (+  [   [   [ C ]  D)))
## </table>
thm (EqReplaceImp1Eq1Add0 () (
     replacee (-> ph (= A (+ B D)))
     substitution (= B C)) 
     (-> ph (= A (+ C D)))
  replacee substitution
  D addeq1i
  EqReplaceImp1Eq1
)

## <title> Detach the Last Number in a sum </title>
thm (sumdetach () () (-> (< A B) (= (sum A B S) (+ (sum A (.- B (1)) S) (apply S B)))) 
  A B ltle
  A B (1) halfminusaddcom  
  ## <d 'Symmetric Property '>
    (+ (.- B A) (1)) (.- (+ B (1)) A) eqcom
    sylib
  ## </d 'Symmetric Property '>
  (sum-step S)  (<,> A (0)) recurseeq2d
  taileqd

  A B S df-sum eqcomi
  
  EqReplaceImp1Eq0

  S (.- B A) A (0) tail-sum-step  
  EqReplaceImp1Eq1
  syl

  (0) A B lelttr
  A 0le  
  (< A B) anRemove1
  (< (0) B) imbi1i
  mpbi
  
  ## <d 'Convert between ≤ and < '>
    (0) B ltle2
    (1) pa_ax3r
    EqReplaceBi1Le0
    sylib
  ## </d 'Convert between ≤ and < '>
  (1) B halfminus    
  syl  
  ## <d 'Symmetric Property '>
    (+ (.- B (1)) (1)) B eqcom
    sylib
  ## </d 'Symmetric Property '>
  A halfminuseq1d
  (sum-step S)  (<,> A (0)) recurseeq2d
  taileqd
  (apply S (+ A (.- B A))) addeq1d
  eqtrd  
  ## <d>
    A (.- B (1)) S df-sum
    ## <d 'Commutative Property'>
      (sum A (.- B (1)) S) (tail (recurse (sum-step S) (.- (+ (.- B (1)) (1)) A) (<,> A (0)))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq1Add0
  ## </d>

  A B ltle
  A B halfminus
  ## <d 'Commutative Property '>
    (.- B A) A addcom
    EqReplaceImp1Eq0
  ## </d 'Commutative Property '>  
  syl
  S applyeq2d
  (sum A (.- B (1)) S) addeq2d
  eqtrd
)

## <title> Detach the Last Number in a sum </title>
thm (sumdetachi () (hyp (< A B)) (= (sum A B S) (+ (sum A (.- B (1)) S) (apply S B)))
  hyp
  A B S sumdetach
  ax-mp
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (+ (sum B  [ C ]   ]   ]  S) A')))
##   (=                     [ C ]   [ D ] )
##   (-> ph (= A (+ (sum B  [   [   [ D ]  S) A')))
## </table>
thm (EqReplaceImp1Eq1Add0Sum1 () (
     replacee (-> ph (= A (+ (sum B C S) A')))
     substitution (= C D)) 
     (-> ph (= A (+ (sum B D S) A')))
  replacee substitution
  B S sumeq2i
  EqReplaceImp1Eq1Add0
)

## <title> Detach the Last Number in a sum </title>
thm (sumdetach2 () () (= (sum (0) (+ A (1)) S) (+ (sum (0) A S) (apply S (+ A (1)))))
  0less1
  A addge01t2  
  ## <d 'Commutative Property '>
    (1) A addcom
    EqReplaceLt1
  ## </d 'Commutative Property '>

  (0) (+ A (1)) S sumdetach  
  ## <d>
    A (1) halfminuscan
    EqReplaceImp1Eq1Add0Sum1
  ## </d>  
  ax-mp
)

# Product of a sequence.
thm (df-product-step-just () () (-> (= A B) (= (<,> (+ (head A) (1)) (* (tail A) (apply S (head A)))) (<,> (+ (head B) (1)) (* (tail B) (apply S (head B))))))
  A B headeq
  (1) addeq1d
  A B taileq
  A B headeq
  S applyeq2d
  muleq12d
  opeq12d
)

defthm (df-product-step set (product-step S) ((S y)) () (=_ (product-step S) (lambda y (<,> (+ (head y) (1)) (* (tail y) (apply S (head y))))))
  x y S df-product-step-just lambdaeq1
)

thm (product-stepseq () () (-> (=_ S T) (=_ (product-step S) (product-step T)))
  (=_ S T)  x  alnfi
  S T (head x) applyseq1
  (tail x) muleq2d
  (+ (head x) (1)) opeq2d
  x 19.20i
  syl
  lambdaeq2d
  S x df-product-step seqcomi  
  SeqReplaceImp1Seq0
  T x df-product-step seqcomi  
  SeqReplaceImp1Seq1
)

thm (product-stepseqi () (
     hyp1 (=_ S T))
     (=_ (product-step S) (product-step T))
  hyp1
  S T product-stepseq
  ax-mp
)

thm (product-stepseqd () (
     hyp1 (-> ph (=_ S T)))
     (-> ph (=_ (product-step S) (product-step T)))
  hyp1
  S T product-stepseq
  syl
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (<,> B (*  [ C ]   ]   ]  A'))))
##   (=                     [ C ]   [ D ] )
##   (-> ph (= A (<,> B (*  [   [   [ D ]  A'))))
## </table>
thm (EqReplaceImp1Eq1Op1Mul0 () (
     replacee (-> ph (= A (<,> B (* C A'))))
     substitution (= C D)) 
     (-> ph (= A (<,> B (* D A'))))
  replacee substitution
  A' muleq1i
  EqReplaceImp1Eq1Op1
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (<,> B (* C  [ D ]   ]    ] ))))
##   (=                       [ D ]   [ A' ] )
##   (-> ph (= A (<,> B (* C  [   [   [ A' ] ))))
## </table>
thm (EqReplaceImp1Eq1Op1Mul1 () (
     replacee (-> ph (= A (<,> B (* C D))))
     substitution (= D A')) 
     (-> ph (= A (<,> B (* C A'))))
  replacee substitution
  C muleq2i
  EqReplaceImp1Eq1Op1
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (<,> B (* C (apply S  [ D ]   ]    ] )))))
##   (=                                [ D ]   [ A' ] )
##   (-> ph (= A (<,> B (* C (apply S  [   [   [ A' ] )))))
## </table>
thm (EqReplaceImp1Eq1Op1Mul1Apply1 () (
     replacee (-> ph (= A (<,> B (* C (apply S D)))))
     substitution (= D A')) 
     (-> ph (= A (<,> B (* C (apply S A')))))
  replacee substitution
  S applyeq2i
  EqReplaceImp1Eq1Op1Mul1
)

thm (productrecurrence () () (= (apply (product-step S) (<,> A B)) (<,> (+ A (1)) (* B (apply S A))))
  x y S df-product-step-just
  x (<,> A B) S df-product-step-just
  ## <d 'Apply Head Operator '>
    A B headop
    EqReplaceImp1Eq1Op0Add0
  ## </d 'Apply Head Operator '>  
  ## <d 'Apply Tail Operator '>
    A B tailop
    EqReplaceImp1Eq1Op1Mul0
  ## </d 'Apply Tail Operator '>
  
  ## <d 'Apply Head Operator '>
    A B headop
    EqReplaceImp1Eq1Op1Mul1Apply1
  ## </d 'Apply Head Operator '>
  applylambda

  S x df-product-step
  ## <d 'Commutative Property '>
    (product-step S) (lambda x (<,> (+ (head x) (1)) (* (tail x) (apply S (head x))))) seqcom
    mpbi
  ## </d 'Commutative Property '>  
  SeqReplaceEq0Apply0
)

thm (fun-product-step () () (fun (product-step S))
  x y S df-product-step-just
  funlambda
  S x df-product-step  
  ## <d 'Commutative Property '>
    (product-step S) (lambda x (<,> (+ (head x) (1)) (* (tail x) (apply S (head x))))) seqcom
    mpbi
  ## </d 'Commutative Property '>  
  funseqi
  mpbi
)

thm (head-product-step.1 () () (= (head (apply (product-step S) A)) (+ (head A) (1)))
  x y S df-product-step-just
  x A S df-product-step-just
  applylambda
  S x df-product-step
  ## <d 'Commutative Property '>
    (product-step S) (lambda x (<,> (+ (head x) (1)) (* (tail x) (apply S (head x))))) seqcom
    mpbi
  ## </d 'Commutative Property '>
  SeqReplaceEq0Apply0
  headeqi
  
  ## <d 'Apply Head Operator '>
    (+ (head A) (1)) (* (tail A) (apply S (head A))) headop
    EqReplaceEq1
  ## </d 'Apply Head Operator '>
)

thm (head-product-step.2 () () (-> (= C D) (<-> (= (head (recurse (product-step S) C (<,> A B))) (+ A C)) (= (head (recurse (product-step S) D (<,> A B))) (+ A D)))) 
  C D (product-step S) (<,> A B) recurseeq2
  headeqd
  (= C D) id
  A addeq2d
  eqeq12d
)

thm (head-product-step () () (= (head (recurse (product-step S) C (<,> A B))) (+ A C))
  x (0) S A B head-product-step.2
  x y S A B head-product-step.2
  x (+ y (1)) S A B head-product-step.2
  x C S A B head-product-step.2

  S fun-product-step
  (<,> A B) recurse0
  headeqi
  
  ## <d 'Apply Head Operator '>
    A B headop
    EqReplaceEq1
  ## </d 'Apply Head Operator '>
  A pa_ax3
  eqcomi
  eqtr

  (head (recurse (product-step S) y (<,> A B))) (+ A y) (1) addeq1
  (head (recurse (product-step S) (+ y (1)) (<,> A B))) eqeq2d

  S fun-product-step
  y (<,> A B) recursesuc
  headeqi
  S (recurse (product-step S) y (<,> A B)) head-product-step.1  
  EqReplaceEq1
  
  (= (head (recurse (product-step S) (+ y (1)) (<,> A B))) (+ (+ A y) (1))) biRemove1
  (= (head (recurse (product-step S) y (<,> A B))) (+ A y)) imbi2i
  mpbi
  
  ## <d 'Associative Property '>
    A y (1) addass
    EqReplaceImp1Eq1
  ## </d 'Associative Property '>
  findplus1
)

thm (tail-product-step.1 () () (= (tail (apply (product-step S) A)) (* (tail A) (apply S (head A))))
  x y S df-product-step-just
  x A S df-product-step-just
  applylambda
  S x df-product-step
  ## <d 'Commutative Property '>
    (product-step S) (lambda x (<,> (+ (head x) (1)) (* (tail x) (apply S (head x))))) seqcom
    mpbi
  ## </d 'Commutative Property '>
  SeqReplaceEq0Apply0
  taileqi  
  ## <d 'Apply Tail Operator '>
    (+ (head A) (1)) (* (tail A) (apply S (head A))) tailop
    EqReplaceEq1
  ## </d 'Apply Tail Operator '>
)

## <title> Substitution </title>
## <table>
##   (= A (* B (apply S  [ C ]   ]   ] )))
##   (=                  [ C ]   [ D ] )
##   (= A (* B (apply S  [   [   [ D ] )))
## </table>
thm (EqReplaceEq1Mul1Apply1 () (
     replacee (= A (* B (apply S C)))
     substitution (= C D)) 
     (= A (* B (apply S D)))
  replacee substitution
  S applyeq2i
  EqReplaceEq1Mul1
)

## <suggest> right('Equivalence', 'rec') </suggest>
thm (tail-product-step () () (= (tail (recurse (product-step S) (+ B (1)) (<,> A C))) (* (tail (recurse (product-step S) B (<,> A C))) (apply S (+ A B))))
  S fun-product-step
  B (<,> A C) recursesuc
  taileqi  
  S (recurse (product-step S) B (<,> A C)) tail-product-step.1  
  EqReplaceEq1
  S B A C head-product-step
  
  EqReplaceEq1Mul1Apply1
)

# Multiply a sequence of numbers from a function. Capital Pi.
## <suggest> right('Define', 'Π') left('Simplify', 'Π') </suggest>
defthm (df-product nat (product A B S) () () (= (product A B S) (tail (recurse (product-step S) (.-  (+ B (1)) A) (<,> A (1)))))
		(tail (recurse (product-step S) (.-  (+ B (1)) A) (<,> A (1)))) eqid
)

## <title> Equivalence for product </title> ##
thm (producteq1 () () (-> (= A C) (= (product A B S) (product C B S)))
  A C (+ B (1)) halfminuseq2
  A C (1) opeq1
  jca
  (.- (+ B (1)) A) (.- (+ B (1)) C) (<,> A (1)) (<,> C (1)) (product-step S) recurseeq23   
  syl
  taileqd
    
  ## <d>
    A B S df-product
    ## <d 'Commutative Property'>
      (product A B S) (tail (recurse (product-step S) (.- (+ B (1)) A) (<,> A (1)))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq0
  ## </d>
  
  ## <d>
    C B S df-product
    ## <d 'Commutative Property'>
      (product C B S) (tail (recurse (product-step S) (.- (+ B (1)) C) (<,> C (1)))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq1
  ## </d>
)

thm (producteq1i () (
     hyp1 (= A C))
     (= (product A B S) (product C B S))
  hyp1
  A C B S producteq1
  ax-mp
)


thm (producteq1d () (
     hyp1 (-> ph (= A C)))
     (-> ph (= (product A B S) (product C B S)))
  hyp1
  A C B S producteq1
  syl
)

## <title> Equivalence for product </title> ##
thm (producteq2 () () (-> (= B C) (= (product A B S) (product A C S)))
  B C (1) addeq1
  A halfminuseq1d
  (product-step S) (<,> A (1)) recurseeq2d
  taileqd
  A B S df-product
  ## <d 'Commutative Property'>
    (product A B S) (tail (recurse (product-step S) (.- (+ B (1)) A) (<,> A (1)))) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq0
  A C S df-product
  ## <d 'Commutative Property'>
    (product A C S) (tail (recurse (product-step S) (.- (+ C (1)) A) (<,> A (1)))) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq1
)

thm (producteq2i () (
     hyp1 (= B C))
     (= (product A B S) (product A C S))
  hyp1
  B C A S producteq2
  ax-mp
)

## <title> Equivalence for product </title> ##
thm (productseq3 () () (-> (=_ S T) (= (product A B S) (product A B T)))
  S T product-stepseq
  (.- (+ B (1)) A) (<,> A (1)) recurseseq1d
  taileqd
  A B S df-product
  ## <d 'Commutative Property'>
    (product A B S) (tail (recurse (product-step S) (.- (+ B (1)) A) (<,> A (1)))) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq0
  A B T df-product
  ## <d 'Commutative Property'>
    (product A B T) (tail (recurse (product-step T) (.- (+ B (1)) A) (<,> A (1)))) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq1
)


thm (producteq2d () (
     hyp1 (-> ph (= B C)))
     (-> ph (= (product A B S) (product A C S)))
  hyp1
  B C A S producteq2
  syl
)

thm (productseq3i () (
     hyp1 (=_ S T))
     (= (product A B S) (product A B T))
  hyp1
  S T A B productseq3
  ax-mp
)

thm (productseq3d () (
     hyp1 (-> ph (=_ S T)))
     (-> ph (= (product A B S) (product A B T)))
  hyp1
  S T A B productseq3
  syl
)

thm (producteq23 () () (-> (/\ (= A B) (=_ S T)) (= (product C A S) (product C B T)))
  A B C S producteq2
  S T C B productseq3
  pm3.2i  
  ## <d 'Praeclarum Theorema '>
    (= A B) (= (product C A S) (product C B S)) (=_ S T) (= (product C B S) (product C B T)) prth
    ax-mp
  ## </d 'Praeclarum Theorema '>
  
  ## <d 'Transitive Property '>
    (product C A S) (product C B S) (product C B T) eqtr1
    syl
  ## </d 'Transitive Property '>
)

## <title> Substitution </title>
## <table>
##   (= A (* (tail  [ B ]   ]   ] ) D))
##   (=             [ B ]   [ C ] )
##   (= A (* (tail  [   [   [ C ] ) D))
## </table>
thm (EqReplaceEq1Mul0Tail0 () (
     replacee (= A (* (tail B) D))
     substitution (= B C)) 
     (= A (* (tail C) D))
  replacee substitution
  taileqi
  EqReplaceEq1Mul0
)

## <title> Multiply a sequence of One Number </title>
thm (product1 () () (= (product A A S) (apply S A))
  A A S df-product
  A leid
  A A (1) halfminusaddcom
  ax-mp
  eqcomi  
  
  ## <d 'A number minus itself is zero '>
    A halfminusid
    EqReplaceEq1Add0
  ## </d 'A number minus itself is zero '>
  
  ## <d 'Additive Identity Axiom '>
    (1) pa_ax3r
    EqReplaceEq1
  ## </d 'Additive Identity Axiom '>
  EqReplaceEq1Tail0Recurse1

  S (0) A (1) tail-product-step  
  ## <d 'Additive Identity Axiom '>
    (1) pa_ax3r
    EqReplaceEq0Tail0Recurse1
  ## </d 'Additive Identity Axiom '>
  
  EqReplaceEq1
  ## <d 'Additive Identity Axiom '>
    A pa_ax3
    EqReplaceEq1Mul1Apply1
  ## </d 'Additive Identity Axiom '>

  S fun-product-step
  (<,> A (1)) recurse0
  EqReplaceEq1Mul0Tail0

  ## <d 'Apply Tail Operator '>
    A (1) tailop
    EqReplaceEq1Mul0
  ## </d 'Apply Tail Operator '>

  ## <d 'Multiplicative Identity '>
    (apply S A) mulidr
    EqReplaceEq1
  ## </d 'Multiplicative Identity '>
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (*  [ B ]   ]   ]  D)))
##   (=              [ B ]   [ C ] )
##   (-> ph (= A (*  [   [   [ C ]  D)))
## </table>
thm (EqReplaceImp1Eq1Mul0 () (
     replacee (-> ph (= A (* B D)))
     substitution (= B C)) 
     (-> ph (= A (* C D)))
  replacee substitution
  D muleq1i
  EqReplaceImp1Eq1
)

## <title> Detach the last number in a product </title>
thm (productdetach () () (-> (< A B) (= (product A B S) (* (product A (.- B (1)) S) (apply S B)))) 
  A B ltle
  A B (1) halfminusaddcom  
  ## <d 'Symmetric Property '>
    (+ (.- B A) (1)) (.- (+ B (1)) A) eqcom
    sylib
  ## </d 'Symmetric Property '>
  (product-step S)  (<,> A (1)) recurseeq2d
  taileqd

  A B S df-product eqcomi
  
  EqReplaceImp1Eq0

  S (.- B A) A (1) tail-product-step  
  EqReplaceImp1Eq1
  syl  

  (0) A B lelttr
  A 0le  
  (< A B) anRemove1
  (< (0) B) imbi1i
  mpbi
  
  ## <d 'Convert between ≤ and < '>
    (0) B ltle2
    (1) pa_ax3r
    EqReplaceBi1Le0
    sylib
  ## </d 'Convert between ≤ and < '>
  (1) B halfminus    
  syl  
  ## <d 'Symmetric Property '>
    (+ (.- B (1)) (1)) B eqcom
    sylib
  ## </d 'Symmetric Property '>
  A halfminuseq1d
  (product-step S)  (<,> A (1)) recurseeq2d
  taileqd
  (apply S (+ A (.- B A))) muleq1d
  eqtrd

  ## <d>
    A (.- B (1)) S df-product
    ## <d 'Commutative Property'>
      (product A (.- B (1)) S) (tail (recurse (product-step S) (.- (+ (.- B (1)) (1)) A) (<,> A (1)))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq1Mul0
  ## </d>

  A B ltle
  A B halfminus
  ## <d 'Commutative Property '>
    (.- B A) A addcom
    EqReplaceImp1Eq0
  ## </d 'Commutative Property '>  
  syl
  S applyeq2d
  (product A (.- B (1)) S) muleq2d
  eqtrd
)

## <title> Detach the last number in a product </title>
thm (productdetachi () (hyp (< A B)) (= (product A B S) (* (product A (.- B (1)) S) (apply S B)))
  hyp
  A B S productdetach
  ax-mp
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (* (product B  [ C ]   ]   ]  S) A')))
##   (=                         [ C ]   [ D ] )
##   (-> ph (= A (* (product B  [   [   [ D ]  S) A')))
## </table>
thm (EqReplaceImp1Eq1Mul0Product1 () (
     replacee (-> ph (= A (* (product B C S) A')))
     substitution (= C D)) 
     (-> ph (= A (* (product B D S) A')))
  replacee substitution
  B S producteq2i
  EqReplaceImp1Eq1Mul0
)

thm (productdetach1 () () (-> (<= (1) A) (= (product (1) (+ A (1)) S) (* (product (1) A S) (apply S (+ A (1))))))
  (1) (+ A (1)) S productdetach    
  ## <d>
    A (1) halfminuscan
    EqReplaceImp1Eq1Mul0Product1
  ## </d>
  
  ## <d 'Convert between ≤ and < '>
    (1) A lePlus1
    sylbi2
  ## </d 'Convert between ≤ and < '>
)

## <title> Multiply an empty sequence </title>
thm (product0 () () (-> (< B A) (= (product A B S) (1)))
  ## <d 'Convert between ≤ and < '>
    B A ltle2
  ## </d 'Convert between ≤ and < '>
  (+ B (1)) A halfminus-neg  
  ImpReplaceBi1
  (product-step S) (<,> A (1)) recurseeq2d
  taileqd  
  ## <d>
    A B S df-product
    ## <d 'Commutative Property'>
      (product A B S) (tail (recurse (product-step S) (.- (+ B (1)) A) (<,> A (1)))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq0
  ## </d>
  S fun-product-step (<,> A (1)) recurse0  
  EqReplaceImp1Eq1Tail0
  
  ## <d 'Apply Tail Operator '>
    A (1) tailop
    EqReplaceImp1Eq1
  ## </d 'Apply Tail Operator '>
)


## <summary>
##   Unfortunately, this is much more complicated because 0 .- 1 = 0. We need to check that B > 0, because
##   the value:
##     product 0 (.= 0 1) S = S(0), not 1 as we'd expect if we were using a real minus and not a halfminus.
## </summary>
thm (productdetach2 () () (-> (/\ (< (0) B) (<= A B)) (= (product A B S) (* (product A (.- B (1)) S) (apply S B))))
  (0) B (1) ltadd1
  ## <d 'Additive Identity Axiom '>
    (1) pa_ax3r
    EqReplaceBi1Lt0
  ## </d 'Additive Identity Axiom '>
  (1) B halfminus
  
  ## <d 'Equality Conversion '>
    (+ (.- B (1)) (1)) B eqle
    syl
  ## </d 'Equality Conversion '>
  (.- B (1)) B ltle2 bicomi
  sylib
  
  ## <d 'Convert between ≤ and < '>
    (1) B lePlus1
    ## <d 'Commutative Property'>
      (< (1) (+ B (1))) (<= (1) B) bicom
      mpbi
    ## </d 'Commutative Property'>
    sylbi2
  ## </d 'Convert between ≤ and < '>  
  ImpReplaceBi1

  (.- B (1)) B S product0  
  syl

  A B (.- B (1)) S producteq1
  pm3.2i
  ## <d 'Praeclarum Theorema '>
    (< (0) B) (= (product B (.- B (1)) S) (1)) (= A B) (= (product A (.- B (1)) S) (product B (.- B (1)) S)) prth
    ax-mp
  ## </d 'Praeclarum Theorema '>
  
  ## <d 'Symmetric Property '>
    (product A (.- B (1)) S) (product B (.- B (1)) S) eqcom
    BiReplaceImp1An1
  ## </d 'Symmetric Property '>
  
  ## <d 'Transitive Property '>
    (product B (.- B (1)) S) (1) (product A (.- B (1)) S) ax-eqtr
    syl
  ## </d 'Transitive Property '>
  
  ## <d 'Symmetric Property '>
    (1) (product A (.- B (1)) S) eqcom
    sylib
  ## </d 'Symmetric Property '>  
  ## <d 'Symmetric Property '>
    (product A (.- B (1)) S) (1) eqcom
    sylib
  ## </d 'Symmetric Property '>


  (< (0) B) (= A B) pm3.27
  A B B S producteq1
  syl

  (< (0) B) (= A B) pm3.26
  B S product1
  (< (0) B) a1i
  syl

  eqtrd
  muleq12d  
  
  ## <d 'Multiplicative Identity '>
    (product A B S) mulidr
    EqReplaceImp1Eq0
  ## </d 'Multiplicative Identity '>

  A B S productdetach
  (< (0) B) adantl
  jaoi  
  ## <d 'Distributive Property '>
    (< (0) B) (= A B) (< A B) andi
    bicomi
    sylbi2
  ## </d 'Distributive Property '>
  
  ## <d 'Commutative Property '>
    (= A B) (< A B) orcom
    BiReplaceImp0An1
  ## </d 'Commutative Property '>
  
  ## <d ' '>
    A B leleo
    ## <d 'Commutative Property'>
      (<= A B) (\/ (< A B) (= A B)) bicom
      mpbi
    ## </d 'Commutative Property'>
    BiReplaceImp0An1
  ## </d ' '>
)

thm (productdetach3 () ()  (= (product (1) (+ A (1)) S) (* (product (1) A S) (apply S (+ A (1)))))
  (+ A (1)) (1) S productdetach2
    
    ## <d>
      A (1) halfminuscan
      EqReplaceImp1Eq1Mul0Product1
    ## </d>
    
    ## <d 'Convert between ≤ and < '>
      (0) A lePlus1
      BiReplaceImp0An0
    ## </d 'Convert between ≤ and < '>
    
    A 0le
    
    (<= (1) (+ A (1))) anRemove1
    (= (product (1) (+ A (1)) S) (* (product (1) A S) (apply S (+ A (1))))) imbi1i
    mpbi
    
  (0) A (1) leadd1    
    ## <d 'Additive Identity Axiom '>
      (1) pa_ax3r
      EqReplaceBi1Le0
    ## </d 'Additive Identity Axiom '>
  A 0le
    
    mpbiRemove
    
    ax-mpRemove
)



## <title> Substitution </title>
## <table>
##   (<-> ph (-> ps (< A  [ B ]   ]   ] )))
##   (=                   [ B ]   [ C ] )
##   (<-> ph (-> ps (< A  [   [   [ C ] )))
## </table>
thm (EqReplaceBi1Imp1Lt1 () (
     replacee (<-> ph (-> ps (< A B)))
     substitution (= B C)) 
     (<-> ph (-> ps (< A C)))
  replacee substitution
  A lteq2i
  BiReplaceBi1Imp1
)

thm (productnot0.1 ((B x) (A x) (S x)) () (<-> ([/] B x (-> (<= x A) (< (0) (product (1) x S)))) (-> (<= B A) (< (0) (product (1) B S))))
  x B A leeq1
  x B (1) S producteq2
  (0) lteq2d
  imbi12d
  sbcie
)

thm (productnot0.2 () (hyp (-> th (-> ph (-> ps ch))) hyp2 (-> th (-> ps ta))) (-> th (-> (-> ta ph) (-> ps ch)))
  ta ph pm2.27
  (-> ps ch) imim1d
  th imim2d
  hyp  
  (-> th (-> (-> ta ph) (-> ps ch))) impRemove1
  ta imbi2i
  mpbi

  hyp2  
  ## <d 'Negate Both Sides '>
    ps ta con34b
    sylib
  ## </d 'Negate Both Sides '>
  ps ch pm2.21  
  ImpReplaceImp1Imp1
  com12
  (-> ta ph) a1dd

  pm3.2i

  ta (-> th (-> (-> ta ph) (-> ps ch))) pm4.83    
  mpbi
)

thm (productnot0.3 ((A x) (S x)) ()  (-> (A. x (-> (/\ (<= (1) x) (<= x A)) (< (0) (apply S x)))) (-> (<= B A) (< (0) (product (1) B S))))
  (0) y A S productnot0.1
  (0) (1) S product0
  0less1
  ax-mpRemove
  EqReplaceBi1Imp1Lt1
  0less1
  (<= (0) A) impRemove2
  ([/] (0) y (-> (<= y A) (< (0) (product (1) y S)))) bibi2i
  mpbi
  tru
  mpbirRemove
  
  (A. x (-> (/\ (<= (1) x) (<= x A)) (< (0) (apply S x))))  a1i

  x y (1) leeq2
  x y A leeq1
  anbi12d
  x y S applyeq2
  (0) lteq2d
  imbi12d
  alpha  
  ## <d>
    y (-> (/\ (<= (1) y) (<= y A)) (< (0) (apply S y))) ax-4
    ImpReplaceBi1
  ## </d>
  (= y (+ z (1))) a1i

  y (+ z (1)) (1) leeq2
  y (+ z (1)) A leeq1
  anbi12d
  y (+ z (1)) S applyeq2
  (0) lteq2d
  imbi12d  
  ## <d 'Infer Left to Right '>
    (-> (/\ (<= (1) y) (<= y A)) (< (0) (apply S y))) (-> (/\ (<= (1) (+ z (1))) (<= (+ z (1)) A)) (< (0) (apply S (+ z (1))))) bi1
    syl
  ## </d 'Infer Left to Right '>
  syld
  vtocle
  (1) z addge02t  
  (<= (+ z (1)) A) anRemove1
  (< (0) (apply S (+ z (1)))) imbi1i
  sylib

  (apply S (+ z (1))) (0) (product (1) z S) ltmul1
  ## <d 'Evaluate'>
    (apply S (+ z (1))) pa_ax5
    EqReplaceImp1Imp1Lt0
  ## </d 'Evaluate'>
  ## <d 'Commutative Property '>
    (apply S (+ z (1))) (product (1) z S) mulcom
    EqReplaceImp1Imp1Lt1
  ## </d 'Commutative Property '>

  z S productdetach3 eqcomi
  EqReplaceImp1Imp1Lt1
  ImpReplaceImp1Imp1
  com23

  z A ltle2
  ## <d 'Infer Right to Left '>
    (< z A) (<= (+ z (1)) A) bi2
    ax-mp
  ## </d 'Infer Right to Left '>
  ## <d 'Inequality Conversion '>
    z A ltle
    syl
  ## </d 'Inequality Conversion '>
  (A. x (-> (/\ (<= (1) x) (<= x A)) (< (0) (apply S x)))) a1i
  productnot0.2
  z y A S productnot0.1 bicomi
  BiReplaceImp1Imp0
  (+ z (1)) y A S productnot0.1 bicomi
  BiReplaceImp1Imp1 
  B inductiond
  B y A S productnot0.1  
  sylib
)

## <title> Substitution </title>
## <table>
##   (<-> ph (=  [ A ]   ]   ]  C))
##   (=          [ A ]   [ B ] )
##   (<-> ph (=  [   [   [ B ]  C))
## </table>
thm (EqReplaceBi1Eq0 () (
     replacee (<-> ph (= A C))
     substitution (= A B)) 
     (<-> ph (= B C))
  replacee substitution
  C eqeq1i
  bitri
)


## <title> Substitution </title>
## <table>
##   (<-> ph (= (* A  [ B ]   ]   ] ) D))
##   (=               [ B ]   [ C ] )
##   (<-> ph (= (* A  [   [   [ C ] ) D))
## </table>
thm (EqReplaceBi1Eq0Mul1 () (
     replacee (<-> ph (= (* A B) D))
     substitution (= B C)) 
     (<-> ph (= (* A C) D))
  replacee substitution
  A muleq2i
  EqReplaceBi1Eq0
)

## <title> Substitution </title>
## <table>
##   (<-> ph (= A (product B  [ C ]   ]   ]  S)))
##   (=                       [ C ]   [ D ] )
##   (<-> ph (= A (product B  [   [   [ D ]  S)))
## </table>
thm (EqReplaceBi1Eq1Product1 () (
     replacee (<-> ph (= A (product B C S)))
     substitution (= C D)) 
     (<-> ph (= A (product B D S)))
  replacee substitution
  B S producteq2i
  EqReplaceBi1Eq1
)

## <title> Substitution </title>
## <table>
##   (<= A  [ B ]   ]   ] )
##   (=     [ B ]   [ C ] )
##   (<= A  [   [   [ C ] )
## </table>
thm (EqReplaceLe1 () (
     replacee (<= A B)
     substitution (= B C)) 
     (<= A C)
  replacee substitution
  A leeq2i
  mpbi
)

## <title> Substitution </title>
## <table>
##   (<= A (+ B  [ C ]   ]   ] ))
##   (=          [ C ]   [ D ] )
##   (<= A (+ B  [   [   [ D ] ))
## </table>
thm (EqReplaceLe1Add1 () (
     replacee (<= A (+ B C))
     substitution (= C D)) 
     (<= A (+ B D))
  replacee substitution
  B addeq2i
  EqReplaceLe1
)

## <title> Substitution </title>
## <table>
##   (= A (* (product B  [ C ]   ]   ]  S) A'))
##   (=                  [ C ]   [ D ] )
##   (= A (* (product B  [   [   [ D ]  S) A'))
## </table>
thm (EqReplaceEq1Mul0Product1 () (
     replacee (= A (* (product B C S) A'))
     substitution (= C D)) 
     (= A (* (product B D S) A'))
  replacee substitution
  B S producteq2i
  EqReplaceEq1Mul0
)

## <title> Substitution </title>
## <table>
##   (-> ph (= (* A  [ B ]   ]   ] ) D))
##   (=              [ B ]   [ C ] )
##   (-> ph (= (* A  [   [   [ C ] ) D))
## </table>
thm (EqReplaceImp1Eq0Mul1 () (
     replacee (-> ph (= (* A B) D))
     substitution (= B C)) 
     (-> ph (= (* A C) D))
  replacee substitution
  A muleq2i
  EqReplaceImp1Eq0
)


## <title> Substitution </title>
## <table>
##   (-> ph (= (* A (product B  [ C ]   ]   ]  S)) A'))
##   (=                         [ C ]   [ D ] )
##   (-> ph (= (* A (product B  [   [   [ D ]  S)) A'))
## </table>
thm (EqReplaceImp1Eq0Mul1Product1 () (
     replacee (-> ph (= (* A (product B C S)) A'))
     substitution (= C D)) 
     (-> ph (= (* A (product B D S)) A'))
  replacee substitution
  B S producteq2i
  EqReplaceImp1Eq0Mul1
)

## <title> Substitution </title>
## <table>
##   (= A (.-  [ B ]   ]   ]  D))
##   (=        [ B ]   [ C ] )
##   (= A (.-  [   [   [ C ]  D))
## </table>
thm (EqReplaceEq1HM0 () (
     replacee (= A (.- B D))
     substitution (= B C)) 
     (= A (.- C D))
  replacee substitution
  D halfminuseq1i
  EqReplaceEq1
)

## <title> Substitution </title>
## <table>
##   (= (*  [ A ]   ]   ]  C) D)
##   (=     [ A ]   [ B ] )
##   (= (*  [   [   [ B ]  C) D)
## </table>
thm (EqReplaceEq0Mul0 () (
     replacee (= (* A C) D)
     substitution (= A B)) 
     (= (* B C) D)
  replacee substitution
  C muleq1i
  EqReplaceEq0
)


## <title> Substitution </title>
## <table>
##   (= (* (product A  [ B ]   ]   ]  S) D) A')
##   (=                [ B ]   [ C ] )
##   (= (* (product A  [   [   [ C ]  S) D) A')
## </table>
thm (EqReplaceEq0Mul0Product1 () (
     replacee (= (* (product A B S) D) A')
     substitution (= B C)) 
     (= (* (product A C S) D) A')
  replacee substitution
  A S producteq2i
  EqReplaceEq0Mul0
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (* B  [ C ]   ]   ] )))
##   (=                [ C ]   [ D ] )
##   (-> ph (= A (* B  [   [   [ D ] )))
## </table>
thm (EqReplaceImp1Eq1Mul1 () (
     replacee (-> ph (= A (* B C)))
     substitution (= C D)) 
     (-> ph (= A (* B D)))
  replacee substitution
  B muleq2i
  EqReplaceImp1Eq1
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (* B (apply S  [ C ]   ]   ] ))))
##   (=                         [ C ]   [ D ] )
##   (-> ph (= A (* B (apply S  [   [   [ D ] ))))
## </table>
thm (EqReplaceImp1Eq1Mul1Apply1 () (
     replacee (-> ph (= A (* B (apply S C))))
     substitution (= C D)) 
     (-> ph (= A (* B (apply S D))))
  replacee substitution
  S applyeq2i
  EqReplaceImp1Eq1Mul1
)

thm (productadd.1 ((C x) (A x) (B x) (S x)) () (<-> ([/] C x (= (* (product A B S) (product (+ B (1)) (+ B x) S)) (product A (+ B x) S))) (= (* (product A B S) (product (+ B (1)) (+ B C) S)) (product A (+ B C) S)))
  x C B addeq2
  (+ B (1)) S producteq2d
  (product A B S) muleq2d
  x C B addeq2
  A S producteq2d
  eqeq12d
  sbcie
)

## <title> Substitution </title>
## <table>
##   (< A (+ B  [ C ]   ]   ] ))
##   (=         [ C ]   [ D ] )
##   (< A (+ B  [   [   [ D ] ))
## </table>
thm (EqReplaceLt1Add1 () (
     replacee (< A (+ B C))
     substitution (= C D)) 
     (< A (+ B D))
  replacee substitution
  B addeq2i
  EqReplaceLt1
)

thm (productadd () (hyp (<= A B)) (= (* (product A B S) (product (+ B (1)) (+ B C) S)) (product A (+ B C) S))
  (0) y  A B S productadd.1
  ## <d 'Additive Identity Axiom '>
    B pa_ax3
    EqReplaceBi1Eq1Product1
  ## </d 'Additive Identity Axiom '>

  (+ B (0)) (+ B (1)) S product0
  (0) (1) B ltadd2
  0less1
  mpbiRemove
  ax-mpRemove
  (product A B S) muleq2i
  ## <d 'Evaluate'>
    (product A B S) mulid
    EqReplaceEq1
  ## </d 'Evaluate'>
  mpbirRemove


  (* (product A B S) (product (+ B (1)) (+ B x) S)) (product A (+ B x) S) (apply S (+ (+ B x) (1))) muleq1
  (* (product A B S) (product (+ B (1)) (+ (+ B x) (1)) S)) eqeq2d

  (+ (+ B x) (1)) (+ B (1)) S productdetach2
  0less1
  (+ B x) ltadd2i
  (0) ltTrle
  (+ (+ B x) (0)) 0le
  ax-mpRemove

  (<= (+ B (1)) (+ (+ B x) (1))) anRemove1
  (= (product (+ B (1)) (+ (+ B x) (1)) S) (* (product (+ B (1)) (.- (+ (+ B x) (1)) (1)) S) (apply S (+ (+ B x) (1))))) imbi1i
  mpbi
  x 0le
  (+ B (1)) leadd2i
  ## <d 'Additive Identity Axiom '>
    (+ B (1)) pa_ax3
    EqReplaceLe0
  ## </d 'Additive Identity Axiom '>

  ## <d 'Associative Property '>
    B (1) x addass
    EqReplaceLe1
  ## </d 'Associative Property '>

  ## <d 'Commutative Property '>
    (1) x addcom
    EqReplaceLe1Add1
  ## </d 'Commutative Property '>

  ## <d 'Associative Property '>
    B x (1) addass
    ## <d 'Commutative Property'>
      (+ (+ B x) (1)) (+ B (+ x (1))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceLe1
  ## </d 'Associative Property '>
  ax-mpRemove

  ## <d>
    (+ B x) (1) halfminuscan
    EqReplaceEq1Mul0Product1
  ## </d>
  (product A B S) muleq2i
  ## <d 'Associative Property '>
    (product A B S) (product (+ B (1)) (+ B x) S) (apply S (+ (+ B x) (1))) mulass
    ## <d 'Commutative Property'>
      (* (* (product A B S) (product (+ B (1)) (+ B x) S)) (apply S (+ (+ B x) (1)))) (* (product A B S) (* (product (+ B (1)) (+ B x) S) (apply S (+ (+ B x) (1))))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceEq1
  ## </d 'Associative Property '>
  (= (* (product A B S) (product (+ B (1)) (+ (+ B x) (1)) S)) (* (product A (+ B x) S) (apply S (+ (+ B x) (1))))) biRemove1
  (= (* (product A B S) (product (+ B (1)) (+ B x) S)) (product A (+ B x) S)) imbi2i
  mpbi

  x y  A B S productadd.1 bicomi
  sylbi2

  ## <d 'Associative Property '>
    B x (1) addass
    EqReplaceImp1Eq0Mul1Product1
  ## </d 'Associative Property '>

  ## <d 'Associative Property '>
    B x (1) addass
    EqReplaceImp1Eq1Mul1Apply1
  ## </d 'Associative Property '>

  A (+ B (+ x (1))) S productdetach

  hyp
  A B lePlus1 bicomi  
  mpbi
  x addge01t2  
  ## <d 'Associative Property '>
    B (1) x addass
    EqReplaceLt1
  ## </d 'Associative Property '>
  
  ## <d 'Commutative Property '>
    (1) x addcom
    EqReplaceLt1Add1
  ## </d 'Commutative Property '>


  ax-mpRemove eqcomi
  (1) (+ x (1)) B halfminusaddcom
  (1) x addge02t
  ax-mpRemove

  ## <d 'Commutative Property '>
    (+ x (1)) B addcom
    EqReplaceEq1HM0
  ## </d 'Commutative Property '>
  eqcomi
  ## <d>
    x (1) halfminuscan
    EqReplaceEq1Add0
  ## </d>
  EqReplaceEq0Mul0Product1

  ## <d 'Commutative Property '>
    x B addcom
    EqReplaceEq0Mul0Product1
  ## </d 'Commutative Property '>

  EqReplaceImp1Eq1

  (+ x (1)) y  A B S productadd.1 bicomi
  sylib

  C induction
  C y  A B S productadd.1
  mpbi
)



## <title> Substitution </title>
## <table>
##   (<-> ph (< A  [ B ]   ]   ] ))
##   (<=           [ B ]   [ C ] )
##   (<-> ph (< A  [   [   [ C ] ))
## </table>
thm (LeReplaceBi1Lt1 () (
     replacee (<-> ph (< A B))
     substitution (<= B C)) 
     (-> ph (< A C))
  replacee substitution
  A leTrlt
  ImpReplaceBi1
)

## <title> Substitution </title>
## <table>
##   (-> ph (< A (+ B  [ C ]   ]   ] )))
##   (=                [ C ]   [ D ] )
##   (-> ph (< A (+ B  [   [   [ D ] )))
## </table>
thm (EqReplaceImp1Lt1Add1 () (
     replacee (-> ph (< A (+ B C)))
     substitution (= C D)) 
     (-> ph (< A (+ B D)))
  replacee substitution
  B addeq2i
  EqReplaceImp1Lt1
)

thm (productaddd () () (-> (<= A B) (= (* (product A B S) (product (+ B (1)) (+ B C) S)) (product A (+ B C) S)))
  (0) y  A B S productadd.1
  ## <d 'Additive Identity Axiom '>
    B pa_ax3
    EqReplaceBi1Eq1Product1
  ## </d 'Additive Identity Axiom '>

  (+ B (0)) (+ B (1)) S product0
  (0) (1) B ltadd2
  0less1
  mpbiRemove
  ax-mpRemove
  (product A B S) muleq2i
  ## <d 'Evaluate'>
    (product A B S) mulid
    EqReplaceEq1
  ## </d 'Evaluate'>
  mpbirRemove
  (<= A B) a1i

  A B lePlus1 bicomi
  (+ B (1)) x addge01t  
  LeReplaceBi1Lt1
    
  ## <d 'Associative Property '>
    B (1) x addass
    EqReplaceImp1Lt1
  ## </d 'Associative Property '>
  
  ## <d 'Commutative Property '>
    (1) x addcom
    EqReplaceImp1Lt1Add1
  ## </d 'Commutative Property '>

  A (+ B (+ x (1))) S productdetach  
  syl
  (1) (+ x (1)) B halfminusaddcom
  (1) x addge02t  
  ax-mpRemove
  ## <d 'Commutative Property '>
    (+ x (1)) B addcom
    EqReplaceEq1HM0
  ## </d 'Commutative Property '>
  eqcomi
  ## <d>
    x (1) halfminuscan
    EqReplaceEq1Add0
  ## </d>  
  EqReplaceImp1Eq1Mul0Product1
  
  ## <d 'Commutative Property '>
    x B addcom
    EqReplaceImp1Eq1Mul0Product1
  ## </d 'Commutative Property '>

  
  ## <d 'Symmetric Property '>
    (product A (+ B (+ x (1))) S) (* (product A (+ B x) S) (apply S (+ B (+ x (1))))) eqcom
    sylib
  ## </d 'Symmetric Property '>
  (* (product A B S) (product (+ B (1)) (+ B (+ x (1))) S)) eqeq2d
  ([/] x y (= (* (product A B S) (product (+ B (1)) (+ B y) S)) (product A (+ B y) S))) imbi2d

  (* (product A B S) (product (+ B (1)) (+ B x) S)) (product A (+ B x) S) (apply S (+ (+ B x) (1))) muleq1
  (* (product A B S) (product (+ B (1)) (+ (+ B x) (1)) S)) eqeq2d

  (+ (+ B x) (1)) (+ B (1)) S productdetach2
  0less1
  (+ B x) ltadd2i
  (0) ltTrle
  (+ (+ B x) (0)) 0le
  ax-mpRemove

  (<= (+ B (1)) (+ (+ B x) (1))) anRemove1
  (= (product (+ B (1)) (+ (+ B x) (1)) S) (* (product (+ B (1)) (.- (+ (+ B x) (1)) (1)) S) (apply S (+ (+ B x) (1))))) imbi1i
  mpbi
  x 0le
  (+ B (1)) leadd2i
  ## <d 'Additive Identity Axiom '>
    (+ B (1)) pa_ax3
    EqReplaceLe0
  ## </d 'Additive Identity Axiom '>

  ## <d 'Associative Property '>
    B (1) x addass
    EqReplaceLe1
  ## </d 'Associative Property '>

  ## <d 'Commutative Property '>
    (1) x addcom
    EqReplaceLe1Add1
  ## </d 'Commutative Property '>

  ## <d 'Associative Property '>
    B x (1) addass
    ## <d 'Commutative Property'>
      (+ (+ B x) (1)) (+ B (+ x (1))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceLe1
  ## </d 'Associative Property '>
  ax-mpRemove

  ## <d>
    (+ B x) (1) halfminuscan
    EqReplaceEq1Mul0Product1
  ## </d>
  (product A B S) muleq2i
  ## <d 'Associative Property '>
    (product A B S) (product (+ B (1)) (+ B x) S) (apply S (+ (+ B x) (1))) mulass
    ## <d 'Commutative Property'>
      (* (* (product A B S) (product (+ B (1)) (+ B x) S)) (apply S (+ (+ B x) (1)))) (* (product A B S) (* (product (+ B (1)) (+ B x) S) (apply S (+ (+ B x) (1))))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceEq1
  ## </d 'Associative Property '>
  (= (* (product A B S) (product (+ B (1)) (+ (+ B x) (1)) S)) (* (product A (+ B x) S) (apply S (+ (+ B x) (1))))) biRemove1
  (= (* (product A B S) (product (+ B (1)) (+ B x) S)) (product A (+ B x) S)) imbi2i
  mpbi

  x y  A B S productadd.1 bicomi
  sylbi2

  ## <d 'Associative Property '>
    B x (1) addass
    EqReplaceImp1Eq0Mul1Product1
  ## </d 'Associative Property '>

  ## <d 'Associative Property '>
    B x (1) addass
    EqReplaceImp1Eq1Mul1Apply1
  ## </d 'Associative Property '>  
  (-> ([/] x y (= (* (product A B S) (product (+ B (1)) (+ B y) S)) (product A (+ B y) S))) (= (* (product A B S) (product (+ B (1)) (+ B (+ x (1))) S)) (product A (+ B (+ x (1))) S))) biRemove1
  (<= A B) imbi2i
  mpbi
  
  (+ x (1)) y  A B S productadd.1 bicomi  
  BiReplaceImp1Imp1
  C inductiond
  C y  A B S productadd.1  
  sylib
)

## <title> Product is divisible by its last number </title>
thm (lastproductdivides () () (-> (<= A B) (| (apply S B) (product A B S)))
  A B S productdetach
  ## <d 'Symmetric Property '>
    (product A B S) (* (product A (.- B (1)) S) (apply S B)) eqcom
    sylib
  ## </d 'Symmetric Property '>
  ## <d 'Commutative Property '>
    (product A (.- B (1)) S) (apply S B) mulcom
    EqReplaceImp1Eq0
  ## </d 'Commutative Property '>
  proveDividesd

  A B B S producteq1
  (apply S B) eqeq1d
  B S product1  
  (= (product A B S) (apply S B)) biRemove2
  (= A B) imbi2i
  mpbi
  (apply S B) mulid eqcomi    
  EqReplaceImp1Eq1
  
  ## <d 'Symmetric Property '>
    (product A B S) (* (apply S B) (1)) eqcom
    sylib
  ## </d 'Symmetric Property '>
  proveDividesd
  jaoi  
  ## <d '≤ means < OR ='>
    A B leleo
    ## <d 'Commutative Property'>
      (<= A B) (\/ (< A B) (= A B)) bicom
      mpbi
    ## </d 'Commutative Property'>
    sylbi2
  ## </d '≤ means < OR ='>
)


## <title> Substitution </title>
## <table>
##   (= (* A (product B  [ C ]   ]   ]  S)) A')
##   (=                  [ C ]   [ D ] )
##   (= (* A (product B  [   [   [ D ]  S)) A')
## </table>
thm (EqReplaceEq0Mul1Product1 () (
     replacee (= (* A (product B C S)) A')
     substitution (= C D)) 
     (= (* A (product B D S)) A')
  replacee substitution
  B S producteq2i
  EqReplaceEq0Mul1
)

## <title> Substitution </title>
## <table>
##   (= A (product B  [ C ]   ]   ]  S))
##   (=               [ C ]   [ D ] )
##   (= A (product B  [   [   [ D ]  S))
## </table>
thm (EqReplaceEq1Product1 () (
     replacee (= A (product B C S))
     substitution (= C D)) 
     (= A (product B D S))
  replacee substitution
  B S producteq2i
  EqReplaceEq1
)

## <title> Substitution </title>
## <table>
##   (| A  [ B ]   ]   ] )
##   (=    [ B ]   [ C ] )
##   (| A  [   [   [ C ] )
## </table>
thm (EqReplaceDivs1 () (
     replacee (| A B)
     substitution (= B C)) 
     (| A C)
  replacee substitution
  A divideseq2i
  mpbi
)

thm (productdivides () (hyp (<= A C) hyp2 (<= C B)) (| (apply S C) (product A B S))
  hyp
  A C S lastproductdivides  
  ax-mp

  (product (+ C (1)) B S) dividesmuli

  hyp
  S (.- B C) productadd
    
  ## <d 'Commutative Property '>
    C (.- B C) addcom
  ## </d 'Commutative Property '>
  C B C halfminusaddcom  
  ## <d>
    B C halfminuscan
    EqReplaceImp1Eq1
  ## </d>

  hyp2
  ax-mpRemove  
  EqReplaceEq1
  
  EqReplaceEq0Mul1Product1
  ## <d 'Commutative Property '>
    C (.- B C) addcom
  ## </d 'Commutative Property '>
  C B C halfminusaddcom  
  ## <d>
    B C halfminuscan
    EqReplaceImp1Eq1
  ## </d>
  hyp2
  ax-mpRemove  
  EqReplaceEq1
  
  EqReplaceEq1Product1  
  EqReplaceDivs1
)

thm (productdividesd () () (-> (/\ (<= A C) (<= C B)) (| (apply S C) (product A B S)))
  A C S lastproductdivides
  (apply S C) (product A C S) (product (+ C (1)) B S) dividesmul    
  syl
  (<= C B) a1i  
  ## <d 'Import-Export Theorem '>
    (<= C B) (<= A C) (| (apply S C) (* (product A C S) (product (+ C (1)) B S))) impexp
    ## <d 'Commutative Property'>
      (-> (/\ (<= C B) (<= A C)) (| (apply S C) (* (product A C S) (product (+ C (1)) B S)))) (-> (<= C B) (-> (<= A C) (| (apply S C) (* (product A C S) (product (+ C (1)) B S))))) bicom
      mpbi
    ## </d 'Commutative Property'>
    mpbi
  ## </d 'Import-Export Theorem '>
  
  ## <d 'Commutative Property '>
    (<= C B) (<= A C) ancom
    sylbi2
  ## </d 'Commutative Property '>

  A C S (.- B C) productaddd  
  ## <d 'Commutative Property '>
    C (.- B C) addcom
    EqReplaceImp1Eq0Mul1Product1
  ## </d 'Commutative Property '>

  C B C halfminusaddcom
  ## <d>
    B C halfminuscan
    EqReplaceImp1Eq1
  ## </d>
  (+ C (1)) S producteq2d
  (product A C S) muleq2d
#  (product A (+ C (.- B C)) S) eqeq1d
  pm3.2i  
  ## <d 'Praeclarum Theorema '>
    (<= A C) (= (* (product A C S) (product (+ C (1)) (+ (.- B C) C) S)) (product A (+ C (.- B C)) S)) (<= C B) (= (* (product A C S) (product (+ C (1)) (+ (.- B C) C) S)) (* (product A C S) (product (+ C (1)) B S))) prth
    ax-mp
  ## </d 'Praeclarum Theorema '>
  
  ## <d 'Transitive Property '>
    (* (product A C S) (product (+ C (1)) (+ (.- B C) C) S)) (product A (+ C (.- B C)) S) (* (product A C S) (product (+ C (1)) B S)) ax-eqtr
    syl
  ## </d 'Transitive Property '>

  C B C halfminusaddcom
  ## <d>
    B C halfminuscan
    EqReplaceImp1Eq1
  ## </d>  
  
  ## <d 'Commutative Property '>
    (.- B C) C addcom
    EqReplaceImp1Eq0
  ## </d 'Commutative Property '>
  
  ## <d 'Symmetric Property '>
    (+ C (.- B C)) B eqcom
    sylib
  ## </d 'Symmetric Property '>
  A S producteq2d
  (<= A C) a1i
  ## <d 'Import-Export Theorem '>
    (<= A C) (<= C B) (= (product A B S) (product A (+ C (.- B C)) S)) impexp
    ## <d 'Commutative Property'>
      (-> (/\ (<= A C) (<= C B)) (= (product A B S) (product A (+ C (.- B C)) S))) (-> (<= A C) (-> (<= C B) (= (product A B S) (product A (+ C (.- B C)) S)))) bicom
      mpbi
    ## </d 'Commutative Property'>
    mpbi
  ## </d 'Import-Export Theorem '>
  jca  
  ## <d 'Commutative Property '>
    (= (product A (+ C (.- B C)) S) (* (product A C S) (product (+ C (1)) B S))) (= (product A B S) (product A (+ C (.- B C)) S)) ancom
    sylib
  ## </d 'Commutative Property '>
  
  ## <d 'Transitive Property '>
    (product A B S) (product A (+ C (.- B C)) S) (* (product A C S) (product (+ C (1)) B S)) eqtr1
    syl
  ## </d 'Transitive Property '>
  
  ## <d 'Symmetric Property '>
    (product A B S) (* (product A C S) (product (+ C (1)) B S)) eqcom
    sylib
  ## </d 'Symmetric Property '>

  (* (product A C S) (product (+ C (1)) B S)) (product A B S) (apply S C) divideseq2
  syl
  mpbid
)

## <suggest> right('Define', '!') left('Simplify', '!') </suggest>
defthm (df-factorial nat (! A) () () (= (! A) (product (1) A (lambda x x)))
  (= y x) id
  lambdaeq1
  (1) A productseq3i
)

## <title> Equivalence for ! </title> ##
thm (factorialeq () () (-> (= A B) (= (! A) (! B)))
  A B (1) (lambda x x) producteq2
  A x df-factorial
  ## <d 'Commutative Property'>
    (! A) (product (1) A (lambda x x)) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq0
  B x df-factorial
  ## <d 'Commutative Property'>
    (! B) (product (1) B (lambda x x)) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq1
)
thm (factorialeqi () (
     hyp1 (= A B))
     (= (! A) (! B))
  hyp1
  A B factorialeq
  ax-mp
)

thm (factorialeqd () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (! A) (! B)))
  hyp1
  A B factorialeq
  syl
)

thm (factorial0 () () (= (! (0)) (1))
  ## <d>
    (0) x df-factorial
  ## </d>
  0less1
  (0) (1) (lambda x x) product0
  ax-mp  
  EqReplaceEq1
)

thm (factorial1 () () (= (! (1)) (1))
  ## <d>
    (1) x df-factorial
  ## </d>
  (1) (lambda x x) product1
  EqReplaceEq1
  (= x y) id
  (= x (1)) id
  applylambda
  EqReplaceEq1
)

thm (factorialpred () () (-> (< (1) A) (= (! A) (* (! (.- A (1))) A)))
  (1) A (lambda x x) productdetach  
  
  ## <d>
    A x df-factorial
    ## <d 'Commutative Property'>
      (! A) (product (1) A (lambda x x)) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq0
  ## </d>
  
  ## <d>
    (.- A (1)) x df-factorial
    ## <d 'Commutative Property'>
      (! (.- A (1))) (product (1) (.- A (1)) (lambda x x)) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq1Mul0
  ## </d>

  (= x y) id
  (= x A) id
  applylambda  
  EqReplaceImp1Eq1Mul1
)

## <title> Substitution </title>
## <table>
##   (= (!  [ A ]   ]   ] ) C)
##   (=     [ A ]   [ B ] )
##   (= (!  [   [   [ B ] ) C)
## </table>
thm (EqReplaceEq0Fact0 () (
     replacee (= (! A) C)
     substitution (= A B)) 
     (= (! B) C)
  replacee substitution
  factorialeqi
  EqReplaceEq0
)

## <title> Recursive Definition of Factorial </title>
thm (factorialrecurse () () (= (! (+ A (1))) (* (! A) (+ A (1))))
  A (lambda x x) productdetach1  
  ## <d>
    (+ A (1)) x df-factorial
    ## <d 'Commutative Property'>
      (! (+ A (1))) (product (1) (+ A (1)) (lambda x x)) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq0
  ## </d>
  
  ## <d>
    A x df-factorial
    ## <d 'Commutative Property'>
      (! A) (product (1) A (lambda x x)) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq1Mul0
  ## </d>
  
  ## <d 'Evaluate'>
    x (+ A (1)) applyfunid
    EqReplaceImp1Eq1Mul1
  ## </d 'Evaluate'>
    
  ## <d 'Convert between ≤ and < '>
    (0) A ltle2
    (1) pa_ax3r
    EqReplaceBi1Le0
  ## </d 'Convert between ≤ and < '>
  bicomi  
  sylbi2


  (0) A (1) addeq1
  factorialeqd
  (0) A factorialeq
  (0) A (1) addeq1
  muleq12d
  eqeq12d

  factorial1
  (1) pa_ax3r
  eqcomi  
  EqReplaceEq0Fact0
  eqcomi
  factorial0
  (! (0)) mulid eqcomi  
  EqReplaceEq0
  eqcomi  
  EqReplaceEq0
  eqcomi
  
  
  ## <d 'Evaluate'>
    (1) pa_ax3r
  ## </d 'Evaluate'>
  eqcomi
  (! (0)) muleq2i
  EqReplaceEq1  
  (= (! (+ A (1))) (* (! A) (+ A (1)))) biRemove1
  (= (0) A) imbi2i
  mpbi

  jaoi  
  ## <d ' '>
    (0) A leleo
    ## <d 'Commutative Property'>
      (<= (0) A) (\/ (< (0) A) (= (0) A)) bicom
      mpbi
    ## </d 'Commutative Property'>
    sylbi2
  ## </d ' '>
  A 0le
  ax-mpRemove
)

## <suggest> right('Define', 'nCr') left('Simplify', 'nCr') </suggest>
defthm (df-binomial nat (nCr A B) () () (= (nCr A B) (div (! A) (* (! B) (! (.- A B)))))
  (div (! A) (* (! B) (! (.- A B)))) eqid
)

thm (binomialeq1() () (-> (= A B) (= (nCr A C) (nCr B C)))
  A B factorialeq
  A B C halfminuseq1
  factorialeqd
  (! C) muleq2d
  anim12i  
  (! A) (! B) (* (! C) (! (.- A C))) (* (! C) (! (.- B C))) diveq12
  syl  
  ## <d 'Conjunction is Idempotent '>
    (= A B) anidm
    sylbi2
  ## </d 'Conjunction is Idempotent '>  
  ## <d>
    A C df-binomial eqcomi
    EqReplaceImp1Eq0
  ## </d>  
  ## <d>
    B C df-binomial eqcomi
    EqReplaceImp1Eq1
  ## </d>
)



thm (binomialeq1i () (
     hyp1 (= A B))
     (= (nCr A C) (nCr B C))
  hyp1
  A B C binomialeq1
  ax-mp
)

## <title> Equivalence for nCr </title> ##
thm (binomialeq2 () () (-> (= B C) (= (nCr A B) (nCr A C)))
  B C factorialeq
  B C A halfminuseq2
  factorialeqd
  muleq12d
  (! A) diveq2d
  A B df-binomial
  ## <d 'Commutative Property'>
    (nCr A B) (div (! A) (* (! B) (! (.- A B)))) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq0
  A C df-binomial
  ## <d 'Commutative Property'>
    (nCr A C) (div (! A) (* (! C) (! (.- A C)))) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq1
)


thm (binomialeq1d () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (nCr A C) (nCr B C)))
  hyp1
  A B C binomialeq1
  syl
)

thm (binomialeq2i () (
     hyp1 (= B C))
     (= (nCr A B) (nCr A C))
  hyp1
  B C A binomialeq2
  ax-mp
)

thm (binomialeq2d () (
     hyp1 (-> ph (= B C)))
     (-> ph (= (nCr A B) (nCr A C)))
  hyp1
  B C A binomialeq2
  syl
)

# == Exponentiation ==

# A new definition of exponent that will replace the old one, once a few theorems have been added.
defthm (df-exponent nat (exponent A B) ((A y)) () (= (exponent A B) (product (1) B (lambda y A)))
  A eqid
  (= x y) a1i
  lambdaeq1
  (1) B productseq3i
)

thm (exponent0 () () (= (exponent A (0)) (1))
  A (0) x df-exponent
  0less1
  (0) (1) (lambda x A) product0
  ax-mp  
  EqReplaceEq1
)

thm (exponent1 () () (= (exponent A (1)) A)
  A (1) x df-exponent
  (1) (lambda x A) product1  
  EqReplaceEq1
  
  ## <d 'Evaluate'>
    x A (1) applylambdaconst
    EqReplaceEq1
  ## </d 'Evaluate'>
)

# Definition of exponentiation in terms of recursed multiplication.
# NOTE(abliss): this entails 0^0 = 1.  Maybe a bad choice we'll pay for later?
thm (df-exp-just ((A w x y z) (B x z)) () (=
  (iota ({|} x (recursep (lambda y (* y A)) B (1) x)))
  (iota ({|} z (recursep (lambda w (* w A)) B (1) z))))

 x  z  (lambda w (* w A))  B  (1)  recursepeq4
  y  w  A  muleq1
  lambdaeq1
  (lambda y (* y A))  (lambda w (* w A))  B  (1)  x  recursepeq1    ax-mp
 syl5bb
 abeq
 ({|} x (recursep (lambda y (* y A)) B (1) x))  ({|} z (recursep (lambda w (* w A)) B (1) z))  ax-iotaeq    ax-mp
)

defthm (df-exp nat (exp A B) ((A x y) (B x)) ()
  (= (exp A B) (iota ({|} x (recursep (lambda y (* y A)) B (1) x))))
  x'  y'  A  B  x  y  df-exp-just)

# Exponent zero.
#
# Together with expsuc, this provides a "working definition" of exponentiation
# similar to what pa_ax3/pa_ax4 provide for addition and what pa_ax5/pa_ax6
# provide for multiplication.  If you want an interface that includes
# exponentiation, you should be able to import only these two (along with the
# equality identities expeq1 and expeq2); no knowledge of the recursep / beta
# framework should be required.
thm (exp0 () () (= (exp A (0)) (1))

    x  (1)  tyeu
      (lambda y (* y A))  (1)  recursep0
      x  (1)  (lambda y (* y A))  (0)  (1)  recursepeq4  mpbiri

    (lambda y (* y A))  (1)  recursep0
          y  z  A  muleq1    funlambda
          (lambda y (* y A))  (0)  (1)  (1)  x  recursep-uniq    ax-mp
        ex    ax-mp    eqcomd
      impbii
      x  eubii
    mpbi
    x  (recursep (lambda y (* y A)) (0) (1) x)  iotacl2    ax-mp



      A  (0)  x  y  df-exp
      (exp A (0))  (iota ({|} x (recursep (lambda y (* y A)) (0) (1) x)))  ({|} x (recursep (lambda y (* y A)) (0) (1) x))  ax-eleq1  ax-mp
    mpbir

      x  (exp A (0))    (lambda y (* y A))  (0)  (1)  recursepeq4
      elab
    mpbi


        (lambda y (* y A))  (1)  recursep0
          y  z  A  muleq1    funlambda
          (lambda y (* y A))  (0)  (1)  (1)  (exp A (0))  recursep-uniq    ax-mp
        ex    ax-mp    eqcomd
    ax-mp
)

# Successor of exponent.  See [exp0] for more notes.
thm (expsuc () () (= (exp A (S B)) (* A (exp A B)))

y  z  A  muleq1    funlambda
(lambda y (* y A))  x  (S B)  (1)  eurecursep    ax-mp
x  (recursep (lambda y (* y A)) (S B) (1) x)  iotacl2    ax-mp

  A  (S B)  x  y  df-exp
    (exp A (S B))  (iota ({|} x (recursep (lambda y (* y A)) (S B) (1) x)))  ({|} x (recursep (lambda y (* y A)) (S B) (1) x))  ax-eleq1
  ax-mp

mpbir

x  (exp A (S B))  (lambda y (* y A))  (S B)  (1)  recursepeq4  elab    mpbi


  (lambda y (* y A))  B  (1)  (exp A (S B))  x  recursepsuc
ax-mp

  y  x  A  muleq1  lambdaeq1
  (lambda y (* y A))  (lambda x (* x A))  (<,> x (exp A (S B)))  eleq2    ax-mp
  x  z  A  muleq1  (exp A (S B))  ellambda    bitri
  x  A  mulcom    (exp A (S B))  eqeq2i    bitri
  (recursep (lambda y (* y A)) B (1) x)  anbi2i
  x  exbii
mpbi



y  z  A  muleq1    funlambda
(lambda y (* y A))  x  B  (1)  eurecursep    ax-mp
x  (recursep (lambda y (* y A)) B (1) x)  iotacl2    ax-mp
  A  B  x  y  df-exp
    (exp A B)  (iota ({|} x (recursep (lambda y (* y A)) B (1) x)))  ({|} x (recursep (lambda y (* y A)) B (1) x))  ax-eleq1
  ax-mp
mpbir
x  (exp A B)  (lambda y (* y A))  B  (1)  recursepeq4  elab    mpbi


y  z  A  muleq1  funlambda
  (lambda y (* y A))  B  (1)  (exp A B)  x  recursep-uniq    ax-mp
mpan
(= (exp A (S B)) (* A x))  anim1i

  (exp A B)  x  A  muleq2    (= (exp A (S B)) (* A x))  anim1i
    (* A x)  (exp A (S B))  (* A (exp A B))  ax-eqtr  ex    eqcoms    com12    eqcoms   imp    syl
  syl
x  19.22i    ax-mp

x  (= (exp A (S B)) (* A (exp A B)))  ex-nf    ax-mp
)

# First equality identity for exponentiation
thm (expeq1 () () (-> (= A B) (= (exp A C) (exp B C)))
  (= A B)  y  alnfi
    A  B  y  muleq2
    y  19.20i
    y  (* y A)  (* y B)  lambdaeq2   syl
    (lambda y (* y A))  (lambda y (* y B))  C  (1)  x  recursepeq1    syl
    x  19.21ai
    x  (recursep (lambda y (* y A)) C (1) x)  (recursep (lambda y (* y B)) C (1) x)  abbi2    syl
    ({|} x (recursep (lambda y (* y A)) C (1) x))  ({|} x (recursep (lambda y (* y B)) C (1) x))  ax-iotaeq    syl
    B  C  x  y  df-exp    syl6eqr
    A  C  x  y  df-exp    syl5eq
  syl
)

# Second equality identity for exponentiation
thm (expeq2 () () (-> (= A B) (= (exp C A) (exp C B)))
  (= A B)  x  alnfi
    A  B  (lambda y (* y C))  (1)  x  recursepeq2
    x  19.20i
    x  (recursep (lambda y (* y C)) A (1) x)  (recursep (lambda y (* y C)) B (1) x)  abbi2    syl
    ({|} x (recursep (lambda y (* y C)) A (1) x))  ({|} x (recursep (lambda y (* y C)) B (1) x))  ax-iotaeq    syl
    C  B  x  y  df-exp    syl6eqr
    C  A  x  y  df-exp    syl5eq
  syl
)


## <title> Equality over Exponentiation </title>
thm (expeq1i () (hyp (= A B)) (= (exp A C) (exp B C))
 hyp
 A B C expeq1  
 ax-mp
)

## <title> Equality over Exponentiation </title>
thm (expeq2i () (hyp (= A B)) (= (exp C A) (exp C B))
 hyp
 A B C expeq2  
 ax-mp
)

## <title> Substitution </title>
## <table>
##   (= (exp A  [ B ]   ]   ] ) D)
##   (=         [ B ]   [ C ] )
##   (= (exp A  [   [   [ C ] ) D)
## </table>
thm (EqReplaceEq0Exp1 () (
     replacee (= (exp A B) D)
     substitution (= B C)) 
     (= (exp A C) D)
  replacee
  substitution
A expeq2i
D eqeq1i
mpbi
)

thm (expplus1 () () (= (exp A (+ B (1))) (* A (exp A B)))
  A B expsuc
  B a1suc
  EqReplaceEq0Exp1
)

thm (expmul.1 () () (-> (= x D) (<->
  (= (exp (* A B) x) (* (exp A x) (exp B x)))
  (= (exp (* A B) D) (* (exp A D) (exp B D)))))

  x  D  (* A B)  expeq2
    x  D  A  expeq2
      x  D  B  expeq2
    muleq12d
  eqeq12d
)

# Multiplying of exponents
thm (expmul () () (= (exp (* A B) C) (* (exp A C) (exp B C)))

x  (0)  A  B  expmul.1
x  y  A  B  expmul.1
x  (S y)  A  B  expmul.1
x  C  A  B  expmul.1

# base case
(* A B)  exp0
  A  exp0
    B  exp0
  muleq12i
  (1)  mulid  eqtr
eqtr4

# inductive step
(exp (* A B) y)  (* (exp A y) (exp B y))  (* A B)  muleq2
(* A B)  y  expsuc  syl5eq
  A  y  expsuc
    B  y  expsuc
  muleq12i
  (* A (exp A y))  B  (exp B y)  mulass   eqtr4
    A  (exp A y)  B  mulass  (exp A y)  B  mulcom   (* (exp A y) B)  (* B (exp A y))  A  muleq2  ax-mp  eqtr
    A  B  (exp A y)  mulass  eqtr4
    (exp B y)  muleq1i
  eqtr
  (* A B)  (exp A y)  (exp B y)  mulass  eqtr
  syl6eqr

finds
)

thm (expadd.1 () () (-> (= x B) (<->
  (= (exp A (+ x C)) (* (exp A x) (exp A C)))
  (= (exp A (+ B C)) (* (exp A B) (exp A C)))))

x  B  C  addeq1
(+ x C)  (+ B C)  A  expeq2  syl
  x  B  A  expeq2
  (exp A C)  muleq1d
eqeq12d
)

# Adding of exponents
thm (expadd () () (= (exp A (+ B C)) (* (exp A B) (exp A C)))

x  (0)  A  C  expadd.1
x  y  A  C  expadd.1
x  (S y)  A  C  expadd.1
x  B  A  C  expadd.1

# base case
C  pa_ax3r
(+ (0) C)  C  A  expeq2    ax-mp
  A  exp0
  (exp A C)  muleq1i
  (1)  (exp A C)  mulcom     (exp A C)  mulid  eqtr  eqtr
eqtr4

# inductive step
(exp A (+ y C))  (* (exp A y) (exp A C))  A  muleq2
  y  C  pa_ax4r
    (+ (S y) C)  (S (+ y C))  A  expeq2  ax-mp
  A  (+ y C)  expsuc  eqtr
syl5eq
  A  y  expsuc    (exp A C)  muleq1i
  A  (exp A y)  (exp A C)  mulass    eqtr
syl6eqr

finds
)

thm (expexp.1 () () (-> (= x C) (<->
 (= (exp (exp A B) x) (exp A (* B x)))
 (= (exp (exp A B) C) (exp A (* B C)))))

x  C  (exp A B)  expeq2
  x  C  B  muleq2
  (* B x)  (* B C)  A  expeq2    syl
eqeq12d
)

# Exponentiation over exponentiation yields multiplication.
thm (expexp () () (= (exp (exp A B) C) (exp A (* B C)))

x  (0)    A  B  expexp.1
x  y      A  B  expexp.1
x  (S y)  A  B  expexp.1
x  C      A  B  expexp.1

# base case
(exp A B)  exp0
  B  pa_ax5    (* B (0))  (0)  A  expeq2    ax-mp
  A  exp0    eqtr
eqtr4

# inductive step
(exp (exp A B) y)  (exp A (* B y))  (exp A B)  muleq2
  (exp A B)  y  expsuc
    B  y  pa_ax6    (* B (S y))  (+ (* B y) B)  A  expeq2    ax-mp
    A  (* B y)  B  expadd    eqtr
    (exp A (* B y))  (exp A B)  mulcom   eqtr
  eqeq12i
sylibr

finds
)

## <title> Exponent Right Identity </title>
thm (expid () () (= (exp A (1)) A)
  A (0) expplus1  
  ## <d 'Evaluate'>
    (1) pa_ax3r
    EqReplaceEq0Exp1
  ## </d 'Evaluate'>
  A exp0  
  EqReplaceEq1Mul1
  A mulid
  EqReplaceEq1
)

thm (explt1 () ()
  (-> (< (0) A) (<= (1) (exp A B)))
  x (0) A expeq2 (1) leeq2d (< (0) A) imbi2d
    x y A expeq2 (1) leeq2d (< (0) A) imbi2d
      x (S y) A expeq2 (1) leeq2d (< (0) A) imbi2d
        x B A expeq2 (1) leeq2d (< (0) A) imbi2d

  # Base case
  (1) leid A exp0 (1) leeq2i mpbir (< (0) A) a1i

  # Induction step
  (0) A nnltp1let (1) pa_ax3r A leeq1i bitri
    (1) A (exp A y) lemul2
    (exp A y) mulid (* (exp A y) A) leeq1i sylib
    A y expsuc A (exp A y) mulcom eqtr (exp A y) leeq2i sylibr
  sylbi
  (1) (exp A y) (exp A (S y)) letr ancoms ex syl a2i

  finds
)

thm (explt2 () ()
  (-> (< (0) A) (-> (<= B C) (<= (exp A B) (exp A C))))
  B C x df-le
    A x explt1 (1) (exp A x) (exp A B) lemul2 syl
    (exp A B) mulid (* (exp A B) (exp A x)) leeq1i sylib
      (+ B x) C A expeq2
      A B x expadd syl5eqr
      (exp A B) leeq2d
      (< (0) A) imbi2d
    mpbii x 19.23ai
  sylbi com12
)

thm (explt.3 () ()
  (-> (< (1) A) (-> (< B C) (< (exp A B) (exp A C))))
  (0) leid (0) (0) lesuc mpbir df-1 (0) lteq2i mpbir
  (0) (1) A lttr mpan
  A (+ B (1)) C explt2
  B C nnltp1let
  syl5ib

    A B expsuc eqcomi
    B a1suc (S B) (+ B (1)) A expeq2 ax-mp eqtr
    (exp A C) leeq1i
  syl6ibr (< (1) A) adantr
  A B explt1 (0) (exp A B) nnltp1let (1) pa_ax3r (exp A B) leeq1i bitri sylibr
  (exp A B) (1) A ltmul1 syl imp
  (exp A B) mulid (* (exp A B) A) lteq1i
  sylib
  (exp A B) A mulcom (exp A B) lteq2i sylib
   (exp A B) (* A (exp A B)) (exp A C) lelttr2 ex syl
  syld ex com12
  mpd
)

## <summary> Exponentation is strictly monotonic with base of two or greater </summary>
thm (exple () ()
  (-> (< (1) A) (<-> (<= B C) (<= (exp A B) (exp A C))))
  (0) leid (0) (0) lesuc mpbir df-1 (0) lteq2i mpbir (0) (1) A lttr mpan
  A B C explt2 syl
    A C B explt.3
      B C lenltt con2bii
        (exp A B) (exp A C) lenltt con2bii
    3imtr3g
    con4d
  impbid
)

## <summary> Exponentation is strictly monotonic with base of two or greater </summary>
thm (explt () ()
  (-> (< (1) A) (<-> (< B C) (< (exp A B) (exp A C))))
  A C B exple
    C B lenltt
      (exp A C) (exp A B) lenltt
  3bitr3g con4bid
)

# A tuple defining a finite sequence of numbers.
# The tuple is just an ordered pair. The second argument (the tail) is the length of the
# tuple. The first argument is a group of nested ordered pair containing the values in the
# tuple. This definition is useful because it signals to the typesetter how to format the
# values. For example, the 3-tuple (1, 2, 3) is displayed as (1, 2, 3) not as the ordered pairs
# (((1, 2), 3), 3). This is also useful as a reminder that the values are being treated as
# a tuple.
defthm (df-tuple nat (<> A B) () () (= (<> A B) (<,> A B))
  (<,> A B) eqid
)

## <title> Equivalence for <> </title> ##
thm (tupleeq1 () () (-> (= A C) (= (<> A B) (<> C B)))
  A C B opeq1
  A B df-tuple
  ## <d 'Commutative Property'>
    (<> A B) (<,> A B) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq0
  C B df-tuple
  ## <d 'Commutative Property'>
    (<> C B) (<,> C B) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq1
)

thm (tupleeq1i () (
     hyp1 (= A C))
     (= (<> A B) (<> C B))
  hyp1
  A C B tupleeq1
  ax-mp
)

thm (tupleeq1d () (
     hyp1 (-> ph (= A C)))
     (-> ph (= (<> A B) (<> C B)))
  hyp1
  A C B tupleeq1
  syl
)

## <title> Equivalence for <> </title> ##
thm (tupleeq2 () () (-> (= B C) (= (<> A B) (<> A C)))
  B C A opeq2
  A B df-tuple
  ## <d 'Commutative Property'>
    (<> A B) (<,> A B) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq0
  A C df-tuple
  ## <d 'Commutative Property'>
    (<> A C) (<,> A C) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq1
)

thm (tupleeq2i () (
     hyp1 (= B C))
     (= (<> A B) (<> A C))
  hyp1
  B C A tupleeq2
  ax-mp
)

thm (tupleeq2d () (
     hyp1 (-> ph (= B C)))
     (-> ph (= (<> A B) (<> A C)))
  hyp1
  B C A tupleeq2
  syl
)

## <title> Tuple Equality </title>
thm (tupleeq12 () () (-> (/\ (= A B) (= C D)) (= (<> A C) (<> B D)))
  A B C D opeq12
  A C df-tuple eqcomi  
  EqReplaceImp1Eq0
  B D df-tuple eqcomi  
  EqReplaceImp1Eq1
)

## <title> Tuple Equality </title>
thm (tupleeq12i () (hyp1 (= A B) hyp2 (= C D)) (= (<> A C) (<> B D))
  hyp1 hyp2 A B C D tupleeq12 mp2an
)

## <title> Tuple Equality </title>
thm (tupleeq12d ()
  (hyp1 (-> ph (= A B))
   hyp2 (-> ph (= C D)))
  (-> ph (= (<> A C) (<> B D)))
  hyp1 hyp2 jca A B C D tupleeq12 syl
)

# The length of a tuple. This is just the tail. This definition is just a
# way of explaining that the tail of the tuple is its length.
defthm (df-length nat (length A) () () (= (length A) (tail A))
  (tail A) eqid
)

## <title> Equivalence for length </title> ##
thm (lengtheq () () (-> (= A B) (= (length A) (length B)))
  A B taileq
  A df-length  eqcomi  EqReplaceImp1Eq0
  B df-length  eqcomi  EqReplaceImp1Eq1
)

thm (lengtheqi () (
     hyp1 (= A B))
     (= (length A) (length B))
  hyp1  A B lengtheq  ax-mp
)

thm (lengtheqd () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (length A) (length B)))
  hyp1  A B lengtheq  syl
)

## <title> Apply Length Operator </title>
## <suggest> right('Simplify', 'Lng') </suggest>
thm (lengthtuple () () (= (length (<> A B)) B)
  (<> A B) df-length
  A B df-tuple
  taileqi  
  EqReplaceEq1
  ## <d 'Apply Tail Operator '>
    A B tailop
    EqReplaceEq1
  ## </d 'Apply Tail Operator '>
)

## <title> Apply Head Operator </title>
## <suggest> right('Simplify', 'Hd') </suggest>
thm (headtuple () () (= (head (<> A B)) A)
  A B df-tuple
  headeqi  
  ## <d 'Apply Head Operator '>
    A B headop
    EqReplaceEq1
  ## </d 'Apply Head Operator '>
)

# Take the B-th element of the tuple A.
## <title> Tuple Index Definition </title>
## <suggest> right('Define', '_') left('Simplify', '_') </suggest>
defthm (df-index nat (_ A B) () () (= (_ A B) (tail (recurse (lambda y (head y)) (.- (+ (length A) (1)) B) A)))
  x y headeq
  lambdaeq1
  (.- (+ (length A) (1)) B) A  recurseseq1i
  taileqi
)

thm (indexeq1 () () (-> (= A B) (= (_ A C) (_ B C)))
  A B lengtheq
  (1) addeq1d
  C halfminuseq1d
  (= A B) id
  jca
  (.- (+ (length A) (1)) C) (.- (+ (length B) (1)) C) A B 
  (lambda x (head x)) recurseeq23  
  syl
  taileqd
  A C x df-index eqcomi
  EqReplaceImp1Eq0
  B C x df-index eqcomi  
  EqReplaceImp1Eq1
)

thm (indexeq1i () (
     hyp1 (= A B))
     (= (_ A C) (_ B C))
  hyp1
  A B C indexeq1
  ax-mp
)


thm (indexeq1d () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (_ A C) (_ B C)))
  hyp1
  A B C indexeq1
  syl
)

## <title> Equivalence for _ </title> ##
thm (indexeq2 () () (-> (= B C) (= (_ A B) (_ A C)))
  B C (+ (length A) (1)) halfminuseq2
  (lambda y (head y)) A recurseeq2d
  taileqd
  A B y df-index
  ## <d 'Commutative Property'>
    (_ A B) (tail (recurse (lambda y (head y)) (.- (+ (length A) (1)) B) A)) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq0
  A C y df-index
  ## <d 'Commutative Property'>
    (_ A C) (tail (recurse (lambda y (head y)) (.- (+ (length A) (1)) C) A)) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq1
)

thm (indexeq2i () (
     hyp1 (= B C))
     (= (_ A B) (_ A C))
  hyp1
  B C A indexeq2
  ax-mp
)

thm (indexeq2d () (
     hyp1 (-> ph (= B C)))
     (-> ph (= (_ A B) (_ A C)))
  hyp1
  B C A indexeq2
  syl
)

# Add a number to the end of a tuple. Using the analogy of a stack, we push a number onto the stack.
## <title> Push onto Tuple Definition </title>
## <suggest> right('Define', 'ps') left('Simplify', 'ps') </suggest>
defthm (df-push nat (push A B) () () (= (push A B) (<> (<,> (head A) B) (+ (length A) (1))))
  (<> (<,> (head A) B) (+ (length A) (1))) eqid
)

thm (pusheq1 () () (-> (= A C) (= (push A B) (push C B)))
  A C headeq
  B opeq1d
  A C lengtheq
  (1) addeq1d
  jca

  (<,> (head A) B) (<,> (head C) B) (+ (length A) (1)) (+ (length C) (1)) tupleeq12
  A B df-push eqcomi  
  EqReplaceImp1Eq0
  C B df-push eqcomi
  EqReplaceImp1Eq1
  
  syl
)

thm (pusheq1i () (
     hyp1 (= A C))
     (= (push A B) (push C B))
  hyp1
  A C B pusheq1
  ax-mp
)

## <title> Equivalence for push </title> ##
thm (pusheq2 () () (-> (= B C) (= (push A B) (push A C)))
  B C (head A) opeq2
  (+ (length A) (1)) tupleeq1d
  A B df-push
  ## <d 'Commutative Property'>
    (push A B) (<> (<,> (head A) B) (+ (length A) (1))) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq0
  A C df-push
  ## <d 'Commutative Property'>
    (push A C) (<> (<,> (head A) C) (+ (length A) (1))) eqcom
    mpbi
  ## </d 'Commutative Property'>
  EqReplaceImp1Eq1
)


thm (pusheq1d () (
     hyp1 (-> ph (= A C)))
     (-> ph (= (push A B) (push C B)))
  hyp1
  A C B pusheq1
  syl
)

thm (pusheq2i () (
     hyp1 (= B C))
     (= (push A B) (push A C))
  hyp1
  B C A pusheq2
  ax-mp
)

thm (pusheq2d () (
     hyp1 (-> ph (= B C)))
     (-> ph (= (push A B) (push A C)))
  hyp1
  B C A pusheq2
  syl
)

## <title> Substitution </title>
## <table>
##   (= A (<>  [ B ]   ]   ]  D))
##   (=        [ B ]   [ C ] )
##   (= A (<>  [   [   [ C ]  D))
## </table>
thm (EqReplaceEq1Tuple0 () (
     replacee (= A (<> B D))
     substitution (= B C)) 
     (= A (<> C D))
  replacee substitution
  D tupleeq1i
  EqReplaceEq1
)


## <title> Substitution </title>
## <table>
##   (= A (<> (<,>  [ B ]   ]   ]  D) A'))
##   (=             [ B ]   [ C ] )
##   (= A (<> (<,>  [   [   [ C ]  D) A'))
## </table>
thm (EqReplaceEq1Tuple0Op0 () (
     replacee (= A (<> (<,> B D) A'))
     substitution (= B C)) 
     (= A (<> (<,> C D) A'))
  replacee substitution
  D opeq1i
  EqReplaceEq1Tuple0
)

## <title> Substitution </title>
## <table>
##   (= A (<> B  [ C ]   ]   ] ))
##   (=          [ C ]   [ D ] )
##   (= A (<> B  [   [   [ D ] ))
## </table>
thm (EqReplaceEq1Tuple1 () (
     replacee (= A (<> B C))
     substitution (= C D)) 
     (= A (<> B D))
  replacee substitution
  B tupleeq2i
  EqReplaceEq1
)


## <title> Substitution </title>
## <table>
##   (= A (<> B (+  [ C ]   ]   ]  A')))
##   (=             [ C ]   [ D ] )
##   (= A (<> B (+  [   [   [ D ]  A')))
## </table>
thm (EqReplaceEq1Tuple1Add0 () (
     replacee (= A (<> B (+ C A')))
     substitution (= C D)) 
     (= A (<> B (+ D A')))
  replacee substitution
  A' addeq1i
  EqReplaceEq1Tuple1
)

thm (pushtuple () () (= (push (<> A C) B) (<> (<,> A B) (+ C (1))))
  (<> A C) B df-push  
  ## <d 'Apply Head Operator '>
    A C headtuple
    EqReplaceEq1Tuple0Op0
  ## </d 'Apply Head Operator '>
  
  ## <d 'Apply Length Operator '>
    A C lengthtuple
    EqReplaceEq1Tuple1Add0
  ## </d 'Apply Length Operator '>
)

## <suggest> right('Simplify', 'ps') </suggest>
thm (lengthpush () () (= (length (push A B)) (+ (length A) (1)))
  A B df-push
  lengtheqi
  ## <d 'Apply Length Operator '>
    (<,> (head A) B) (+ (length A) (1)) lengthtuple
    EqReplaceEq1
  ## </d 'Apply Length Operator '>
)

## <title> Substitution </title>
## <table>
##   (= A (tail (recurse S (.-  [ B ]   ]   ]  D) A')))
##   (=                         [ B ]   [ C ] )
##   (= A (tail (recurse S (.-  [   [   [ C ]  D) A')))
## </table>
thm (EqReplaceEq1Tail0Recurse1HM0 () (
     replacee (= A (tail (recurse S (.- B D) A')))
     substitution (= B C)) 
     (= A (tail (recurse S (.- C D) A')))
  replacee substitution
  D halfminuseq1i
  EqReplaceEq1Tail0Recurse1
)

## <title> Substitution </title>
## <table>
##   (= A (tail (recurse S (.- (+  [ B ]   ]   ]  D) A') B')))
##   (=                            [ B ]   [ C ] )
##   (= A (tail (recurse S (.- (+  [   [   [ C ]  D) A') B')))
## </table>
thm (EqReplaceEq1Tail0Recurse1HM0Add0 () (
     replacee (= A (tail (recurse S (.- (+ B D) A') B')))
     substitution (= B C)) 
     (= A (tail (recurse S (.- (+ C D) A') B')))
  replacee substitution
  D addeq1i
  EqReplaceEq1Tail0Recurse1HM0
)

## <title> Index of pushed element </title>
## <suggest> right('Simplify', '_') </suggest>
thm (indexpush () () (= (_ (push A B) (+ (length A) (1))) B)
  (push A B) (+ (length A) (1)) x df-index  
  ## <d>
    A B lengthpush
    EqReplaceEq1Tail0Recurse1HM0Add0
  ## </d>  
  ## <d>
    (+ (length A) (1)) (1) halfminuscan2
    EqReplaceEq1Tail0Recurse1
  ## </d>
  x y headeq
  funlambda
  (push A B) recurse1  
  EqReplaceEq1Tail0
  
  ## <d 'Evaluate'>
    x y headeq
    x (push A B) headeq
    applylambda
    EqReplaceEq1Tail0
  ## </d 'Evaluate'>
  A B df-push
  headeqi  
  ## <d 'Apply Head Operator '>
    (<,> (head A) B) (+ (length A) (1)) headtuple
    EqReplaceEq1
  ## </d 'Apply Head Operator '>
  
  EqReplaceEq1Tail0
  
  ## <d 'Apply Tail Operator '>
    (head A) B tailop
    EqReplaceEq1
  ## </d 'Apply Tail Operator '>
)

# Pop a number off a tuple.
## <title> Pop Definition </title>
## <suggest> right('Define', 'pop') left('Simplify', 'pop') </suggest>
defthm (df-pop nat (pop A) () () (= (pop A) (<> (head (head A)) (.- (length A) (1))))
  (<> (head (head A)) (.- (length A) (1))) eqid
)

thm (popeq () () (-> (= A B) (= (pop A) (pop B))) 
  A B headeq
  headeqd
  A B lengtheq
  (1) halfminuseq1d
  jca
  (head (head A)) (head (head B)) (.- (length A) (1)) (.- (length B) (1)) tupleeq12
  syl
  A df-pop eqcomi  
  EqReplaceImp1Eq0
  B df-pop eqcomi  
  EqReplaceImp1Eq1
)

thm (popeqi () (
     hyp1 (= A B))
     (= (pop A) (pop B))
  hyp1
  A B popeq
  ax-mp
)

thm (popeqd () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (pop A) (pop B)))
  hyp1
  A B popeq
  syl
)

## <suggest> right('Simplify', 'pop') </suggest>
thm (lengthpop () () (= (length (pop A)) (.- (length A) (1)))
  A df-pop lengtheqi  
  ## <d 'Apply Length Operator '>
    (head (head A)) (.- (length A) (1)) lengthtuple
    EqReplaceEq1
  ## </d 'Apply Length Operator '>
)

## <suggest> right('Define', '<+>') left('Simplify', '<+>') </suggest>
defthm (df-tuplesum nat (<+> A) ((A y)) () (= (<+> A) (sum (1) (length A) (lambda y (_ A y))))
  x y A indexeq2 lambdaeq1 (1) (length A) sumseq3i
)

## <suggest> right('Define', '<*>') left('Simplify', '<*>') </suggest>
defthm (df-tupleproduct nat (<*> A) ((A y)) () (= (<*> A) (product (1) (length A) (lambda y (_ A y))))
  x y A indexeq2 lambdaeq1 (1) (length A) productseq3i
)

thm (tupleproducteq () () (-> (= A B) (= (<*> A) (<*> B)))
  A B lengtheq
  (= A B) x alnfi
  A B x indexeq1
  x 19.20i  
  syl
  x (_ A x) (_ B x) lambdaeq2  
  syl
  jca
  (length A) (length B) (lambda x (_ A x)) (lambda x (_ B x)) (1) producteq23  
  syl
  
  ## <d>
    A x df-tupleproduct
    ## <d 'Commutative Property'>
      (<*> A) (product (1) (length A) (lambda x (_ A x))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq0
  ## </d>
  
  ## <d>
    B x df-tupleproduct
    ## <d 'Commutative Property'>
      (<*> B) (product (1) (length B) (lambda x (_ B x))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq1
  ## </d>
)

thm (tupleproducteqi () (
     hyp1 (= A B))
     (= (<*> A) (<*> B))
  hyp1
  A B tupleproducteq
  ax-mp
)

thm (tupleproducteqd () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (<*> A) (<*> B)))
  hyp1
  A B tupleproducteq
  syl
)

thm (tuplesumeq () () (-> (= A B) (= (<+> A) (<+> B)))
  A B lengtheq
  (= A B) x alnfi
  A B x indexeq1
  x 19.20i  
  syl
  x (_ A x) (_ B x) lambdaeq2  
  syl
  jca
  (length A) (length B) (lambda x (_ A x)) (lambda x (_ B x)) (1) sumeq23    
  syl
  
  ## <d>
    A x df-tuplesum
    ## <d 'Commutative Property'>
      (<+> A) (sum (1) (length A) (lambda x (_ A x))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq0
  ## </d>
  
  ## <d>
    B x df-tuplesum
    ## <d 'Commutative Property'>
      (<+> B) (sum (1) (length B) (lambda x (_ B x))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Eq1
  ## </d>
)

thm (tuplesumeqi () (
     hyp1 (= A B))
     (= (<+> A) (<+> B))
  hyp1
  A B tuplesumeq
  ax-mp
)

thm (tuplesumeqd () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (<+> A) (<+> B)))
  hyp1
  A B tuplesumeq
  syl
)

defthm (df-tupleset set (<{}> A) ((A y)) () (=_ (<{}> A) ({.|} (lambda y (_ A y)) ({|} y (/\ (<= (1) y) (<= y (length A))))))
  x y A indexeq2 lambdaeq1
  x y (1) leeq2
  x y (length A) leeq1
  anbi12d
  abeq
  pm3.2i
  (lambda x (_ A x)) (lambda y (_ A y)) ({|} x (/\ (<= (1) x) (<= x (length A)))) ({|} y (/\ (<= (1) y) (<= y (length A)))) applysetseq12  
  ax-mp
)

## <title> Substitution </title>
## <table>
##   (<-> ph (E. x  [ ps ]   ]    ] ))
##   (<->           [ ps ]   [ ch ] )
##   (<-> ph (E. x  [    [   [ ch ] ))
## </table>
thm (BiReplaceBi1Ex1 () (
     replacee (<-> ph (E. x ps))
     substitution (<-> ps ch)) 
     (<-> ph (E. x ch))
  replacee substitution
  x exbii
  bitri
)


## <title> Substitution </title>
## <table>
##   (<-> ph (E. x (/\ ps  [ ch ]   ]    ] )))
##   (<->                  [ ch ]   [ th ] )
##   (<-> ph (E. x (/\ ps  [    [   [ th ] )))
## </table>
thm (BiReplaceBi1Ex1An1 () (
     replacee (<-> ph (E. x (/\ ps ch)))
     substitution (<-> ch th)) 
     (<-> ph (E. x (/\ ps th)))
  replacee substitution
  ps anbi2i
  BiReplaceBi1Ex1
)

thm (elementDivides.1 ((B y) (A y) (S y)) () (-> (e. B ({.|} S ({|} y (/\ (<= (1) y) (<= y (length A)))))) (| B (product (1) (length A) S)))
  S ({|} y (/\ (<= (1) y) (<= y (length A)))) x y df-applyset
  B eleq2i 
  ## <d>
    B x (E. y (/\ (= x (apply S y)) (e. y ({|} y (/\ (<= (1) y) (<= y (length A))))))) ax-elab
    bitri
  ## </d>
  x B (apply S y) eqeq1

  (e. y ({|} y (/\ (<= (1) y) (<= y (length A))))) anbi1d
  y exbid
  sbcie  
  bitri

#  (1) y (length A) S productdividesd  
  ## <d>
    y y (/\ (<= (1) y) (<= y (length A))) ax-elab
    BiReplaceBi1Ex1An1
  ## </d>
  y (1) (length A) interval-rwff
  sbcid
  bicomi
  BiReplaceBi1Ex1An1

  (1) y (length A) S productdividesd
  (= B (apply S y)) anim2i
  y 19.22i
  ImpReplaceBi1
  B (apply S y) (product (1) (length A) S) divideseq1
  ImpReplaceImp1Ex1An0

  ## <d 'Commutative Property '>
    (<-> (| B (product (1) (length A) S)) (| (apply S y) (product (1) (length A) S))) (| (apply S y) (product (1) (length A) S)) ancom
    BiReplaceImp1Ex1
  ## </d 'Commutative Property '>
  ## <d 'Commutative Property '>
    (| B (product (1) (length A) S)) (| (apply S y) (product (1) (length A) S)) bicom
    BiReplaceImp1Ex1An1
  ## </d 'Commutative Property '>
  ## <d>
    (| (apply S y) (product (1) (length A) S)) (| B (product (1) (length A) S)) mpbi-inline
    ImpReplaceImp1Ex1
  ## </d>
  y (| B (product (1) (length A) S)) ex-nf
  syl
)



## <title> Substitution </title>
## <table>
##   (-> (e. A  [ S ]   ]   ] ) ph)
##   (=_        [ S ]   [ T ] )
##   (-> (e. A  [   [   [ T ] ) ph)
## </table>
thm (SeqReplaceImp0El1 () (
     replacee (-> (e. A S) ph)
     substitution (=_ S T)) 
     (-> (e. A T) ph)
  replacee substitution
  A eleq2i
  sylbi2
)

## <title> Each element in the set is a divisor </title>
thm (elementDivides () () (-> (e. B (<{}> A)) (| B (<*> A)))
  B (lambda x (_ A x)) x A elementDivides.1
  A x df-tupleset seqcomi  
  SeqReplaceImp0El1
  
  ## <d>
    A x df-tupleproduct
    ## <d 'Commutative Property'>
      (<*> A) (product (1) (length A) (lambda x (_ A x))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Divs1
  ## </d>
)



## <title> Substitution </title>
## <table>
##   (-> (A. x  [ ph ]   ]    ] ) ch)
##   (<->       [ ph ]   [ ps ] )
##   (-> (A. x  [    [   [ ps ] ) ch)
## </table>
thm (BiReplaceImp0Al1 () (
     replacee (-> (A. x ph) ch)
     substitution (<-> ph ps)) 
     (-> (A. x ps) ch)
  replacee substitution
  x albii
  sylbi2
)


## <title> Substitution </title>
## <table>
##   (-> (A. x (-> ph  [ ps ]   ]    ] )) th)
##   (<->              [ ps ]   [ ch ] )
##   (-> (A. x (-> ph  [    [   [ ch ] )) th)
## </table>
thm (BiReplaceImp0Al1Imp1 () (
     replacee (-> (A. x (-> ph ps)) th)
     substitution (<-> ps ch)) 
     (-> (A. x (-> ph ch)) th)
  replacee substitution
  ph imbi2i
  BiReplaceImp0Al1
)

## <title> Substitution </title>
## <table>
##   (-> (A. x (->  [ ph ]   ]    ]  ch)) th)
##   (<->           [ ph ]   [ ps ] )
##   (-> (A. x (->  [    [   [ ps ]  ch)) th)
## </table>
thm (BiReplaceImp0Al1Imp0 () (
     replacee (-> (A. x (-> ph ch)) th)
     substitution (<-> ph ps)) 
     (-> (A. x (-> ps ch)) th)
  replacee substitution
  ch imbi1i
  BiReplaceImp0Al1
)

## <title> Substitution </title>
## <table>
##   (-> (A. x (-> ph (-.  [ ps ]   ]    ] ))) th)
##   (<->                  [ ps ]   [ ch ] )
##   (-> (A. x (-> ph (-.  [    [   [ ch ] ))) th)
## </table>
thm (BiReplaceImp0Al1Imp1Not0 () (
     replacee (-> (A. x (-> ph (-. ps))) th)
     substitution (<-> ps ch)) 
     (-> (A. x (-> ph (-. ch))) th)
  replacee substitution
  con4biir
  BiReplaceImp0Al1Imp1
)

## <title> Substitution </title>
## <table>
##   (-> (-. (e. A  [ S ]   ]   ] )) ph)
##   (=_            [ S ]   [ T ] )
##   (-> (-. (e. A  [   [   [ T ] )) ph)
## </table>
thm (SeqReplaceImp0Not0El1 () (
     replacee (-> (-. (e. A S)) ph)
     substitution (=_ S T)) 
     (-> (-. (e. A T)) ph)
  replacee substitution
  A eleq2i
  BiReplaceImp0Not0
)

## <title> Product of nonzero numbers is not zero </title>
thm (tupleproduct0 () () (-> (-. (e. (0) (<{}> A))) (-. (<= (<*> A) (0))))
  x (length A) (lambda x (_ A x)) (length A) productnot0.3
  (length A) leid  
  (< (0) (product (1) (length A) (lambda x (_ A x)))) impRemove1
  (A. x (-> (/\ (<= (1) x) (<= x (length A))) (< (0) (apply (lambda x (_ A x)) x)))) imbi2i  
  mpbi
  
  ## <d>
    A x df-tupleproduct
    ## <d 'Commutative Property'>
      (<*> A) (product (1) (length A) (lambda x (_ A x))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceImp1Lt1
  ## </d>
#  A x df-tupleset
  (apply (lambda x (_ A x)) x) 0inequalities bicomi  
  BiReplaceImp0Al1Imp1
  x (1) (length A) interval-rwff
  abid bicomi  
  BiReplaceImp0Al1Imp0
  
  ## <d 'Symmetric Property '>
    (0) (apply (lambda x (_ A x)) x) eqcom
    BiReplaceImp0Al1Imp1Not0
  ## </d 'Symmetric Property '>
  (0) (lambda x (_ A x)) ({|} x (/\ (<= (1) x) (<= x (length A))))  x notelapplyset bicomi
  sylbi2
  A x df-tupleset seqcomi  
  SeqReplaceImp0Not0El1
  
  ## <d 'Commute Inequality '>
    (0) (<*> A) ltcom
    sylib
  ## </d>
)

## <title> Product of nonzero numbers is not zero </title>
thm (tupleproduct1 () () (-> (-. (e. (0) (<{}> A))) (-. (< (<*> A) (1))))
  A tupleproduct0
  ## <d 'Convert between ≤ and < '>
    (<*> A) (0) lePlus1
    ## <d 'Commutative Property'>
      (< (<*> A) (+ (0) (1))) (<= (<*> A) (0)) bicom
      mpbi
    ## </d 'Commutative Property'>
    (1) pa_ax3r
    EqReplaceBi1Lt1
    BiReplaceImp1Not0
  ## </d 'Convert between ≤ and < '>
)

thm (elprime ((A x)) () (<-> (prime A) (e. A ({|} x (prime x))))
  ## <d>
    A x (prime x) ax-elab
  ## </d>
  x A primeeq sbcie  
  bitri
  bicomi
)

# number 7.4
## <title> 0 is not prime </title>
thm (0notprime () () (-. (prime (0)))
  (0) x df-prime
  (1) 0le
  notnoti
  (A. x (-> (| x (0)) (\/ (= x (1)) (= x (0))))) anNotRemove1
  (prime (0)) bibi2i
  mpbi
  notfal  
  mtbirRemove
)


## <title> Substitution </title>
## <table>
##   (-> ph (-> (-.  [ ps ]   ]    ] ) th))
##   (<->            [ ps ]   [ ch ] )
##   (-> ph (-> (-.  [    [   [ ch ] ) th))
## </table>
thm (BiReplaceImp1Imp0Not0 () (
     replacee (-> ph (-> (-. ps) th))
     substitution (<-> ps ch)) 
     (-> ph (-> (-. ch) th))
  replacee substitution
  con4biir
  BiReplaceImp1Imp0
)

# == Unique factorization ==

# number 0.5
thm (lincomgcd () () (lincom (S A) B (gcd (S A) B))
x  (gcd (S A) B)  tyex
  A  B  x  gcddiv1.2
  pm3.27d
  eqcoms
  x  (gcd (S A) B)  (S A)  B  lincomeq3    mpbid
  x  exani
ax-mp
)
# number 0.9
## <suggest> right('Simplify', '|') </suggest>
thm (dividesadd12 () () (-> (/\ (| A B) (| A C)) (| A (+ B C)))
  A  B  x  df-divides    biimpi
    A  C  y  df-divides    biimpi
  anim12i
  x  (= (* A x) B)  y  (= (* A y) C)  exey    syl
   z  (+ x y)  tyex
    (* A x)  B  (* A y)  C  addeq12
    A  x  y  distr    (+ B C)  eqeq1i    sylibr
      z  (+ x y)  A  muleq2
      (+ B C)  eqeq1d
      biimprd
      com12
      z  19.22d
    syl
   mpi
   y  exani
   x  exani
  syl
    A  (+ B C)  z  df-divides
  sylibr
)

thm (addmod0 () () (-> (/\ (= (mod B A) (0)) (= (mod C A) (0))) (= (mod (+ B C) A) (0)))
  A B dividesmod
  A C dividesmod
  anbi12i  
  ## <d>
    A B C dividesadd12
    ImpReplaceBi0
  ## </d>
  A (+ B C) dividesmod  
  sylib
)

## <title> Distribute an integer division </title>
## <summary>
##   Integer division distributes when adding two multiples of the divisor
## </summary>
thm (divdist() (hyp (| A B) hyp2 (| A C)) (-> (< (0) A) (= (+ (div B A) (div C A)) (div (+ B C) A)))
  A (+ (div B A) (div C A)) (div (+ B C) A) mulcant2
  A B div
  hyp
  A B dividesmod  
  mpbi
  EqReplaceEq0Add1
  ## <d 'Additive Identity Axiom '>
    (* A (div B A)) pa_ax3
    EqReplaceEq0
  ## </d 'Additive Identity Axiom '>
  A C div

  hyp2
  A C dividesmod  
  mpbi
  EqReplaceEq0Add1
  ## <d 'Additive Identity Axiom '>
    (* A (div C A)) pa_ax3
    EqReplaceEq0
  ## </d 'Additive Identity Axiom '>
  addeq12i

  A (+ B C) div
  hyp
  A B dividesmod  
  mpbi
  hyp2
  A C dividesmod  
  mpbi
  pm3.2i
  B A C addmod0
  ax-mp
  EqReplaceEq0Add1
  ## <d 'Additive Identity Axiom '>
    (* A (div (+ B C) A)) pa_ax3
    EqReplaceEq0
  ## </d 'Additive Identity Axiom '>
  eqcomi
  EqReplaceEq1

  ## <d 'Distributive Property '>
    A (div B A) (div C A) distr
    ## <d 'Commutative Property'>
      (* A (+ (div B A) (div C A))) (+ (* A (div B A)) (* A (div C A))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceEq0
  ## </d 'Distributive Property '>

  (= (+ (div B A) (div C A)) (div (+ B C) A)) biRemove1
  (< (0) A) imbi2i
  mpbi
)

## <title> Distribute an integer division </title>
## <table>
##   (< (0) A)
##   (| A <g> B) 
##   (| A <r> C)
##   (= (+ (div <g> B A) (div <r> C A)) (div (+ <g> B <r> C) A))
## </table>
## <summary>
##   Integer division distributes when adding two multiples of the divisor
## </summary>
thm (divdisti() (hyp (< (0) A) hyp2 (| A B) hyp3 (| A C)) (= (+ (div B A) (div C A)) (div (+ B C) A))
  hyp
  hyp2
  hyp3
  divdist
  ax-mp
)

## <title> Substitution </title>
## <table>
##   (<-> ph (= A (div  [ B ]   ]   ]  D)))
##   (=                 [ B ]   [ C ] )
##   (<-> ph (= A (div  [   [   [ C ]  D)))
## </table>
thm (EqReplaceBi1Eq1Div0 () (
     replacee (<-> ph (= A (div B D)))
     substitution (= B C)) 
     (<-> ph (= A (div C D)))
  replacee substitution
  D diveq1i
  EqReplaceBi1Eq1
)



## <title> Substitution </title>
## <table>
##   (= A (div  [ B ]   ]   ]  D))
##   (=         [ B ]   [ C ] )
##   (= A (div  [   [   [ C ]  D))
## </table>
thm (EqReplaceEq1Div0 () (
     replacee (= A (div B D))
     substitution (= B C)) 
     (= A (div C D))
  replacee substitution
  D diveq1i
  EqReplaceEq1
)


## <title> Substitution </title>
## <table>
##   (<-> ph (= A (div (* B  [ C ]   ]   ] ) A')))
##   (=                      [ C ]   [ D ] )
##   (<-> ph (= A (div (* B  [   [   [ D ] ) A')))
## </table>
thm (EqReplaceBi1Eq1Div0Mul1 () (
     replacee (<-> ph (= A (div (* B C) A')))
     substitution (= C D)) 
     (<-> ph (= A (div (* B D) A')))
  replacee substitution
  B muleq2i
  EqReplaceBi1Eq1Div0
)

## <title> Substitution </title>
## <table>
##   (<-> ph (= A (div (* B (+ C  [ D ]   ]    ] )) B')))
##   (=                           [ D ]   [ A' ] )
##   (<-> ph (= A (div (* B (+ C  [   [   [ A' ] )) B')))
## </table>
thm (EqReplaceBi1Eq1Div0Mul1Add1 () (
     replacee (<-> ph (= A (div (* B (+ C D)) B')))
     substitution (= D A')) 
     (<-> ph (= A (div (* B (+ C A')) B')))
  replacee substitution
  C addeq2i
  EqReplaceBi1Eq1Div0Mul1
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (div  [ B ]   ]   ]  D)))
##   (=                [ B ]   [ C ] )
##   (-> ph (= A (div  [   [   [ C ]  D)))
## </table>
thm (EqReplaceImp1Eq1Div0 () (
     replacee (-> ph (= A (div B D)))
     substitution (= B C)) 
     (-> ph (= A (div C D)))
  replacee substitution
  D diveq1i
  EqReplaceImp1Eq1
)

thm (mod0 () (hyp (< (0) A)) (= (mod (0) A) (0))
  hyp
  ## <d 'Evaluate'>
    ## <d 'Evaluate'>
      A pa_ax5
      (0) addeq1i
    ## </d 'Evaluate'>
    ## <d 'Evaluate'>
      (0) pa_ax3r
      EqReplaceEq1
    ## </d 'Evaluate'>
  ## </d 'Evaluate'>
  modvali
)

## <title> 0 divided by a positive number is 0 </title>
thm (div0 () (hyp (< (0) A)) (= (div (0) A) (0))
    hyp  
    ## <d 'Commute Inequality '>
      (0) A ltcom
      mpbi
    ## </d>
    ## <d 'Evaluate'>
      ## <d 'Evaluate'>
        A pa_ax5
        (mod (0) A) addeq1i
      ## </d 'Evaluate'>
      ## <d 'Evaluate'>
        hyp
        mod0
        EqReplaceEq1Add1
      ## </d 'Evaluate'>
      ## <d 'Evaluate'>
        (0) pa_ax3r
        EqReplaceEq1
      ## </d 'Evaluate'>
    ## </d 'Evaluate'>
    divval
)

## <title> Perform a substitution </title>
## <summary>
##   Perform substitution for a formula describing an arithmetic sum. Replace every instance of y with A.
## </summary>
thm (sbc-arithmeticsum ((A y)) () (<-> ([/] A y (= (sum (0) y (lambda x x)) (div (* y (+ y (1))) (2)))) (= (sum (0) A (lambda x x)) (div (* A (+ A (1))) (2))))
  y A (0) (lambda x x)  sumeq2
  (= y A) id
  y A (1) addeq1
  muleq12d
  (2) diveq1d
  eqeq12d
  sbcie
)

## <title> Replace number using a hypothetical equality </title>
## <table>
##                       (= [ C (+ [ <g> A ] B))
##   (-> (= <g> A <r> D) (= [ C (+ [ <r> D ] B)))
## </table>
thm (hypaddeq1 () (hyp (= C (+ A B))) (-> (= A D) (= C (+ D B)))
  A D B addeq1
  hyp
  eqcomi
  EqReplaceImp1Eq0
)

## <title> Cancel multiplication for numbers above 0 </title>
## <table>
##   (-. (<= <r> A (0)))
##   (= (div (* <r> A B) <r> A) B)
## </table>
thm (muldivi () (hyp (-. (<= A (0)))) (= (div (* A B) A) B)
  hyp
  A B muldiv  
  ## <d 'Commute Inequality '>
    (0) A ltcom
    sylbi2
  ## </d 'Commute Inequality '>
  ax-mp
)

## <title> Sum of an Arithmetic Series </title>
## <summary> A formula for the sum of all numbers between 0 and A. Proved using induction. </summary>
thm (arithmeticsum () () (= (sum (0) A (lambda x x)) (div (* A (+ A (1))) (2)))
  ## <d>
    ## <d 'Basis Case'>
      ## <d 'Sum the sequence from 0 to 0'>
        (0) (lambda x x) sum1
        ## <d 'Sum the sequence from 0 to 0'>
          x (0) applyfunid
          EqReplaceEq1
        ## </d 'Sum the sequence from 0 to 0'>
      ## </d 'Sum the number 0'>
      ## <d 'Arithmetic'>
        ## <d 'Arithmetic'>
          ## <d 'Multiply by 0'>
            (+ (0) (1)) pa_ax5r
            eqcomi
          ## </d 'Multiply by 0'>
          ## <d>
            (2) diveq1i
            0less2
            ## <d 'Divide 0 by 2' >
              div0
              EqReplaceEq0
            ## </d>
          ## </d>
        ## </d 'Arithmetic'>
        eqtr
      ## </d 'Sum the number 0'>
      ## <d 'Use substitution for z = 0'>
        ## <d 'Use substitution for z = 0'>
          (0) z x sbc-arithmeticsum bicomi
        ## </d 'Use substitution for z = 0'>
        mpbi
      ## </d 'Use substitution for z = 0'>
    ## </d 'Basis Case'>

    ## <d 'Detach the last number in a sum: y + 1'>
      ## <d 'Detach the last number in a sum: y + 1'>
        y (lambda x x) sumdetach2
        ## <d 'Apply the identity function'>
          x (+ y (1)) applyfunid
          EqReplaceEq1Add1
        ## </d 'Apply the identity function'>
      ## </d 'Detach the last number in a sum: y + 1'>
    (div (* y (+ y (1))) (2)) hypaddeq1
    ## </d 'Detach the last number in a sum: y + 1'>
  ## </d>
  ## <d 'Multiply and Divide y+1 by 2'>
    ## <d 'Multiply and Divide by 2'>
      2greater0
      (+ y (1)) muldivi
      eqcomi
    ## </d 'Multiply and Divide by 2'>
    EqReplaceImp1Eq1Add1
  ## </d 'Multiply and Divide by 2'>
  ## <d 'Distributive Property'>
    0less2
    y evenxxplus1
    (2) (+ y (1)) dividessymmul
    divdisti

    ## <d 'Distributive Property '>
      ## <d 'Distributive Property of Multiplication'>
        y (2) (+ y (1)) distl
        eqcomi
      ## </d 'Distributive Property of Multiplication'>
      EqReplaceEq1Div0
    ## </d 'Distributive Property '>
    EqReplaceImp1Eq1
  ## </d 'Distributive Property'>

  ## <d 'Induction'>
    ## <d 'Substitute z in for  z = y and z = y+1'>
      ## <d 'Substitute z in for  z = y'>
        ## <d 'Substitute z in for  z = y'>
          y z x sbc-arithmeticsum bicomi
        ## </d 'Substitute z in for  z = y'>
        sylbi2
      ## </d 'Substitute z in for z = y'>
      ## <d 'Substitute z in for z = y+1'>
        ## <d 'Commute Multiplication'>
          (+ y (2)) (+ y (1)) mulcom
          EqReplaceImp1Eq1Div0
        ## </d 'Commute Multiplication'>
        ## <d 'Substitute z in for z = y+1'>
          (+ y (1)) z x sbc-arithmeticsum
          ## <d 'Associative Property '>
            y (1) (1) addass
            EqReplaceBi1Eq1Div0Mul1
          ## </d 'Associative Property '>
          ## <d 'Add 1 + 1'>
            1plus1
            EqReplaceBi1Eq1Div0Mul1Add1
          ## </d 'Add 1 + 1'>
          bicomi
          sylib
        ## </d 'Substitute z in for z = y+1'>
      ## </d 'Substitute z in for z = y+1'>
    ## </d 'Substitute z in for  z = y and z = y+1'>

    A induction
    ## <d 'Substitute A in for z'>
      A z x sbc-arithmeticsum
      mpbi
    ## </d>
  ## </d 'Induction'>
)


## <title> Divide the difference </title> 
## <suggest> right('Simplify', '|') </suggest>
## <table>
##   (-> (/\ (| A <r> B) (| A <g> C)) (| A (.- <r> B <g> C)))
## </table>
thm (divideshalfminus12 () () (-> (/\ (| A B) (| A C)) (| A (.- B C)))
  A  B  x  df-divides    biimpi
  A  C  y  df-divides    biimpi
  anim12i
  x  (= (* A x) B)  y  (= (* A y) C)  exey    syl
  z  (.- x y)  tyex
  (* A x)  B  (* A y)  C  halfminuseq12
    A  x  y  halfminusdist  (.- B C)  eqeq1i    sylibr
      z  (.- x y)  A  muleq2
      (.- B C)  eqeq1d
      biimprd
      com12
      z  19.22d
    syl
   mpi
   y  exani
   x  exani
  syl
  A  (.- B C)  z  df-divides
  sylibr
)


## <title> Numbers above 1 have prime divisors </title>
thm (primesetdivisor2 ((A y)) () (-> (-. (< A (2))) (E. y (/\ (e. y (primeset)) (| y A))))
  A y primedivisor2
  ## <d 'Commute Inequality '>
    (2) A lecom
    sylbi2
  ## </d 'Commute Inequality '>  
  ## <d 'Def. Set of Prime Numbers '>
    y elprimeset
    ## <d 'Commutative Property'>
      (e. y (primeset)) (prime y) bicom
      mpbi
    ## </d 'Commutative Property'>
    BiReplaceImp1Ex1An0
  ## </d 'Def. Set of Prime Numbers '>
)

## <title> Substitution </title>
## <table>
##   (-> ph (| A (+  [ B ]   ]   ]  D)))
##   (=              [ B ]   [ C ] )
##   (-> ph (| A (+  [   [   [ C ]  D)))
## </table>
thm (EqReplaceImp1Divs1Add0 () (
     replacee (-> ph (| A (+ B D)))
     substitution (= B C)) 
     (-> ph (| A (+ C D)))
  replacee substitution
  D addeq1i
  EqReplaceImp1Divs1
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ ps (-> ch  [ th ]   ]    ] ))))
##   (->                         [ th ]   [ ta ] )
##   (-> ph (E. x (/\ ps (-> ch  [    [   [ ta ] ))))
## </table>
thm (ImpReplaceImp1Ex1An1Imp1 () (
     replacee (-> ph (E. x (/\ ps (-> ch th))))
     substitution (-> th ta)) 
     (-> ph (E. x (/\ ps (-> ch ta))))
  replacee substitution
  ch imim2i
  ImpReplaceImp1Ex1An1
)

## <title> Substitution </title>
## <table>
##   (<-> ph (/\ ps  [ ch ]   ]    ] ))
##   (->             [ ch ]   [ th ] )
##   (<-> ph (/\ ps  [    [   [ th ] ))
## </table>
thm (ImpReplaceBi1An1 () (
     replacee (<-> ph (/\ ps ch))
     substitution (-> ch th)) 
     (-> ph (/\ ps th))
  replacee substitution
  ps anim2i
  ImpReplaceBi1
)

## <title> Modus Ponens </title>
## <table>
##   (-> ta (E. x (/\ (/\ ph ] ps) ] (-> ps [ ch))))
##   (-> ta (E. x (/\     ph ]     ]        [ ch)))
## </table>
thm (exmpanand () (hyp (-> ta (E. x (/\ (/\ ph ps) (-> ps ch))))) (-> ta (E. x (/\ ph ch)))
  hyp
  ph ps (-> ps ch) anass  
  ## <d 'Introduce conjunct as antecedent '>
    ps ch abai
    ## <d 'Commutative Property'>
      (/\ ps ch) (/\ ps (-> ps ch)) bicom
      mpbi
    ## </d 'Commutative Property'>
    BiReplaceBi1An1
  ## </d 'Introduce conjunct as antecedent '>
  
  ## <d ''Remove Left Side of AND' '>
    ps ch pm3.27
    ImpReplaceBi1An1
  ## </d ''Remove Left Side of AND' '>
  x 19.22i
  ta imim2i
  ax-mp
)

## <title> Sets are unequal if an element is only in one </title>
## <table>
##   (-> ph (E. y (/\ (e. y S) (-. (e. y [ T ] )))))
##   (-> ph (E. y                (-. (=_ [ T ] S))))
## </table>
thm (ImExelnotseqcom () (hyp (-> ph (E. y (/\ (e. y S) (-. (e. y T)))))) (-> ph (E. y (-. (=_ T S))))
  hyp
  y S T elnotseqcom
  y 19.22i
  ph imim2i    
  ax-mp
)

## <title> Contrapositive </title>
## <table>
##   (-> th (E. x (/\ ch [ (-> <r> ph <g> ps)          ] )))
##   (-> th (E. x (/\ ch [ (-> <g> (-. ps) <r> (-. ph) ] ))))
## </table>
thm (ImExAncon3i () (hyp (-> th (E. x (/\ ch (-> ph ps)))) ) (-> th (E. x (/\ ch (-> (-. ps) (-. ph)))))
  hyp
  ph ps con34b
  ch anbi2i
  x exbii
  th imbi2i
  mpbi
)

## <title> Remove a true antecedent </title>
## <table>
##   (-> ph (-> [ <r> ps [ ch))
##              [ <r> ps ]
##   (-> ph     [        [ ch)
## </table>
thm (removeImp23 () (hyp (-> ph (-> ps ch)) hyp2 ps) (-> ph ch)
  hyp
  hyp2
  ch impRemove1
  ph imbi2i
  mpbi
)

## <title> Euclid's Theorem </title>
## <summary>
##   <a href="http://en.wikipedia.org/wiki/Euclid">Euclid</a>'s Proof that there are infinitely
##   many prime numbers.
## </summary>
thm (euclidthm () () (-. (=_ (<{}> x) (primeset)))
  ## <d 'Product + 1 has a prime divisor y'>
    ## <d '0 is not in a subset of primes' >
      ## <d '0 is not in the set of primes' >
        ## <d>
          0notprime
        ## </d>
        ## <d 'Def. Set of Prime Numbers' >
         (0) elprimeset bicomi
        ## </d>
        mtbi
      ## </d>
      (<{}> x) (primeset) (0) subsetnoextra
      mpan2
    ## </d '0 is not in a subset of primes' >
    ## <d 'A product of nonzero numbers is not zero' >
      x tupleproduct1
      syl
    ## </d 'A p roduct of nonzero numbers is not zero' >
    ## <d 'Add 1 to both sides' >
      ## <d 'Add 1 to both sides' >
        (<*> x) (1) (1) geadd1
        1plus1
        EqReplaceBi1Not0Lt1
      ## </d 'Add 1 to both sides' >
      sylib
    ## </d 'Add 1 to both sides' >
    ## <d 'Numbers above 1 have prime divisors' >
      (+ (<*> x) (1)) y primesetdivisor2
      syl
    ## </d 'Add 1 to both sides' >
  ## </d>

  ## <d 'y would divide 1 if it was in the set' >
    ## <d 'A divisor can divide the difference' >
      y (+ (<*> x) (1)) (<*> x) divideshalfminus12
      ## <d 'Cancel with subtraction' >
        (<*> x ) (1) halfminuscan2
        EqReplaceImp1Divs1
      ## </d>
      impexpi2
    ## </d>
    ImpReplaceImp1Ex1An1
  ## </d>
  ## <d 'A prime number cannot divide 1' >
    ImExAncon3i
    ## <d 'If y is not a divisor, y is not in the set'>
      ## <d 'If y is not a divisor, y is not in the set'>
        y x elementDivides
        con3i
      ## </d>
      ImpReplaceImp1Ex1An1Imp1
    ## </d>
    ## <d 'A prime number cannot divide 1'>
      ## <d 'A prime number cannot divide 1'>
        ## <d 'A prime number cannot divide 1'>
          y divides1prime
          ## <d 'Def. Set of Prime Numbers' >
            ## <d 'Def. Set of Prime Numbers' >
              y elprimeset
              bicomi
            ## </d 'Def. Set of Prime Numbers' >
            sylbi2
          ## </d 'Def. Set of Prime Numbers' >
          ancli
        ## </d>
        ImpReplaceImp1Ex1An0
      ## </d>
      exmpanand
    ## </d>
  ## </d 'The divisor would divide 1 if in the set'>

  ## <d 'The set is missing the prime number y'>
    ## <d 'Sets are not equal '>
      ImExelnotseqcom
    ## </d 'Sets are not equal '>
    19.9d
  ## </d>

  ## <d 'No finite set contains all primes'>
    ## <d 'A set is equal to itself'>
      (<{}> x) (primeset) seqss
      con3i
    ## </d>
    pm2.61i
  ## </d>
)

# number 0.95
thm (divideslincom () () (-> (/\ (| (S A) B) (| (S A) C)) (-> (lincom B C D) (| (S A) D)))
B  C  D  w  x  y  z  df-lincom
  (S A)  B  w  dividesmul
  B  w  mulcom  (* B w)  (* w B)  (S A)  divideseq2    ax-mp   sylib
    (S A)  C  x  dividesmul
    C  x  mulcom  (* C x)  (* x C)  (S A)  divideseq2    ax-mp   sylib
  anim12i
  (S A)  (* w B)  (* x C)  dividesadd12    syl
    (+ (* w B) (* x C))  (+ (+ (* y B) (* z C)) D)  (S A)  divideseq2    biimpd
  mpan9
  ex    com12

 (S A)  B  y  dividesmul
  B  y  mulcom  (* B y)  (* y B)  (S A)  divideseq2    ax-mp   sylib
    (S A)  C  z  dividesmul
    C  z  mulcom  (* C z)  (* z C)  (S A)  divideseq2    ax-mp   sylib
  anim12i
  (S A)  (* y B)  (* z C)  dividesadd12    syl

  A  (+ (* y B) (* z C))  D  dividesadd.2    syl

  sylcom

  z  exani    y  exani    x  exani    w  exani    sylbi
  com12
)

thm (gcd () () (-> (/\ (| (S A) (S B)) (| (S A) C)) (| (S A) (gcd (S B) C)))
  B  C  lincomgcd
  A  (S B)  C  (gcd (S B) C)  divideslincom
mpi
)

# Linear combination is commutative
thm (lincomcom () () (<-> (lincom A B C) (lincom B A C))
  A  B  C  w  x  y  z  df-lincom
    (* w A)  (* x B)  addcom
      (* y A)  (* z B)  addcom    C  addeq1i
    eqeq12i
    z  exbii
    y  exbii
    y  z  (= (+ (* x B) (* w A)) (+ (+ (* z B) (* y A)) C))  excom    bitri
    x  exbii
    w  exbii
    w  x  (E. z (E. y (= (+ (* x B) (* w A)) (+ (+ (* z B) (* y A)) C))))  excom    bitri
  bitri
    B  A  C  x  w  z  y  df-lincom
  bitr4i
)

thm (gcdcom () () (= (gcd A B) (gcd B A))
  A  B  x  df-gcd
    A  B  x  lincomcom
    (-. (= x (0)))  anbi2i
    x  gen
    x  (/\ (-. (= x (0))) (lincom A B x))  (/\ (-. (= x (0))) (lincom B A x))  abbi2    ax-mp
    ({|} x (/\ (-. (= x (0))) (lincom A B x)))  ({|} x (/\ (-. (= x (0))) (lincom B A x)))  minseq    ax-mp
  eqtr
  B  A  x  df-gcd   eqtr4
)

# number 7.0
thm (primegcd () () (-> (prime (S A)) (\/ (| (S A) (S B)) (= (gcd (S A) (S B)) (1))))
A  (S B)  gcddiv1
  (S A)  x  df-prime    biimpi  
  (-. (<= (S A) (1))) 
  (A. x (-> (| x (S A)) (\/ (= x (1)) (= x (S A)))))
  pm3.27
  syl
  x  (gcd (S A) (S B))  (S A)    divideseq1
      x  (gcd (S A) (S B))  (1)  eqeq1
      x  (gcd (S A) (S B))  (S A)  eqeq1  orbi12d
    imbi12d
    cla4g
  syl
mpi

B  (S A)  gcddiv1
  (S A)  (S B)  gcdcom    (S A)  eqeq1i     biimpi
  (gcd (S B) (S A))  (S A)  (S B)  divideseq1    biimpd  syl
mpi

(= (gcd (S A) (S B)) (1)) orim2i    syl

(= (gcd (S A) (S B)) (1))  (| (S A) (S B))  orcom    sylib
)
# number 7.1
thm (divides0 () () (| A (0))
  x  (0)  tyex
    x  (0)  A  muleq2
    A  pa_ax5    syl6eq
  x  19.22i    ax-mp
  A  (0)  x  df-divides  mpbir
)

# number 7.2
thm (0divides () () (<-> (| (0) A) (= (0) A))
  (0)  A  x  df-divides
    x  pa_ax5r    A  eqeq1i
    x  exbii
  bitri
    x  (= (0) A)   19.9
  bitri
)

# number 7.3
thm (0primeideal () () (<-> (= (* A B) (0)) (\/ (= A (0)) (= B (0))))
  A  (0)  B  muleq1
  B  pa_ax5r    syl6eq
    B  (0)  A  muleq2
    A  pa_ax5    syl6eq
  jaoi

    A  x  lefoo
    x  a1suc    x  (1)  addcom  eqtr    A  eqeq1i  biimpri
    B  muleq1d
    (0)  eqeq1d   biimprd
      x  B  mul0
    syl6
    x  exani    (= A (0))    orim2i    ax-mp
    ori    com12    orrd
  impbii
  bicomi
)

## <summary> Euclid's lemma, assuming A and B are not 0. </summary>
thm (euclidlem.1 () () (-> (prime (S A)) (-> (| (S A) (* (S B) C)) (\/ (| (S A) (S B)) (| (S A) C))))
   A  B  primegcd  ord
      A  (S B)  lincomgcd
      (gcd (S A) (S B))  (1)  (S A)  (S B)  lincomeq3    mpbii
   syl6
   (S A)  (S B)  (1)  w  x  y  z  df-lincom    syl6ib


       (S A)  dividessym  (S A)  (S A)  (* w C)  dividesmul    ax-mp
         (S A)  w  mulcom    C  muleq1i   (S A)  w  C  mulass  eqtr3
         (* (* w (S A)) C)  (* (S A) (* w C))  (S A)  divideseq2    ax-mp
       mpbir
         (S A)  (* (S B) C)  x  dividesmul    (* (S B) C)  x  mulcom   x  (S B)  C  mulass    eqtr4   (* (* (S B) C) x)  (* (* x (S B)) C)  (S A)  divideseq2    ax-mp    sylib
      jctilb
      (S A)  (* (* w (S A)) C)  (* (* x (S B)) C)  dividesadd12    syl

     (+ (* w (S A))  (* x (S B)))  (+ (+ (* y (S A))  (* z (S B))) (1))   C  muleq1
     (* w (S A))  (* x (S B))  C  distl    syl5eqr
     (+ (* y (S A)) (* z (S B)))  (1)  C  distl    syl6eq
     (* y (S A))  (* z (S B))  C  distl    (* (1) C)  addeq1i    syl6eq

     (+ (* (* w (S A)) C) (* (* x (S B)) C))  (+ (+ (* (* y (S A)) C) (* (* z (S B)) C)) (* (1) C))  (S A)  divideseq2    syl    biimpd

     mpan9
     ex

       (S A)  dividessym  (S A)  (S A)  (* y C)  dividesmul    ax-mp
         (S A)  y  mulcom    C  muleq1i   (S A)  y  C  mulass  eqtr3
         (* (* y (S A)) C)  (* (S A) (* y C))  (S A)  divideseq2    ax-mp
       mpbir
         (S A)  (* (S B) C)  z  dividesmul    (* (S B) C)  z  mulcom   z  (S B)  C  mulass    eqtr4   (* (* (S B) C) z)  (* (* z (S B)) C)  (S A)  divideseq2    ax-mp    sylib
       jctilb
       (S A)  (* (* y (S A)) C)  (* (* z (S B)) C)  dividesadd12    syl

       A  (+ (* (* y (S A)) C) (* (* z (S B)) C))  (* (1) C)  dividesadd.2    syl

       C  mulid    C  (1)  mulcom    eqtr3    C  (* (1) C)  (S A)  divideseq2    ax-mp
    syl6ibr

    syld
    com12

  z  19.22i    y   19.22i    x  19.22i    w  19.22i    syl6
  z  (-> (| (S A) (* (S B) C)) (| (S A) C))  19.9    biimpi    y  exani    x  exani    w  exani    syl6
  com23
  imp
  orrd
  ex
)

## <summary> 
##   Removes one of the S marks from [euclidlem.1] by considering the case A=0.
##   The other S mark will be removed in [euclidlem] by considering B=0.
## </summary> 
thm (euclidlem.2 () () (-> (prime A) (-> (| A (* (S B) C)) (\/ (| A (S B)) (| A C))))
0notprime
(0)  A  primeeq    biimprd    con3d    mpi
con2i
A  (0)  eqcom    notbii  sylibr
A  x  lefoo    ori    syl
  x  a1suc    x  (1)  addcom  eqtr     A  eqeq1i    biimpri
x  19.22i    syl
  (S x)  A  primeeq    biimprd
  (S x)  A  (* (S B) C)  divideseq1   biimprd    anim12d
  x  B  C  euclidlem.1    imp    syl6
    (S x)  A  (S B)  divideseq1
    (S x)  A  C  divideseq1    orbi12d
  sylibd
x  exani    syl
anabsi5
ex
)
# number 8.0
## <title> Euclid's lemma </title>
thm (euclidlem () () (-> (prime A) (-> (| A (* B C)) (\/ (| A B) (| A C))))
  B  x  lefoo
    A  divides0
    B  (0)  A  divideseq2    biimprd    mpi
    (| A C)  orcd    (| A (* B C))  a1d    (prime A)  a1d

      x a1suc    x  (1)  addcom    (S x)  eqeq2i    mpbi
      B  eqeq1i     biimpri
       A  x  C  euclidlem.2
        (S x)  B  C  muleq1
        (* (S x) C)  (* B C)  A  divideseq2    syl
          (S x)  B  A  divideseq2    (| A C)  orbi1d
        imbi12d  biimpd
       mpan9
      ancoms   ex    syl
      x  exani
    jaoi
  ax-mp
)

# primes(A B) shall mean that the first A elements of the list represented by
# the beta-numeral B are all prime.
thm (df-primes-just ((A x y) (B x y)) () (<->
  (A. x (-> (< x A) (prime (beta B x))))
  (A. y (-> (< y A) (prime (beta B y)))))

  (= x y)  id    A  lteq1d
    x  y  B  betaeq2
    (beta B x)  (beta B y)  primeeq    syl
  imbi12d
  alpha
)

defthm (df-primes wff (primes A B) ((A x) (B x)) ()
    (<-> (primes A B)    (A. x (-> (< x A) (prime (beta B x)))))
  y  A  B  x  df-primes-just)
# number 10.0
# nondecr(A B) shall mean that the first A elements of the list represented by
# the beta-numeral B are nondecreasing.
thm (df-nondecr-just ((A x y) (B x y)) () (<->
  (A. x (-> (< (S x) A) (<= (beta B x) (beta B (S x)))))
  (A. y (-> (< (S y) A) (<= (beta B y) (beta B (S y))))))
  (= x y)  id    suceqd    A  lteq1d

    x  y  B  betaeq2
    (beta B (S x))  leeq1d

      (= x y)  id    suceqd
      (S x)  (S y)  B  betaeq2    syl
      (beta B y)  leeq2d
    bitr2d
    bicomd

  imbi12d
  alpha
)

defthm (df-nondecr wff (nondecr A B) ((A x) (B x)) ()
    (<-> (nondecr A B)   (A. x (-> (< (S x) A) (<= (beta B x) (beta B (S x))))))
  y  A  B  x  df-nondecr-just)


# partprod(A B C) shall mean that the first A elements of the sequence in
# beta-numeral B have their partial products in the beta-numeral C.
# May act funky if A == 0.
thm (df-partprod-just ((A x y) (B x y) (C x y)) () (<->
  (/\ (= (beta B (0)) (beta C (0)))
      (A. x (-> (< (S x) A) (= (beta C (S x)) (* (beta C x) (beta B x))))))
  (/\ (= (beta B (0)) (beta C (0)))
      (A. y (-> (< (S y) A) (= (beta C (S y)) (* (beta C y) (beta B y)))))))

  (= x y)  id    suceqd    A  lteq1d

    (= x y)  id    suceqd
    (S x)  (S y)  C  betaeq2    syl
      x  y  C  betaeq2
        x  y  B  betaeq2
      muleq12d
     eqeq12d
   imbi12d
  alpha
  (= (beta B (0)) (beta C (0)))  anbi2i
)

defthm (df-partprod wff (partprod A B C) ((A x) (B x) (C x)) ()
    (<-> (partprod A B C)
      (/\ (= (beta B (0)) (beta C (0)))
        (A. x (-> (< (S x) A) (= (beta C (S x)) (* (beta C x) (beta B x)))))))
  B  C  y  A  x  df-partprod-just)

# factorization(A, B, C, D) shall mean that D has been factored into A' primes,
# which are listed nondecreasingly in the beta-numeral B.  The beta-numeral C
# shall list the partial products alongside.
defthm (df-factorization  wff (factorization A B C D) () ()
  (<-> (factorization A B C D)
  (/\ (primes (S A) B)
      (/\ (nondecr (S A) B)
          (/\ (partprod (S A) B C)
              (= D (beta C A))))))

  (/\ (primes (S A) B)
      (/\ (nondecr (S A) B)
          (/\ (partprod (S A) B C)
              (= D (beta C A)))))  biid
)


## <summary> Any prime number has a trivial length-1 factorization </summary>
thm (exfactorization.0 ((A x)) ()
  (-> (prime A) (E. x (factorization (0) x x A)))

# x will be the beta-numeral of the length-1 list [A].
  x  A  recursive.2.1
# 1. primes [A]
    (beta x (0))  A  primeeq    biimprd
        z  (0)  lesuc    z  eq0le0    bitr4i    z  (0)  x  betaeq2    sylbi
        (beta x z)  (beta x (0))  primeeq    syl    biimprcd
    syl6
    imp
    z  19.21ai
    (S (0))  x  z  df-primes    sylibr
    #ex

# 2. nondecr 0' x  (for any x)
      y  pa_ax1    (S y)  (0)    lesuc    (S y)  eq0le0    bitr4i    biimpi   eqcomd     con3i   ax-mp
      (<= (beta x y) (beta x (S y)))  pm2.21i
      y  gen
        (S (0))  x  y  df-nondecr
      biimpri  ax-mp

# 3. partprod 0' x x  (for any x)
        (beta x (0))  eqid
          y  pa_ax1    (S y)  (0)    lesuc    (S y)  eq0le0    bitr4i    biimpi   eqcomd     con3i   ax-mp
          (= (beta x (S y)) (* (beta x y) (beta x y)))  pm2.21i
          y  gen
        pm3.2i
        (S (0))  x  x  y  df-partprod    mpbir

# assemble
          (beta x (0))  A  eqcom    biimpi    (prime A)  adantr
        jctilb
      jctilb
    jca

    ex
    com12
    x  19.22d
  mpi

    (0)  x  x  A  df-factorization    x  exbii
  sylibr
)

# Third equality identity for factorization
thm (factorizationeq3 () () (-> (= C C') (<-> (factorization A B C D) (factorization A B C' D)))


# just proving partprodeq3 in-place
    C  C'  (0)  betaeq1    (beta B (0))  eqeq2d
      C  C'  (S x)  betaeq1
      C  C'  x  betaeq1    (beta B x)  muleq1d    eqeq12d
      (< (S x) (S A))  imbi2d
      x  19.21ai            19.15d
    anbi12d
    (S A)  B  C  x  df-partprod    syl5bb
    (S A)  B  C'  x  df-partprod    syl6bbr


  C  C'  A  betaeq1
  D  eqeq2d

  anbi12d
  (nondecr (S A) B)  anbi2d
  (primes (S A) B)  anbi2d


  A  B  C  D  df-factorization    syl5bb
  A  B  C'  D  df-factorization    syl6bbr
)
# number 14.0
# Fourth equality identity for factorization
thm (factorizationeq4 () () (-> (= A B) (<-> (factorization D C C' A) (factorization D C C' B)))

  A  B  (beta C' D)  eqeq1
  (partprod (S D) C C')  anbi2d
  (nondecr (S D) C)  anbi2d
  (primes (S D) C)  anbi2d
  D  C  C'  B  df-factorization    syl6bbr
  D  C  C'  A  df-factorization    syl5bb
)
# number 14.5
# First equality identity for factorization
thm (factorizationeq1 () () (-> (= A B) (<-> (factorization A C C' D)
(factorization B C C' D)))

# primeseq1
A  B  pa_ax2    biimpi
x  lteq2d    (prime (beta C x))  imbi1d    x  19.21ai    19.15d
(S A)  C  x  df-primes    syl5bb
(S B)  C  x  df-primes    syl6bbr


# nondecreq1
A  B  pa_ax2    biimpi
(S x)  lteq2d    (<= (beta C x) (beta C (S x)))  imbi1d    x  19.21ai    19.15d
(S A)  C  x  df-nondecr    syl5bb
(S B)  C  x  df-nondecr    syl6bbr


# partprodeq1
  A  B  pa_ax2    biimpi
  (S x)  lteq2d    (= (beta C' (S x)) (* (beta C' x) (beta C x)))  imbi1d    x  19.21ai    19.15d
  (= (beta C (0)) (beta C' (0)))  anbi2d
    (S A)  C  C'  x  df-partprod    syl5bb
    (S B)  C  C'  x  df-partprod    syl6bbr


  A  B  C'   betaeq2
  D  eqeq2d

#assemble
  anbi12d
  anbi12d
  anbi12d

  A  C  C'  D  df-factorization    syl5bb
  B  C  C'  D  df-factorization    syl6bbr
)
# number 15.0
thm (exfactorization.1 ((A y) (A z) (A w)) () (-> (= x A)
  (<-> (E. w (E. y (E. z (factorization w y z (S (S x))))))
       (E. w (E. y (E. z (factorization w y z (S (S A))))))))
(= x A)  id    suceqd    suceqd
  (S (S x))  (S (S A))  w  y  z  factorizationeq4
  z  exbid    y  exbid    w  exbid
syl
)

## <summary> This is used just for convenience to get an empty theorem. </summary>
thm (emptyThm() () (T)
 tru
)

# number 16.0
## <summary> Existence of a factorization for any number bigger than 1. </summary>
# thm (exfactorization () () (E. x (E. y (E. y' (factorization x y y' (S (S A))))))

# # setup
# w  (0)  x  y  y'  exfactorization.1
# w  (S z)  x  y  y'  exfactorization.1
# w  A  x  y  y'  exfactorization.1

# # base case: 2, being prime, has a factorization
# 2prime
#   (1)  a1suc    df-1   (1)  (S (0))  pa_ax2  mpbi    eqtr3
# (+ (1) (1))  (S (S (0)))  primeeq    ax-mp  mpbi
# (S (S (0)))  y  exfactorization.0    ax-mp
#   y'  y  tyex
#     y'  y  (0)  y  (S (S (0)))  factorizationeq3
#     biimprd    y' 19.22i   ax-mp
#     y  gen
#   pm3.2i
#   y  (factorization (0) y y (S (S (0))))  (E. y' (-> (factorization (0) y y (S (S (0)))) (factorization (0) y y' (S (S (0))))))  19.29r    ax-mp
#   y'  (factorization (0) y y (S (S (0))))  (-> (factorization (0) y y (S (S (0)))) (factorization (0) y y' (S (S (0)))))  19.41l    biimpri   (factorization (0) y y (S (S (0))))  (factorization (0) y y' (S (S (0))))  pm3.35    y'  19.22i    syl    y  19.22i    ax-mp
#   x  gen

#   x  (0)  tyex
#   x  (0)  y  y'  (S (S (0)))  factorizationeq1    biimprd    y'  19.22d  y  19.22d    x  19.22i    ax-mp
# pm3.2i

# x  (E. y (E. y' (factorization (0) y y' (S (S (0))))))  (-> (E. y (E. y' (factorization (0) y y' (S (S (0)))))) (E. y (E. y' (factorization x y y' (S (S (0)))))))  19.29   (E. y (E. y' (factorization (0) y y' (S (S (0))))))  (E. y (E. y' (factorization x y y' (S (S (0))))))  pm3.35    x  19.22i    syl    ax-mp



# # Strong induction step
# v  (S z)  primedivisor

# (S (S v))  (S (S z))  dividesle    (S (S v))  (S (S (S z)))  lefoo3  sylib
# (prime (S (S v)))  anim2i

# (=  w v)  id    z  leeq1d
#   w  v  pa_ax2    biimpi    suceqd
#   (S (S w))  (S (S v))  x  y  y'  factorizationeq4    syl
#   y'  exbid    y  exbid    x  exbid
# imbi12d
# cla4g

#   ?
# )

export (PEANO_THMS /peano/peano_thms.ghi (PROP PEANO_MIN PEANO NAIVE_SET) "")
