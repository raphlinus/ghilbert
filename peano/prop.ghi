# Adapted mechanically from set.mm
# todo: proper attribution

kind (wff)
tvar (wff ph)
tvar (wff ps)
tvar (wff ch)
tvar (wff th)
tvar (wff ta)

#  (_Note_:  This theorem will never appear in a completed proof and can be
#        ignored if you are using this database to learn logic - please start
#        with the next statement, [[wn]].)
#
#        This is a technical theorem to assist proof development.  It provides a
#        temporary way to add an independent subproof to a proof under
#        development, for later assignment to a normal proof step.
#
#        The Metamath program's Proof Assistant requires proofs to be developed
#        backwards from the conclusion with no gaps, and it has no mechanism that
#        lets the user to work on isolated subproofs.  This theorem provides a
#        workaround for this limitation.  It can be inserted at any point in a
#        proof to allow an independent subproof to be developed on the side, for
#        later use as part of the final proof.
#
#        //Instructions//:  (1) Assign this theorem to any unknown step in the
#        proof.  Typically, the last unknown step is the most convenient, since
#        'assign last' can be used.  This step will be replicated in hypothesis
#        dummylink.1, from where the development of the main proof can continue.
#        (2) Develop the independent subproof backwards from hypothesis
#        dummylink.2.  If desired, use a 'let' command to pre-assign the
#        conclusion of the independent subproof to dummylink.2.  (3) After the
#        independent subproof is complete, use 'improve all' to assign it
#        automatically to an unknown step in the main proof that matches it.
#        (4) After the entire proof is complete, use
#        'minimize */n/b/e 3syl,we?,wsb' to clean up (discard) all dummylink
#        references automatically.
#
#        This theorem was originally designed to assist importing partially
#        completed Proof Worksheets from Mel O'Cat's mmj2 Proof Assistant GUI,
#        but it can also be useful on its own.  Interestingly, this "theorem" -
#        or more precisely, inference - requires no axioms for its proof.
stmt (dummylink () (ph ps) ph)
term (wff (-. ph))
term (wff (-> ph ps))

#  Axiom //Simp//.  Axiom A1 of [bib/Margaris] p. 49.  One of the 3 axioms of
#      propositional calculus.  The 3 axioms are also given as Definition 2.1
#      of [bib/Hamilton] p. 28.  This axiom is called //Simp// or "the principle of
#      simplification" in //Principia Mathematica// (Theorem *2.02 of
#      [bib/WhiteheadRussell] p. 100) because "it enables us to pass from the joint
#      assertion of #ph# and #ps# to the assertion of #ph# simply."
#
#      //General remarks//:  Propositional calculus (axioms [[ax-1]] through [[ax-3]]
#      and rule [[ax-mp]]) can be thought of as asserting formulas that are
#      universally "true" when their variables are replaced by any combination
#      of "true" and "false."  Propositional calculus was first formalized by
#      Frege in 1879, using as his axioms (in addition to rule [[ax-mp]]) the
#      wffs [[ax-1]], [[ax-2]], [[pm2.04]], [[con3]], [[notnot2]], and [[notnot1]].
#      Around 1930, Lukasiewicz simplified the system by eliminating the third
#      (which follows from the first two, as you can see by looking at the proof
#      of [[pm2.04]]) and replacing the last three with our [[ax-3]].  (Thanks to
#      Ted Ulrich for this information.)
#
#      The theorems of propositional calculus are also called //tautologies//.
#      Tautologies can be proved very simply using truth tables, based on the
#      true/false interpretation of propositional calculus.  To do this, we
#      assign all possible combinations of true and false to the wff variables
#      and verify that the result (using the rules described in [[wi]] and [[wn]])
#      always evaluates to true.  This is called the //semantic// approach.  Our
#      approach is called the //syntactic// approach, in which everything is
#      derived from axioms.  A metatheorem called the Completeness Theorem for
#      Propositional Calculus shows that the two approaches are equivalent and
#      even provides an algorithm for automatically generating syntactic proofs
#      from a truth table.  Those proofs, however, tend to be long, and the
#      much shorter proofs that we show here were found manually.  Truth tables
#      grow exponentially with the number of variables, but it is unknown if the
#      same is true of proofs - an answer to this would resolve the P=NP
#      conjecture in complexity theory.
stmt (ax-1 () () (-> ph (-> ps ph)))

#  Axiom //Frege//.  Axiom A2 of [bib/Margaris] p. 49.  One of the 3 axioms of
#      propositional calculus.  It "distributes" an antecedent over two
#      consequents.  This axiom was part of Frege's original system and is known
#      as //Frege// in the literature.  It is also proved as Theorem *2.77 of
#      [bib/WhiteheadRussell] p. 108.  The other direction of this axiom also
#      turns out to be true, as demonstrated by [[pm5.41]].
stmt (ax-2 () () (-> (-> ph (-> ps ch)) (-> (-> ph ps) (-> ph ch))))

#  Axiom //Transp//.  Axiom A3 of [bib/Margaris] p. 49.  One of the 3 axioms of
#      propositional calculus.  It swaps or "transposes" the order of the
#      consequents when negation is removed.  An informal example is that the
#      statement "if there are no clouds in the sky, it is not raining" implies
#      the statement "if it is raining, there are clouds in the sky."  This
#      axiom is called //Transp// or "the principle of transposition" in
#      //Principia Mathematica// (Theorem *2.17 of [bib/WhiteheadRussell] p. 103).
#      We will also use the term "contraposition" for this principle, although
#      the reader is advised that in the field of philosophical logic,
#      "contraposition" has a different technical meaning.
stmt (ax-3 () () (-> (-> (-. ph) (-. ps)) (-> ps ph)))

#  Rule of Modus Ponens.  The postulated inference rule of propositional
#        calculus.  See e.g. Rule 1 of [bib/Hamilton] p. 73.  The rule says, "if
#        #ph# is true, and #ph# implies #ps#, then #ps# must also be
#        true."  This rule is sometimes called "detachment," since it detaches
#        the minor premise from the major premise.
#
#        Note:  In some web page displays such as the Statement List, the symbols
#        "&" and "=>" informally indicate the relationship between the hypotheses
#        and the assertion (conclusion), abbreviating the English words "and" and
#        "implies."  They are not part of the formal language.
## <title> Modus Ponens Axiom </title>
## <table>
##      ph ] ]
##  (-> ph ] [ ps)
##         [ [ ps
## </table>
stmt (ax-mp () (ph (-> ph ps)) ps)

#  Inference derived from axiom [[ax-1]].  See [[a1d]] for an explanation of
#        our informal use of the terms "inference" and "deduction."  See also
#        the comment in [[syld]].
## <title> Axiom 1 Inference </title>
## <table>
##          [ ph
##   (-> ps [ ph)
## </table>
stmt (a1i () (ph) (-> ps ph))

#  Inference derived from axiom [[ax-2]].
## <title> Second Axiom Inference </title>
## <table>
##   (->     ph ] (-> [ ps ]         [ ch))
##   (-> (-> ph ]     [ ps ] ) (-> ph [ ch))
## </table>
stmt (a2i () ((-> ph (-> ps ch))) (-> (-> ph ps) (-> ph ch)))

#  An inference version of the transitive laws for implication [[imim2]] and
#        [[imim1]], which Russell and Whitehead call "the principle of the
#        syllogism...because...the syllogism in Barbara is derived from them"
#        (quote after Theorem *2.06 of [bib/WhiteheadRussell] p. 101).  Some authors
#        call this law a "hypothetical syllogism."
#
#        (A bit of trivia:  this is the most commonly referenced assertion in our
#        database.  In second place is [[ax-mp]], followed by [[visset]], [[bitri]],
#        [[imp]], and [[ex]].  The Metamath program command 'show usage' shows the
#        number of references.)
## <title> Syllogism </title>
## <table>
##   (-> ph [     ps ] ]    ] )
##          [ (-> ps ] [ ch ] )
##   (-> ph [        [ [ ch ] )
## </table>
stmt (syl () ((-> ph ps) (-> ps ch)) (-> ph ch))

#  Inference that swaps (commutes) antecedents in an implication.
## <title> Commute First and Second Antecedents </title>
## <table>
##   (-> <r> ph (-> <g> ps ch))
##   (-> <g> ps (-> <r> ph ch))
## </table>
stmt (com12 () ((-> ph (-> ps ch))) (-> ps (-> ph ch)))

#  Deduction introducing an embedded antecedent.  (The proof was revised by
#        Stefan Allan, 20-Mar-2006.)
#
#        //Naming convention//:  We often call a theorem a "deduction" and suffix
#        its label with "d" whenever the hypotheses and conclusion are each
#        prefixed with the same antecedent.  This allows us to use the theorem in
#        places where (in traditional textbook formalizations) the standard
#        Deduction Theorem would be used; here #ph# would be replaced with a
#        conjunction ([[df-an]]) of the hypotheses of the would-be deduction.  By
#        contrast, we tend to call the simpler version with no common antecedent
#        an "inference" and suffix its label with "i"; compare theorem [[a1i]].
#        Finally, a "theorem" would be the form with no hypotheses; in this case
#        the "theorem" form would be the original axiom [[ax-1]].  We usually show
#        the theorem form without a suffix on its label (e.g. [[pm2.43]] vs.
#        [[pm2.43i]] vs. [[pm2.43d]]).  When an inference is converted to a theorem
#        by eliminating an "is a set" hypothesis, we sometimes suffix the theorem
#        form with "g" (for "more general") as in [[uniex]] vs. [[uniexg]].
## <title> First Axiom Deduction </title>
## <table>
##          [ ph
##   (-> ps [ ph)
## </table>
stmt (a1d () ((-> ph ps)) (-> ph (-> ch ps)))

#  Deduction distributing an embedded antecedent.
## <title> Second Axiom Deduction </title>
## <table>
##   (-> ph (->     ps ] (-> [ ch ]          [ th)))
##   (-> ph (-> (-> ps ]     [ ch ] ) (-> ps [ th)))
## </table>
stmt (a2d () ((-> ph (-> ps (-> ch th)))) (-> ph (-> (-> ps ch) (-> ps th))))

#  A closed form of syllogism (see [[syl]]).  Theorem *2.05 of
#      [bib/WhiteheadRussell] p. 100.
stmt (imim2 () () (-> (-> ph ps) (-> (-> ch ph) (-> ch ps))))

#  A closed form of syllogism (see [[syl]]).  Theorem *2.06 of
#      [bib/WhiteheadRussell] p. 100.
stmt (imim1 () () (-> (-> ph ps) (-> (-> ps ch) (-> ph ch))))

#  Inference adding common consequents in an implication, thereby
#        interchanging the original antecedent and consequent.
stmt (imim1i () ((-> ph ps)) (-> (-> ps ch) (-> ph ch)))

#  Inference adding common antecedents in an implication.
stmt (imim2i () ((-> ph ps)) (-> (-> ch ph) (-> ch ps)))

#  Inference joining two implications.
stmt (imim12i () ((-> ph ps) (-> ch th)) (-> (-> ps ch) (-> ph th)))

#  Inference adding three nested antecedents.
stmt (imim3i () ((-> ph (-> ps ch))) (-> (-> th ph) (-> (-> th ps) (-> th ch))))

#  Inference chaining two syllogisms.
stmt (3syl () ((-> ph ps) (-> ps ch) (-> ch th)) (-> ph th))

#  A syllogism rule of inference.  The second premise is used to replace
#        the second antecedent of the first premise.
stmt (syl5 () ((-> ph (-> ps ch)) (-> th ps)) (-> ph (-> th ch)))

#  A syllogism rule of inference.  The second premise is used to replace
#        the consequent of the first premise.
stmt (syl6 () ((-> ph (-> ps ch)) (-> ch th)) (-> ph (-> ps th)))

#  A syllogism rule of inference.  The second premise is used to replace
#        the third antecedent of the first premise.
stmt (syl7 () ((-> ph (-> ps (-> ch th))) (-> ta ch)) (-> ph (-> ps (-> ta th))))

#  A syllogism rule of inference.  The second premise is used to replace
#        the consequent of the first premise.
stmt (syl8 () ((-> ph (-> ps (-> ch th))) (-> th ta)) (-> ph (-> ps (-> ch ta))))

#  Deduction adding nested antecedents.
stmt (imim2d () ((-> ph (-> ps ch))) (-> ph (-> (-> th ps) (-> th ch))))

#  A modus ponens deduction.
## <title> Modus Ponens </title>
## <table>
##   (-> ph     [ ps ] ] )
##   (-> ph (-> [ ps ] [ ch))
##   (-> ph     [    [ [ ch)
## </table>
stmt (mpd () ((-> ph ps) (-> ph (-> ps ch))) (-> ph ch))

#  Syllogism deduction.  (The proof was shortened by O'Cat, 19-Feb-2008.)
#
#        Notice that [[syld]] can be obtained from [[syl]] by replacing each
#        hypothesis and conclusion #ta# by #(-> ph ta)#.  In general, this
#        process will always yield a new propositional calculus theorem because
#        of something called the Deduction Theorem for propositional calculus.
stmt (syld () ((-> ph (-> ps ch)) (-> ph (-> ch th))) (-> ph (-> ps th)))

#  Deduction adding nested consequents.
stmt (imim1d () ((-> ph (-> ps ch))) (-> ph (-> (-> ch th) (-> ps th))))

#  Deduction combining antecedents and consequents.
stmt (imim12d () ((-> ph (-> ps ch)) (-> ph (-> th ta))) (-> ph (-> (-> ch th) (-> ps ta))))

#  Swap antecedents.  Theorem *2.04 of [bib/WhiteheadRussell] p. 100.
stmt (pm2.04 () () (-> (-> ph (-> ps ch)) (-> ps (-> ph ch))))

#  Theorem *2.83 of [bib/WhiteheadRussell] p. 108.
stmt (pm2.83 () () (-> (-> ph (-> ps ch)) (-> (-> ph (-> ch th)) (-> ph (-> ps th)))))

#  Commutation of antecedents.  Swap 2nd and 3rd.
stmt (com23 () ((-> ph (-> ps (-> ch th)))) (-> ph (-> ch (-> ps th))))

#  Commutation of antecedents.  Swap 1st and 3rd.
stmt (com13 () ((-> ph (-> ps (-> ch th)))) (-> ch (-> ps (-> ph th))))

#  Commutation of antecedents.  Rotate left.
stmt (com3l () ((-> ph (-> ps (-> ch th)))) (-> ps (-> ch (-> ph th))))

#  Commutation of antecedents.  Rotate right.
stmt (com3r () ((-> ph (-> ps (-> ch th)))) (-> ch (-> ph (-> ps th))))

#  Commutation of antecedents.  Swap 3rd and 4th.
stmt (com34 () ((-> ph (-> ps (-> ch (-> th ta))))) (-> ph (-> ps (-> th (-> ch ta)))))

#  Commutation of antecedents.  Swap 2nd and 4th.
stmt (com24 () ((-> ph (-> ps (-> ch (-> th ta))))) (-> ph (-> th (-> ch (-> ps ta)))))

#  Commutation of antecedents.  Swap 1st and 4th.
stmt (com14 () ((-> ph (-> ps (-> ch (-> th ta))))) (-> th (-> ps (-> ch (-> ph ta)))))

#  Commutation of antecedents.  Rotate left.  (The proof was shortened by
#        O'Cat, 15-Aug-2004.)
stmt (com4l () ((-> ph (-> ps (-> ch (-> th ta))))) (-> ps (-> ch (-> th (-> ph ta)))))

#  Commutation of antecedents.  Rotate twice.
stmt (com4t () ((-> ph (-> ps (-> ch (-> th ta))))) (-> ch (-> th (-> ph (-> ps ta)))))

#  Commutation of antecedents.  Rotate right.
stmt (com4r () ((-> ph (-> ps (-> ch (-> th ta))))) (-> th (-> ph (-> ps (-> ch ta)))))

#  Deduction introducing a nested embedded antecedent.  (The proof was
#        shortened by O'Cat, 15-Jan-2008.)
stmt (a1dd () ((-> ph (-> ps ch))) (-> ph (-> ps (-> th ch))))

#  A double modus ponens inference.
stmt (mp2 () (ph ps (-> ph (-> ps ch))) ch)

#  A nested modus ponens inference.  (The proof was shortened by Stefan
#        Allan, 20-Mar-2006.)
stmt (mpi () (ps (-> ph (-> ps ch))) (-> ph ch))

#  A doubly nested modus ponens inference.
stmt (mpii () (ch (-> ph (-> ps (-> ch th)))) (-> ph (-> ps th)))

#  A nested modus ponens deduction.
stmt (mpdd () ((-> ph (-> ps ch)) (-> ph (-> ps (-> ch th)))) (-> ph (-> ps th)))

#  A nested modus ponens deduction.
stmt (mpid () ((-> ph ch) (-> ph (-> ps (-> ch th)))) (-> ph (-> ps th)))

#  A nested modus ponens deduction.  (The proof was shortened by O'Cat,
#        15-Jan-2008.)
stmt (mpdi () ((-> ps ch) (-> ph (-> ps (-> ch th)))) (-> ph (-> ps th)))

#  Modus ponens inference with commutation of antecedents.
stmt (mpcom () ((-> ps ph) (-> ph (-> ps ch))) (-> ps ch))

#  Nested syllogism deduction.
stmt (syldd () ((-> ph (-> ps (-> ch th))) (-> ph (-> ps (-> th ta)))) (-> ph (-> ps (-> ch ta))))

#  Syllogism inference with commutation of antecedents.  (The proof was
#        shortened by O'Cat, 2-Feb-2006 and shortened further by Stefan Allan,
#        23-Feb-2006.)
stmt (sylcom () ((-> ph (-> ps ch)) (-> ps (-> ch th))) (-> ph (-> ps th)))

#  Syllogism inference with commuted antecedents.
stmt (syl5com () ((-> ph (-> ps ch)) (-> th ps)) (-> th (-> ph ch)))

#  Syllogism inference with commuted antecedents.
stmt (syl6com () ((-> ph (-> ps ch)) (-> ch th)) (-> ps (-> ph th)))

#  Syllogism inference with common nested antecedent.
stmt (syli () ((-> ps (-> ph ch)) (-> ch (-> ph th))) (-> ps (-> ph th)))

#  A nested syllogism deduction.  (The proof was shortened by Josh
#        Purinton, 29-Dec-2000 and shortened further by O'Cat, 2-Feb-2006.)
stmt (syl5d () ((-> ph (-> ps (-> ch th))) (-> ph (-> ta ch))) (-> ph (-> ps (-> ta th))))

#  A nested syllogism deduction.  (The proof was shortened by Josh
#        Purinton, 29-Dec-2000 and shortened further by O'Cat, 2-Feb-2006.)
stmt (syl6d () ((-> ph (-> ps (-> ch th))) (-> ph (-> th ta))) (-> ph (-> ps (-> ch ta))))

#  A nested syllogism inference with different antecedents.  (The proof
#        was shortened by Josh Purinton, 29-Dec-2000.)
stmt (syl9 () ((-> ph (-> ps ch)) (-> th (-> ch ta))) (-> ph (-> th (-> ps ta))))

#  A nested syllogism inference with different antecedents.
stmt (syl9r () ((-> ph (-> ps ch)) (-> th (-> ch ta))) (-> th (-> ph (-> ps ta))))

#  Principle of identity.  Theorem *2.08 of [bib/WhiteheadRussell] p. 101.
#      For another version of the proof directly from axioms, see [[id1]].
#      (The proof was shortened by Stefan Allan, 20-Mar-2006.)
## <title> Identity </title>
## <table>
##   (-> <g> ph <g> ph)
## </table>
stmt (id () () (-> ph ph))

#  Principle of identity.  Theorem *2.08 of [bib/WhiteheadRussell] p. 101.  This
#      version is proved directly from the axioms for demonstration purposes.
#      This proof is a popular example in the literature and is identical,
#      step for step, to the proofs of Theorem 1 of [bib/Margaris] p. 51,
#      Example 2.7(a) of [bib/Hamilton] p. 31, Lemma 10.3 of [bib/BellMachover] p. 36,
#      and Lemma 1.8 of [bib/Mendelson] p. 36.  It is also
#      "Our first proof" in Hirst and Hirst's //A Primer for Logic and Proof//
#      p. 16 (PDF p. 22) at
#      [[http://www.mathsci.appstate.edu/~jlh/primer/hirst.pdf]].
#      For a shorter version of the proof that takes advantage of previously
#      proved theorems, see [[id]].
## <title> Identity </title>
## <table>
##   (-> <g> ph <g> ph)
## </table>
stmt (id1 () () (-> ph ph))

#  Principle of identity with antecedent.
## <title> Identity </title>
stmt (idd () () (-> ph (-> ps ps)))

#  This theorem, called "Assertion," can be thought of as closed form of
#      modus ponens [[ax-mp]].  Theorem *2.27 of [bib/WhiteheadRussell] p. 104.
## <title> Modus Ponens </title>
stmt (pm2.27 () () (-> ph (-> (-> ph ps) ps)))

#  Absorption of redundant antecedent.  Also called the "Contraction" or
#      "Hilbert" axiom.  Theorem *2.43 of [bib/WhiteheadRussell] p. 106.  (The proof
#      was shortened by O'Cat, 15-Aug-2004.)
stmt (pm2.43 () () (-> (-> ph (-> ph ps)) (-> ph ps)))

#  Inference absorbing redundant antecedent.  (The proof was shortened by
#        O'Cat, 28-Nov-2008.)
stmt (pm2.43i () ((-> ph (-> ph ps))) (-> ph ps))

#  Deduction absorbing redundant antecedent.  (The proof was shortened by
#        O'Cat, 28-Nov-2008.)
stmt (pm2.43d () ((-> ph (-> ps (-> ps ch)))) (-> ph (-> ps ch)))

#  Inference absorbing redundant antecedent.  (The proof was shortened by
#        O'Cat, 28-Nov-2008.)
stmt (pm2.43a () ((-> ps (-> ph (-> ps ch)))) (-> ps (-> ph ch)))

#  Inference absorbing redundant antecedent.
stmt (pm2.43b () ((-> ps (-> ph (-> ps ch)))) (-> ph (-> ps ch)))

#  A syllogism inference combined with contraction.
stmt (sylc () ((-> ph (-> ps ch)) (-> th ph) (-> th ps)) (-> th ch))

#  Converse of axiom [[ax-2]].  Theorem *2.86 of [bib/WhiteheadRussell] p. 108.
stmt (pm2.86 () () (-> (-> (-> ph ps) (-> ph ch)) (-> ph (-> ps ch))))

#  Inference based on [[pm2.86]].
stmt (pm2.86i () ((-> (-> ph ps) (-> ph ch))) (-> ph (-> ps ch)))

#  Deduction based on [[pm2.86]].
stmt (pm2.86d () ((-> ph (-> (-> ps ch) (-> ps th)))) (-> ph (-> ps (-> ch th))))

#  The Linearity Axiom of the infinite-valued sentential logic (L-infinity)
#      of Lukasiewicz.  (Contributed by O'Cat, 12-Aug-2004.)
stmt (loolin () () (-> (-> (-> ph ps) (-> ps ph)) (-> ps ph)))

#  An alternate for the Linearity Axiom of the infinite-valued sentential
#      logic (L-infinity) of Lukasiewicz, due to Barbara Wozniakowska, //Reports
#      on Mathematical Logic// 10, 129-137 (1978).  (Contributed by O'Cat,
#      8-Aug-2004.)
stmt (loowoz () () (-> (-> (-> ph ps) (-> ph ch)) (-> (-> ps ph) (-> ps ch))))

#  Inference rule derived from axiom [[ax-3]].
stmt (con4i () ((-> (-. ph) (-. ps))) (-> ps ph))

#  Deduction derived from axiom [[ax-3]].
stmt (con4d () ((-> ph (-> (-. ps) (-. ch)))) (-> ph (-> ch ps)))

#  From a wff and its negation, anything is true.  Theorem *2.21 of
#      [bib/WhiteheadRussell] p. 104.  Also called the Duns Scotus law.
## <title> Contradiction Implies Anything </title>
stmt (pm2.21 () () (-> (-. ph) (-> ph ps)))

#  A contradiction implies anything.  Inference from [[pm2.21]].
## <title> Contradiction Implies Anything </title>
stmt (pm2.21i () ((-. ph)) (-> ph ps))

#  A contradiction implies anything.  Deduction from [[pm2.21]].
## <title> Contradiction Implies Anything </title>
## <table>
##   (-> ph     [ (-. [ ps ]   ))
##   (-> ph (-> [     [ ps ] ch))
## </table>
stmt (pm2.21d () ((-> ph (-. ps))) (-> ph (-> ps ch)))

#  Theorem *2.24 of [bib/WhiteheadRussell] p. 104.
stmt (pm2.24 () () (-> ph (-> (-. ph) ps)))

#  A contradiction implies anything.  Inference from [[pm2.24]].
## <title> Contradiction Implies Anything </title>
stmt (pm2.24ii () (ph (-. ph)) ps)

#  Proof by contradiction.  Theorem *2.18 of [bib/WhiteheadRussell] p. 103.
#      Also called the Law of Clavius.
## <title> Proof by contradiction </title>
stmt (pm2.18 () () (-> (-> (-. ph) ph) ph))

#  Peirce's axiom.  This odd-looking theorem is the "difference" between
#      an intuitionistic system of propositional calculus and a classical system
#      and is not accepted by intuitionists.  When Peirce's axiom is added to an
#      intuitionistic system, the system becomes equivalent to our classical
#      system [[ax-1]] through [[ax-3]].  A curious fact about this
#      theorem is that it requires [[ax-3]] for its proof even though the
#      result has no negation connectives in it.
stmt (peirce () () (-> (-> (-> ph ps) ph) ph))

#  The Inversion Axiom of the infinite-valued sentential logic (L-infinity)
#      of Lukasiewicz.  Using [[dfor2]], we can see that this essentially
#      expresses "disjunction commutes."  Theorem *2.69 of [bib/WhiteheadRussell]
#      p. 108.
stmt (looinv () () (-> (-> (-> ph ps) ps) (-> (-> ps ph) ph)))

#  Converse of double negation.  Theorem *2.14 of [bib/WhiteheadRussell] p. 102.
#      (The proof was shortened by David Harvey, 5-Sep-1999.  An even shorter
#      proof found by Josh Purinton, 29-Dec-2000.)
## <title> Double Negative </title>
stmt (notnot2 () () (-> (-. (-. ph)) ph))

#  Inference from double negation.
## <title> Double Negative </title>
stmt (notnotri () ((-. (-. ph))) ph)

#  Converse of double negation.  Theorem *2.12 of [bib/WhiteheadRussell]
#      p. 101.
## <title> Double Negative </title>
stmt (notnot1 () () (-> ph (-. (-. ph))))

#  Infer double negation.
## <title> Double Negative </title>
stmt (notnoti () (ph) (-. (-. ph)))

#  Reductio ad absurdum.  Theorem *2.01 of [bib/WhiteheadRussell] p. 100.  (The
#      proof was shortened by O'Cat, 21-Nov-2008.
stmt (pm2.01 () () (-> (-> ph (-. ph)) (-. ph)))

#  Deduction based on reductio ad absurdum.
stmt (pm2.01d () ((-> ph (-> ps (-. ps)))) (-> ph (-. ps)))

#  Contraposition.  Theorem *2.03 of [bib/WhiteheadRussell] p. 100.
## <title> Contraposition </title>
stmt (con2 () () (-> (-> ph (-. ps)) (-> ps (-. ph))))

#  A contraposition deduction.
## <title> Contraposition </title>
stmt (con2d () ((-> ph (-> ps (-. ch)))) (-> ph (-> ch (-. ps))))

#  Contraposition.  Theorem *2.15 of [bib/WhiteheadRussell] p. 102.
## <title> Contraposition </title>
stmt (con1 () () (-> (-> (-. ph) ps) (-> (-. ps) ph)))

#  A contraposition deduction.
## <title> Contraposition </title>
stmt (con1d () ((-> ph (-> (-. ps) ch))) (-> ph (-> (-. ch) ps)))

#  Contraposition.  Theorem *2.16 of [bib/WhiteheadRussell] p. 103.
## <title> Contraposition </title>
stmt (con3 () () (-> (-> ph ps) (-> (-. ps) (-. ph))))

#  A contraposition deduction.
## <title> Contraposition </title>
stmt (con3d () ((-> ph (-> ps ch))) (-> ph (-> (-. ch) (-. ps))))

#  A contraposition inference.  (The proof was shortened by O'Cat,
#        28-Nov-2008.)
## <title> Contraposition </title>
stmt (con1i () ((-> (-. ph) ps)) (-> (-. ps) ph))

#  A contraposition inference.  (The proof was shortened by O'Cat,
#        28-Nov-2008.)
## <title> Contraposition </title>
## <table>
##   (-> <r> ph (-. <g> ps))
##   (-> <g> ps (-. <r> ph))
## </table>
stmt (con2i () ((-> ph (-. ps))) (-> ps (-. ph)))

#  A contraposition inference.
## <title> Contraposition </title>
## <table>
##   (-> <r>     ph  <g>     ps )
##   (-> <g> (-. ps) <r> (-. ph))
## </table>
stmt (con3i () ((-> ph ps)) (-> (-. ps) (-. ph)))

#  Theorem *2.5 of [bib/WhiteheadRussell] p. 107.
stmt (pm2.5 () () (-> (-. (-> ph ps)) (-> (-. ph) ps)))

#  Theorem *2.51 of [bib/WhiteheadRussell] p. 107.
stmt (pm2.51 () () (-> (-. (-> ph ps)) (-> ph (-. ps))))

#  Theorem *2.52 of [bib/WhiteheadRussell] p. 107.
stmt (pm2.52 () () (-> (-. (-> ph ps)) (-> (-. ph) (-. ps))))

#  Theorem *2.521 of [bib/WhiteheadRussell] p. 107.
stmt (pm2.521 () () (-> (-. (-> ph ps)) (-> ps ph)))

#  Inference version of [[pm2.24]].
stmt (pm2.24i () (ph) (-> (-. ph) ps))

#  Deduction version of [[pm2.21]].
stmt (pm2.24d () ((-> ph ps)) (-> ph (-> (-. ps) ch)))

## <title> Modus Tollens </title>
## <table>
##          [    [   [ (-. [ ps)
##  (->     [ ph ]   [     [ ps)
##      (-. [ ph ] ) ]     ]
## </table>
stmt (mto () ((-. ps) (-> ph ps)) (-. ph))

## <title> Modus Tollens </title>
## <table>
##                  [    [  [ (-. [ ch)
##   (-> ph (->     [ ps ]  [     [ ch))
##   (-> ph     (-. [ ps ]  ]     ]   ))
## </table>
stmt (mtoi () ((-. ch) (-> ph (-> ps ch))) (-> ph (-. ps)))

## <title> Modus Tollens </title>
stmt (mtod () ((-> ph (-. ch)) (-> ph (-> ps ch))) (-> ph (-. ps)))

#  A rule similar to modus tollens.
stmt (mt2 () (ps (-> ph (-. ps))) (-. ph))

#  Modus tollens inference.
stmt (mt2i () (ch (-> ph (-> ps (-. ch)))) (-> ph (-. ps)))

#  Modus tollens deduction.
stmt (mt2d () ((-> ph ch) (-> ph (-> ps (-. ch)))) (-> ph (-. ps)))

#  A rule similar to modus tollens.
stmt (mt3 () ((-. ps) (-> (-. ph) ps)) ph)

#  Modus tollens inference.
stmt (mt3i () ((-. ch) (-> ph (-> (-. ps) ch))) (-> ph ps))

#  Modus tollens deduction.
stmt (mt3d () ((-> ph (-. ch)) (-> ph (-> (-. ps) ch))) (-> ph ps))

#  Modus tollens deduction.
stmt (mt4d () ((-> ph ps) (-> ph (-> (-. ch) (-. ps)))) (-> ph ch))

#  A negated syllogism inference.
stmt (nsyl () ((-> ph (-. ps)) (-> ch ps)) (-> ph (-. ch)))

#  A negated syllogism deduction.
stmt (nsyld () ((-> ph (-> ps (-. ch))) (-> ph (-> ta ch))) (-> ph (-> ps (-. ta))))

#  A negated syllogism inference.
stmt (nsyl2 () ((-> ph (-. ps)) (-> (-. ch) ps)) (-> ph ch))

#  A negated syllogism inference.
stmt (nsyl3 () ((-> ph (-. ps)) (-> ch ps)) (-> ch (-. ph)))

#  A negated syllogism inference.
stmt (nsyl4 () ((-> ph ps) (-> (-. ph) ch)) (-> (-. ch) ps))

#  A negated syllogism inference.
stmt (nsyli () ((-> ph (-> ps ch)) (-> th (-. ch))) (-> ph (-> th (-. ps))))

#  Theorem *3.2 of [bib/WhiteheadRussell] p. 111, expressed with primitive
#      connectives.  (The proof was shortened by Josh Purinton, 29-Dec-2000.)
stmt (pm3.2im () () (-> ph (-> ps (-. (-> ph (-. ps))))))

#  Theorem 8 of [bib/Margaris] p. 60.  (The proof was shortened by Josh Purinton,
#      29-Dec-2000.)
stmt (mth8 () () (-> ph (-> (-. ps) (-. (-> ph ps)))))

#  Theorem *2.61 of [bib/WhiteheadRussell] p. 107.  Useful for eliminating an
#      antecedent.
stmt (pm2.61 () () (-> (-> ph ps) (-> (-> (-. ph) ps) ps)))

#  Inference eliminating an antecedent.
## <title> Proof by cases </title>
## <table>
##   (->     ph  [ ps)
##   (-> (-. ph) [ ps)
##               [ ps
## </table>
stmt (pm2.61i () ((-> ph ps) (-> (-. ph) ps)) ps)

#  Deduction eliminating an antecedent.
stmt (pm2.61d () ((-> ph (-> ps ch)) (-> ph (-> (-. ps) ch))) (-> ph ch))

#  Inference eliminating an antecedent.
stmt (pm2.61d1 () ((-> ph (-> ps ch)) (-> (-. ps) ch)) (-> ph ch))

#  Inference eliminating an antecedent.
stmt (pm2.61d2 () ((-> ph (-> (-. ps) ch)) (-> ps ch)) (-> ph ch))

#  Inference eliminating two antecedents.  (The proof was shortened by Josh
#        Purinton,  29-Dec-2000.)
stmt (pm2.61ii () ((-> (-. ph) (-> (-. ps) ch)) (-> ph ch) (-> ps ch)) ch)

#  Inference eliminating two antecedents.
stmt (pm2.61nii () ((-> ph (-> ps ch)) (-> (-. ph) ch) (-> (-. ps) ch)) ch)

#  Inference eliminating three antecedents.
stmt (pm2.61iii () ((-> (-. ph) (-> (-. ps) (-> (-. ch) th))) (-> ph th) (-> ps th) (-> ch th)) th)

#  Theorem *2.6 of [bib/WhiteheadRussell] p. 107.
stmt (pm2.6 () () (-> (-> (-. ph) ps) (-> (-> ph ps) ps)))

#  Theorem *2.65 of [bib/WhiteheadRussell] p. 107.  Proof by contradiction.
stmt (pm2.65 () () (-> (-> ph ps) (-> (-> ph (-. ps)) (-. ph))))

#  Inference rule for proof by contradiction.
stmt (pm2.65i () ((-> ph ps) (-> ph (-. ps))) (-. ph))

#  Deduction rule for proof by contradiction.
stmt (pm2.65d () ((-> ph (-> ps ch)) (-> ph (-> ps (-. ch)))) (-> ph (-. ps)))

#  Inference joining the antecedents of two premises.  (The proof was
#        shortened by O'Cat, 19-Feb-2008.)
stmt (ja () ((-> (-. ph) ch) (-> ps ch)) (-> (-> ph ps) ch))

#  Inference joining the consequents of two premises.
stmt (jc () ((-> ph ps) (-> ph ch)) (-> ph (-. (-> ps (-. ch)))))

#  Simplification.  Similar to Theorem *3.26 (Simp) of [bib/WhiteheadRussell]
#      p. 112.
stmt (pm3.26im () () (-> (-. (-> ph (-. ps))) ph))

#  Simplification.  Similar to Theorem *3.27 (Simp) of [bib/WhiteheadRussell]
#      p. 112.
stmt (pm3.27im () () (-> (-. (-> ph (-. ps))) ps))

#  Importation theorem expressed with primitive connectives.
stmt (impt () () (-> (-> ph (-> ps ch)) (-> (-. (-> ph (-. ps))) ch)))

#  Exportation theorem expressed with primitive connectives.
stmt (expt () () (-> (-> (-. (-> ph (-. ps))) ch) (-> ph (-> ps ch))))

#  An importation inference.
stmt (impi () ((-> ph (-> ps ch))) (-> (-. (-> ph (-. ps))) ch))

#  An exportation inference.  (The proof was shortened by O'Cat,
#        28-Nov-2008.)
stmt (expi () ((-> (-. (-> ph (-. ps))) ch)) (-> ph (-> ps ch)))

#  Theorem used to justify definition of biconditional [[df-bi]].  (The proof
#      was shortened by Josh Purinton, 29-Dec-2000.)
stmt (bijust () () (-. (-> (-> ph ph) (-. (-> ph ph)))))
term (wff (<-> ph ps))

#  This is our first definition, which introduces and defines the
#      biconditional connective {{{<->}}}.  We define a wff of the form
#      #(<-> ph ps)# as an abbreviation for
#      #(-. (-> (-> ph ps) (-. (-> ps ph))))#.
#
#      Unlike most traditional developments, we have chosen not to have a
#      separate symbol such as "Df." to mean "is defined as."  Instead, we will
#      later use the biconditional connective for this purpose ([[df-or]] is its
#      first use), as it allows us to use logic to manipulate definitions
#      directly.  This greatly simplifies many proofs since it eliminates the
#      need for a separate mechanism for introducing and eliminating
#      definitions.  Of course, we cannot use this mechanism to define the
#      biconditional itself, since it hasn't been introduced yet.  Instead, we
#      use a more general form of definition, described as follows.
#
#      In its most general form, a definition is simply an assertion that
#      introduces a new symbol (or a new combination of existing symbols, as in
#      [[df-3an]]) that is eliminable and does not strengthen the existing
#      language.  The latter requirement means that the set of provable
#      statements not containing the new symbol (or new combination) should
#      remain exactly the same after the definition is introduced.  Our
#      definition of the biconditional may look unusual compared to most
#      definitions, but it strictly satisfies these requirements.
#
#      The justification for our definition is that if we mechanically replace
#      the first wff above (the definiendum i.e. the thing being defined) with
#      the second (the definiens i.e. the defining expression) in the
#      definition, the definition becomes a substitution instance of previously
#      proved theorem [[bijust]].  It is impossible to use [[df-bi]] to prove any
#      statement expressed in the original language that can't be proved from
#      the original axioms.  For if it were, we could replace it with instances
#      of [[bijust]] throughout the proof, thus obtaining a proof from the
#      original axioms (contradiction).
#
#      Note that from Metamath's point of view, a definition is just another
#      axiom - i.e. an assertion we claim to be true - but from our high level
#      point of view, we are are not strengthening the language.  To indicate
#      this fact, we prefix definition labels with "df-" instead of "ax-".
#      (This prefixing is an informal convention that means nothing to the
#      Metamath proof verifier; it is just for human readability.)
#
#      See [[dfbi1]], [[dfbi2]], and [[dfbi3]] for theorems suggesting typical
#      textbook definitions of {{{<->}}}, showing that our definition has the
#      properties we expect.  Theorem [[dfbi]] shows this definition rewritten
#      in an abbreviated form after conjunction is introduced, for easier
#      understanding.
stmt (df-bi () () (-. (-> (-> (<-> ph ps) (-. (-> (-> ph ps) (-. (-> ps ph))))) (-. (-> (-. (-> (-> ph ps) (-. (-> ps ph)))) (<-> ph ps))))))

#  Property of the biconditional connective.
## <title> Infer Right to Left </title>
## <suggest> right('Infer', '←') </suggest>
stmt (bi2 () () (-> (<-> ph ps) (-> ps ph)))

#  Property of the biconditional connective.
## <title> Infer Left to Right </title>
## <suggest> right('Infer', '→') </suggest>
stmt (bi1 () () (-> (<-> ph ps) (-> ph ps)))

#  Property of the biconditional connective.
stmt (bi3 () () (-> (-> ph ps) (-> (-> ps ph) (<-> ph ps))))

#  Infer an implication from a logical equivalence.
## <title> Biconditional Implies Conditional </title>
stmt (biimpi () ((<-> ph ps)) (-> ph ps))

#  Infer a converse implication from a logical equivalence.
## <title> Biconditional Implies Conditional </title>
## <table>
##   ((<-> <r> ph <g> ps)) (-> <g> ps <r> ph))
## </table>
stmt (biimpri () ((<-> ph ps)) (-> ps ph))

#  Deduce an implication from a logical equivalence.
## <title> Equivalence to Implication </title>
## <table>
##   (-> ph (<-> [ ps ch ] ))
##   (-> ph (->  [ ps ch ] ))
## </table>
stmt (biimpd () ((-> ph (<-> ps ch))) (-> ph (-> ps ch)))

#  Deduce a converse implication from a logical equivalence.
## <title> Equivalence to Implication </title>
stmt (biimprd () ((-> ph (<-> ps ch))) (-> ph (-> ch ps)))

#  Deduce a commuted implication from a logical equivalence.
## <title> Equivalence to Implication </title>
stmt (biimpcd () ((-> ph (<-> ps ch))) (-> ps (-> ph ch)))

#  Deduce a converse commuted implication from a logical equivalence.
## <title> Equivalence to Implication </title>
stmt (biimprcd () ((-> ph (<-> ps ch))) (-> ch (-> ph ps)))

#  Infer an equivalence from an implication and its converse.
## <title> Infer Equivalence </title>
## <table>
##   (-> <r> ph <g> ps)
##   (-> <g> ps <r> ph)
##   (<-> <r> ph <g> ps)
## </table>
stmt (impbii () ((-> ph ps) (-> ps ph)) (<-> ph ps))

#  Relate the biconditional connective to primitive connectives.  See
#      [[dfbi1gb]] for an unusual version proved directly from axioms.
stmt (dfbi1 () () (<-> (<-> ph ps) (-. (-> (-> ph ps) (-. (-> ps ph))))))

#  This proof of [[dfbi1]], discovered by Gregory Bush on 8-Mar-2004, has
#      several curious properties.  First, it has only 17 steps directly
#      from the axioms and [[df-bi]], compared to over 800 steps were the proof
#      of [[dfbi1]] expanded into axioms.  Second, step 2 demands only the property
#      of "true"; any axiom (or theorem) could be used.  It might be thought,
#      therefore, that it is in some sense redundant, but in fact no proof
#      is shorter than this (measured by number of steps).  Third, it illustrates
#      how intermediate steps can "blow up" in size even in short proofs.
#      Fourth, the compressed proof is only 182 bytes (or 17 bytes in D-proof
#      notation), but the generated web page is over 200kB with intermediate
#      steps that are essentially incomprehensible to humans (other than Gregory
#      Bush).  If there were an obfuscated code contest for proofs, this would be
#      a contender.
stmt (dfbi1gb () () (<-> (<-> ph ps) (-. (-> (-> ph ps) (-. (-> ps ph))))))

#  Logical equivalence of commuted antecedents.  Part of Theorem *4.87 of
#      [bib/WhiteheadRussell] p. 122.
stmt (bi2.04 () () (<-> (-> ph (-> ps ch)) (-> ps (-> ph ch))))

#  Double negation.  Theorem *4.13 of [bib/WhiteheadRussell] p. 117.
## <title> Double Negative </title>
stmt (notnot () () (<-> ph (-. (-. ph))))

## <title> Double Negative </title>
## <suggest> auto-right('Simplify', '¬¬') </suggest>
stmt (notnotr () () (<-> (-. (-. ph)) ph))

#  Theorem *4.8 of [bib/WhiteheadRussell] p. 122.
stmt (pm4.8 () () (<-> (-> ph (-. ph)) (-. ph)))

#  Theorem *4.81 of [bib/WhiteheadRussell] p. 122.
stmt (pm4.81 () () (<-> (-> (-. ph) ph) ph))

#  Contraposition.  Bidirectional version of [[con1]].
stmt (con1b () () (<-> (-> (-. ph) ps) (-> (-. ps) ph)))

#  Contraposition.  Bidirectional version of [[con2]].
stmt (con2b () () (<-> (-> ph (-. ps)) (-> ps (-. ph))))

#  Contraposition.  Theorem *4.1 of [bib/WhiteheadRussell] p. 116.
## <title> Contrapositive </title>
## <suggest> right('Equivalence', '←') </suggest>
stmt (con34b () () (<-> (-> ph ps) (-> (-. ps) (-. ph))))

#  Antecedent absorption implication.  Theorem *5.4 of
#      [bib/WhiteheadRussell] p. 125.
stmt (pm5.4 () () (<-> (-> ph (-> ph ps)) (-> ph ps)))

#  Distributive law for implication.  Compare Theorem *5.41 of
#      [bib/WhiteheadRussell] p. 125.
## <suggest> right('Distribute', 'L') left('Distribute', '-L') </suggest>
stmt (imdi () () (<-> (-> ph (-> ps ch)) (-> (-> ph ps) (-> ph ch))))

#  Theorem *5.41 of [bib/WhiteheadRussell] p. 125.
stmt (pm5.41 () () (<-> (-> (-> ph ps) (-> ph ch)) (-> ph (-> ps ch))))

#  Principle of identity for logical equivalence.  Theorem *4.2 of
#      [bib/WhiteheadRussell] p. 117.
## <title> Bidirectional Identity <title>
## <suggest> full('Simplify', 'T') </suggest>
stmt (biid () () (<-> ph ph))

#  Principle of identity with antecedent.
stmt (biidd () () (-> ph (<-> ps ps)))

#  Inference from commutative law for logical equivalence.
## <title> Commutative Property </title>
## <table>
##   (<-> <r> ph <g> ps)
##   (<-> <g> ps <r> ph)
## </table>
stmt (bicomi () ((<-> ph ps)) (<-> ps ph))

#  An inference from transitive law for logical equivalence.
## <title> Transitive Property </title>
## <table>
##   (<-> ph ]      [ ps ] ] )
##           [ (<-> [ ps ] [ ch)
##   (<-> ph ]      [    [ [ ch)
## </table>
stmt (bitri () ((<-> ph ps) (<-> ps ch)) (<-> ph ch))

#  An inference from transitive law for logical equivalence.
stmt (bitr2i () ((<-> ph ps) (<-> ps ch)) (<-> ch ph))

#  An inference from transitive law for logical equivalence.
stmt (bitr3i () ((<-> ps ph) (<-> ps ch)) (<-> ph ch))

#  An inference from transitive law for logical equivalence.
stmt (bitr4i () ((<-> ph ps) (<-> ch ps)) (<-> ph ch))

#  A chained inference from transitive law for logical equivalence.
stmt (3bitri () ((<-> ph ps) (<-> ps ch) (<-> ch th)) (<-> ph th))

#  A chained inference from transitive law for logical equivalence.
stmt (3bitrri () ((<-> ph ps) (<-> ps ch) (<-> ch th)) (<-> th ph))

#  A chained inference from transitive law for logical equivalence.
stmt (3bitr2i () ((<-> ph ps) (<-> ch ps) (<-> ch th)) (<-> ph th))

#  A chained inference from transitive law for logical equivalence.
stmt (3bitr2ri () ((<-> ph ps) (<-> ch ps) (<-> ch th)) (<-> th ph))

#  A chained inference from transitive law for logical equivalence.
stmt (3bitr3i () ((<-> ph ps) (<-> ph ch) (<-> ps th)) (<-> ch th))

#  A chained inference from transitive law for logical equivalence.
stmt (3bitr3ri () ((<-> ph ps) (<-> ph ch) (<-> ps th)) (<-> th ch))

#  A chained inference from transitive law for logical equivalence.  This
#        inference is frequently used to apply a definition to both sides of a
#        logical equivalence.
stmt (3bitr4i () ((<-> ph ps) (<-> ch ph) (<-> th ps)) (<-> ch th))

#  A chained inference from transitive law for logical equivalence.
stmt (3bitr4ri () ((<-> ph ps) (<-> ch ph) (<-> th ps)) (<-> th ch))

#  Introduce an antecedent to both sides of a logical equivalence.
## <title> Equivalence over Implication </title>
## <table>
##   (<->        [ ph ]   [        [ ps)
##   (<-> (-> ch [ ph ] ) [ (-> ch [ ps))
## </table>
stmt (imbi2i () ((<-> ph ps)) (<-> (-> ch ph) (-> ch ps)))

#  Introduce a consequent to both sides of a logical equivalence.
## <title> Equivalence over Implication </title>
## <table>
##   (<->     ph ]     ]     [ ps ] )
##   (<-> (-> ph ] ch) ] (-> [ ps ] ch))
## </table>
stmt (imbi1i () ((<-> ph ps)) (<-> (-> ph ch) (-> ps ch)))

#  Negate both sides of a logical equivalence.
## <title> Negation Equivalence </title>
## <table>
##   (<->     [ ph ]       [ ps ] )
##   (<-> (-. [ ph ] ) (-. [ ps ] ))
## </table>
stmt (notbii () ((<-> ph ps)) (<-> (-. ph) (-. ps)))

#  Join two logical equivalences to form equivalence of implications.
stmt (imbi12i () ((<-> ph ps) (<-> ch th)) (<-> (-> ph ch) (-> ps th)))

#  An inference from a biconditional, related to modus ponens.
## <title> Modus Ponens </title>
## <table>
##      ph ] ]    ]
## (<-> ph ] [ ps ] )
##         [ [ ps ]
## </table>
stmt (mpbi () (ph (<-> ph ps)) ps)

#  An inference from a biconditional, related to modus ponens.
## <title> Modus Ponens </title>
## <table>
##         [ [ ps ]
## (<-> ph ] [ ps ] )
##      ph ] ]    ]
## </table>
stmt (mpbir () (ps (<-> ph ps)) ph)

#  An inference from a biconditional, related to modus tollens.
## <title> Modus Tollens </title>
## <table>
##       (-. [ ph ] ) ]     ]
##  (<->     [ ph ]   [     [ ps)
##           [    [   [ (-. [ ps)
## </table>
stmt (mtbi () ((-. ph) (<-> ph ps)) (-. ps))

#  An inference from a biconditional, related to modus tollens.
## <title> Modus Tollens </title>
## <table>
##                 [ [ (-. [ ps)
##   (<->    [ ph  ] [     [ ps)
##       (-. [ ph) ] ]     ]
## </table>
stmt (mtbir () ((-. ps) (<-> ph ps)) (-. ph))

#  An inference from a nested biconditional, related to modus ponens.
## <title> Modus Ponens </title>
## <table>
##               [ ps ]
##   (-> ph (<-> [ ps ] ch))
##   (-> ph      [    [ ch))
## </table>
stmt (mpbii () (ps (-> ph (<-> ps ch))) (-> ph ch))

#  An inference from a nested biconditional, related to modus ponens.
## <title> Modus Ponens </title>
stmt (mpbiri () (ch (-> ph (<-> ps ch))) (-> ph ps))

#  A deduction from a biconditional, related to modus ponens.
## <title> Modus Ponens </title>
stmt (mpbid () ((-> ph ps) (-> ph (<-> ps ch))) (-> ph ch))

#  A deduction from a biconditional, related to modus ponens.
## <title> Modus Ponens </title>
stmt (mpbird () ((-> ph ch) (-> ph (<-> ps ch))) (-> ph ps))

#  Inference rule introducing a theorem as an antecedent.
## <title> Theorem as antecedent </title>
## <table>
##               [ ph ]
##   (<-> ps (-> [ ph ] ps))
## </table>
stmt (a1bi () (ph) (<-> ps (-> ph ps)))

#  A mixed syllogism inference from an implication and a biconditional.
## <title> Syllogism </title>
## <table>
##   (-> ph [      ps ] ]    ] )
##          [ (<-> ps ] [ ch ] )
##   (-> ph [         [ [ ch ] )
## </table>
stmt (sylib () ((-> ph ps) (<-> ps ch)) (-> ph ch))

#  A mixed syllogism inference from a biconditional and an implication.
#        Useful for substituting an antecedent with a definition.

## <title> Syllogism </title>
## <table>
##   (<-> ph [     ps ] ]    ] )
##           [ (-> ps ] [ ch ] )
##   ( -> ph [        [ [ ch ] )
## </table>
stmt (sylbi () ((<-> ph ps) (-> ps ch)) (-> ph ch))

#  A mixed syllogism inference from an implication and a biconditional.
#        Useful for substituting a consequent with a definition.
## <title> Syllogism </title>
stmt (sylibr () ((-> ph ps) (<-> ch ps)) (-> ph ch))

#  A mixed syllogism inference from a biconditional and an implication.
## <title> Syllogism </title>
stmt (sylbir () ((<-> ps ph) (-> ps ch)) (-> ph ch))

#  A syllogism deduction.
## <title> Syllogism </title>
stmt (sylibd () ((-> ph (-> ps ch)) (-> ph (<-> ch th))) (-> ph (-> ps th)))

#  A syllogism deduction.
## <title> Syllogism </title>
stmt (sylbid () ((-> ph (<-> ps ch)) (-> ph (-> ch th))) (-> ph (-> ps th)))

#  A syllogism deduction.
## <title> Syllogism </title>
stmt (sylibrd () ((-> ph (-> ps ch)) (-> ph (<-> th ch))) (-> ph (-> ps th)))

#  A syllogism deduction.
## <title> Syllogism </title>
stmt (sylbird () ((-> ph (<-> ch ps)) (-> ph (-> ch th))) (-> ph (-> ps th)))

#  A mixed syllogism inference from a nested implication and a
#        biconditional.  Useful for substituting an embedded antecedent with a
#        definition.
## <title> Syllogism </title>
stmt (syl5ib () ((-> ph (-> ps ch)) (<-> th ps)) (-> ph (-> th ch)))

#  A mixed syllogism inference from a nested implication and a
#        biconditional.
## <title> Syllogism </title>
stmt (syl5ibr () ((-> ph (-> ps ch)) (<-> ps th)) (-> ph (-> th ch)))

#  A mixed syllogism inference.
## <title> Syllogism </title>
stmt (syl5bi () ((-> ph (<-> ps ch)) (-> th ps)) (-> ph (-> th ch)))

#  A mixed syllogism inference.
## <title> Syllogism </title>
stmt (syl5cbi () ((-> ph (<-> ps ch)) (-> th ps)) (-> th (-> ph ch)))

#  A mixed syllogism inference.
## <title> Syllogism </title>
stmt (syl5bir () ((-> ph (<-> ps ch)) (-> th ch)) (-> ph (-> th ps)))

#  A mixed syllogism inference.
## <title> Syllogism </title>
stmt (syl5cbir () ((-> ph (<-> ps ch)) (-> th ch)) (-> th (-> ph ps)))

#  A mixed syllogism inference from a nested implication and a
#        biconditional.
## <title> Syllogism </title>
stmt (syl6ib () ((-> ph (-> ps ch)) (<-> ch th)) (-> ph (-> ps th)))

#  A mixed syllogism inference from a nested implication and a
#        biconditional.  Useful for substituting an embedded consequent with a
#        definition.
## <title> Syllogism </title>
stmt (syl6ibr () ((-> ph (-> ps ch)) (<-> th ch)) (-> ph (-> ps th)))

#  A mixed syllogism inference.
## <title> Syllogism </title>
stmt (syl6bi () ((-> ph (<-> ps ch)) (-> ch th)) (-> ph (-> ps th)))

#  A mixed syllogism inference.
## <title> Syllogism </title>
stmt (syl6bir () ((-> ph (<-> ch ps)) (-> ch th)) (-> ph (-> ps th)))

#  A mixed syllogism inference from a doubly nested implication and a
#        biconditional.
## <title> Syllogism </title>
stmt (syl7ib () ((-> ph (-> ps (-> ch th))) (<-> ta ch)) (-> ph (-> ps (-> ta th))))

#  A syllogism rule of inference.  The second premise is used to replace
#        the consequent of the first premise.
## <title> Syllogism </title>
stmt (syl8ib () ((-> ph (-> ps (-> ch th))) (<-> th ta)) (-> ph (-> ps (-> ch ta))))

#  A mixed syllogism inference, useful for removing a definition from both
#        sides of an implication.
stmt (3imtr3i () ((-> ph ps) (<-> ph ch) (<-> ps th)) (-> ch th))

#  A mixed syllogism inference, useful for applying a definition to both
#        sides of an implication.
stmt (3imtr4i () ((-> ph ps) (<-> ch ph) (<-> th ps)) (-> ch th))

#  A contraposition inference.
stmt (con1bii () ((<-> (-. ph) ps)) (<-> (-. ps) ph))

#  A contraposition inference.
## <title> Contraposition </title>
## <table>
##   (<-> <r> ph (-. <g> ps))
##   (<-> <g> ps (-. <r> ph))
## </table>
stmt (con2bii () ((<-> ph (-. ps))) (<-> ps (-. ph)))
term (wff (\/ ph ps))
term (wff (/\ ph ps))

#  Define disjunction (logical 'or').  This is our first use of the
#      biconditional connective in a definition; we use it in place of the
#      traditional "<=def=>", which means the same thing, except that we can
#      manipulate the biconditional connective directly in proofs rather than
#      having to rely on an informal definition substitution rule.  Note that
#      if we mechanically substitute #(-> (-. ph) ps)# for #(\/ ph ps)#,
#      we end up with an instance of previously proved theorem [[biid]].  This
#      is the justification for the definition, along with the fact that it
#      introduces a new symbol {{{\/}}}.  Definition of [bib/Margaris] p. 49.
## <title> Definition of OR </title>
## <suggest> right('Equivalence', '→') </suggest>
stmt (df-or () () (<-> (\/ ph ps) (-> (-. ph) ps)))

#  Define conjunction (logical 'and').  Definition of [bib/Margaris] p. 49.
## <title> Definition of AND </title>
## <suggest> right('Equivalence', '→') </suggest>
stmt (df-an () () (<-> (/\ ph ps) (-. (-> ph (-. ps)))))

#  Theorem *4.64 of [bib/WhiteheadRussell] p. 120.
stmt (pm4.64 () () (<-> (-> (-. ph) ps) (\/ ph ps)))

#  Theorem *2.54 of [bib/WhiteheadRussell] p. 107.
stmt (pm2.54 () () (-> (-> (-. ph) ps) (\/ ph ps)))

#  Theorem *4.63 of [bib/WhiteheadRussell] p. 120.
stmt (pm4.63 () () (<-> (-. (-> ph (-. ps))) (/\ ph ps)))

#  Logical 'or' expressed in terms of implication only.  Theorem *5.25 of
#      [bib/WhiteheadRussell] p. 124.
stmt (dfor2 () () (<-> (\/ ph ps) (-> (-> ph ps) ps)))

#  Infer implication from disjunction.
stmt (ori () ((\/ ph ps)) (-> (-. ph) ps))

#  Infer implication from disjunction.
stmt (orri () ((-> (-. ph) ps)) (\/ ph ps))

#  Deduce implication from disjunction.
stmt (ord () ((-> ph (\/ ps ch))) (-> ph (-> (-. ps) ch)))

#  Deduce implication from disjunction.
stmt (orrd () ((-> ph (-> (-. ps) ch))) (-> ph (\/ ps ch)))

#  Implication in terms of disjunction.  Theorem *4.6 of
#      [bib/WhiteheadRussell] p. 120.
## <title> OR and → Equivalance </title>
## <suggest> right('Equivalence', '∨') </suggest>
stmt (imor () () (<-> (-> ph ps) (\/ (-. ph) ps)))

#  Theorem *4.62 of [bib/WhiteheadRussell] p. 120.
stmt (pm4.62 () () (<-> (-> ph (-. ps)) (\/ (-. ph) (-. ps))))

#  Theorem *4.66 of [bib/WhiteheadRussell] p. 120.
stmt (pm4.66 () () (<-> (-> (-. ph) (-. ps)) (\/ ph (-. ps))))

#  Express implication in terms of conjunction.  Theorem 3.4(27) of [bib/Stoll]
#      p. 176.
## <title> AND and → Equivalance </title>
## <suggest> right('Equivalence', '∧') </suggest>
stmt (iman () () (<-> (-> ph ps) (-. (/\ ph (-. ps)))))

#  Express conjunction in terms of implication.
stmt (annim () () (<-> (/\ ph (-. ps)) (-. (-> ph ps))))

#  Theorem *4.61 of [bib/WhiteheadRussell] p. 120.
stmt (pm4.61 () () (<-> (-. (-> ph ps)) (/\ ph (-. ps))))

#  Theorem *4.65 of [bib/WhiteheadRussell] p. 120.
stmt (pm4.65 () () (<-> (-. (-> (-. ph) ps)) (/\ (-. ph) (-. ps))))

#  Theorem *4.67 of [bib/WhiteheadRussell] p. 120.
stmt (pm4.67 () () (<-> (-. (-> (-. ph) (-. ps))) (/\ (-. ph) ps)))

#  Express implication in terms of conjunction.
stmt (imnan () () (<-> (-> ph (-. ps)) (-. (/\ ph ps))))

#  Idempotent law for disjunction.  Theorem *4.25 of [bib/WhiteheadRussell]
#      p. 117.
## <title> Disjunction is Idempotent </title>
## <suggest> right('Simplify', '∨') </suggest>
stmt (oridm () () (<-> (\/ ph ph) ph))

#  Theorem *4.25 of [bib/WhiteheadRussell] p. 117.
stmt (pm4.25 () () (<-> ph (\/ ph ph)))

#  Axiom *1.2 (Taut) of [bib/WhiteheadRussell] p. 96.
stmt (pm1.2 () () (-> (\/ ph ph) ph))

#  Commutative law for disjunction.  Theorem *4.31 of [bib/WhiteheadRussell]
#      p. 118.
## <title> Commutative Property of OR </title>
## <table>
##   (<-> (\/ <r> ph <g> ps) (\/ <g> ps <r> ph))
## </table>
## <suggest> right('Commute', '∨') </suggest>
stmt (orcom () () (<-> (\/ ph ps) (\/ ps ph)))

#  Axiom *1.4 of [bib/WhiteheadRussell] p. 96.
stmt (pm1.4 () () (-> (\/ ph ps) (\/ ps ph)))

#  Theorem *2.62 of [bib/WhiteheadRussell] p. 107.
stmt (pm2.62 () () (-> (\/ ph ps) (-> (-> ph ps) ps)))

#  Theorem *2.621 of [bib/WhiteheadRussell] p. 107.
stmt (pm2.621 () () (-> (-> ph ps) (-> (\/ ph ps) ps)))

#  Theorem *2.68 of [bib/WhiteheadRussell] p. 108.
stmt (pm2.68 () () (-> (-> (-> ph ps) ps) (\/ ph ps)))

#  Elimination of disjunction by denial of a disjunct.  Theorem *2.55 of
#      [bib/WhiteheadRussell] p. 107.
stmt (orel1 () () (-> (-. ph) (-> (\/ ph ps) ps)))

#  Elimination of disjunction by denial of a disjunct.  Theorem *2.56 of
#      [bib/WhiteheadRussell] p. 107.
stmt (orel2 () () (-> (-. ph) (-> (\/ ps ph) ps)))

#  Theorem *2.25 of [bib/WhiteheadRussell] p. 104.
stmt (pm2.25 () () (\/ ph (-> (\/ ph ps) ps)))

#  Theorem *2.53 of [bib/WhiteheadRussell] p. 107.
stmt (pm2.53 () () (-> (\/ ph ps) (-> (-. ph) ps)))

#  Inference adding a left disjunct to both sides of a logical
#        equivalence.
## <title> Equivalence over Disjunction </title>
## <table>
##   (<->        [ ph ]   [        [ ps)
##   (<-> (\/ ch [ ph ] ) [ (\/ ch [ ps))
## </table>
stmt (orbi2i () ((<-> ph ps)) (<-> (\/ ch ph) (\/ ch ps)))

#  Inference adding a right disjunct to both sides of a logical
#        equivalence.
## <title> Equivalence over Disjunction </title>
## <table>
##   (<->     ph ]     ]     [ ps ] )
##   (<-> (\/ ph ] ch) ] (\/ [ ps ] ch))
## </table>
stmt (orbi1i () ((<-> ph ps)) (<-> (\/ ph ch) (\/ ps ch)))

#  Infer the disjunction of two equivalences.
stmt (orbi12i () ((<-> ph ps) (<-> ch th)) (<-> (\/ ph ch) (\/ ps th)))

#  A rearrangement of disjuncts.
stmt (or12 () () (<-> (\/ ph (\/ ps ch)) (\/ ps (\/ ph ch))))

#  Axiom *1.5 (Assoc) of [bib/WhiteheadRussell] p. 96.
stmt (pm1.5 () () (-> (\/ ph (\/ ps ch)) (\/ ps (\/ ph ch))))

#  Associative law for disjunction.  Theorem *4.33 of [bib/WhiteheadRussell]
#      p. 118.
## <title> Associatative Property of OR </title>
## <suggest> right('Associate', 'R') left('Associate', 'L') </suggest>
stmt (orass () () (<-> (\/ (\/ ph ps) ch) (\/ ph (\/ ps ch))))

#  Theorem *2.31 of [bib/WhiteheadRussell] p. 104.
stmt (pm2.31 () () (-> (\/ ph (\/ ps ch)) (\/ (\/ ph ps) ch)))

#  Theorem *2.32 of [bib/WhiteheadRussell] p. 105.
stmt (pm2.32 () () (-> (\/ (\/ ph ps) ch) (\/ ph (\/ ps ch))))

#  A rearrangement of disjuncts.
stmt (or23 () () (<-> (\/ (\/ ph ps) ch) (\/ (\/ ph ch) ps)))

#  Rearrangement of 4 disjuncts.
stmt (or4 () () (<-> (\/ (\/ ph ps) (\/ ch th)) (\/ (\/ ph ch) (\/ ps th))))

#  Rearrangement of 4 disjuncts.
stmt (or42 () () (<-> (\/ (\/ ph ps) (\/ ch th)) (\/ (\/ ph ch) (\/ th ps))))

#  Distribution of disjunction over disjunction.
stmt (orordi () () (<-> (\/ ph (\/ ps ch)) (\/ (\/ ph ps) (\/ ph ch))))

#  Distribution of disjunction over disjunction.
stmt (orordir () () (<-> (\/ (\/ ph ps) ch) (\/ (\/ ph ch) (\/ ps ch))))

#  Introduction of a disjunct.  Axiom *1.3 of [bib/WhiteheadRussell] p. 96.
## <title> Introduce a Disjunct </title>
stmt (olc () () (-> ph (\/ ps ph)))

#  Introduction of a disjunct.  Theorem *2.2 of [bib/WhiteheadRussell] p. 104.
## <title> Introduce a Disjunct </title>
stmt (orc () () (-> ph (\/ ph ps)))

#  Deduction introducing a disjunct.
## <title> Introduce a Disjunct </title>
stmt (orci () (ph) (\/ ph ps))

#  Deduction introducing a disjunct.
## <title> Introduce a Disjunct </title>
stmt (olci () (ph) (\/ ps ph))

#  Deduction introducing a disjunct.
## <title> Introduce a Disjunct </title>
stmt (orcd () ((-> ph ps)) (-> ph (\/ ps ch)))

#  Deduction introducing a disjunct.
## <title> Introduce a Disjunct </title>
stmt (olcd () ((-> ph ps)) (-> ph (\/ ch ps)))

#  Deduction eliminating disjunct.
stmt (orcs () ((-> (\/ ph ps) ch)) (-> ph ch))

#  Deduction eliminating disjunct.
stmt (olcs () ((-> (\/ ph ps) ch)) (-> ps ch))

#  Theorem *2.07 of [bib/WhiteheadRussell] p. 101.
stmt (pm2.07 () () (-> ph (\/ ph ph)))

#  Theorem *2.45 of [bib/WhiteheadRussell] p. 106.
stmt (pm2.45 () () (-> (-. (\/ ph ps)) (-. ph)))

#  Theorem *2.46 of [bib/WhiteheadRussell] p. 106.
stmt (pm2.46 () () (-> (-. (\/ ph ps)) (-. ps)))

#  Theorem *2.47 of [bib/WhiteheadRussell] p. 107.
stmt (pm2.47 () () (-> (-. (\/ ph ps)) (\/ (-. ph) ps)))

#  Theorem *2.48 of [bib/WhiteheadRussell] p. 107.
stmt (pm2.48 () () (-> (-. (\/ ph ps)) (\/ ph (-. ps))))

#  Theorem *2.49 of [bib/WhiteheadRussell] p. 107.
stmt (pm2.49 () () (-> (-. (\/ ph ps)) (\/ (-. ph) (-. ps))))

#  Theorem *2.67 of [bib/WhiteheadRussell] p. 107.
stmt (pm2.67 () () (-> (-> (\/ ph ps) ps) (-> ph ps)))

#  Join antecedents with conjunction.  Theorem *3.2 of [bib/WhiteheadRussell]
#      p. 111.
stmt (pm3.2 () () (-> ph (-> ps (/\ ph ps))))

#  Join antecedents with conjunction.  Theorem *3.21 of
#      [bib/WhiteheadRussell] p. 111.
stmt (pm3.21 () () (-> ph (-> ps (/\ ps ph))))

#  Infer conjunction of premises.
## <title> Conjunction from premises </title>
## <table>
##       ph ] ]
##          [ [ ps
##   (/\ ph ] [ ps)
## </table>
stmt (pm3.2i () (ph ps) (/\ ph ps))

#  Theorem *3.37 (Transp) of [bib/WhiteheadRussell] p. 112.
stmt (pm3.37 () () (-> (-> (/\ ph ps) ch) (-> (/\ ph (-. ch)) (-. ps))))

#  Nested conjunction of antecedents.
stmt (pm3.43i () () (-> (-> ph ps) (-> (-> ph ch) (-> ph (/\ ps ch)))))

#  Deduce conjunction of the consequents of two implications ("join
#        consequents with 'and'").
## <title> Join two implications </title>
## <table>
##   (-> ph     ps ] ] ) 
##   (-> ph        ] [ ch)
##   (-> ph (/\ ps ] [ ch))
## </table>
stmt (jca () ((-> ph ps) (-> ph ch)) (-> ph (/\ ps ch)))

#  Deduction replacing implication with conjunction.
## <title> Join two implications </title>
stmt (jcai () ((-> ph ps) (-> ph (-> ps ch))) (-> ph (/\ ps ch)))

#  Inference conjoining a theorem to the left of a consequent.
stmt (jctl () (ps) (-> ph (/\ ps ph)))

#  Inference conjoining a theorem to the right of a consequent.
stmt (jctr () (ps) (-> ph (/\ ph ps)))

#  Inference conjoining a theorem to left of consequent in an
#        implication.
stmt (jctil () ((-> ph ps) ch) (-> ph (/\ ch ps)))

#  Inference conjoining a theorem to right of consequent in an
#        implication.
stmt (jctir () ((-> ph ps) ch) (-> ph (/\ ps ch)))

#  Conjoin antecedent to left of consequent.
stmt (ancl () () (-> (-> ph ps) (-> ph (/\ ph ps))))

#  Conjoin antecedent to right of consequent.
stmt (ancr () () (-> (-> ph ps) (-> ph (/\ ps ph))))

#  Deduction conjoining antecedent to left of consequent.
## <title> Add Antecedent </title>
## <table>
##   (-> ph [        [ ps)
##   (-> ph [ (/\ ph [ ps))
## </table>
stmt (ancli () ((-> ph ps)) (-> ph (/\ ph ps)))

#  Deduction conjoining antecedent to right of consequent.
## <title> Add Antecedent </title>
## <table>
##   (-> ph     [ ps ] )
##   (-> ph (/\ [ ps ] ph))
## </table>
stmt (ancri () ((-> ph ps)) (-> ph (/\ ps ph)))

#  Deduction conjoining antecedent to left of consequent in nested
#        implication.
stmt (ancld () ((-> ph (-> ps ch))) (-> ph (-> ps (/\ ps ch))))

#  Deduction conjoining antecedent to right of consequent in nested
#        implication.
stmt (ancrd () ((-> ph (-> ps ch))) (-> ph (-> ps (/\ ch ps))))

#  Conjoin antecedent to left of consequent in nested implication.
stmt (anc2l () () (-> (-> ph (-> ps ch)) (-> ph (-> ps (/\ ph ch)))))

#  Conjoin antecedent to right of consequent in nested implication.
stmt (anc2r () () (-> (-> ph (-> ps ch)) (-> ph (-> ps (/\ ch ph)))))

#  Deduction conjoining antecedent to left of consequent in nested
#        implication.
stmt (anc2li () ((-> ph (-> ps ch))) (-> ph (-> ps (/\ ph ch))))

#  Deduction conjoining antecedent to right of consequent in nested
#        implication.
stmt (anc2ri () ((-> ph (-> ps ch))) (-> ph (-> ps (/\ ch ph))))

#  Conjunction in terms of disjunction (DeMorgan's law).  Theorem *4.5 of
#      [bib/WhiteheadRussell] p. 120.
## <title> DeMorgan's Law </title>
## <suggest> right('Equivalence', '∨') </suggest>
stmt (anor () () (<-> (/\ ph ps) (-. (\/ (-. ph) (-. ps)))))

#  Negated conjunction in terms of disjunction (DeMorgan's law).  Theorem
#      *4.51 of [bib/WhiteheadRussell] p. 120.
stmt (ianor () () (<-> (-. (/\ ph ps)) (\/ (-. ph) (-. ps))))

#  Negated disjunction in terms of conjunction (DeMorgan's law).  Compare
#      Theorem *4.56 of [bib/WhiteheadRussell] p. 120.
stmt (ioran () () (<-> (-. (\/ ph ps)) (/\ (-. ph) (-. ps))))

#  Theorem *4.52 of [bib/WhiteheadRussell] p. 120.
stmt (pm4.52 () () (<-> (/\ ph (-. ps)) (-. (\/ (-. ph) ps))))

#  Theorem *4.53 of [bib/WhiteheadRussell] p. 120.
stmt (pm4.53 () () (<-> (-. (/\ ph (-. ps))) (\/ (-. ph) ps)))

#  Theorem *4.54 of [bib/WhiteheadRussell] p. 120.
stmt (pm4.54 () () (<-> (/\ (-. ph) ps) (-. (\/ ph (-. ps)))))

#  Theorem *4.55 of [bib/WhiteheadRussell] p. 120.
stmt (pm4.55 () () (<-> (-. (/\ (-. ph) ps)) (\/ ph (-. ps))))

#  Theorem *4.56 of [bib/WhiteheadRussell] p. 120.
stmt (pm4.56 () () (<-> (/\ (-. ph) (-. ps)) (-. (\/ ph ps))))

#  Disjunction in terms of conjunction (DeMorgan's law).  Compare Theorem
#      *4.57 of [bib/WhiteheadRussell] p. 120.
## <title> DeMorgan's Law </title>
## <suggest> right('Equivalence', '∧') </suggest>
stmt (oran () () (<-> (\/ ph ps) (-. (/\ (-. ph) (-. ps)))))

#  Theorem *4.57 of [bib/WhiteheadRussell] p. 120.
stmt (pm4.57 () () (<-> (-. (/\ (-. ph) (-. ps))) (\/ ph ps)))

#  Theorem *3.1 of [bib/WhiteheadRussell] p. 111.
stmt (pm3.1 () () (-> (/\ ph ps) (-. (\/ (-. ph) (-. ps)))))

#  Theorem *3.11 of [bib/WhiteheadRussell] p. 111.
stmt (pm3.11 () () (-> (-. (\/ (-. ph) (-. ps))) (/\ ph ps)))

#  Theorem *3.12 of [bib/WhiteheadRussell] p. 111.
stmt (pm3.12 () () (\/ (\/ (-. ph) (-. ps)) (/\ ph ps)))

#  Theorem *3.13 of [bib/WhiteheadRussell] p. 111.
stmt (pm3.13 () () (-> (-. (/\ ph ps)) (\/ (-. ph) (-. ps))))

#  Theorem *3.14 of [bib/WhiteheadRussell] p. 111.
stmt (pm3.14 () () (-> (\/ (-. ph) (-. ps)) (-. (/\ ph ps))))

#  Elimination of a conjunct.  Theorem *3.27 (Simp) of [bib/WhiteheadRussell]
#      p. 112.
## <title> 'Remove Left Side of AND' </title>
## <suggest> right('Remove', 'L') </suggest>
stmt (pm3.27 () () (-> (/\ ph ps) ps))

#  Elimination of a conjunct.  Theorem *3.26 (Simp) of [bib/WhiteheadRussell]
#      p. 112.
## <title> 'Remove Right Side of AND' </title>
## <suggest> right('Remove', 'R') </suggest>
stmt (pm3.26 () () (-> (/\ ph ps) ph))

#  Inference eliminating a conjunct.
stmt (pm3.26i () ((/\ ph ps)) ph)

#  Deduction eliminating a conjunct.
stmt (pm3.26d () ((-> ph (/\ ps ch))) (-> ph ps))

#  Deduction eliminating a conjunct.
stmt (pm3.26bi () ((<-> ph (/\ ps ch))) (-> ph ps))

#  Inference eliminating a conjunct.
stmt (pm3.27i () ((/\ ph ps)) ps)

#  Deduction eliminating a conjunct.
stmt (pm3.27d () ((-> ph (/\ ps ch))) (-> ph ch))

#  Deduction eliminating a conjunct.
stmt (pm3.27bi () ((<-> ph (/\ ps ch))) (-> ph ch))

#  Theorem *3.41 of [bib/WhiteheadRussell] p. 113.
stmt (pm3.41 () () (-> (-> ph ch) (-> (/\ ph ps) ch)))

#  Theorem *3.42 of [bib/WhiteheadRussell] p. 113.
stmt (pm3.42 () () (-> (-> ps ch) (-> (/\ ph ps) ch)))

#  Conjoin antecedent to left of consequent.  Theorem *4.7 of
#      [bib/WhiteheadRussell] p. 120.
stmt (anclb () () (<-> (-> ph ps) (-> ph (/\ ph ps))))

#  Conjoin antecedent to right of consequent.
stmt (ancrb () () (<-> (-> ph ps) (-> ph (/\ ps ph))))

#  Conjunction implies implication.  Theorem *3.4 of [bib/WhiteheadRussell]
#      p. 113.
stmt (pm3.4 () () (-> (/\ ph ps) (-> ph ps)))

#  Conjunction with implication.  Compare Theorem *4.45 of
#      [bib/WhiteheadRussell] p. 119.
stmt (pm4.45im () () (<-> ph (/\ ph (-> ps ph))))

#  Conjoin antecedents and consequents of two premises.
stmt (anim12i () ((-> ph ps) (-> ch th)) (-> (/\ ph ch) (/\ ps th)))

#  Introduce conjunct to both sides of an implication.
stmt (anim1i () ((-> ph ps)) (-> (/\ ph ch) (/\ ps ch)))

#  Introduce conjunct to both sides of an implication.
stmt (anim2i () ((-> ph ps)) (-> (/\ ch ph) (/\ ch ps)))

#  Disjoin antecedents and consequents of two premises.
stmt (orim12i () ((-> ph ps) (-> ch th)) (-> (\/ ph ch) (\/ ps th)))

#  Introduce disjunct to both sides of an implication.
stmt (orim1i () ((-> ph ps)) (-> (\/ ph ch) (\/ ps ch)))

#  Introduce disjunct to both sides of an implication.
stmt (orim2i () ((-> ph ps)) (-> (\/ ch ph) (\/ ch ps)))

#  Theorem *2.3 of [bib/WhiteheadRussell] p. 104.
stmt (pm2.3 () () (-> (\/ ph (\/ ps ch)) (\/ ph (\/ ch ps))))

#  Disjunction of antecedents.  Compare Theorem *3.44 of
#      [bib/WhiteheadRussell] p. 113.
stmt (jao () () (-> (-> ph ps) (-> (-> ch ps) (-> (\/ ph ch) ps))))

#  Inference disjoining the antecedents of two implications.
## <title> Join two implications </title>
## <table>
##   (->     ph ] ]    ]   ps)
##   (->        [ [ ch ]   ps)
##   (-> (\/ ph ] [ ch ] ) ps)
## </table>
stmt (jaoi () ((-> ph ps) (-> ch ps)) (-> (\/ ph ch) ps))

#  Theorem *2.41 of [bib/WhiteheadRussell] p. 106.
stmt (pm2.41 () () (-> (\/ ps (\/ ph ps)) (\/ ph ps)))

#  Theorem *2.42 of [bib/WhiteheadRussell] p. 106.
stmt (pm2.42 () () (-> (\/ (-. ph) (-> ph ps)) (-> ph ps)))

#  Theorem *2.4 of [bib/WhiteheadRussell] p. 106.
stmt (pm2.4 () () (-> (\/ ph (\/ ph ps)) (\/ ph ps)))

#  Theorem *4.44 of [bib/WhiteheadRussell] p. 119.
## <title> Extra Conjunct </title>
## <suggest> left('Simplify', '∨') </suggest>
stmt (pm4.44 () () (<-> ph (\/ ph (/\ ph ps))))

#  Theorem *5.63 of [bib/WhiteheadRussell] p. 125.
stmt (pm5.63 () () (<-> (\/ ph ps) (\/ ph (/\ (-. ph) ps))))

#  Import-export theorem.  Part of Theorem *4.87 of [bib/WhiteheadRussell]
#      p. 122.
## <title> Import-Export Theorem </title>
## <suggest> left('Equivalence', '∧→') right('Equivalence', '→→') </suggest>
stmt (impexp () () (<-> (-> (/\ ph ps) ch) (-> ph (-> ps ch))))

#  Theorem *3.3 (Exp) of [bib/WhiteheadRussell] p. 112.
stmt (pm3.3 () () (-> (-> (/\ ph ps) ch) (-> ph (-> ps ch))))

#  Theorem *3.31 (Imp) of [bib/WhiteheadRussell] p. 112.
stmt (pm3.31 () () (-> (-> ph (-> ps ch)) (-> (/\ ph ps) ch)))

#  Importation inference.  (The proof was shortened by Eric Schmidt,
#        22-Dec-2006.)
stmt (imp () ((-> ph (-> ps ch))) (-> (/\ ph ps) ch))

#  Importation inference with commuted antecedents.
stmt (impcom () ((-> ph (-> ps ch))) (-> (/\ ps ph) ch))

#  Theorem *4.14 of [bib/WhiteheadRussell] p. 117.
stmt (pm4.14 () () (<-> (-> (/\ ph ps) ch) (-> (/\ ph (-. ch)) (-. ps))))

#  Theorem *4.15 of [bib/WhiteheadRussell] p. 117.
stmt (pm4.15 () () (<-> (-> (/\ ph ps) (-. ch)) (-> (/\ ps ch) (-. ph))))

#  Theorem *4.78 of [bib/WhiteheadRussell] p. 121.
## <title> Distributive Property </title>
## <suggest> right('Distribute', '-R') </suggest>
stmt (pm4.78 () () (<-> (\/ (-> ph ps) (-> ph ch)) (-> ph (\/ ps ch))))

#  Theorem *4.79 of [bib/WhiteheadRussell] p. 121.
## <title> Distributive Property </title>
## <suggest> right('Distribute', '-L') </suggest>
stmt (pm4.79 () () (<-> (\/ (-> ps ph) (-> ch ph)) (-> (/\ ps ch) ph)))

#  Theorem *4.87 of [bib/WhiteheadRussell] p. 122.  (The proof was shortened by
#      Eric Schmidt, 26-Oct-2006.)
stmt (pm4.87 () () (/\ (/\ (<-> (-> (/\ ph ps) ch) (-> ph (-> ps ch))) (<-> (-> ph (-> ps ch)) (-> ps (-> ph ch)))) (<-> (-> ps (-> ph ch)) (-> (/\ ps ph) ch))))

#  Theorem *3.33 (Syll) of [bib/WhiteheadRussell] p. 112.
stmt (pm3.33 () () (-> (/\ (-> ph ps) (-> ps ch)) (-> ph ch)))

#  Theorem *3.34 (Syll) of [bib/WhiteheadRussell] p. 112.
stmt (pm3.34 () () (-> (/\ (-> ps ch) (-> ph ps)) (-> ph ch)))

#  Conjunctive detachment.  Theorem *3.35 of [bib/WhiteheadRussell] p. 112.
stmt (pm3.35 () () (-> (/\ ph (-> ph ps)) ps))

#  Theorem *5.31 of [bib/WhiteheadRussell] p. 125.
stmt (pm5.31 () () (-> (/\ ch (-> ph ps)) (-> ph (/\ ps ch))))

#  Importation deduction.
stmt (imp3a () ((-> ph (-> ps (-> ch th)))) (-> ph (-> (/\ ps ch) th)))

#  An importation inference.
stmt (imp31 () ((-> ph (-> ps (-> ch th)))) (-> (/\ (/\ ph ps) ch) th))

#  An importation inference.
stmt (imp32 () ((-> ph (-> ps (-> ch th)))) (-> (/\ ph (/\ ps ch)) th))

#  An importation inference.
stmt (imp4a () ((-> ph (-> ps (-> ch (-> th ta))))) (-> ph (-> ps (-> (/\ ch th) ta))))

#  An importation inference.
stmt (imp4b () ((-> ph (-> ps (-> ch (-> th ta))))) (-> (/\ ph ps) (-> (/\ ch th) ta)))

#  An importation inference.
stmt (imp4c () ((-> ph (-> ps (-> ch (-> th ta))))) (-> ph (-> (/\ (/\ ps ch) th) ta)))

#  An importation inference.
stmt (imp4d () ((-> ph (-> ps (-> ch (-> th ta))))) (-> ph (-> (/\ ps (/\ ch th)) ta)))

#  An importation inference.
stmt (imp41 () ((-> ph (-> ps (-> ch (-> th ta))))) (-> (/\ (/\ (/\ ph ps) ch) th) ta))

#  An importation inference.
stmt (imp42 () ((-> ph (-> ps (-> ch (-> th ta))))) (-> (/\ (/\ ph (/\ ps ch)) th) ta))

#  An importation inference.
stmt (imp43 () ((-> ph (-> ps (-> ch (-> th ta))))) (-> (/\ (/\ ph ps) (/\ ch th)) ta))

#  An importation inference.
stmt (imp44 () ((-> ph (-> ps (-> ch (-> th ta))))) (-> (/\ ph (/\ (/\ ps ch) th)) ta))

#  An importation inference.
stmt (imp45 () ((-> ph (-> ps (-> ch (-> th ta))))) (-> (/\ ph (/\ ps (/\ ch th))) ta))

#  Exportation inference.  (This theorem used to be labeled "exp" but was
#        changed to "ex" so as not to conflict with the math token "exp", per
#        the June 2006 Metamath spec change.)  (The proof was shortened by Eric
#        Schmidt, 22-Dec-2006.)
stmt (ex () ((-> (/\ ph ps) ch)) (-> ph (-> ps ch)))

#  Exportation inference with commuted antecedents.
stmt (expcom () ((-> (/\ ph ps) ch)) (-> ps (-> ph ch)))

#  Exportation followed by a deduction version of importation.
stmt (expimpd () ((-> (/\ ph ps) (-> ch th))) (-> ph (-> (/\ ps ch) th)))

#  Exportation deduction.
stmt (exp3a () ((-> ph (-> (/\ ps ch) th))) (-> ph (-> ps (-> ch th))))

#  A deduction version of exportation, followed by importation.
stmt (expdimp () ((-> ph (-> (/\ ps ch) th))) (-> (/\ ph ps) (-> ch th)))

#  An exportation inference.
stmt (exp31 () ((-> (/\ (/\ ph ps) ch) th)) (-> ph (-> ps (-> ch th))))

#  An exportation inference.
stmt (exp32 () ((-> (/\ ph (/\ ps ch)) th)) (-> ph (-> ps (-> ch th))))

#  An exportation inference.
stmt (exp4a () ((-> ph (-> ps (-> (/\ ch th) ta)))) (-> ph (-> ps (-> ch (-> th ta)))))

#  An exportation inference.
stmt (exp4b () ((-> (/\ ph ps) (-> (/\ ch th) ta))) (-> ph (-> ps (-> ch (-> th ta)))))

#  An exportation inference.
stmt (exp4c () ((-> ph (-> (/\ (/\ ps ch) th) ta))) (-> ph (-> ps (-> ch (-> th ta)))))

#  An exportation inference.
stmt (exp4d () ((-> ph (-> (/\ ps (/\ ch th)) ta))) (-> ph (-> ps (-> ch (-> th ta)))))

#  An exportation inference.
stmt (exp41 () ((-> (/\ (/\ (/\ ph ps) ch) th) ta)) (-> ph (-> ps (-> ch (-> th ta)))))

#  An exportation inference.
stmt (exp42 () ((-> (/\ (/\ ph (/\ ps ch)) th) ta)) (-> ph (-> ps (-> ch (-> th ta)))))

#  An exportation inference.
stmt (exp43 () ((-> (/\ (/\ ph ps) (/\ ch th)) ta)) (-> ph (-> ps (-> ch (-> th ta)))))

#  An exportation inference.
stmt (exp44 () ((-> (/\ ph (/\ (/\ ps ch) th)) ta)) (-> ph (-> ps (-> ch (-> th ta)))))

#  An exportation inference.
stmt (exp45 () ((-> (/\ ph (/\ ps (/\ ch th))) ta)) (-> ph (-> ps (-> ch (-> th ta)))))

#  Importation with conjunction in consequent.
stmt (impac () ((-> ph (-> ps ch))) (-> (/\ ph ps) (/\ ch ps)))

#  Inference adding a conjunct to the left of an antecedent.
## <title> Add Conjunct </title>
## <table>
##   (->        [ ph  [ ps)
##   (-> (/\ ch [ ph) [ ps)
## </table>
stmt (adantl () ((-> ph ps)) (-> (/\ ch ph) ps))

#  Inference adding a conjunct to the right of an antecedent.
## <title> Add Conjunct </title>
## <table>
##   (->     ph ] [    [   [ ps)
##   (-> (/\ ph ] [ ch ] ) [ ps)
## </table>
stmt (adantr () ((-> ph ps)) (-> (/\ ph ch) ps))

#  Deduction adding a conjunct to the left of an antecedent.
## <title> Add Conjunct </title>
stmt (adantld () ((-> ph (-> ps ch))) (-> ph (-> (/\ th ps) ch)))

#  Deduction adding a conjunct to the right of an antecedent.
## <title> Add Conjunct </title>
stmt (adantrd () ((-> ph (-> ps ch))) (-> ph (-> (/\ ps th) ch)))

#  Deduction adding a conjunct to antecedent.
## <title> Add Conjunct </title>
## <table>
##   (-> (/\        [ ph  [ ps) ch)
##   (-> (/\ (/\ th [ ph) [ ps) ch)
## </table>
stmt (adantll () ((-> (/\ ph ps) ch)) (-> (/\ (/\ th ph) ps) ch))

#  Deduction adding a conjunct to antecedent.
## <title> Add Conjunct </title>
stmt (adantlr () ((-> (/\ ph ps) ch)) (-> (/\ (/\ ph th) ps) ch))

#  Deduction adding a conjunct to antecedent.
## <title> Add Conjunct </title>
stmt (adantrl () ((-> (/\ ph ps) ch)) (-> (/\ ph (/\ th ps)) ch))

#  Deduction adding a conjunct to antecedent.
## <title> Add Conjunct </title>
stmt (adantrr () ((-> (/\ ph ps) ch)) (-> (/\ ph (/\ ps th)) ch))

#  Deduction adding a conjunct to antecedent.
## <title> Add Conjunct </title>
stmt (adantlll () ((-> (/\ (/\ ph ps) ch) th)) (-> (/\ (/\ (/\ ta ph) ps) ch) th))

#  Deduction adding a conjunct to antecedent.
## <title> Add Conjunct </title>
stmt (adantllr () ((-> (/\ (/\ ph ps) ch) th)) (-> (/\ (/\ (/\ ph ta) ps) ch) th))

#  Deduction adding a conjunct to antecedent.
## <title> Add Conjunct </title>
stmt (adantlrl () ((-> (/\ (/\ ph ps) ch) th)) (-> (/\ (/\ ph (/\ ta ps)) ch) th))

#  Deduction adding a conjunct to antecedent.
## <title> Add Conjunct </title>
stmt (adantlrr () ((-> (/\ (/\ ph ps) ch) th)) (-> (/\ (/\ ph (/\ ps ta)) ch) th))

#  Deduction adding a conjunct to antecedent.
## <title> Add Conjunct </title>
stmt (adantrll () ((-> (/\ ph (/\ ps ch)) th)) (-> (/\ ph (/\ (/\ ta ps) ch)) th))

#  Deduction adding a conjunct to antecedent.
## <title> Add Conjunct </title>
stmt (adantrlr () ((-> (/\ ph (/\ ps ch)) th)) (-> (/\ ph (/\ (/\ ps ta) ch)) th))

#  Deduction adding a conjunct to antecedent.
## <title> Add Conjunct </title>
stmt (adantrrl () ((-> (/\ ph (/\ ps ch)) th)) (-> (/\ ph (/\ ps (/\ ta ch))) th))

#  Deduction adding a conjunct to antecedent.
## <title> Add Conjunct </title>
stmt (adantrrr () ((-> (/\ ph (/\ ps ch)) th)) (-> (/\ ph (/\ ps (/\ ch ta))) th))

#  Deduction adding conjuncts to antecedent.
## <title> Add Conjuncts </title>
stmt (ad2antrr () ((-> ph ps)) (-> (/\ (/\ ph ch) th) ps))

#  Deduction adding conjuncts to antecedent.
## <title> Add Conjuncts </title>
stmt (ad2antlr () ((-> ph ps)) (-> (/\ (/\ ch ph) th) ps))

#  Deduction adding conjuncts to antecedent.
## <title> Add Conjuncts </title>
stmt (ad2antrl () ((-> ph ps)) (-> (/\ ch (/\ ph th)) ps))

#  Deduction adding conjuncts to antecedent.
## <title> Add Conjuncts </title>
stmt (ad2antll () ((-> ph ps)) (-> (/\ ch (/\ th ph)) ps))

#  Deduction adding two conjuncts to antecedent.
## <title> Add Conjuncts </title>
stmt (ad2ant2l () ((-> (/\ ph ps) ch)) (-> (/\ (/\ th ph) (/\ ta ps)) ch))

#  Deduction adding two conjuncts to antecedent.
## <title> Add Conjuncts </title>
stmt (ad2ant2r () ((-> (/\ ph ps) ch)) (-> (/\ (/\ ph th) (/\ ps ta)) ch))

#  Deduction adding two conjuncts to antecedent.
## <title> Add Conjuncts </title>
stmt (ad2ant2lr () ((-> (/\ ph ps) ch)) (-> (/\ (/\ th ph) (/\ ps ta)) ch))

#  Deduction adding two conjuncts to antecedent.
## <title> Add Conjuncts </title>
stmt (ad2ant2rl () ((-> (/\ ph ps) ch)) (-> (/\ (/\ ph th) (/\ ta ps)) ch))

#  Simplification of a conjunction.
stmt (simpll () () (-> (/\ (/\ ph ps) ch) ph))

#  Simplification of a conjunction.
stmt (simplr () () (-> (/\ (/\ ph ps) ch) ps))

#  Simplification of a conjunction.
stmt (simprl () () (-> (/\ ph (/\ ps ch)) ps))

#  Simplification of a conjunction.
stmt (simprr () () (-> (/\ ph (/\ ps ch)) ch))

#  Inference from a logical equivalence.
stmt (biimpa () ((-> ph (<-> ps ch))) (-> (/\ ph ps) ch))

#  Inference from a logical equivalence.
stmt (biimpar () ((-> ph (<-> ps ch))) (-> (/\ ph ch) ps))

#  Inference from a logical equivalence.
stmt (biimpac () ((-> ph (<-> ps ch))) (-> (/\ ps ph) ch))

#  Inference from a logical equivalence.
stmt (biimparc () ((-> ph (<-> ps ch))) (-> (/\ ch ph) ps))

#  Deduction eliminating a conjunct.
stmt (pm3.26bda () ((-> ph (<-> ps (/\ ch th)))) (-> (/\ ph ps) ch))

#  Deduction eliminating a conjunct.
stmt (pm3.27bda () ((-> ph (<-> ps (/\ ch th)))) (-> (/\ ph ps) th))

#  Disjunction of antecedents.  Compare Theorem *4.77 of
#      [bib/WhiteheadRussell] p. 121.
## <title> Distributive Property </title>
## <suggest> left('Distribute', '→') right('Distribute', '∧') </suggest>
stmt (jaob () () (<-> (-> (\/ ph ch) ps) (/\ (-> ph ps) (-> ch ps))))

#  Theorem *4.77 of [bib/WhiteheadRussell] p. 121.
## <title> Distributive Property </title>
## <suggest> right('Distribute', '∧') left('Distribute', '→') </suggest>
stmt (pm4.77 () () (<-> (/\ (-> ps ph) (-> ch ph)) (-> (\/ ps ch) ph)))

#  Deduction disjoining the antecedents of two implications.
stmt (jaod () ((-> ph (-> ps ch)) (-> ph (-> th ch))) (-> ph (-> (\/ ps th) ch)))

#  Inference disjoining the antecedents of two implications.
stmt (jaoian () ((-> (/\ ph ps) ch) (-> (/\ th ps) ch)) (-> (/\ (\/ ph th) ps) ch))

#  Deduction disjoining the antecedents of two implications.
stmt (jaodan () ((-> (/\ ph ps) ch) (-> (/\ ph th) ch)) (-> (/\ ph (\/ ps th)) ch))

#  Inference conjoining and disjoining the antecedents of two
#        implications.
stmt (jaao () ((-> ph (-> ps ch)) (-> th (-> ta ch))) (-> (/\ ph th) (-> (\/ ps ta) ch)))

#  Inference disjoining and conjoining the antecedents of two
#        implications.  (Contributed by Stefan Allan, 1-Nov-2008.)
stmt (jaoa () ((-> ph (-> ps ch)) (-> th (-> ta ch))) (-> (\/ ph th) (-> (/\ ps ta) ch)))

#  Theorem *2.63 of [bib/WhiteheadRussell] p. 107.
stmt (pm2.63 () () (-> (\/ ph ps) (-> (\/ (-. ph) ps) ps)))

#  Theorem *2.64 of [bib/WhiteheadRussell] p. 107.
stmt (pm2.64 () () (-> (\/ ph ps) (-> (\/ ph (-. ps)) ph)))

#  Theorem *3.44 of [bib/WhiteheadRussell] p. 113.
stmt (pm3.44 () () (-> (/\ (-> ps ph) (-> ch ph)) (-> (\/ ps ch) ph)))

#  Theorem *4.43 of [bib/WhiteheadRussell] p. 119.
## <title> Excluded Middle </title>
## <suggest> left('Simplify', '∧') </suggest>
stmt (pm4.43 () () (<-> ph (/\ (\/ ph ps) (\/ ph (-. ps)))))

#  Idempotent law for conjunction.
## <title> Conjunction is Idempotent </title>
## <suggest> right('Simplify', '∧') </suggest>
stmt (anidm () () (<-> (/\ ph ph) ph))

#  Theorem *4.24 of [bib/WhiteheadRussell] p. 117.
stmt (pm4.24 () () (<-> ph (/\ ph ph)))

#  Inference from idempotent law for conjunction.
## <title> Conjunction is Idempotent </title>
## <table>
##   (-> (/\ <r> ph [ <r> ph ) ps)
##              (-> [ <r> ph   ps)
## </table>
stmt (anidms () ((-> (/\ ph ph) ps)) (-> ph ps))

#  Conjunction idempotence with antecedent. (Contributed by Roy F.
#      Longton, 8-Aug-2005.)
## <title> Conjunction is Idempotent </title>
stmt (anidmdbi () () (<-> (-> ph (/\ ps ps)) (-> ph ps)))

#  Commutative law for conjunction.  Theorem *4.3 of [bib/WhiteheadRussell]
#      p. 118.
## <title> Commutative Property </title>
## <suggest> right('Commute', '∧') </suggest>
stmt (ancom () () (<-> (/\ ph ps) (/\ ps ph)))

#  Inference commuting conjunction in antecedent.  //Notational convention//:
#        We sometimes suffix with "s" the label of an inference that manipulates
#        an antecedent, leaving the consequent unchanged.  The "s" means that the
#        inference eliminates the need for a syllogism ([[syl]]) -type inference
#        in a proof.
## <title> Commutative Property </title>
stmt (ancoms () ((-> (/\ ph ps) ch)) (-> (/\ ps ph) ch))

#  Deduction commuting conjunction in antecedent.
## <title> Commutative Property </title>
stmt (ancomsd () ((-> ph (-> (/\ ps ch) th))) (-> ph (-> (/\ ch ps) th)))

#  Theorem *3.22 of [bib/WhiteheadRussell] p. 111.
stmt (pm3.22 () () (-> (/\ ph ps) (/\ ps ph)))

#  Associative law for conjunction.  Theorem *4.32 of [bib/WhiteheadRussell]
#      p. 118.
## <title> Associative Property </title>
## <suggest> right('Associate', 'R') left('Associate', 'L') </suggest>
stmt (anass () () (<-> (/\ (/\ ph ps) ch) (/\ ph (/\ ps ch))))

#  Associative law for conjunction applied to antecedent (eliminates
#        syllogism).
stmt (anasss () ((-> (/\ (/\ ph ps) ch) th)) (-> (/\ ph (/\ ps ch)) th))

#  Associative law for conjunction applied to antecedent (eliminates
#        syllogism).
stmt (anassrs () ((-> (/\ ph (/\ ps ch)) th)) (-> (/\ (/\ ph ps) ch) th))

#  Distribution of implication with conjunction.
stmt (imdistan () () (<-> (-> ph (-> ps ch)) (-> (/\ ph ps) (/\ ph ch))))

#  Distribution of implication with conjunction.
stmt (imdistani () ((-> ph (-> ps ch))) (-> (/\ ph ps) (/\ ph ch)))

#  Distribution of implication with conjunction.
stmt (imdistanri () ((-> ph (-> ps ch))) (-> (/\ ps ph) (/\ ch ph)))

#  Distribution of implication with conjunction (deduction rule).
stmt (imdistand () ((-> ph (-> ps (-> ch th)))) (-> ph (-> (/\ ps ch) (/\ ps th))))

#  Theorem *5.3 of [bib/WhiteheadRussell] p. 125.
stmt (pm5.3 () () (<-> (-> (/\ ph ps) ch) (-> (/\ ph ps) (/\ ph ch))))

#  Theorem *5.61 of [bib/WhiteheadRussell] p. 125.
stmt (pm5.61 () () (<-> (/\ (\/ ph ps) (-. ps)) (/\ ph (-. ps))))

#  A syllogism inference.
stmt (sylan () ((-> (/\ ph ps) ch) (-> th ph)) (-> (/\ th ps) ch))

#  A syllogism inference.
stmt (sylanb () ((-> (/\ ph ps) ch) (<-> th ph)) (-> (/\ th ps) ch))

#  A syllogism inference.
stmt (sylanbr () ((-> (/\ ph ps) ch) (<-> ph th)) (-> (/\ th ps) ch))

#  A syllogism inference.
stmt (sylan2 () ((-> (/\ ph ps) ch) (-> th ps)) (-> (/\ ph th) ch))

#  A syllogism inference.
stmt (sylan2b () ((-> (/\ ph ps) ch) (<-> th ps)) (-> (/\ ph th) ch))

#  A syllogism inference.
stmt (sylan2br () ((-> (/\ ph ps) ch) (<-> ps th)) (-> (/\ ph th) ch))

#  A double syllogism inference.
stmt (syl2an () ((-> (/\ ph ps) ch) (-> th ph) (-> ta ps)) (-> (/\ th ta) ch))

#  A double syllogism inference.
stmt (syl2anb () ((-> (/\ ph ps) ch) (<-> th ph) (<-> ta ps)) (-> (/\ th ta) ch))

#  A double syllogism inference.
stmt (syl2anbr () ((-> (/\ ph ps) ch) (<-> ph th) (<-> ps ta)) (-> (/\ th ta) ch))

#  A syllogism deduction.
stmt (syland () ((-> ph (-> (/\ ps ch) th)) (-> ph (-> ta ps))) (-> ph (-> (/\ ta ch) th)))

#  A syllogism deduction.
stmt (sylan2d () ((-> ph (-> (/\ ps ch) th)) (-> ph (-> ta ch))) (-> ph (-> (/\ ps ta) th)))
tvar (wff et)

#  A syllogism deduction.
stmt (syl2and () ((-> ph (-> (/\ ps ch) th)) (-> ph (-> ta ps)) (-> ph (-> et ch))) (-> ph (-> (/\ ta et) th)))

#  A syllogism inference.
stmt (sylanl1 () ((-> (/\ (/\ ph ps) ch) th) (-> ta ph)) (-> (/\ (/\ ta ps) ch) th))

#  A syllogism inference.
stmt (sylanl2 () ((-> (/\ (/\ ph ps) ch) th) (-> ta ps)) (-> (/\ (/\ ph ta) ch) th))

#  A syllogism inference.
stmt (sylanr1 () ((-> (/\ ph (/\ ps ch)) th) (-> ta ps)) (-> (/\ ph (/\ ta ch)) th))

#  A syllogism inference.
stmt (sylanr2 () ((-> (/\ ph (/\ ps ch)) th) (-> ta ch)) (-> (/\ ph (/\ ps ta)) th))

#  A syllogism inference.
stmt (sylani () ((-> ph (-> (/\ ps ch) th)) (-> ta ps)) (-> ph (-> (/\ ta ch) th)))

#  A syllogism inference.
stmt (sylan2i () ((-> ph (-> (/\ ps ch) th)) (-> ta ch)) (-> ph (-> (/\ ps ta) th)))

#  A syllogism inference.
stmt (syl2ani () ((-> ph (-> (/\ ps ch) th)) (-> ta ps) (-> et ch)) (-> ph (-> (/\ ta et) th)))

#  A syllogism deduction with conjoined antecents.
stmt (syldan () ((-> (/\ ph ps) ch) (-> (/\ ph ch) th)) (-> (/\ ph ps) th))

#  Nested syllogism inference conjoining dissimilar antecedents.
stmt (sylan9 () ((-> ph (-> ps ch)) (-> th (-> ch ta))) (-> (/\ ph th) (-> ps ta)))

#  Nested syllogism inference conjoining dissimilar antecedents.
stmt (sylan9r () ((-> ph (-> ps ch)) (-> th (-> ch ta))) (-> (/\ th ph) (-> ps ta)))

#  Modus ponens conjoining dissimilar antecedents.
stmt (mpan9 () ((-> ph ps) (-> ch (-> ps th))) (-> (/\ ph ch) th))

#  A syllogism inference combined with contraction.
stmt (sylanc () ((-> (/\ ph ps) ch) (-> th ph) (-> th ps)) (-> th ch))

#  A syllogism inference combined with contraction.
stmt (syl2anc () ((-> (/\ (/\ ph ps) (/\ ch th)) ta) (-> et ph) (-> et ps) (-> et ch) (-> et th)) (-> et ta))

#  A syllogism inference combined with contraction.
stmt (sylancb () ((-> (/\ ph ps) ch) (<-> th ph) (<-> th ps)) (-> th ch))

#  A syllogism inference combined with contraction.
stmt (sylancbr () ((-> (/\ ph ps) ch) (<-> ph th) (<-> ps th)) (-> th ch))

#  Syllogism inference with commutation of antecents.
stmt (sylancom () ((-> (/\ ph ps) ch) (-> (/\ ch ps) th)) (-> (/\ ph ps) th))

#  Elimination of an antecedent.
stmt (pm2.61ian () ((-> (/\ ph ps) ch) (-> (/\ (-. ph) ps) ch)) (-> ps ch))

#  Elimination of an antecedent.
stmt (pm2.61dan () ((-> (/\ ph ps) ch) (-> (/\ ph (-. ps)) ch)) (-> ph ch))

#  Proof by contradiction.
stmt (condan () ((-> (/\ ph (-. ps)) ch) (-> (/\ ph (-. ps)) (-. ch))) (-> ph ps))

#  Introduce one conjunct as an antecedent to the another.
## <title> Introduce conjunct as antecedent </title>
## <suggest> left('Simplify', '→') </suggest>
stmt (abai () () (<-> (/\ ph ps) (/\ ph (-> ph ps))))

#  Introduce a left conjunct to both sides of a logical equivalence.
## <title> Equivalence over Conjunction </title>
## <table>
##   (<->        [ ph ]   [        [ ps)
##   (<-> (/\ ch [ ph ] ) [ (/\ ch [ ps))
## </table>
stmt (anbi2i () ((<-> ph ps)) (<-> (/\ ch ph) (/\ ch ps)))

#  Introduce a right conjunct to both sides of a logical equivalence.
## <title> Equivalence over Conjunction </title>
## <table>
##   (<->     ph ]     ]     [ ps ] )
##   (<-> (/\ ph ] ch) ] (/\ [ ps ] ch))
## </table>
stmt (anbi1i () ((<-> ph ps)) (<-> (/\ ph ch) (/\ ps ch)))

#  Conjoin both sides of two equivalences.
## <title> Equivalence over Conjunction </title>
stmt (anbi12i () ((<-> ph ps) (<-> ch th)) (<-> (/\ ph ch) (/\ ps th)))

#  Theorem *5.53 of [bib/WhiteheadRussell] p. 125.
stmt (pm5.53 () () (<-> (-> (\/ (\/ ph ps) ch) th) (/\ (/\ (-> ph th) (-> ps th)) (-> ch th))))

#  A rearrangement of conjuncts.
stmt (an12 () () (<-> (/\ ph (/\ ps ch)) (/\ ps (/\ ph ch))))

#  A rearrangement of conjuncts.
stmt (an23 () () (<-> (/\ (/\ ph ps) ch) (/\ (/\ ph ch) ps)))

#  Deduction rearranging conjuncts.
stmt (an1s () ((-> (/\ ph (/\ ps ch)) th)) (-> (/\ ps (/\ ph ch)) th))

#  Inference commuting a nested conjunction in antecedent.
stmt (ancom2s () ((-> (/\ ph (/\ ps ch)) th)) (-> (/\ ph (/\ ch ps)) th))

#  Deduction rearranging conjuncts.
stmt (ancom13s () ((-> (/\ ph (/\ ps ch)) th)) (-> (/\ ch (/\ ps ph)) th))

#  Deduction rearranging conjuncts.
stmt (an1rs () ((-> (/\ (/\ ph ps) ch) th)) (-> (/\ (/\ ph ch) ps) th))

#  Inference commuting a nested conjunction in antecedent.
stmt (ancom1s () ((-> (/\ (/\ ph ps) ch) th)) (-> (/\ (/\ ps ph) ch) th))

#  Deduction rearranging conjuncts.
stmt (ancom31s () ((-> (/\ (/\ ph ps) ch) th)) (-> (/\ (/\ ch ps) ph) th))

#  Absorption into embedded conjunct.
stmt (anabs1 () () (<-> (/\ (/\ ph ps) ph) (/\ ph ps)))

#  Absorption into embedded conjunct.
stmt (anabs5 () () (<-> (/\ ph (/\ ph ps)) (/\ ph ps)))

#  Absorption into embedded conjunct.
stmt (anabs7 () () (<-> (/\ ps (/\ ph ps)) (/\ ph ps)))

#  Absorption of antecedent into conjunction.
stmt (anabsi5 () ((-> ph (-> (/\ ph ps) ch))) (-> (/\ ph ps) ch))

#  Absorption of antecedent into conjunction.
stmt (anabsi6 () ((-> ph (-> (/\ ps ph) ch))) (-> (/\ ph ps) ch))

#  Absorption of antecedent into conjunction.
stmt (anabsi7 () ((-> ps (-> (/\ ph ps) ch))) (-> (/\ ph ps) ch))

#  Absorption of antecedent into conjunction.
stmt (anabsi8 () ((-> ps (-> (/\ ps ph) ch))) (-> (/\ ph ps) ch))

#  Absorption of antecedent into conjunction.
stmt (anabss1 () ((-> (/\ (/\ ph ps) ph) ch)) (-> (/\ ph ps) ch))

#  Absorption of antecedent into conjunction.
stmt (anabss3 () ((-> (/\ (/\ ph ps) ps) ch)) (-> (/\ ph ps) ch))

#  Absorption of antecedent into conjunction.
stmt (anabss4 () ((-> (/\ (/\ ps ph) ps) ch)) (-> (/\ ph ps) ch))

#  Absorption of antecedent into conjunction.
stmt (anabss5 () ((-> (/\ ph (/\ ph ps)) ch)) (-> (/\ ph ps) ch))

#  Absorption of antecedent into conjunction.
stmt (anabss7 () ((-> (/\ ps (/\ ph ps)) ch)) (-> (/\ ph ps) ch))

#  Absorption of antecedent with conjunction.
stmt (anabsan () ((-> (/\ (/\ ph ph) ps) ch)) (-> (/\ ph ps) ch))

#  Absorption of antecedent with conjunction.
stmt (anabsan2 () ((-> (/\ ph (/\ ps ps)) ch)) (-> (/\ ph ps) ch))

#  Rearrangement of 4 conjuncts.
stmt (an4 () () (<-> (/\ (/\ ph ps) (/\ ch th)) (/\ (/\ ph ch) (/\ ps th))))

#  Rearrangement of 4 conjuncts.
stmt (an42 () () (<-> (/\ (/\ ph ps) (/\ ch th)) (/\ (/\ ph ch) (/\ th ps))))

#  Inference rearranging 4 conjuncts in antecedent.
stmt (an4s () ((-> (/\ (/\ ph ps) (/\ ch th)) ta)) (-> (/\ (/\ ph ch) (/\ ps th)) ta))

#  Inference rearranging 4 conjuncts in antecedent.
stmt (an42s () ((-> (/\ (/\ ph ps) (/\ ch th)) ta)) (-> (/\ (/\ ph ch) (/\ th ps)) ta))

#  Distribution of conjunction over conjunction.
stmt (anandi () () (<-> (/\ ph (/\ ps ch)) (/\ (/\ ph ps) (/\ ph ch))))

#  Distribution of conjunction over conjunction.
stmt (anandir () () (<-> (/\ (/\ ph ps) ch) (/\ (/\ ph ch) (/\ ps ch))))

#  Inference that undistributes conjunction in the antecedent.
stmt (anandis () ((-> (/\ (/\ ph ps) (/\ ph ch)) ta)) (-> (/\ ph (/\ ps ch)) ta))

#  Inference that undistributes conjunction in the antecedent.
stmt (anandirs () ((-> (/\ (/\ ph ch) (/\ ps ch)) ta)) (-> (/\ (/\ ph ps) ch) ta))

#  A theorem similar to the standard definition of the biconditional.
#      Definition of [bib/Margaris] p. 49.
## <title> Definition of biconditional </title>
## <suggest> left('Simplify', '↔') </suggest>
stmt (dfbi2 () () (<-> (<-> ph ps) (/\ (-> ph ps) (-> ps ph))))

#  Definition [[df-bi]] rewritten in an abbreviated form to help intuitive
#      understanding of that definition.  Note that it is a conjunction of
#      two implications; one which asserts properties that follow from the
#      biconditional and one which asserts properties that imply the
#      biconditional.
stmt (dfbi () () (/\ (-> (<-> ph ps) (/\ (-> ph ps) (-> ps ph))) (-> (/\ (-> ph ps) (-> ps ph)) (<-> ph ps))))

#  Deduce an equivalence from two implications.
## <title> Deduce Equivalence </title>
## <table>
##   (-> ph (->  [ <r> ps <g> ch ] ))
##   (-> ph (->  [ <g> ch <r> ps ] ))
##   (-> ph (<-> [ <r> ps <g> ch ] ))
## </table>
stmt (impbid () ((-> ph (-> ps ch)) (-> ph (-> ch ps))) (-> ph (<-> ps ch)))

#  Infer an equivalence from two implications.
stmt (impbid1 () ((-> ph (-> ps ch)) (-> ch ps)) (-> ph (<-> ps ch)))

#  Infer an equivalence from two implications.
stmt (impbid2 () ((-> ps ch) (-> ph (-> ch ps))) (-> ph (<-> ps ch)))

#  Deduce an equivalence from two implications.
stmt (impbida () ((-> (/\ ph ps) ch) (-> (/\ ph ch) ps)) (-> ph (<-> ps ch)))

#  Commutative law for equivalence.  Theorem *4.21 of [bib/WhiteheadRussell]
#      p. 117.
## <title> Commutative Property </title>
## <suggest> right('Commute', '↔') </suggest>
stmt (bicom () () (<-> (<-> ph ps) (<-> ps ph)))

#  Commute two sides of a biconditional in a deduction.
## <title> Commutative Property </title>
stmt (bicomd () ((-> ph (<-> ps ch))) (-> ph (<-> ch ps)))

#  Contraposition.  Theorem *4.11 of [bib/WhiteheadRussell] p. 117.
## <title> Negate Both Sides </title>
## <suggest> left('Simplify', '¬') right('Add', '¬') </suggest>
stmt (notbi () () (<-> (<-> ph ps) (<-> (-. ph) (-. ps))))

#  A contraposition inference.
## <title> Contraposition </title>
stmt (con4bii () ((<-> (-. ph) (-. ps))) (<-> ph ps))

#  A contraposition deduction.
## <title> Contraposition </title>
stmt (con4bid () ((-> ph (<-> (-. ps) (-. ch)))) (-> ph (<-> ps ch)))

#  Contraposition.  Theorem *4.12 of [bib/WhiteheadRussell] p. 117.
## <title> Contraposition </title>
stmt (con2bi () () (<-> (<-> ph (-. ps)) (<-> ps (-. ph))))

#  A contraposition deduction.
## <title> Contraposition </title>
stmt (con2bid () ((-> ph (<-> ps (-. ch)))) (-> ph (<-> ch (-. ps))))

#  A contraposition deduction.
## <title> Contraposition </title>
stmt (con1bid () ((-> ph (<-> (-. ps) ch))) (-> ph (<-> (-. ch) ps)))

#  Deduction form of [[bitri]].
stmt (bitrd () ((-> ph (<-> ps ch)) (-> ph (<-> ch th))) (-> ph (<-> ps th)))

#  Deduction form of [[bitr2i]].
stmt (bitr2d () ((-> ph (<-> ps ch)) (-> ph (<-> ch th))) (-> ph (<-> th ps)))

#  Deduction form of [[bitr3i]].
stmt (bitr3d () ((-> ph (<-> ps ch)) (-> ph (<-> ps th))) (-> ph (<-> ch th)))

#  Deduction form of [[bitr4i]].
stmt (bitr4d () ((-> ph (<-> ps ch)) (-> ph (<-> th ch))) (-> ph (<-> ps th)))

#  A syllogism inference from two biconditionals.
stmt (syl5bb () ((-> ph (<-> ps ch)) (<-> th ps)) (-> ph (<-> th ch)))

#  A syllogism inference from two biconditionals.
stmt (syl5rbb () ((-> ph (<-> ps ch)) (<-> th ps)) (-> ph (<-> ch th)))

#  A syllogism inference from two biconditionals.
stmt (syl5bbr () ((-> ph (<-> ps ch)) (<-> ps th)) (-> ph (<-> th ch)))

#  A syllogism inference from two biconditionals.
stmt (syl5rbbr () ((-> ph (<-> ps ch)) (<-> ps th)) (-> ph (<-> ch th)))

#  A syllogism inference from two biconditionals.
stmt (syl6bb () ((-> ph (<-> ps ch)) (<-> ch th)) (-> ph (<-> ps th)))

#  A syllogism inference from two biconditionals.
stmt (syl6rbb () ((-> ph (<-> ps ch)) (<-> ch th)) (-> ph (<-> th ps)))

#  A syllogism inference from two biconditionals.
stmt (syl6bbr () ((-> ph (<-> ps ch)) (<-> th ch)) (-> ph (<-> ps th)))

#  A syllogism inference from two biconditionals.
stmt (syl6rbbr () ((-> ph (<-> ps ch)) (<-> th ch)) (-> ph (<-> th ps)))

#  Nested syllogism inference conjoining dissimilar antecedents.
stmt (sylan9bb () ((-> ph (<-> ps ch)) (-> th (<-> ch ta))) (-> (/\ ph th) (<-> ps ta)))

#  Nested syllogism inference conjoining dissimilar antecedents.
stmt (sylan9bbr () ((-> ph (<-> ps ch)) (-> th (<-> ch ta))) (-> (/\ th ph) (<-> ps ta)))

#  More general version of [[3imtr3i]].  Useful for converting
#        conditional definitions in a formula.
stmt (3imtr3d () ((-> ph (-> ps ch)) (-> ph (<-> ps th)) (-> ph (<-> ch ta))) (-> ph (-> th ta)))

#  More general version of [[3imtr4i]].  Useful for converting
#        conditional definitions in a formula.
stmt (3imtr4d () ((-> ph (-> ps ch)) (-> ph (<-> th ps)) (-> ph (<-> ta ch))) (-> ph (-> th ta)))

#  Deduction from transitivity of biconditional.
stmt (3bitrd () ((-> ph (<-> ps ch)) (-> ph (<-> ch th)) (-> ph (<-> th ta))) (-> ph (<-> ps ta)))

#  Deduction from transitivity of biconditional.
stmt (3bitrrd () ((-> ph (<-> ps ch)) (-> ph (<-> ch th)) (-> ph (<-> th ta))) (-> ph (<-> ta ps)))

#  Deduction from transitivity of biconditional.
stmt (3bitr2d () ((-> ph (<-> ps ch)) (-> ph (<-> th ch)) (-> ph (<-> th ta))) (-> ph (<-> ps ta)))

#  Deduction from transitivity of biconditional.
stmt (3bitr2rd () ((-> ph (<-> ps ch)) (-> ph (<-> th ch)) (-> ph (<-> th ta))) (-> ph (<-> ta ps)))

#  Deduction from transitivity of biconditional.  Useful for converting
#        conditional definitions in a formula.
stmt (3bitr3d () ((-> ph (<-> ps ch)) (-> ph (<-> ps th)) (-> ph (<-> ch ta))) (-> ph (<-> th ta)))

#  Deduction from transitivity of biconditional.
stmt (3bitr3rd () ((-> ph (<-> ps ch)) (-> ph (<-> ps th)) (-> ph (<-> ch ta))) (-> ph (<-> ta th)))

#  Deduction from transitivity of biconditional.  Useful for converting
#        conditional definitions in a formula.
stmt (3bitr4d () ((-> ph (<-> ps ch)) (-> ph (<-> th ps)) (-> ph (<-> ta ch))) (-> ph (<-> th ta)))

#  Deduction from transitivity of biconditional.
stmt (3bitr4rd () ((-> ph (<-> ps ch)) (-> ph (<-> th ps)) (-> ph (<-> ta ch))) (-> ph (<-> ta th)))

#  More general version of [[3imtr3i]].  Useful for converting
#        definitions in a formula.
stmt (3imtr3g () ((-> ph (-> ps ch)) (<-> ps th) (<-> ch ta)) (-> ph (-> th ta)))

#  More general version of [[3imtr4i]].  Useful for converting
#        definitions in a formula.
stmt (3imtr4g () ((-> ph (-> ps ch)) (<-> th ps) (<-> ta ch)) (-> ph (-> th ta)))

#  More general version of [[3bitr3i]].  Useful for converting
#        definitions in a formula.
stmt (3bitr3g () ((-> ph (<-> ps ch)) (<-> ps th) (<-> ch ta)) (-> ph (<-> th ta)))

#  More general version of [[3bitr4i]].  Useful for converting
#        definitions in a formula.
stmt (3bitr4g () ((-> ph (<-> ps ch)) (<-> th ps) (<-> ta ch)) (-> ph (<-> th ta)))

#  Theorem *3.47 of [bib/WhiteheadRussell] p. 113.  It was proved by Leibniz, and
#      it evidently pleased him enough to call it 'praeclarum theorema.'
## <title> Praeclarum Theorema </title>
## <suggest> right('Infer', '→') </suggest>
stmt (prth () () (-> (/\ (-> ph ps) (-> ch th)) (-> (/\ ph ch) (/\ ps th))))

#  Theorem *3.48 of [bib/WhiteheadRussell] p. 114.
stmt (pm3.48 () () (-> (/\ (-> ph ps) (-> ch th)) (-> (\/ ph ch) (\/ ps th))))

#  Conjoin antecedents and consequents in a deduction.
stmt (anim12d () ((-> ph (-> ps ch)) (-> ph (-> th ta))) (-> ph (-> (/\ ps th) (/\ ch ta))))

#  Conjoin antecedents and consequents in a deduction.
stmt (anim12ii () ((-> ph (-> ps ch)) (-> th (-> ps ta))) (-> (/\ ph th) (-> ps (/\ ch ta))))

#  Add a conjunct to right of antecedent and consequent in a deduction.
stmt (anim1d () ((-> ph (-> ps ch))) (-> ph (-> (/\ ps th) (/\ ch th))))

#  Add a conjunct to left of antecedent and consequent in a deduction.
stmt (anim2d () ((-> ph (-> ps ch))) (-> ph (-> (/\ th ps) (/\ th ch))))

#  Theorem *3.45 (Fact) of [bib/WhiteheadRussell] p. 113.
stmt (pm3.45 () () (-> (-> ph ps) (-> (/\ ph ch) (/\ ps ch))))

#  Deduction joining nested implications to form implication of
#        conjunctions.
stmt (im2anan9 () ((-> ph (-> ps ch)) (-> th (-> ta et))) (-> (/\ ph th) (-> (/\ ps ta) (/\ ch et))))

#  Deduction joining nested implications to form implication of
#        conjunctions.
stmt (im2anan9r () ((-> ph (-> ps ch)) (-> th (-> ta et))) (-> (/\ th ph) (-> (/\ ps ta) (/\ ch et))))

#  Disjoin antecedents and consequents in a deduction.
stmt (orim12d () ((-> ph (-> ps ch)) (-> ph (-> th ta))) (-> ph (-> (\/ ps th) (\/ ch ta))))

#  Disjoin antecedents and consequents in a deduction.
stmt (orim1d () ((-> ph (-> ps ch))) (-> ph (-> (\/ ps th) (\/ ch th))))

#  Disjoin antecedents and consequents in a deduction.
stmt (orim2d () ((-> ph (-> ps ch))) (-> ph (-> (\/ th ps) (\/ th ch))))

#  Axiom *1.6 (Sum) of [bib/WhiteheadRussell] p. 97.
stmt (orim2 () () (-> (-> ps ch) (-> (\/ ph ps) (\/ ph ch))))

#  Theorem *2.38 of [bib/WhiteheadRussell] p. 105.
stmt (pm2.38 () () (-> (-> ps ch) (-> (\/ ps ph) (\/ ch ph))))

#  Theorem *2.36 of [bib/WhiteheadRussell] p. 105.
stmt (pm2.36 () () (-> (-> ps ch) (-> (\/ ph ps) (\/ ch ph))))

#  Theorem *2.37 of [bib/WhiteheadRussell] p. 105.
stmt (pm2.37 () () (-> (-> ps ch) (-> (\/ ps ph) (\/ ph ch))))

#  Theorem *2.73 of [bib/WhiteheadRussell] p. 108.
stmt (pm2.73 () () (-> (-> ph ps) (-> (\/ (\/ ph ps) ch) (\/ ps ch))))

#  Theorem *2.74 of [bib/WhiteheadRussell] p. 108.
stmt (pm2.74 () () (-> (-> ps ph) (-> (\/ (\/ ph ps) ch) (\/ ph ch))))

#  Theorem *2.75 of [bib/WhiteheadRussell] p. 108.
stmt (pm2.75 () () (-> (\/ ph ps) (-> (\/ ph (-> ps ch)) (\/ ph ch))))

#  Theorem *2.76 of [bib/WhiteheadRussell] p. 108.
stmt (pm2.76 () () (-> (\/ ph (-> ps ch)) (-> (\/ ph ps) (\/ ph ch))))

#  Theorem *2.8 of [bib/WhiteheadRussell] p. 108.
stmt (pm2.8 () () (-> (\/ ps ch) (-> (\/ (-. ch) th) (\/ ps th))))

#  Theorem *2.81 of [bib/WhiteheadRussell] p. 108.
stmt (pm2.81 () () (-> (-> ps (-> ch th)) (-> (\/ ph ps) (-> (\/ ph ch) (\/ ph th)))))

#  Theorem *2.82 of [bib/WhiteheadRussell] p. 108.
stmt (pm2.82 () () (-> (\/ (\/ ph ps) ch) (-> (\/ (\/ ph (-. ch)) th) (\/ (\/ ph ps) th))))

#  Theorem *2.85 of [bib/WhiteheadRussell] p. 108.
stmt (pm2.85 () () (-> (-> (\/ ph ps) (\/ ph ch)) (\/ ph (-> ps ch))))

#  Infer negated disjunction of negated premises.
stmt (pm3.2ni () ((-. ph) (-. ps)) (-. (\/ ph ps)))

#  Absorption of redundant internal disjunct.  Compare Theorem *4.45
#      of [bib/WhiteheadRussell] p. 119.
stmt (orabs () () (<-> ph (/\ (\/ ph ps) ph)))

#  Absorb a disjunct into a conjunct.  (Contributed by Roy F. Longton
#      23-Jun-2005.)
stmt (oranabs () () (<-> (/\ (\/ ph (-. ps)) ps) (/\ ph ps)))

#  Distribution of implication over biconditional.  Theorem *5.74 of
#      [bib/WhiteheadRussell] p. 126.
stmt (pm5.74 () () (<-> (-> ph (<-> ps ch)) (<-> (-> ph ps) (-> ph ch))))

#  Distribution of implication over biconditional (inference rule).
stmt (pm5.74i () ((-> ph (<-> ps ch))) (<-> (-> ph ps) (-> ph ch)))

#  Distribution of implication over biconditional (deduction rule).
stmt (pm5.74d () ((-> ph (-> ps (<-> ch th)))) (-> ph (<-> (-> ps ch) (-> ps th))))

#  Distribution of implication over biconditional (deduction rule).
stmt (pm5.74da () ((-> (/\ ph ps) (<-> ch th))) (-> ph (<-> (-> ps ch) (-> ps th))))

#  Distribution of implication over biconditional (reverse inference
#        rule).
stmt (pm5.74ri () ((<-> (-> ph ps) (-> ph ch))) (-> ph (<-> ps ch)))

#  Distribution of implication over biconditional (deduction rule).
stmt (pm5.74rd () ((-> ph (<-> (-> ps ch) (-> ps th)))) (-> ph (-> ps (<-> ch th))))

#  A deduction from a biconditional, related to modus ponens.
stmt (mpbidi () ((-> th (-> ph ps)) (-> ph (<-> ps ch))) (-> th (-> ph ch)))

#  Implication in terms of implication and biconditional.
## <title> Implication & Biconditional </title>
## <suggest> left('Simplify', '↔') </suggest>
stmt (ibib () () (<-> (-> ph ps) (-> ph (<-> ph ps))))

#  Implication in terms of implication and biconditional.
## <title> Implication & Biconditional </title>
## <suggest> left('Simplify', '↔') </suggest>
stmt (ibibr () () (<-> (-> ph ps) (-> ph (<-> ps ph))))

#  Inference that converts a biconditional implied by one of its arguments,
#        into an implication.
stmt (ibi () ((-> ph (<-> ph ps))) (-> ph ps))

#  Inference that converts a biconditional implied by one of its arguments,
#        into an implication.
stmt (ibir () ((-> ph (<-> ps ph))) (-> ph ps))

#  Deduction that converts a biconditional implied by one of its arguments,
#        into an implication.
stmt (ibd () ((-> ph (-> ps (<-> ps ch)))) (-> ph (-> ps ch)))

#  Theorem *5.501 of [bib/WhiteheadRussell] p. 125.
stmt (pm5.501 () () (-> ph (<-> ps (<-> ph ps))))

#  Distributive law for disjunction.  Theorem *4.41 of [bib/WhiteheadRussell]
#      p. 119.
## <title> Distributive Property </title>
## <suggest> right('Distribute', 'L') left('Distribute', '-L') </suggest>
stmt (ordi () () (<-> (\/ ph (/\ ps ch)) (/\ (\/ ph ps) (\/ ph ch))))

#  Distributive law for disjunction.
## <title> Distributive Property </title>
## <suggest> right('Distribute', 'R') left('Distribute', '-R') </suggest>
stmt (ordir () () (<-> (\/ (/\ ph ps) ch) (/\ (\/ ph ch) (\/ ps ch))))

#  Distributive law for implication over conjunction.  Compare Theorem
#      *4.76 of [bib/WhiteheadRussell] p. 121.
## <title> Distributive Property </title>
## <suggest> left('Distribute', '-∧') right('Distribute', '→') </suggest>
stmt (jcab () () (<-> (-> ph (/\ ps ch)) (/\ (-> ph ps) (-> ph ch))))

#  Theorem *4.76 of [bib/WhiteheadRussell] p. 121.
stmt (pm4.76 () () (<-> (/\ (-> ph ps) (-> ph ch)) (-> ph (/\ ps ch))))

#  Deduction conjoining the consequents of two implications.
## <title> Join two implications </title>
stmt (jcad () ((-> ph (-> ps ch)) (-> ph (-> ps th))) (-> ph (-> ps (/\ ch th))))

#  Deduction conjoining a theorem to left of consequent in an
#        implication.
stmt (jctild () ((-> ph (-> ps ch)) (-> ph th)) (-> ph (-> ps (/\ th ch))))

#  Deduction conjoining a theorem to right of consequent in an
#        implication.
stmt (jctird () ((-> ph (-> ps ch)) (-> ph th)) (-> ph (-> ps (/\ ch th))))

#  Theorem *3.43 (Comp) of [bib/WhiteheadRussell] p. 113.
stmt (pm3.43 () () (-> (/\ (-> ph ps) (-> ph ch)) (-> ph (/\ ps ch))))

#  Distributive law for conjunction.  Theorem *4.4 of [bib/WhiteheadRussell]
#      p. 118.
## <title> Distributive Property </title>
## <suggest> right('Distribute', 'L') left('Distribute', '-L') </suggest>
stmt (andi () () (<-> (/\ ph (\/ ps ch)) (\/ (/\ ph ps) (/\ ph ch))))

#  Distributive law for conjunction.
## <title> Distributive Property </title>
## <suggest> right('Distribute', 'R') left('Distribute', '-R') </suggest>
stmt (andir () () (<-> (/\ (\/ ph ps) ch) (\/ (/\ ph ch) (/\ ps ch))))

#  Double distributive law for disjunction.
stmt (orddi () () (<-> (\/ (/\ ph ps) (/\ ch th)) (/\ (/\ (\/ ph ch) (\/ ph th)) (/\ (\/ ps ch) (\/ ps th)))))

#  Double distributive law for conjunction.
stmt (anddi () () (<-> (/\ (\/ ph ps) (\/ ch th)) (\/ (\/ (/\ ph ch) (/\ ph th)) (\/ (/\ ps ch) (/\ ps th)))))

#  Inference adding a biconditional to the left in an equivalence.
## <title> Equivalence over Equivalence </title>
## <table>
##   (<->        [ ph ]   [        [ ps)
##   (<-> (-> ch [ ph ] ) [ (-> ch [ ps))
## </table>
stmt (bibi2i () ((<-> ph ps)) (<-> (<-> ch ph) (<-> ch ps)))

#  Inference adding a biconditional to the right in an equivalence.
## <table>
##   (<->      ph ]     ]      [ ps ] )
##   (<-> (<-> ph ] ch) ] (<-> [ ps ] ch))
## </table>
stmt (bibi1i () ((<-> ph ps)) (<-> (<-> ph ch) (<-> ps ch)))

#  The equivalence of two equivalences.
stmt (bibi12i () ((<-> ph ps) (<-> ch th)) (<-> (<-> ph ch) (<-> ps th)))

#  Deduction negating both sides of a logical equivalence.
stmt (notbid () ((-> ph (<-> ps ch))) (-> ph (<-> (-. ps) (-. ch))))

#  Deduction adding an antecedent to both sides of a logical
#        equivalence.
stmt (imbi2d () ((-> ph (<-> ps ch))) (-> ph (<-> (-> th ps) (-> th ch))))

#  Deduction adding a consequent to both sides of a logical equivalence.
stmt (imbi1d () ((-> ph (<-> ps ch))) (-> ph (<-> (-> ps th) (-> ch th))))

#  Deduction adding a left disjunct to both sides of a logical
#        equivalence.
stmt (orbi2d () ((-> ph (<-> ps ch))) (-> ph (<-> (\/ th ps) (\/ th ch))))

#  Deduction adding a right disjunct to both sides of a logical
#        equivalence.
stmt (orbi1d () ((-> ph (<-> ps ch))) (-> ph (<-> (\/ ps th) (\/ ch th))))

#  Deduction adding a left conjunct to both sides of a logical
#        equivalence.
stmt (anbi2d () ((-> ph (<-> ps ch))) (-> ph (<-> (/\ th ps) (/\ th ch))))

#  Deduction adding a right conjunct to both sides of a logical
#        equivalence.
stmt (anbi1d () ((-> ph (<-> ps ch))) (-> ph (<-> (/\ ps th) (/\ ch th))))

#  Deduction adding a biconditional to the left in an equivalence.
stmt (bibi2d () ((-> ph (<-> ps ch))) (-> ph (<-> (<-> th ps) (<-> th ch))))

#  Deduction adding a biconditional to the right in an equivalence.
stmt (bibi1d () ((-> ph (<-> ps ch))) (-> ph (<-> (<-> ps th) (<-> ch th))))

#  Theorem *4.37 of [bib/WhiteheadRussell] p. 118.
stmt (orbi1 () () (-> (<-> ph ps) (<-> (\/ ph ch) (\/ ps ch))))

#  Theorem *4.36 of [bib/WhiteheadRussell] p. 118.
stmt (anbi1 () () (-> (<-> ph ps) (<-> (/\ ph ch) (/\ ps ch))))

stmt (anbi2 () () (-> (<-> ph ps) (<-> (/\ ch ph) (/\ ch ps))))

#  Theorem *4.22 of [bib/WhiteheadRussell] p. 117.
## <title> Transitive Property </title>
## <suggest> right('Simplify', '↔') </suggest>
stmt (bitr () () (-> (/\ (<-> ph ps) (<-> ps ch)) (<-> ph ch)))

#  Theorem *4.84 of [bib/WhiteheadRussell] p. 122.
stmt (imbi1 () () (-> (<-> ph ps) (<-> (-> ph ch) (-> ps ch))))

#  Theorem *4.85 of [bib/WhiteheadRussell] p. 122.
stmt (imbi2 () () (-> (<-> ph ps) (<-> (-> ch ph) (-> ch ps))))

#  Theorem *4.86 of [bib/WhiteheadRussell] p. 122.
stmt (bibi1 () () (-> (<-> ph ps) (<-> (<-> ph ch) (<-> ps ch))))

#  Deduction joining two equivalences to form equivalence of
#        implications.
stmt (imbi12d () ((-> ph (<-> ps ch)) (-> ph (<-> th ta))) (-> ph (<-> (-> ps th) (-> ch ta))))

#  Deduction joining two equivalences to form equivalence of
#        disjunctions.
stmt (orbi12d () ((-> ph (<-> ps ch)) (-> ph (<-> th ta))) (-> ph (<-> (\/ ps th) (\/ ch ta))))

#  Deduction joining two equivalences to form equivalence of
#        conjunctions.
## <table>
##   (-> ph (<->     ps ] ]     ]     ch ] ]    ] ))
##   (-> ph (<->        [ [ th  ]        [ [ ta ] ))
##   (-> ph (<-> (/\ ps ] [ th) ] (/\ ch ] [ ta ] )))
## </table>
stmt (anbi12d () ((-> ph (<-> ps ch)) (-> ph (<-> th ta))) (-> ph (<-> (/\ ps th) (/\ ch ta))))

#  Deduction joining two equivalences to form equivalence of
#        biconditionals.
stmt (bibi12d () ((-> ph (<-> ps ch)) (-> ph (<-> th ta))) (-> ph (<-> (<-> ps th) (<-> ch ta))))

#  Theorem *4.39 of [bib/WhiteheadRussell] p. 118.
stmt (pm4.39 () () (-> (/\ (<-> ph ch) (<-> ps th)) (<-> (\/ ph ps) (\/ ch th))))

#  Theorem *4.38 of [bib/WhiteheadRussell] p. 118.
## <suggest> right('Infer', '∧↔∧') </suggest>
stmt (pm4.38 () () (-> (/\ (<-> ph ch) (<-> ps th)) (<-> (/\ ph ps) (/\ ch th))))

#  Deduction joining two equivalences to form equivalence of
#        conjunctions.
stmt (bi2anan9 () ((-> ph (<-> ps ch)) (-> th (<-> ta et))) (-> (/\ ph th) (<-> (/\ ps ta) (/\ ch et))))

#  Deduction joining two equivalences to form equivalence of
#        conjunctions.
stmt (bi2anan9r () ((-> ph (<-> ps ch)) (-> th (<-> ta et))) (-> (/\ th ph) (<-> (/\ ps ta) (/\ ch et))))

#  Deduction joining two biconditionals with different antecedents.
stmt (bi2bian9 () ((-> ph (<-> ps ch)) (-> th (<-> ta et))) (-> (/\ ph th) (<-> (<-> ps ta) (<-> ch et))))

#  Implication in terms of biconditional and conjunction.  Theorem *4.71 of
#      [bib/WhiteheadRussell] p. 120.
stmt (pm4.71 () () (<-> (-> ph ps) (<-> ph (/\ ph ps))))

#  Implication in terms of biconditional and conjunction.  Theorem *4.71 of
#      [bib/WhiteheadRussell] p. 120 (with conjunct reversed).
stmt (pm4.71r () () (<-> (-> ph ps) (<-> ph (/\ ps ph))))

#  Inference converting an implication to a biconditional with conjunction.
#        Inference from Theorem *4.71 of [bib/WhiteheadRussell] p. 120.
stmt (pm4.71i () ((-> ph ps)) (<-> ph (/\ ph ps)))

#  Inference converting an implication to a biconditional with conjunction.
#        Inference from Theorem *4.71 of [bib/WhiteheadRussell] p. 120 (with
#        conjunct reversed).
stmt (pm4.71ri () ((-> ph ps)) (<-> ph (/\ ps ph)))

#  Deduction converting an implication to a biconditional with conjunction.
#        Deduction from Theorem *4.71 of [bib/WhiteheadRussell] p. 120.
stmt (pm4.71rd () ((-> ph (-> ps ch))) (-> ph (<-> ps (/\ ch ps))))

#  Theorem *4.45 of [bib/WhiteheadRussell] p. 119.
stmt (pm4.45 () () (<-> ph (/\ ph (\/ ph ps))))

#  Implication in terms of biconditional and disjunction.  Theorem *4.72 of
#      [bib/WhiteheadRussell] p. 121.
stmt (pm4.72 () () (<-> (-> ph ps) (<-> ps (\/ ph ps))))

#  Introduction of antecedent as conjunct.  Theorem *4.73 of
#      [bib/WhiteheadRussell] p. 121.
stmt (iba () () (-> ph (<-> ps (/\ ps ph))))

#  Introduction of antecedent as conjunct.
stmt (ibar () () (-> ph (<-> ps (/\ ph ps))))

#  Distribution of implication over biconditional.  Theorem *5.32 of
#      [bib/WhiteheadRussell] p. 125.
stmt (pm5.32 () () (<-> (-> ph (<-> ps ch)) (<-> (/\ ph ps) (/\ ph ch))))

#  Distribution of implication over biconditional (inference rule).
stmt (pm5.32i () ((-> ph (<-> ps ch))) (<-> (/\ ph ps) (/\ ph ch)))

#  Distribution of implication over biconditional (inference rule).
stmt (pm5.32ri () ((-> ph (<-> ps ch))) (<-> (/\ ps ph) (/\ ch ph)))

#  Distribution of implication over biconditional (deduction rule).
stmt (pm5.32d () ((-> ph (-> ps (<-> ch th)))) (-> ph (<-> (/\ ps ch) (/\ ps th))))

#  Distribution of implication over biconditional (deduction rule).
stmt (pm5.32rd () ((-> ph (-> ps (<-> ch th)))) (-> ph (<-> (/\ ch ps) (/\ th ps))))

#  Distribution of implication over biconditional (deduction rule).
stmt (pm5.32da () ((-> (/\ ph ps) (<-> ch th))) (-> ph (<-> (/\ ps ch) (/\ ps th))))

#  Theorem *5.33 of [bib/WhiteheadRussell] p. 125.
stmt (pm5.33 () () (<-> (/\ ph (-> ps ch)) (/\ ph (-> (/\ ph ps) ch))))

#  Theorem *5.36 of [bib/WhiteheadRussell] p. 125.
stmt (pm5.36 () () (<-> (/\ ph (<-> ph ps)) (/\ ps (<-> ph ps))))

#  Theorem *5.42 of [bib/WhiteheadRussell] p. 125.
stmt (pm5.42 () () (<-> (-> ph (-> ps ch)) (-> ph (-> ps (/\ ph ch)))))

#  Absorb a hypothesis into the second member of a biconditional.
#        (Contributed by FL, 15-Feb-2007.)
stmt (bianabs () ((-> ph (<-> ps (/\ ph ch)))) (-> ph (<-> ps ch)))

#  Absorption of disjunction into equivalence.
stmt (oibabs () () (<-> (-> (\/ ph ps) (<-> ph ps)) (<-> ph ps)))

#  Law of excluded middle, also called the principle of //tertium non datur//.
#      Theorem *2.11 of [bib/WhiteheadRussell] p. 101.  It says that something is
#      either true or not true; there are no in-between values of truth.  This is
#      an essential distinction of our classical logic and is not a theorem of
#      intuitionistic logic.
stmt (exmid () () (\/ ph (-. ph)))

#  Theorem *2.1 of [bib/WhiteheadRussell] p. 101.
stmt (pm2.1 () () (\/ (-. ph) ph))

#  Theorem *2.13 of [bib/WhiteheadRussell] p. 101.
stmt (pm2.13 () () (\/ ph (-. (-. (-. ph)))))

#  Law of noncontradiction.  Theorem *3.24 of [bib/WhiteheadRussell] p. 111
#      (who call it the "law of contradiction").
## <title> Law of Noncontradiction </title>
## <suggest> full('Simplify', 'F') </suggest>
stmt (pm3.24 () () (-. (/\ ph (-. ph))))

#  Theorem *2.26 of [bib/WhiteheadRussell] p. 104.
stmt (pm2.26 () () (\/ (-. ph) (-> (-> ph ps) ps)))

#  Theorem *5.18 of [bib/WhiteheadRussell] p. 124.  This theorem says that
#      logical equivalence is the same as negated "exclusive-or."
stmt (pm5.18 () () (<-> (<-> ph ps) (-. (<-> ph (-. ps)))))

#  Move negation outside of biconditional.  Compare Theorem *5.18 of
#      [bib/WhiteheadRussell] p. 124.
stmt (nbbn () () (<-> (<-> (-. ph) ps) (-. (<-> ph ps))))

#  Theorem *5.11 of [bib/WhiteheadRussell] p. 123.
stmt (pm5.11 () () (\/ (-> ph ps) (-> (-. ph) ps)))

#  Theorem *5.12 of [bib/WhiteheadRussell] p. 123.
stmt (pm5.12 () () (\/ (-> ph ps) (-> ph (-. ps))))

#  Theorem *5.13 of [bib/WhiteheadRussell] p. 123.
stmt (pm5.13 () () (\/ (-> ph ps) (-> ps ph)))

#  Theorem *5.14 of [bib/WhiteheadRussell] p. 123.
stmt (pm5.14 () () (\/ (-> ph ps) (-> ps ch)))

#  Theorem *5.15 of [bib/WhiteheadRussell] p. 124.
stmt (pm5.15 () () (\/ (<-> ph ps) (<-> ph (-. ps))))

#  Theorem *5.16 of [bib/WhiteheadRussell] p. 124.
stmt (pm5.16 () () (-. (/\ (<-> ph ps) (<-> ph (-. ps)))))

#  Theorem *5.17 of [bib/WhiteheadRussell] p. 124.
stmt (pm5.17 () () (<-> (/\ (\/ ph ps) (-. (/\ ph ps))) (<-> ph (-. ps))))

#  Theorem *5.19 of [bib/WhiteheadRussell] p. 124.
stmt (pm5.19 () () (-. (<-> ph (-. ph))))

#  An alternate definition of the biconditional.  Theorem *5.23 of
#      [bib/WhiteheadRussell] p. 124.
stmt (dfbi3 () () (<-> (<-> ph ps) (\/ (/\ ph ps) (/\ (-. ph) (-. ps)))))

#  Two ways to express "exclusive or."  Theorem *5.22 of [bib/WhiteheadRussell]
#      p. 124.
stmt (xor () () (<-> (-. (<-> ph ps)) (\/ (/\ ph (-. ps)) (/\ ps (-. ph)))))

#  Theorem *5.24 of [bib/WhiteheadRussell] p. 124.
stmt (pm5.24 () () (<-> (-. (\/ (/\ ph ps) (/\ (-. ph) (-. ps)))) (\/ (/\ ph (-. ps)) (/\ ps (-. ph)))))

#  Two ways to express "exclusive or."
stmt (xor2 () () (<-> (-. (<-> ph ps)) (/\ (\/ ph ps) (-. (/\ ph ps)))))

#  Two ways to express "exclusive or."
stmt (xor3 () () (<-> (-. (<-> ph ps)) (<-> ph (-. ps))))

#  Conjunction distributes over exclusive-or, using #(-. (<-> ph ps))#
#      to express exclusive-or.  This is one way to interpret the distributive
#      law of multiplication over addition in modulo 2 arithmetic.
stmt (xordi () () (<-> (/\ ph (-. (<-> ps ch))) (-. (<-> (/\ ph ps) (/\ ph ch)))))

#  Theorem *5.55 of [bib/WhiteheadRussell] p. 125.
stmt (pm5.55 () () (\/ (<-> (\/ ph ps) ph) (<-> (\/ ph ps) ps)))

#  Two propositions are equivalent if they are both true.  Theorem *5.1 of
#      [bib/WhiteheadRussell] p. 123.
stmt (pm5.1 () () (-> (/\ ph ps) (<-> ph ps)))

#  Two propositions are equivalent if they are both false.  Theorem *5.21 of
#      [bib/WhiteheadRussell] p. 124.
stmt (pm5.21 () () (-> (/\ (-. ph) (-. ps)) (<-> ph ps)))

#  Two propositions implying a false one are equivalent.
stmt (pm5.21ni () ((-> ph ps) (-> ch ps)) (-> (-. ps) (<-> ph ch)))

#  Eliminate an antecedent implied by each side of a biconditional.
stmt (pm5.21nii () ((-> ph ps) (-> ch ps) (-> ps (<-> ph ch))) (<-> ph ch))

#  Eliminate an antecedent implied by each side of a biconditional.
stmt (pm5.21nd () ((-> (/\ ph ps) th) (-> (/\ ph ch) th) (-> th (<-> ps ch))) (-> ph (<-> ps ch)))

#  Transfer negation via an equivalence.
stmt (bibif () () (-> (-. ps) (<-> (<-> ph ps) (-. ph))))

#  Theorem *5.35 of [bib/WhiteheadRussell] p. 125.
stmt (pm5.35 () () (-> (/\ (-> ph ps) (-> ph ch)) (-> ph (<-> ps ch))))

#  Theorem *5.54 of [bib/WhiteheadRussell] p. 125.
stmt (pm5.54 () () (\/ (<-> (/\ ph ps) ph) (<-> (/\ ph ps) ps)))

#  Elimination of antecedents in an implication. (The proof was shortened by
#      Juha Arpiainen, 19-Jan-2006.)
stmt (elimant () () (-> (/\ (-> ph ps) (-> (-> ps ch) (-> ph th))) (-> ph (-> ch th))))

#  Move conjunction outside of biconditional.
stmt (baib () ((<-> ph (/\ ps ch))) (-> ps (<-> ph ch)))

#  Move conjunction outside of biconditional.
stmt (baibr () ((<-> ph (/\ ps ch))) (-> ps (<-> ch ph)))

#  Theorem *5.44 of [bib/WhiteheadRussell] p. 125.
stmt (pm5.44 () () (-> (-> ph ps) (<-> (-> ph ch) (-> ph (/\ ps ch)))))

#  Conjunction in antecedent versus disjunction in consequent.  Theorem *5.6
#      of [bib/WhiteheadRussell] p. 125.
stmt (pm5.6 () () (<-> (-> (/\ ph (-. ps)) ch) (-> ph (\/ ps ch))))

#  Theorem to move a conjunct in and out of a negation.
stmt (nan () () (<-> (-> ph (-. (/\ ps ch))) (-> (/\ ph ps) (-. ch))))

#  Change disjunction in consequent to conjunction in antecedent.
stmt (orcanai () ((-> ph (\/ ps ch))) (-> (/\ ph (-. ps)) ch))

#  Introduction of conjunct inside of a contradiction.
stmt (intnan () ((-. ph)) (-. (/\ ps ph)))

#  Introduction of conjunct inside of a contradiction.
stmt (intnanr () ((-. ph)) (-. (/\ ph ps)))

#  Introduction of conjunct inside of a contradiction.
stmt (intnand () ((-> ph (-. ps))) (-> ph (-. (/\ ch ps))))

#  Introduction of conjunct inside of a contradiction.
stmt (intnanrd () ((-> ph (-. ps))) (-> ph (-. (/\ ps ch))))

#  An inference based on modus ponens.
## <title> Modus Ponens </title>
stmt (mpan () (ph (-> (/\ ph ps) ch)) (-> ps ch))

#  An inference based on modus ponens.
## <title> Modus Ponens </title>
## <table>
##              [ <r> ps ]
##   (-> (/\ ph [ <r> ps ] ) ch)
##   (->     ph ]        ]   ch)
## </table>
stmt (mpan2 () (ps (-> (/\ ph ps) ch)) (-> ph ch))

#  An inference based on modus ponens.
## <title> Modus Ponens </title>
## <table>
##           ph ] ]    ]   ]
##              [ [ ps ]   ]
##   (-> (/\ ph ] [ ps ] ) [ ch)
##              [ [    [   [ ch
## </table>
stmt (mp2an () (ph ps (-> (/\ ph ps) ch)) ch)

#  An inference based on modus ponens.
## <title> Modus Ponens </title>
stmt (mpani () (ps (-> ph (-> (/\ ps ch) th))) (-> ph (-> ch th)))

#  An inference based on modus ponens.
## <title> Modus Ponens </title>
stmt (mpan2i () (ch (-> ph (-> (/\ ps ch) th))) (-> ph (-> ps th)))

#  An inference based on modus ponens.
## <title> Modus Ponens </title>
stmt (mp2ani () (ps ch (-> ph (-> (/\ ps ch) th))) (-> ph th))

#  A deduction based on modus ponens.
## <title> Modus Ponens </title>
stmt (mpand () ((-> ph ps) (-> ph (-> (/\ ps ch) th))) (-> ph (-> ch th)))

#  A deduction based on modus ponens.
## <title> Modus Ponens </title>
stmt (mpan2d () ((-> ph ch) (-> ph (-> (/\ ps ch) th))) (-> ph (-> ps th)))

#  A deduction based on modus ponens.
## <title> Modus Ponens </title>
stmt (mp2and () ((-> ph ps) (-> ph ch) (-> ph (-> (/\ ps ch) th))) (-> ph th))

#  An inference based on modus ponens.
## <title> Modus Ponens </title>
stmt (mpdan () ((-> ph ps) (-> (/\ ph ps) ch)) (-> ph ch))

#  An inference based on modus ponens with commutation of antecedents.
## <title> Modus Ponens </title>
stmt (mpancom () ((-> ps ph) (-> (/\ ph ps) ch)) (-> ps ch))

#  An inference based on modus ponens.
## <title> Modus Ponens </title>
stmt (mpanl1 () (ph (-> (/\ (/\ ph ps) ch) th)) (-> (/\ ps ch) th))

#  An inference based on modus ponens.
## <title> Modus Ponens </title>
stmt (mpanl2 () (ps (-> (/\ (/\ ph ps) ch) th)) (-> (/\ ph ch) th))

#  An inference based on modus ponens.
## <title> Modus Ponens </title>
stmt (mpanl12 () (ph ps (-> (/\ (/\ ph ps) ch) th)) (-> ch th))

#  An inference based on modus ponens.
## <title> Modus Ponens </title>
stmt (mpanr1 () (ps (-> (/\ ph (/\ ps ch)) th)) (-> (/\ ph ch) th))

#  An inference based on modus ponens.
## <title> Modus Ponens </title>
stmt (mpanr2 () (ch (-> (/\ ph (/\ ps ch)) th)) (-> (/\ ph ps) th))

#  An inference based on modus ponens.
## <title> Modus Ponens </title>
stmt (mpanr12 () (ps ch (-> (/\ ph (/\ ps ch)) th)) (-> ph th))

#  An inference based on modus ponens.
## <title> Modus Ponens </title>
stmt (mpanlr1 () (ps (-> (/\ (/\ ph (/\ ps ch)) th) ta)) (-> (/\ (/\ ph ch) th) ta))

#  Modus-tollens-like theorem.
## <title> Modus Tollens </title>
stmt (mtt () () (-> (-. ph) (<-> (-. ps) (-> ps ph))))

#  A false consequent falsifies an antecedent.
stmt (mt2bi () (ph) (<-> (-. ps) (-> ps (-. ph))))

#  A deduction from a biconditional, similar to modus tollens.
## <title> Modus Tollens </title>
stmt (mtbid () ((-> ph (-. ps)) (-> ph (<-> ps ch))) (-> ph (-. ch)))

#  A deduction from a biconditional, similar to modus tollens.
## <title> Modus Tollens </title>
stmt (mtbird () ((-> ph (-. ch)) (-> ph (<-> ps ch))) (-> ph (-. ps)))

#  An inference from a biconditional, similar to modus tollens.
## <title> Modus Tollens </title>
stmt (mtbii () ((-. ps) (-> ph (<-> ps ch))) (-> ph (-. ch)))

#  An inference from a biconditional, similar to modus tollens.
## <title> Modus Tollens </title>
## <table>
##                  [ [ (-. [ ch)
##   (-> ph (<-> ps ] [     [ ch))
##   (-> ph  (-. ps ] ]     ]   ))
## </table>
stmt (mtbiri () ((-. ch) (-> ph (<-> ps ch))) (-> ph (-. ps)))

#  Two truths are equivalent.
stmt (2th () (ph ps) (<-> ph ps))

#  Two falsehoods are equivalent.
stmt (2false () ((-. ph) (-. ps)) (<-> ph ps))

#  A wff is equivalent to its equivalence with truth. (The proof was
#        shortened by Juha Arpiainen, 19-Jan-2006.)
stmt (tbt () (ph) (<-> ps (<-> ps ph)))

#  The negation of a wff is equivalent to the wff's equivalence to
#      falsehood.  (Contributed by Juha Arpiainen, 19-Jan-2006.)
stmt (nbn2 () () (-> (-. ph) (<-> (-. ps) (<-> ph ps))))

#  The negation of a wff is equivalent to the wff's equivalence to
#        falsehood.
stmt (nbn () ((-. ph)) (<-> (-. ps) (<-> ps ph)))

#  Transfer falsehood via equivalence.
stmt (nbn3 () (ph) (<-> (-. ps) (<-> ps (-. ph))))

#  A wff is equivalent to its conjunction with truth.
stmt (biantru () (ph) (<-> ps (/\ ps ph)))

#  A wff is equivalent to its conjunction with truth.
stmt (biantrur () (ph) (<-> ps (/\ ph ps)))

#  A wff is equivalent to its conjunction with truth.
stmt (biantrud () ((-> ph ps)) (-> ph (<-> ch (/\ ch ps))))

#  A wff is equivalent to its conjunction with truth.
stmt (biantrurd () ((-> ph ps)) (-> ph (<-> ch (/\ ps ch))))

#  Detach truth from conjunction in biconditional.
stmt (mpbiran () ((<-> ph (/\ ps ch)) ps) (<-> ph ch))

#  Detach truth from conjunction in biconditional.
stmt (mpbiran2 () ((<-> ph (/\ ps ch)) ch) (<-> ph ps))

#  Detach a conjunction of truths in a biconditional.
stmt (mpbir2an () ((<-> ph (/\ ps ch)) ps ch) ph)

#  A wff is equivalent to itself with true antecedent.
stmt (biimt () () (-> ph (<-> ps (-> ph ps))))

#  Theorem *5.5 of [bib/WhiteheadRussell] p. 125.
stmt (pm5.5 () () (-> ph (<-> (-> ph ps) ps)))

#  Theorem *5.62 of [bib/WhiteheadRussell] p. 125.  (Contributed by Roy F.
#      Longton, 21-Jun-2005.)
stmt (pm5.62 () () (<-> (\/ (/\ ph ps) (-. ps)) (\/ ph (-. ps))))

#  A wff is disjoined with truth is true.
stmt (biort () () (-> ph (<-> ph (\/ ph ps))))

#  A wff is equivalent to its disjunction with falsehood.  Theorem *4.74 of
#      [bib/WhiteheadRussell] p. 121.
stmt (biorf () () (-> (-. ph) (<-> ps (\/ ph ps))))

#  A wff is equivalent to its disjunction with falsehood.
stmt (biorfi () ((-. ph)) (<-> ps (\/ ps ph)))

#  A wff conjoined with falsehood is false.
stmt (bianfi () ((-. ph)) (<-> ph (/\ ps ph)))

#  A wff conjoined with falsehood is false.
stmt (bianfd () ((-> ph (-. ps))) (-> ph (<-> ps (/\ ps ch))))

#  Theorem *4.82 of [bib/WhiteheadRussell] p. 122.
stmt (pm4.82 () () (<-> (/\ (-> ph ps) (-> ph (-. ps))) (-. ph)))

#  Theorem *4.83 of [bib/WhiteheadRussell] p. 122.
stmt (pm4.83 () () (<-> (/\ (-> ph ps) (-> (-. ph) ps)) ps))

#  Negation inferred from embedded conjunct.
stmt (pclem6 () () (-> (<-> ph (/\ ps (-. ph))) (-. ps)))

#  A transitive law of equivalence.  Compare Theorem *4.22 of
#      [bib/WhiteheadRussell] p. 117.
stmt (biantr () () (-> (/\ (<-> ph ps) (<-> ch ps)) (<-> ph ch)))

#  Disjunction distributes over the biconditional.  An axiom of system DS in
#      Vladimir Lifschitz, "On calculational proofs" (1998),
#      [[http://citeseer.ist.psu.edu/lifschitz98calculational.html]].
stmt (orbidi () () (<-> (\/ ph (<-> ps ch)) (<-> (\/ ph ps) (\/ ph ch))))

#  Associative law for the biconditional.  An axiom of system DS in Vladimir
#      Lifschitz, "On calculational proofs" (1998),
#      [[http://citeseer.ist.psu.edu/lifschitz98calculational.html]].
#      Interestingly, this law was not included in //Principia Mathematica// but
#      was apparently first noted by Jan Lukasiewicz circa 1923.  (The proof was
#      shortened by Juha Arpiainen, 19-Jan-2006.)
## <title> Associative Property </title>
## <suggest> right('Associate', 'R') left('Associate', 'L') </suggest>
stmt (biass () () (<-> (<-> (<-> ph ps) ch) (<-> ph (<-> ps ch))))

#  Lukasiewicz's shortest axiom for equivalential calculus.  Storrs McCall,
#      ed., //Polish Logic 1920-1939// (Oxford, 1967), p. 96.
stmt (biluk () () (<-> (<-> ph ps) (<-> (<-> ch ps) (<-> ph ch))))

#  Disjunction distributes over the biconditional.  Theorem *5.7 of
#      [bib/WhiteheadRussell] p. 125.  This theorem is similar to [[orbidi]].
#      (Contributed by Roy F. Longton, 21-Jun-2005.)
stmt (pm5.7 () () (<-> (<-> (\/ ph ch) (\/ ps ch)) (\/ ch (<-> ph ps))))

#  Dijkstra-Scholten's Golden Rule for calculational proofs.
stmt (bigolden () () (<-> (<-> (/\ ph ps) ph) (<-> ps (\/ ph ps))))

#  Theorem *5.71 of [bib/WhiteheadRussell] p. 125.  (Contributed by Roy F.
#      Longton, 23-Jun-2005.)
stmt (pm5.71 () () (-> (-> ps (-. ch)) (<-> (/\ (\/ ph ps) ch) (/\ ph ch))))

#  Theorem *5.75 of [bib/WhiteheadRussell] p. 126.
stmt (pm5.75 () () (-> (/\ (-> ch (-. ps)) (<-> ph (\/ ps ch))) (<-> (/\ ph (-. ps)) ch)))

#  Removal of conjunct from one side of an equivalence.
stmt (bimsc1 () () (-> (/\ (-> ph ps) (<-> ch (/\ ps ph))) (<-> ch ph)))

#  Deduction for elimination by cases.
stmt (ecase2d () ((-> ph ps) (-> ph (-. (/\ ps ch))) (-> ph (-. (/\ ps th))) (-> ph (\/ ta (\/ ch th)))) (-> ph ta))

#  Inference for elimination by cases.
stmt (ecase3 () ((-> ph ch) (-> ps ch) (-> (-. (\/ ph ps)) ch)) ch)

#  Inference for elimination by cases.
stmt (ecase () ((-> (-. ph) ch) (-> (-. ps) ch) (-> (/\ ph ps) ch)) ch)

#  Deduction for elimination by cases.
stmt (ecase3d () ((-> ph (-> ps th)) (-> ph (-> ch th)) (-> ph (-> (-. (\/ ps ch)) th))) (-> ph th))

#  Inference for combining cases.
stmt (ccase () ((-> (/\ ph ps) ta) (-> (/\ ch ps) ta) (-> (/\ ph th) ta) (-> (/\ ch th) ta)) (-> (/\ (\/ ph ch) (\/ ps th)) ta))

#  Deduction for combining cases.
stmt (ccased () ((-> ph (-> (/\ ps ch) et)) (-> ph (-> (/\ th ch) et)) (-> ph (-> (/\ ps ta) et)) (-> ph (-> (/\ th ta) et))) (-> ph (-> (/\ (\/ ps th) (\/ ch ta)) et)))

#  Inference for combining cases.
stmt (ccase2 () ((-> (/\ ph ps) ta) (-> ch ta) (-> th ta)) (-> (/\ (\/ ph ch) (\/ ps th)) ta))

#  Inference eliminating two antecedents from the four possible cases that
#        result from their true/false combinations.
stmt (4cases () ((-> (/\ ph ps) ch) (-> (/\ ph (-. ps)) ch) (-> (/\ (-. ph) ps) ch) (-> (/\ (-. ph) (-. ps)) ch)) ch)

#  Miscellaneous inference relating falsehoods.
stmt (niabn () (ph) (-> (-. ps) (<-> (/\ ch ps) (-. ph))))

#  Lemma for an alternate version of weak deduction theorem.
stmt (dedlem0a () () (-> ph (<-> ps (-> (-> ch ph) (/\ ps ph)))))

#  Lemma for an alternate version of weak deduction theorem.
stmt (dedlem0b () () (-> (-. ph) (<-> ps (-> (-> ps ph) (/\ ch ph)))))

#  Lemma for weak deduction theorem.
stmt (dedlema () () (-> ph (<-> ps (\/ (/\ ps ph) (/\ ch (-. ph))))))

#  Lemma for weak deduction theorem.
stmt (dedlemb () () (-> (-. ph) (<-> ch (\/ (/\ ps ph) (/\ ch (-. ph))))))

#  Hypothesis builder for weak deduction theorem.  For more information,
#        see the Deduction Theorem link on the Metamath Proof Explorer home
#        page.
stmt (elimh () ((-> (<-> ph (\/ (/\ ph ch) (/\ ps (-. ch)))) (<-> ch ta)) (-> (<-> ps (\/ (/\ ph ch) (/\ ps (-. ch)))) (<-> th ta)) th) ta)

#  The weak deduction theorem.  For more information, see the Deduction
#        Theorem link on the Metamath Proof Explorer home page.
stmt (dedt () ((-> (<-> ph (\/ (/\ ph ch) (/\ ps (-. ch)))) (<-> th ta)) ta) (-> ch th))

#  Contraposition.  Theorem *2.16 of [bib/WhiteheadRussell] p. 103.  This version
#      of [[con3]] demonstrates the use of the weak deduction theorem to derive
#      it from [[con3i]].
stmt (con3th () () (-> (-> ph ps) (-> (-. ps) (-. ph))))

#  The consensus theorem.  This theorem and its dual (with {{{\/}}} and {{{/\}}}
#      interchanged) are commonly used in computer logic design to eliminate
#      redundant terms from Boolean expressions.  Specifically, we prove that the
#      term #(/\ ps ch)# on the left-hand side is redundant.
stmt (consensus () () (<-> (\/ (\/ (/\ ph ps) (/\ (-. ph) ch)) (/\ ps ch)) (\/ (/\ ph ps) (/\ (-. ph) ch))))

#  Theorem *4.42 of [bib/WhiteheadRussell] p. 119.  (Contributed by Roy F.
#      Longton, 21-Jun-2005.)
stmt (pm4.42 () () (<-> ph (\/ (/\ ph ps) (/\ ph (-. ps)))))

#  Miscellaneous inference relating falsehoods.
stmt (ninba () (ph) (-> (-. ps) (<-> (-. ph) (/\ ch ps))))

#  A specialized lemma for set theory (to derive the Axiom of Pairing).
stmt (prlem1 () ((-> ph (<-> et ch)) (-> ps (-. th))) (-> ph (-> ps (-> (\/ (/\ ps ch) (/\ th ta)) et))))

#  A specialized lemma for set theory (to derive the Axiom of Pairing).
stmt (prlem2 () () (<-> (\/ (/\ ph ps) (/\ ch th)) (/\ (\/ ph ch) (\/ (/\ ph ps) (/\ ch th)))))

#  A specialized lemma for set theory (ordered pair theorem).
stmt (oplem1 () ((-> ph (\/ ps ch)) (-> ph (\/ th ta)) (<-> ps th) (-> ch (<-> th ta))) (-> ph ps))

#  Lemma used in construction of real numbers.
stmt (rnlem () () (<-> (/\ (/\ ph ps) (/\ ch th)) (/\ (/\ (/\ ph ch) (/\ ps th)) (/\ (/\ ph th) (/\ ps ch)))))

#  A single axiom for Boolean algebra known as DN_1.  See
#      [[http://www-unix.mcs.anl.gov/~mccune/papers/basax/v12.pdf]].
#      (Contributed by Jeffrey Hankins, 3-Jul-2009.)
stmt (dn1 () () (<-> (-. (\/ (-. (\/ (-. (\/ ph ps)) ch)) (-. (\/ ph (-. (\/ (-. ch) (-. (\/ ch th)))))))) ch))
term (wff (\/\/ ph ps ch))
term (wff (/\/\ ph ps ch))

#  Define disjunction ('or') of 3 wff's.  Definition *2.33 of
#      [bib/WhiteheadRussell] p. 105.  This abbreviation reduces the number of
#      parentheses and emphasizes that the order of bracketing is not
#      important by virtue of the associative law [[orass]].
stmt (df-3or () () (<-> (\/\/ ph ps ch) (\/ (\/ ph ps) ch)))

#  Define conjunction ('and') of 3 wff.s.  Definition *4.34 of
#      [bib/WhiteheadRussell] p. 118.  This abbreviation reduces the number of
#      parentheses and emphasizes that the order of bracketing is not
#      important by virtue of the associative law [[anass]].
stmt (df-3an () () (<-> (/\/\ ph ps ch) (/\ (/\ ph ps) ch)))

#  Associative law for triple disjunction.
stmt (3orass () () (<-> (\/\/ ph ps ch) (\/ ph (\/ ps ch))))

#  Associative law for triple conjunction.
stmt (3anass () () (<-> (/\/\ ph ps ch) (/\ ph (/\ ps ch))))

#  Rotation law for triple conjunction.
stmt (3anrot () () (<-> (/\/\ ph ps ch) (/\/\ ps ch ph)))

#  Rotation law for triple disjunction.
stmt (3orrot () () (<-> (\/\/ ph ps ch) (\/\/ ps ch ph)))

#  Commutation law for triple conjunction.
stmt (3ancoma () () (<-> (/\/\ ph ps ch) (/\/\ ps ph ch)))

#  Commutation law for triple conjunction.
stmt (3ancomb () () (<-> (/\/\ ph ps ch) (/\/\ ph ch ps)))

#  Reversal law for triple conjunction.
stmt (3anrev () () (<-> (/\/\ ph ps ch) (/\/\ ch ps ph)))

#  Simplification of triple conjunction.
stmt (3simpa () () (-> (/\/\ ph ps ch) (/\ ph ps)))

#  Simplification of triple conjunction.
stmt (3simpb () () (-> (/\/\ ph ps ch) (/\ ph ch)))

#  Simplification of triple conjunction.
stmt (3simpc () () (-> (/\/\ ph ps ch) (/\ ps ch)))

#  Simplification of triple conjunction.
stmt (3simp1 () () (-> (/\/\ ph ps ch) ph))

#  Simplification of triple conjunction.
stmt (3simp2 () () (-> (/\/\ ph ps ch) ps))

#  Simplification of triple conjunction.
stmt (3simp3 () () (-> (/\/\ ph ps ch) ch))

#  Infer a conjunct from a triple conjunction.
stmt (3simp1i () ((/\/\ ph ps ch)) ph)

#  Infer a conjunct from a triple conjunction.
stmt (3simp2i () ((/\/\ ph ps ch)) ps)

#  Infer a conjunct from a triple conjunction.
stmt (3simp3i () ((/\/\ ph ps ch)) ch)

#  Deduce a conjunct from a triple conjunction.
stmt (3simp1d () ((-> ph (/\/\ ps ch th))) (-> ph ps))

#  Deduce a conjunct from a triple conjunction.
stmt (3simp2d () ((-> ph (/\/\ ps ch th))) (-> ph ch))

#  Deduce a conjunct from a triple conjunction.
stmt (3simp3d () ((-> ph (/\/\ ps ch th))) (-> ph th))

#  Deduction adding a conjunct to antecedent.
stmt (3adant1 () ((-> (/\ ph ps) ch)) (-> (/\/\ th ph ps) ch))

#  Deduction adding a conjunct to antecedent.
stmt (3adant2 () ((-> (/\ ph ps) ch)) (-> (/\/\ ph th ps) ch))

#  Deduction adding a conjunct to antecedent.
stmt (3adant3 () ((-> (/\ ph ps) ch)) (-> (/\/\ ph ps th) ch))

#  Deduction adding conjuncts to an antecedent.
stmt (3ad2ant1 () ((-> ph ch)) (-> (/\/\ ph ps th) ch))

#  Deduction adding conjuncts to an antecedent.
stmt (3ad2ant2 () ((-> ph ch)) (-> (/\/\ ps ph th) ch))

#  Deduction adding conjuncts to an antecedent.
stmt (3ad2ant3 () ((-> ph ch)) (-> (/\/\ ps th ph) ch))

#  Deduction adding a conjunct to antecedent.
stmt (3adantl1 () ((-> (/\ (/\ ph ps) ch) th)) (-> (/\ (/\/\ ta ph ps) ch) th))

#  Deduction adding a conjunct to antecedent.
stmt (3adantl2 () ((-> (/\ (/\ ph ps) ch) th)) (-> (/\ (/\/\ ph ta ps) ch) th))

#  Deduction adding a conjunct to antecedent.
stmt (3adantl3 () ((-> (/\ (/\ ph ps) ch) th)) (-> (/\ (/\/\ ph ps ta) ch) th))

#  Deduction adding a conjunct to antecedent.
stmt (3adantr1 () ((-> (/\ ph (/\ ps ch)) th)) (-> (/\ ph (/\/\ ta ps ch)) th))

#  Deduction adding a conjunct to antecedent.
stmt (3adantr2 () ((-> (/\ ph (/\ ps ch)) th)) (-> (/\ ph (/\/\ ps ta ch)) th))

#  Deduction adding a conjunct to antecedent.
stmt (3adantr3 () ((-> (/\ ph (/\ ps ch)) th)) (-> (/\ ph (/\/\ ps ch ta)) th))

#  Deduction adding conjuncts to antecedent.
stmt (3ad2antl1 () ((-> (/\ ph ch) th)) (-> (/\ (/\/\ ph ps ta) ch) th))

#  Deduction adding conjuncts to antecedent.
stmt (3ad2antl2 () ((-> (/\ ph ch) th)) (-> (/\ (/\/\ ps ph ta) ch) th))

#  Deduction adding conjuncts to antecedent.
stmt (3ad2antl3 () ((-> (/\ ph ch) th)) (-> (/\ (/\/\ ps ta ph) ch) th))

#  Deduction adding a conjuncts to antecedent.
stmt (3ad2antr1 () ((-> (/\ ph ch) th)) (-> (/\ ph (/\/\ ch ps ta)) th))

#  Deduction adding a conjuncts to antecedent.
stmt (3ad2antr2 () ((-> (/\ ph ch) th)) (-> (/\ ph (/\/\ ps ch ta)) th))

#  Deduction adding a conjuncts to antecedent.
stmt (3ad2antr3 () ((-> (/\ ph ch) th)) (-> (/\ ph (/\/\ ps ta ch)) th))

#  Introduction in triple disjunction.
stmt (3mix1 () () (-> ph (\/\/ ph ps ch)))

#  Introduction in triple disjunction.
stmt (3mix2 () () (-> ph (\/\/ ps ph ch)))

#  Introduction in triple disjunction.
stmt (3mix3 () () (-> ph (\/\/ ps ch ph)))

#  Infer conjunction of premises.
stmt (3pm3.2i () (ph ps ch) (/\/\ ph ps ch))

#  Join consequents with conjunction.
stmt (3jca () ((-> ph ps) (-> ph ch) (-> ph th)) (-> ph (/\/\ ps ch th)))

#  Deduction conjoining the consequents of three implications.
stmt (3jcad () ((-> ph (-> ps ch)) (-> ph (-> ps th)) (-> ph (-> ps ta))) (-> ph (-> ps (/\/\ ch th ta))))

#  Join antecedents and consequents with conjunction.
stmt (3anim123i () ((-> ph ps) (-> ch th) (-> ta et)) (-> (/\/\ ph ch ta) (/\/\ ps th et)))

#  Join 3 biconditionals with conjunction.
stmt (3anbi123i () ((<-> ph ps) (<-> ch th) (<-> ta et)) (<-> (/\/\ ph ch ta) (/\/\ ps th et)))

#  Join 3 biconditionals with disjunction.
stmt (3orbi123i () ((<-> ph ps) (<-> ch th) (<-> ta et)) (<-> (\/\/ ph ch ta) (\/\/ ps th et)))

#  Inference adding two conjuncts to each side of a biconditional.
stmt (3anbi1i () ((<-> ph ps)) (<-> (/\/\ ph ch th) (/\/\ ps ch th)))

#  Inference adding two conjuncts to each side of a biconditional.
stmt (3anbi2i () ((<-> ph ps)) (<-> (/\/\ ch ph th) (/\/\ ch ps th)))

#  Inference adding two conjuncts to each side of a biconditional.
stmt (3anbi3i () ((<-> ph ps)) (<-> (/\/\ ch th ph) (/\/\ ch th ps)))

#  Importation inference.
stmt (3imp () ((-> ph (-> ps (-> ch th)))) (-> (/\/\ ph ps ch) th))

#  Importation from double to triple conjunction.
stmt (3impa () ((-> (/\ (/\ ph ps) ch) th)) (-> (/\/\ ph ps ch) th))

#  Importation from double to triple conjunction.
stmt (3impb () ((-> (/\ ph (/\ ps ch)) th)) (-> (/\/\ ph ps ch) th))

#  Importation to triple conjunction.
stmt (3impia () ((-> (/\ ph ps) (-> ch th))) (-> (/\/\ ph ps ch) th))

#  Importation to triple conjunction.
stmt (3impib () ((-> ph (-> (/\ ps ch) th))) (-> (/\/\ ph ps ch) th))

#  Exportation inference.
stmt (3exp () ((-> (/\/\ ph ps ch) th)) (-> ph (-> ps (-> ch th))))

#  Exportation from triple to double conjunction.
stmt (3expa () ((-> (/\/\ ph ps ch) th)) (-> (/\ (/\ ph ps) ch) th))

#  Exportation from triple to double conjunction.
stmt (3expb () ((-> (/\/\ ph ps ch) th)) (-> (/\ ph (/\ ps ch)) th))

#  Exportation from triple conjunction.
stmt (3expia () ((-> (/\/\ ph ps ch) th)) (-> (/\ ph ps) (-> ch th)))

#  Exportation from triple conjunction.
stmt (3expib () ((-> (/\/\ ph ps ch) th)) (-> ph (-> (/\ ps ch) th)))

#  Commutation in antecedent.  Swap 1st and 3rd.
stmt (3com12 () ((-> (/\/\ ph ps ch) th)) (-> (/\/\ ps ph ch) th))

#  Commutation in antecedent.  Swap 1st and 3rd.
stmt (3com13 () ((-> (/\/\ ph ps ch) th)) (-> (/\/\ ch ps ph) th))

#  Commutation in antecedent.  Swap 2nd and 3rd.
stmt (3com23 () ((-> (/\/\ ph ps ch) th)) (-> (/\/\ ph ch ps) th))

#  Commutation in antecedent.  Rotate left.
stmt (3coml () ((-> (/\/\ ph ps ch) th)) (-> (/\/\ ps ch ph) th))

#  Commutation in antecedent.  Rotate right.
stmt (3comr () ((-> (/\/\ ph ps ch) th)) (-> (/\/\ ch ph ps) th))

#  Deduction adding a conjunct to antecedent.
stmt (3adant3r1 () ((-> (/\/\ ph ps ch) th)) (-> (/\ ph (/\/\ ta ps ch)) th))

#  Deduction adding a conjunct to antecedent.
stmt (3adant3r2 () ((-> (/\/\ ph ps ch) th)) (-> (/\ ph (/\/\ ps ta ch)) th))

#  Deduction adding a conjunct to antecedent.
stmt (3adant3r3 () ((-> (/\/\ ph ps ch) th)) (-> (/\ ph (/\/\ ps ch ta)) th))

#  Swap conjuncts.
stmt (3an1rs () ((-> (/\ (/\/\ ph ps ch) th) ta)) (-> (/\ (/\/\ ph ps th) ch) ta))

#  Importation to left triple conjunction.
stmt (3imp1 () ((-> ph (-> ps (-> ch (-> th ta))))) (-> (/\ (/\/\ ph ps ch) th) ta))

#  Importation deduction for triple conjunction.
stmt (3impd () ((-> ph (-> ps (-> ch (-> th ta))))) (-> ph (-> (/\/\ ps ch th) ta)))

#  Importation to right triple conjunction.
stmt (3imp2 () ((-> ph (-> ps (-> ch (-> th ta))))) (-> (/\ ph (/\/\ ps ch th)) ta))

#  Exportation from left triple conjunction.
stmt (3exp1 () ((-> (/\ (/\/\ ph ps ch) th) ta)) (-> ph (-> ps (-> ch (-> th ta)))))

#  Exportation deduction for triple conjunction.
stmt (3expd () ((-> ph (-> (/\/\ ps ch th) ta))) (-> ph (-> ps (-> ch (-> th ta)))))

#  Exportation from right triple conjunction.
stmt (3exp2 () ((-> (/\ ph (/\/\ ps ch th)) ta)) (-> ph (-> ps (-> ch (-> th ta)))))

#  Deduction adding a conjunct to antecedent.
stmt (3adant1l () ((-> (/\/\ ph ps ch) th)) (-> (/\/\ (/\ ta ph) ps ch) th))

#  Deduction adding a conjunct to antecedent.
stmt (3adant1r () ((-> (/\/\ ph ps ch) th)) (-> (/\/\ (/\ ph ta) ps ch) th))

#  Deduction adding a conjunct to antecedent.
stmt (3adant2l () ((-> (/\/\ ph ps ch) th)) (-> (/\/\ ph (/\ ta ps) ch) th))

#  Deduction adding a conjunct to antecedent.
stmt (3adant2r () ((-> (/\/\ ph ps ch) th)) (-> (/\/\ ph (/\ ps ta) ch) th))

#  Deduction adding a conjunct to antecedent.
stmt (3adant3l () ((-> (/\/\ ph ps ch) th)) (-> (/\/\ ph ps (/\ ta ch)) th))

#  Deduction adding a conjunct to antecedent.
stmt (3adant3r () ((-> (/\/\ ph ps ch) th)) (-> (/\/\ ph ps (/\ ch ta)) th))

#  A syllogism inference combined with contraction.
stmt (syl3anc () ((-> (/\/\ ph ps ch) th) (-> ta ph) (-> ta ps) (-> ta ch)) (-> ta th))
tvar (wff ze)

#  A syllogism inference.
stmt (syl3an1 () ((-> (/\/\ ph ps ch) th) (-> ta ph)) (-> (/\/\ ta ps ch) th))

#  A syllogism inference.
stmt (syl3an2 () ((-> (/\/\ ph ps ch) th) (-> ta ps)) (-> (/\/\ ph ta ch) th))

#  A syllogism inference.
stmt (syl3an3 () ((-> (/\/\ ph ps ch) th) (-> ta ch)) (-> (/\/\ ph ps ta) th))

#  A syllogism inference.
stmt (syl3an1b () ((-> (/\/\ ph ps ch) th) (<-> ta ph)) (-> (/\/\ ta ps ch) th))

#  A syllogism inference.
stmt (syl3an2b () ((-> (/\/\ ph ps ch) th) (<-> ta ps)) (-> (/\/\ ph ta ch) th))

#  A syllogism inference.
stmt (syl3an3b () ((-> (/\/\ ph ps ch) th) (<-> ta ch)) (-> (/\/\ ph ps ta) th))

#  A syllogism inference.
stmt (syl3an1br () ((-> (/\/\ ph ps ch) th) (<-> ph ta)) (-> (/\/\ ta ps ch) th))

#  A syllogism inference.
stmt (syl3an2br () ((-> (/\/\ ph ps ch) th) (<-> ps ta)) (-> (/\/\ ph ta ch) th))

#  A syllogism inference.
stmt (syl3an3br () ((-> (/\/\ ph ps ch) th) (<-> ch ta)) (-> (/\/\ ph ps ta) th))

#  A triple syllogism inference.
stmt (syl3an () ((-> (/\/\ ph ps ch) th) (-> ta ph) (-> et ps) (-> ze ch)) (-> (/\/\ ta et ze) th))

#  A triple syllogism inference.
stmt (syl3anb () ((-> (/\/\ ph ps ch) th) (<-> ta ph) (<-> et ps) (<-> ze ch)) (-> (/\/\ ta et ze) th))

#  A syllogism inference.
stmt (syld3an3 () ((-> (/\/\ ph ps ch) th) (-> (/\/\ ph ps ta) ch)) (-> (/\/\ ph ps ta) th))

#  A syllogism inference.
stmt (syld3an1 () ((-> (/\/\ ph ps ch) th) (-> (/\/\ ta ps ch) ph)) (-> (/\/\ ta ps ch) th))

#  A syllogism inference.
stmt (syld3an2 () ((-> (/\/\ ph ps ch) th) (-> (/\/\ ph ta ch) ps)) (-> (/\/\ ph ta ch) th))
tvar (wff si)

#  A syllogism inference.
stmt (syl3anl1 () ((-> (/\ (/\/\ ph ps ch) th) ta) (-> et ph)) (-> (/\ (/\/\ et ps ch) th) ta))

#  A syllogism inference.
stmt (syl3anl2 () ((-> (/\ (/\/\ ph ps ch) th) ta) (-> et ps)) (-> (/\ (/\/\ ph et ch) th) ta))

#  A syllogism inference.
stmt (syl3anl3 () ((-> (/\ (/\/\ ph ps ch) th) ta) (-> et ch)) (-> (/\ (/\/\ ph ps et) th) ta))

#  A triple syllogism inference.
stmt (syl3anl () ((-> (/\ (/\/\ ph ps ch) th) ta) (-> et ph) (-> ze ps) (-> si ch)) (-> (/\ (/\/\ et ze si) th) ta))

#  A syllogism inference.
stmt (syl3anr1 () ((-> (/\ ph (/\/\ ps ch th)) ta) (-> et ps)) (-> (/\ ph (/\/\ et ch th)) ta))

#  A syllogism inference.
stmt (syl3anr2 () ((-> (/\ ph (/\/\ ps ch th)) ta) (-> et ch)) (-> (/\ ph (/\/\ ps et th)) ta))

#  A syllogism inference.
stmt (syl3anr3 () ((-> (/\ ph (/\/\ ps ch th)) ta) (-> et th)) (-> (/\ ph (/\/\ ps ch et)) ta))

#  Importation inference (undistribute conjunction).
stmt (3impdi () ((-> (/\ (/\ ph ps) (/\ ph ch)) th)) (-> (/\/\ ph ps ch) th))

#  Importation inference (undistribute conjunction).
stmt (3impdir () ((-> (/\ (/\ ph ps) (/\ ch ps)) th)) (-> (/\/\ ph ch ps) th))

#  Inference from idempotent law for conjunction.
stmt (3anidm12 () ((-> (/\/\ ph ph ps) ch)) (-> (/\ ph ps) ch))

#  Inference from idempotent law for conjunction.
stmt (3anidm13 () ((-> (/\/\ ph ps ph) ch)) (-> (/\ ph ps) ch))

#  Inference from idempotent law for conjunction.
stmt (3anidm23 () ((-> (/\/\ ph ps ps) ch)) (-> (/\ ph ps) ch))

#  Infer implication from triple disjunction.
stmt (3ori () ((\/\/ ph ps ch)) (-> (/\ (-. ph) (-. ps)) ch))

#  Disjunction of 3 antecedents.
stmt (3jao () () (-> (/\/\ (-> ph ps) (-> ch ps) (-> th ps)) (-> (\/\/ ph ch th) ps)))

#  Disjunction of 3 antecedents (inference).
stmt (3jaoi () ((-> ph ps) (-> ch ps) (-> th ps)) (-> (\/\/ ph ch th) ps))

#  Disjunction of 3 antecedents (deduction).
stmt (3jaod () ((-> ph (-> ps ch)) (-> ph (-> th ch)) (-> ph (-> ta ch))) (-> ph (-> (\/\/ ps th ta) ch)))

#  Disjunction of 3 antecedents (inference).
stmt (3jaoian () ((-> (/\ ph ps) ch) (-> (/\ th ps) ch) (-> (/\ ta ps) ch)) (-> (/\ (\/\/ ph th ta) ps) ch))

#  Disjunction of 3 antecedents (deduction).
stmt (3jaodan () ((-> (/\ ph ps) ch) (-> (/\ ph th) ch) (-> (/\ ph ta) ch)) (-> (/\ ph (\/\/ ps th ta)) ch))

#  Nested syllogism inference conjoining 3 dissimilar antecedents.
stmt (syl3an9b () ((-> ph (<-> ps ch)) (-> th (<-> ch ta)) (-> et (<-> ta ze))) (-> (/\/\ ph th et) (<-> ps ze)))

#  Deduction joining 3 equivalences to form equivalence of disjunctions.
stmt (3orbi123d () ((-> ph (<-> ps ch)) (-> ph (<-> th ta)) (-> ph (<-> et ze))) (-> ph (<-> (\/\/ ps th et) (\/\/ ch ta ze))))

#  Deduction joining 3 equivalences to form equivalence of conjunctions.
stmt (3anbi123d () ((-> ph (<-> ps ch)) (-> ph (<-> th ta)) (-> ph (<-> et ze))) (-> ph (<-> (/\/\ ps th et) (/\/\ ch ta ze))))

#  Deduction conjoining and adding a conjunct to equivalences.
stmt (3anbi12d () ((-> ph (<-> ps ch)) (-> ph (<-> th ta))) (-> ph (<-> (/\/\ ps th et) (/\/\ ch ta et))))

#  Deduction conjoining and adding a conjunct to equivalences.
stmt (3anbi13d () ((-> ph (<-> ps ch)) (-> ph (<-> th ta))) (-> ph (<-> (/\/\ ps et th) (/\/\ ch et ta))))

#  Deduction conjoining and adding a conjunct to equivalences.
stmt (3anbi23d () ((-> ph (<-> ps ch)) (-> ph (<-> th ta))) (-> ph (<-> (/\/\ et ps th) (/\/\ et ch ta))))

#  Deduction adding conjuncts to an equivalence.
stmt (3anbi1d () ((-> ph (<-> ps ch))) (-> ph (<-> (/\/\ ps th ta) (/\/\ ch th ta))))

#  Deduction adding conjuncts to an equivalence.
stmt (3anbi2d () ((-> ph (<-> ps ch))) (-> ph (<-> (/\/\ th ps ta) (/\/\ th ch ta))))

#  Deduction adding conjuncts to an equivalence.
stmt (3anbi3d () ((-> ph (<-> ps ch))) (-> ph (<-> (/\/\ th ta ps) (/\/\ th ta ch))))

#  Deduction joining 3 implications to form implication of conjunctions.
stmt (3anim123d () ((-> ph (-> ps ch)) (-> ph (-> th ta)) (-> ph (-> et ze))) (-> ph (-> (/\/\ ps th et) (/\/\ ch ta ze))))

#  Deduction joining 3 implications to form implication of disjunctions.
stmt (3orim123d () ((-> ph (-> ps ch)) (-> ph (-> th ta)) (-> ph (-> et ze))) (-> ph (-> (\/\/ ps th et) (\/\/ ch ta ze))))

#  Rearrangement of 6 conjuncts.
stmt (an6 () () (<-> (/\ (/\/\ ph ps ch) (/\/\ th ta et)) (/\/\ (/\ ph th) (/\ ps ta) (/\ ch et))))

#  An inference based on modus ponens.
stmt (mp3an1 () (ph (-> (/\/\ ph ps ch) th)) (-> (/\ ps ch) th))

#  An inference based on modus ponens.
stmt (mp3an2 () (ps (-> (/\/\ ph ps ch) th)) (-> (/\ ph ch) th))

#  An inference based on modus ponens.
stmt (mp3an3 () (ch (-> (/\/\ ph ps ch) th)) (-> (/\ ph ps) th))

#  An inference based on modus ponens.
stmt (mp3an12 () (ph ps (-> (/\/\ ph ps ch) th)) (-> ch th))

#  An inference based on modus ponens.
stmt (mp3an13 () (ph ch (-> (/\/\ ph ps ch) th)) (-> ps th))

#  An inference based on modus ponens.
stmt (mp3an23 () (ps ch (-> (/\/\ ph ps ch) th)) (-> ph th))

#  An inference based on modus ponens.
stmt (mp3an1i () (ps (-> ph (-> (/\/\ ps ch th) ta))) (-> ph (-> (/\ ch th) ta)))

#  An inference based on modus ponens.
stmt (mp3anl1 () (ph (-> (/\ (/\/\ ph ps ch) th) ta)) (-> (/\ (/\ ps ch) th) ta))

#  An inference based on modus ponens.
stmt (mp3anl2 () (ps (-> (/\ (/\/\ ph ps ch) th) ta)) (-> (/\ (/\ ph ch) th) ta))

#  An inference based on modus ponens.
stmt (mp3anl3 () (ch (-> (/\ (/\/\ ph ps ch) th) ta)) (-> (/\ (/\ ph ps) th) ta))

#  An inference based on modus ponens.
stmt (mp3anr1 () (ps (-> (/\ ph (/\/\ ps ch th)) ta)) (-> (/\ ph (/\ ch th)) ta))

#  An inference based on modus ponens.
stmt (mp3anr2 () (ch (-> (/\ ph (/\/\ ps ch th)) ta)) (-> (/\ ph (/\ ps th)) ta))

#  An inference based on modus ponens.
stmt (mp3anr3 () (th (-> (/\ ph (/\/\ ps ch th)) ta)) (-> (/\ ph (/\ ps ch)) ta))

#  An inference based on modus ponens.
stmt (mp3an () (ph ps ch (-> (/\/\ ph ps ch) th)) th)

#  An inference based on modus ponens.
stmt (mpd3an3 () ((-> (/\ ph ps) ch) (-> (/\/\ ph ps ch) th)) (-> (/\ ph ps) th))

#  An inference based on modus ponens.
stmt (mpd3an23 () ((-> ph ps) (-> ph ch) (-> (/\/\ ph ps ch) th)) (-> ph th))

#  Infer implication from a logical equivalence.  Similar to [[biimpa]].
stmt (biimp3a () ((-> (/\ ph ps) (<-> ch th))) (-> (/\/\ ph ps ch) th))

#  Infer implication from a logical equivalence.  Similar to [[biimpar]].
stmt (biimp3ar () ((-> (/\ ph ps) (<-> ch th))) (-> (/\/\ ph ps th) ch))

#  Inference that undistributes a triple conjunction in the antecedent.
stmt (3anandis () ((-> (/\/\ (/\ ph ps) (/\ ph ch) (/\ ph th)) ta)) (-> (/\ ph (/\/\ ps ch th)) ta))

#  Inference that undistributes a triple conjunction in the antecedent.
stmt (3anandirs () ((-> (/\/\ (/\ ph th) (/\ ps th) (/\ ch th)) ta)) (-> (/\ (/\/\ ph ps ch) th) ta))

#  Deduction for elimination by cases.
stmt (ecase23d () ((-> ph (-. ch)) (-> ph (-. th)) (-> ph (\/\/ ps ch th))) (-> ph ps))

#  Inference for elimination by cases.
stmt (3ecase () ((-> (-. ph) th) (-> (-. ps) th) (-> (-. ch) th) (-> (/\/\ ph ps ch) th)) th)

#  Carew Meredith's sole axiom for propositional calculus.  This amazing
#      formula is thought to be the shortest possible single axiom for
#      propositional calculus with inference rule [[ax-mp]], where negation and
#      implication are primitive.  Here we prove Meredith's axiom from [[ax-1]],
#      [[ax-2]], and [[ax-3]].  Then from it we derive the Lukasiewicz axioms
#      [[luk-1]], [[luk-2]], and [[luk-3]].  Using these we finally re-derive our
#      axioms as [[ax1]], [[ax2]], and [[ax3]], thus proving the equivalence of
#      all three systems.  C. A. Meredith, "Single Axioms for the Systems
#      (C,N), (C,O) and (A,N) of the Two-Valued Propositional Calculus," //The
#      Journal of Computing Systems// vol. 1 (1953), pp. 155-164.  Meredith
#      claimed to be close to a proof that this axiom is the shortest possible,
#      but the proof was apparently never completed.
#
#      An obscure Irish lecturer, Meredith (1904-1976) became enamored with
#      logic somewhat late in life after attending talks by Lukasiewicz and
#      produced many remarkable results such as this axiom.  From his obituary:
#      "He did logic whenever time and opportunity presented themselves, and he
#      did it on whatever materials came to hand:  in a pub, his favored pint
#      of porter within reach, he would use the inside of cigarette packs to
#      write proofs for logical colleagues."
stmt (meredith () () (-> (-> (-> (-> (-> ph ps) (-> (-. ch) (-. th))) ch) ta) (-> (-> ta ph) (-> th ph))))

#  Step 3 of Meredith's proof of Lukasiewicz axioms from his sole axiom.
#      (The step numbers refer to Meredith's original paper.)
stmt (merlem1 () () (-> (-> (-> ch (-> (-. ph) ps)) ta) (-> ph ta)))

#  Step 4 of Meredith's proof of Lukasiewicz axioms from his sole axiom.
stmt (merlem2 () () (-> (-> (-> ph ph) ch) (-> th ch)))

#  Step 7 of Meredith's proof of Lukasiewicz axioms from his sole axiom.
stmt (merlem3 () () (-> (-> (-> ps ch) ph) (-> ch ph)))

#  Step 8 of Meredith's proof of Lukasiewicz axioms from his sole axiom.
stmt (merlem4 () () (-> ta (-> (-> ta ph) (-> th ph))))

#  Step 11 of Meredith's proof of Lukasiewicz axioms from his sole axiom.
stmt (merlem5 () () (-> (-> ph ps) (-> (-. (-. ph)) ps)))

#  Step 12 of Meredith's proof of Lukasiewicz axioms from his sole axiom.
stmt (merlem6 () () (-> ch (-> (-> (-> ps ch) ph) (-> th ph))))

#  Between steps 14 and 15 of Meredith's proof of Lukasiewicz axioms from his
#      sole axiom.
stmt (merlem7 () () (-> ph (-> (-> (-> ps ch) th) (-> (-> (-> ch ta) (-> (-. th) (-. ps))) th))))

#  Step 15 of Meredith's proof of Lukasiewicz axioms from his sole axiom.
stmt (merlem8 () () (-> (-> (-> ps ch) th) (-> (-> (-> ch ta) (-> (-. th) (-. ps))) th)))

#  Step 18 of Meredith's proof of Lukasiewicz axioms from his sole
#        axiom.
stmt (merlem9 () () (-> (-> (-> ph ps) (-> ch (-> th (-> ps ta)))) (-> et (-> ch (-> th (-> ps ta))))))

#  Step 19 of Meredith's proof of Lukasiewicz axioms from his sole axiom.
stmt (merlem10 () () (-> (-> ph (-> ph ps)) (-> th (-> ph ps))))

#  Step 20 of Meredith's proof of Lukasiewicz axioms from his sole axiom.
stmt (merlem11 () () (-> (-> ph (-> ph ps)) (-> ph ps)))

#  Step 28 of Meredith's proof of Lukasiewicz axioms from his sole axiom.
stmt (merlem12 () () (-> (-> (-> th (-> (-. (-. ch)) ch)) ph) ph))

#  Step 35 of Meredith's proof of Lukasiewicz axioms from his sole axiom.
stmt (merlem13 () () (-> (-> ph ps) (-> (-> (-> th (-> (-. (-. ch)) ch)) (-. (-. ph))) ps)))

#  1 of 3 axioms for propositional calculus due to Lukasiewicz, derived from
#      Meredith's sole axiom.
stmt (luk-1 () () (-> (-> ph ps) (-> (-> ps ch) (-> ph ch))))

#  2 of 3 axioms for propositional calculus due to Lukasiewicz, derived from
#      Meredith's sole axiom.
stmt (luk-2 () () (-> (-> (-. ph) ph) ph))

#  3 of 3 axioms for propositional calculus due to Lukasiewicz, derived from
#      Meredith's sole axiom.
stmt (luk-3 () () (-> ph (-> (-. ph) ps)))

#  Used to rederive standard propositional axioms from Lukasiewicz'.
stmt (luklem1 () ((-> ph ps) (-> ps ch)) (-> ph ch))

#  Used to rederive standard propositional axioms from Lukasiewicz'.
stmt (luklem2 () () (-> (-> ph (-. ps)) (-> (-> (-> ph ch) th) (-> ps th))))

#  Used to rederive standard propositional axioms from Lukasiewicz'.
stmt (luklem3 () () (-> ph (-> (-> (-> (-. ph) ps) ch) (-> th ch))))

#  Used to rederive standard propositional axioms from Lukasiewicz'.
stmt (luklem4 () () (-> (-> (-> (-> (-. ph) ph) ph) ps) ps))

#  Used to rederive standard propositional axioms from Lukasiewicz'.
stmt (luklem5 () () (-> ph (-> ps ph)))

#  Used to rederive standard propositional axioms from Lukasiewicz'.
stmt (luklem6 () () (-> (-> ph (-> ph ps)) (-> ph ps)))

#  Used to rederive standard propositional axioms from Lukasiewicz'.
stmt (luklem7 () () (-> (-> ph (-> ps ch)) (-> ps (-> ph ch))))

#  Used to rederive standard propositional axioms from Lukasiewicz'.
stmt (luklem8 () () (-> (-> ph ps) (-> (-> ch ph) (-> ch ps))))

#  Standard propositional axiom derived from Lukasiewicz axioms.
stmt (ax1 () () (-> ph (-> ps ph)))

#  Standard propositional axiom derived from Lukasiewicz axioms.
stmt (ax2 () () (-> (-> ph (-> ps ch)) (-> (-> ph ps) (-> ph ch))))

#  Standard propositional axiom derived from Lukasiewicz axioms.
stmt (ax3 () () (-> (-> (-. ph) (-. ps)) (-> ps ph)))
term (wff (-/\ ph ps))

#  Define  incompatibility ('not-and' or 'nand').  This is also called the
#      Sheffer stroke, represented by a vertical bar, but we use a different
#      symbol to avoid ambiguity with other uses of the vertical bar.
stmt (df-nand () () (<-> (-/\ ph ps) (-. (/\ ph ps))))

#  Lemma for handling nested 'nand's.
stmt (nic-justlem () () (<-> (-/\ ph (-/\ ch ps)) (-> ph (/\ ch ps))))

#  Show equivalence between implication and the Nicod version.  To derive
#      [[nic-dfim]], apply [[nic-justbi]].
stmt (nic-justim () () (<-> (-> ph ps) (-/\ ph (-/\ ps ps))))

#  Show equivalence between negation and the Nicod version.  To derive
#      [[nic-dfneg]], apply [[nic-justbi]].
stmt (nic-justneg () () (<-> (-. ps) (-/\ ps ps)))

#  Show equivalence between the bidirectional and the Nicod version.
#      (Contributed by Jeff Hoffman, 19-Nov-2007.)
stmt (nic-justbi () () (<-> (<-> ph ps) (-/\ (-/\ ph ps) (-/\ (-/\ ph ph) (-/\ ps ps)))))

#  Define implication in terms of 'nand'.  Analogous to
#      #(<-> (-/\ ph (-/\ ps ps)) (-> ph ps))#.  In a pure
#      (standalone) treatment of Nicod's axiom, this theorem would be changed
#      to a definition ($a statement).
stmt (nic-dfim () () (-/\ (-/\ (-/\ ph (-/\ ps ps)) (-> ph ps)) (-/\ (-/\ (-/\ ph (-/\ ps ps)) (-/\ ph (-/\ ps ps))) (-/\ (-> ph ps) (-> ph ps)))))

#  Define negation in terms of 'nand'.  Analogous to
#      #(<-> (-/\ ph ph) (-. ph))#.  In a pure (standalone) treatment of
#      Nicod's axiom, this theorem would be changed to a definition ($a
#      statement).
stmt (nic-dfneg () () (-/\ (-/\ (-/\ ph ph) (-. ph)) (-/\ (-/\ (-/\ ph ph) (-/\ ph ph)) (-/\ (-. ph) (-. ph)))))

#  Derive Nicod's rule of modus ponens using 'nand', from the standard
#        one.  Although the major and minor premise together also imply #ch#,
#        this form is necessary for useful derivations from [[nic-ax]].  In a
#        pure (standalone) treatment of Nicod's axiom, this theorem would be
#        changed to an axiom ($a statement).  (Contributed by Jeff Hoffman,
#        19-Nov-2007.)
stmt (nic-mp () (ph (-/\ ph (-/\ ch ps))) ps)

#  A direct proof of [[nic-mp]].
stmt (nic-mpALT () (ph (-/\ ph (-/\ ch ps))) ps)

#  Nicod's axiom derived from the standard ones.  See //Intro. to Math. Phil.//
#      by B. Russell, p. 152.  Like [[meredith]], the usual axioms can be derived
#      from this and vice versa.  Unlike [[meredith]], Nicod uses a different
#      connective ('nand'), so another form of modus ponens must be used in
#      proofs, e.g. {{{{}}} [[nic-ax]], [[nic-mp]]  {{{}}}} is equivalent to
#      {{{{}}} [[luk-1]], [[luk-2]], [[luk-3]], [[ax-mp]] {{{}}}}.  In a pure
#      (standalone) treatment of Nicod's axiom, this theorem would be changed
#      to an axiom ($a statement).  (Contributed by Jeff Hoffman,
#      19-Nov-2007.)
stmt (nic-ax () () (-/\ (-/\ ph (-/\ ch ps)) (-/\ (-/\ ta (-/\ ta ta)) (-/\ (-/\ th ch) (-/\ (-/\ ph th) (-/\ ph th))))))

#  A direct proof of [[nic-ax]].
stmt (nic-axALT () () (-/\ (-/\ ph (-/\ ch ps)) (-/\ (-/\ ta (-/\ ta ta)) (-/\ (-/\ th ch) (-/\ (-/\ ph th) (-/\ ph th))))))

#  Inference for [[nic-mp]] using [[nic-ax]] as major premise.  (Contributed
#         by Jeff Hoffman, 17-Nov-2007.)
stmt (nic-imp () ((-/\ ph (-/\ ch ps))) (-/\ (-/\ th ch) (-/\ (-/\ ph th) (-/\ ph th))))

#  Lemma for [[nic-id]].
stmt (nic-idlem1 () () (-/\ (-/\ th (-/\ ta (-/\ ta ta))) (-/\ (-/\ (-/\ ph (-/\ ch ps)) th) (-/\ (-/\ ph (-/\ ch ps)) th))))

#  Lemma for [[nic-id]].  Inference used by [[nic-id]].
stmt (nic-idlem2 () ((-/\ et (-/\ (-/\ ph (-/\ ch ps)) th))) (-/\ (-/\ th (-/\ ta (-/\ ta ta))) et))

#  Theorem [[id]] expressed with {{{-/\}}}.  (Contributed by Jeff Hoffman,
#      17-Nov-2007.)
stmt (nic-id () () (-/\ ta (-/\ ta ta)))

#  {{{-/\}}} is symmetric.  (Contributed by Jeff Hoffman, 17-Nov-2007.)
stmt (nic-swap () () (-/\ (-/\ th ph) (-/\ (-/\ ph th) (-/\ ph th))))

#  Inference version of [[nic-swap]].  (Contributed by Jeff Hoffman,
#        17-Nov-2007.)
stmt (nic-isw1 () ((-/\ th ph)) (-/\ ph th))

#  Inference for swapping nested terms.  (Contributed by Jeff Hoffman,
#        17-Nov-2007.)
stmt (nic-isw2 () ((-/\ ps (-/\ th ph))) (-/\ ps (-/\ ph th)))

#  Inference version of [[nic-imp]] using right-handed term.  (Contributed
#        by Jeff Hoffman, 17-Nov-2007.)
stmt (nic-iimp1 () ((-/\ ph (-/\ ch ps)) (-/\ th ch)) (-/\ th ph))

#  Inference version of [[nic-imp]] using left-handed term.  (Contributed
#        by Jeff Hoffman, 17-Nov-2007.)
stmt (nic-iimp2 () ((-/\ (-/\ ph ps) (-/\ ch ch)) (-/\ th ph)) (-/\ th (-/\ ch ch)))

#  Inference to remove the trailing term.  (Contributed by Jeff Hoffman,
#        17-Nov-2007.)
stmt (nic-idel () ((-/\ ph (-/\ ch ps))) (-/\ ph (-/\ ch ch)))

#  Chained inference.  (Contributed by Jeff Hoffman, 17-Nov-2007.)
stmt (nic-ich () ((-/\ ph (-/\ ps ps)) (-/\ ps (-/\ ch ch))) (-/\ ph (-/\ ch ch)))

#  Double the terms.  Since doubling is the same as negation,
#        this can be viewed as a contraposition Inference.  (Contributed
#        by Jeff Hoffman, 17-Nov-2007.)
stmt (nic-idbl () ((-/\ ph (-/\ ps ps))) (-/\ (-/\ ps ps) (-/\ (-/\ ph ph) (-/\ ph ph))))

#  For nic-* definitions, the biconditional connective is not used.  Instead,
#      definitions are made based on this form.  [[nic-bi1]] and [[nic-bi2]] are
#      used to convert the definitions into usable theorems about one side of the
#      implication.  (Contributed by Jeff Hoffman, 18-Nov-2007.)
stmt (nic-bijust () () (-/\ (-/\ ta ta) (-/\ (-/\ ta ta) (-/\ ta ta))))

#  Inference to extract one side of an implication from a definition
stmt (nic-bi1 () ((-/\ (-/\ ph ps) (-/\ (-/\ ph ph) (-/\ ps ps)))) (-/\ ph (-/\ ps ps)))

#  Inference to extract the other side of an implication from a
#         'biconditional' definition.
stmt (nic-bi2 () ((-/\ (-/\ ph ps) (-/\ (-/\ ph ph) (-/\ ps ps)))) (-/\ ps (-/\ ph ph)))

#  Derive the standard modus ponens from [[nic-mp]].  (Contributed by Jeff
#        Hoffman, 18-Nov-2007.)
stmt (nic-stdmp () (ph (-> ph ps)) ps)

#  Proof of [[luk-1]] from [[nic-ax]] and [[nic-mp]] (and definitions
#      [[nic-dfim]] and [[nic-dfneg]]).  Note that the standard axioms [[ax-1]],
#      [[ax-2]], and [[ax-3]] are proved from the Lukasiewicz axioms by theorems
#      [[ax1]], [[ax2]], and [[ax3]].  (Contributed by Jeff Hoffman,
#      18-Nov-2007.)
stmt (nic-luk1 () () (-> (-> ph ps) (-> (-> ps ch) (-> ph ch))))

#  Proof of [[luk-2]] from [[nic-ax]] and [[nic-mp]].  (Contributed by Jeff
#      Hoffman, 18-Nov-2007.)
stmt (nic-luk2 () () (-> (-> (-. ph) ph) ph))

#  Proof of [[luk-3]] from [[nic-ax]] and [[nic-mp]].  (Contributed by Jeff
#      Hoffman, 18-Nov-2007.)
stmt (nic-luk3 () () (-> ph (-> (-. ph) ps)))
