# The reals have not been constructed yet and this list is missing essential properties of the reals.

param (PROP prop.ghi () "")
param (PREDICATE_EQ predicate_eq.ghi (PROP) "")

tvar (wff ph ps ch th ta)
tvar (nat A B C D)
var (nat v w x y z)

term (wff (< A B))
term (wff (>= A B))
term (wff (> A B))
term (wff (pos A))
term (wff (zneg A))
term (nat (ifn ph A B))

term (nat (2))
term (nat (3))
term (nat (4))
term (nat (5))
term (nat (6))
term (nat (7))
term (nat (8))
term (nat (9))
term (nat (10))


## Copied from add_multiply_min.ghi

term (nat (+ A B))
term (nat (* A B))
term (nat (0))
term (nat (1))

## <title> Associative Property </title>
## <suggest> right('Associate', 'R') left('Associate', 'L') </suggest>
stmt (addass () () (= (+ (+ A B) C) (+ A (+ B C))))

## <title> Additive Identity </title>
## <suggest> auto-right('Simplify', '0') </suggest>
stmt (addid () () (= (+ A (0)) A))

## <title> Commutative Property </title>
## <table>
##   (= (+ <r> A <g> B) (+ <g> B <r> A))
## </table>
## <suggest> right('Commute', '+') </suggest>
stmt (addcom () () (= (+ A B) (+ B A)))

## <title> Associative Property </title>
## <suggest> right('Associate', 'R') left('Associate', 'L') </suggest>
stmt (mulass () () (= (* (* A B) C) (* A (* B C))))

## <title> Commutative Property </title>
## <table>
##   (= (* <r> A <g> B) (* <g> B <r> A))
## </table>
## <suggest> right('Commute', '*') </suggest>
stmt (mulcom () () (= (* A B) (* B A)))

# Distribution of addition through multiplication
## <title> Distributive Property </title>
## <table>
##   (= (* <c> A (+ B C)) (+ (* <c> A B) (* <c> A C)))
## </table>
## <suggest> right('Distribute', 'R') left('Distribute', '-R') </suggest>
stmt (distr () () (= (* A (+ B C)) (+ (* A B) (* A C))))

## <title> Multiplicative Identity </title>
## <suggest> right('Simplify', '1') </suggest>
## <table>
##   (= (* A <r> (1)) A)
## </table>
## <suggest> auto-right('Simplify') </suggest>
stmt (mulid () () (= (* A (1)) A))

# Equality axiom for addition
## <title> Addition of Equal Numbers Axiom </title>
## <summary>
##   When two equal numbers are added, their sums are equal.
## </summary>
## <axiom>
stmt (addeq12 () () (-> (/\ (= A B) (= C D)) (= (+ A C) (+ B D))))
    
## <title> Multiplication of Equal Numbers Axiom </title>
## <summary>
##   When two equal numbers are added, their products are equal.
## </summary>
## <axiom>
stmt (muleq12 () () (-> (/\ (= A B) (= C D)) (= (* A C) (* B D))))

## <title> Cancellation of addition </title>
## <suggest> right('Cancel', '+') </suggest>
stmt (addcan () () (<-> (= (+ B A) (+ C A)) (= B C)))

## <title> Cancel Multiplication </title>
stmt (mulcan () () (-> (-. (= C (0))) (<-> (= (* A C) (* B C)) (= A B))))


## Copied from inequality_min.ghi

term (wff (<= A B))

## <title> Reflexive Property </title>
stmt (leid () () (<= A A))

## <title> Same upper and lower bound implies equality </title>
## <summary> Trichotomy law (may be a poor choice of name) </summary>
## <suggest> left('Simplify', '=') </suggest>
stmt (lesym () () (<-> (= A B) (/\ (<= A B) (<= B A))))

## <title> Total Relationship </title>
## <summary> Less than or equal is a total relationship </summary>
stmt (letot () () (\/ (<= A B) (<= B A)))

## <title> Transitive Property </title>
## <suggest> right('Simplify', '≤ ≤') </suggest>
stmt (letr () () (-> (/\ (<= A B) (<= B C)) (<= A C)))

## <title> Inequality Multiplication </title>
stmt (lemul1 () () (-> (/\ (<= A B) (<= (0) C)) (<= (* A C) (* B C))))

## <title> 0 is not equal to 1 </title>
stmt (0ne1 () () (-. (= (0) (1))))

## <title> 0 is less than or equal to 1 </title>
stmt (0le1 () () (<= (0) (1)))

## <title> 0 is less than 1 </title>
stmt (0less1 () () (< (0) (1)))

## <title> Inequality Equivalence </title>
stmt (leeq1 () () (-> (= A B) (<-> (<= A C) (<= B C))))

## <title> Inequality Equivalence </title>
stmt (leeq2 () () (-> (= A B) (<-> (<= C A) (<= C B))))

## <title> Less Than or Equal from Nonnegative Difference </title>
stmt (exle ((A x)(B x)) () (<-> (<= A B) (E. x (/\ (<= (0) x) (= (+ A x) B)))))


# Copied from add_multiply.ghi

## <title> Additive Identity </title>
## <suggest> auto-right('Simplify', '0') </suggest>
stmt (addidr () () (= (+ (0) A) A))

## <title> Definition of 2 </title>
stmt (df-2 () () (= (2) (+ (1) (1))))

## <title> Definition of 3 </title>
stmt (df-3 () () (= (3) (+ (2) (1))))

## <title> Definition of 4 </title>
stmt (df-4 () () (= (4) (+ (3) (1))))

## <title> Definition of 5 </title>
stmt (df-5 () () (= (5) (+ (4) (1))))

## <title> Definition of 6 </title>
stmt (df-6 () () (= (6) (+ (5) (1))))

## <title> Definition of 7 </title>
stmt (df-7 () () (= (7) (+ (6) (1))))

## <title> Definition of 8 </title>
stmt (df-8 () () (= (8) (+ (7) (1))))

## <title> Definition of 9 </title>
stmt (df-9 () () (= (9) (+ (8) (1))))

## <title> Definition of 10 </title>
stmt (df-10 () () (= (10) (+ (9) (1))))

## <title> Multiplicative Identity </title>
## <suggest> auto-right('Simplify', '1') </suggest>
stmt (mulidr() () (= (* (1) A) A))

## <title> Inequality over Addition </title>
## <table>
##   (-. (=      [ A ]      [   [ B ))
##   (-. (= (+ C [ A ] ) (+ [ C [ B)))
## </table>
stmt (addneq2i () ((-. (= A B))) (-. (= (+ C A) (+ C B))))

## <title> Multiply by 0 </title>
## <summary> This rederives one of the Peano axioms. </summary>
stmt (mul0 () () (= (* A (0)) (0)))

## <title> Multiply by 0 </title>
## <suggest> auto-right('Simplify','0') </suggest>
stmt (mul0r () () (= (* (0) A) (0)))

## <title> Distributive Property </title>
## <suggest> right('Distribute', 'L') left('Distribute', '-L') </suggest>
stmt (distl () () (= (* (+ A B) C) (+ (* A C) (* B C))))

## <title> Distributive Property </title>
## <table>
##   (= (* (+ <m> A <b> B) (+ <c> C <g> D)) (+ (+ (* <m> A <c> C) (* <b> B <c> C)) (+ (* <m> A <g> D) (* <b> B <g> D))))
## </table>
## <summary> Distribution of addition through multiplication, both arguments </summary>
## <suggest> right('Distribute', 'RL') left('Distribute', 'RL') </suggest>
stmt (distrl () () (= (* (+ A B) (+ C D)) (+ (+ (* A C) (* B C)) (+ (* A D) (* B D)))))

## <title> Equality over Addition </title>
## <table>
##   (=    A ]       [ B ] )
##   (= (+ A ] C) (+ [ B ] C))
## </table>
stmt (addeq1i () ((= A B)) (= (+ A C) (+ B C)))

## <title> Equality over Addition </title>
## <table>
##   (=      [ A ]        [ B )
##   (= (+ C [ A ] ) (+ C [ B))
## </table>
stmt (addeq2i () ((= A B)) (= (+ C A) (+ C B)))

## <title> Equality over Multiplication </title>
## <table>
##   (=    A ]       [ B ] )
##   (= (* A ] C) (* [ B ] C))
## </table>
stmt (muleq1i () ((= A B)) (= (* A C) (* B C)))

## <title> Equality over Multiplication </title>
## <table>
##   (=      [ A ]        [ B )
##   (= (* C [ A ] ) (* C [ B))
## </table>
stmt (muleq2i () ((= A B)) (= (* C A) (* C B)))

# This is identical to eqtr. So ideally we would use eqtr instead.
## <title> Substitution </title>
## <table>
##   (= A  [ B ]   ]   ] )
##   (=    [ B ]   [ C ] )
##   (= A  [   [   [ C ] )
## </table>
stmt (EqReplaceEq1 () ((= A B) (= B C)) (= A C))

## <title> Add a number to both sides of an equation </title>
## <table>
##   (-> (= <g> A <b> B) (= (+ <g> A <r> C) (+ <b> B <r> C)))
## </table>
stmt (addeq1 () () (-> (= A B) (= (+ A C) (+ B C))))

## <title> Add a number to both sides of an equation </title>
stmt (addeq2 () ()
  (-> (= A B) (= (+ C A) (+ C B))))

## <title> Equality over Addition </title>
stmt (addeq1d ()
  ((-> ph (= A B)))
  (-> ph (= (+ A C) (+ B C))))

## <title> Equality over Addition </title>
stmt (addeq2d ()
  ((-> ph (= A B)))
  (-> ph (= (+ C A) (+ C B))))

## <title> Equality over Addition </title>
stmt (addeq12i () ((= A B) (= C D)) (= (+ A C) (+ B D)))

## <title> Equality over Addition </title>
stmt (addeq12d ()
  ((-> ph (= A B))
   (-> ph (= C D)))
  (-> ph (= (+ A C) (+ B D))))

## <title> Equality over Multiplication </title>
## <table>
##   (-> (= A B) (= (* A <r> C) (* B <r> C)))
## </table>
stmt (muleq1 () () (-> (= A B) (= (* A C) (* B C))))

## <title> Equality over Multiplication </title>
## <table>
##   (-> (= A B) (= (* <r> C A) (* <r> C B)))
## </table>
stmt (muleq2 () () (-> (= A B) (= (* C A) (* C B))))

## <title> Equality over Multiplication </title>
stmt (muleq1d ()
  ((-> ph (= A B)))
  (-> ph (= (* A C) (* B C))))
	
stmt (muleq2d () ((-> ph (= A B))) (-> ph (= (* C A) (* C B))))

stmt (muleq12d ()
  ((-> ph (= A B))
   (-> ph (= C D)))
  (-> ph (= (* A C) (* B D))))

## <title> Equality over Multiplication </title>
stmt (muleq12i ()
  ((= A B)
   (= C D))
  (= (* A C) (* B D)))

## <title> Cancellation of addition </title>
stmt (addcan2 () () (<-> (= (+ A B) (+ A C)) (= B C)))

## <title> Rearrange Addition Terms </title>
## <table>
##   (= (+ (+ A <g> B) (+ <r> C D)) (+ (+ A <r> C) (+ <g> B D)))
## </table>
stmt (add4 () () (= (+ (+ A B) (+ C D)) (+ (+ A C) (+ B D))))

## <title> Rearrange the second and fourth terms </title>
## <table>
##   (= (+ (+ A <g> B) (+ C <r> D)) (+ (+ A <r> D) (+ C <g> B)))
## </table>
stmt (add24 () () (= (+ (+ A B) (+ C D)) (+ (+ A D) (+ C B))))

## <title> Rearrange Addition Terms </title>
## <table>
##   (= (+ (+ A <r> B) <g> C) (+ (+ A <g> C) <r> B))
## </table>
stmt (add23 () () (= (+ (+ A B) C) (+ (+ A C) B)))

## <title> Rearrange Addition Terms </title>
stmt (add432 () () (= (+ (+ A B) (+ C D)) (+ (+ A D) (+ B C))))

## <title> Cancel Addition </title>
## <table>
##   (= (+ A ] <r> C ) ] (+ [ B <r> C))
##   (=    A ]         ]    [ B)
## </table>
stmt (addcani () ((= (+ A C) (+ B C))) (= A B))

## <title> Cancel Addition </title>
## <table>
##   (=  (+ <r> C [ A ) ] (+ <r> C [ B ))
##   (=           [ A   ]          [ B)
## </table>
stmt (addcan2i () ((= (+ C A) (+ C B))) (= A B))

## <title> Reorder Multiplication Terms </title>
stmt (mul4() () (= (* (* A B) (* C D)) (* (* A C) (* B D))))

## <title> Reorder Multiplication Terms </title>
stmt (mul42() () (= (* (* A B) (* C D)) (* (* A D) (* C B))))

## <title> Commutative Property </title>
stmt (mulcom12 () () (= (* A (* B C)) (* B (* A C))))

stmt (dist_ax6 () () (= (* A (+ B (1))) (+ (* A B) A)))    

stmt (dist_ax6r () () (= (* (+ A (1)) B) (+ (* A B) B)))

## <title> Adding twice mean Multiply by 2 </title>
## <suggest> right('Simplify', '2') </suggest>
stmt (add2mul () () (= (+ A A) (* (2) A)))


## Copied from inequality.ghi

## <title> Inequality Conversion </title>
## <suggest> left('Simplify', '<') </suggest>
stmt (axlttri2 () () (<-> (< A B) (/\ (-. (= A B)) (<= A B))))

## <title> Inequality Conversion </title>
## <suggest> left('Simplify', '>') </suggest>
stmt (axgrtri () () (<-> (> A B) (/\ (-. (= A B)) (>= A B))))

## <title> Addition is Monotonic </title>
## <summary> Addition is strictly monotonic in the second addend </summary>
## <suggest> left('Cancel', '+') </suggest>
## <table>
##   (<-> (<= A B) (<= (+ <g> C A) (+ <g> C B)))
## </table>
stmt (leadd2 () () (<-> (<= A B) (<= (+ C A) (+ C B))))

## <title> Addition Over Inequality </title>
## <table>
##  (<=    A ]       [ B ] )
##  (<= (+ A ] C) (+ [ B ] C))
## </table>
stmt (leadd1i () ((<= A B)) (<= (+ A C) (+ B C)))

## <title> Addition Over Inequality </title>
## <table>
##  (<=      [ A ]        [ B )
##  (<= (+ C [ A ] ) (+ C [ B ))
## </table>
stmt (leadd2i () ((<= A B)) (<= (+ C A) (+ C B)))

## <title> Inequality Over Addition </title>
## <table>
##  (<    A ]       [ B ] )
##  (< (+ A ] C) (+ [ B ] C))
## </table>
stmt (ltadd1i () ((< A B)) (< (+ A C) (+ B C)))

## <title> Inequality Over Addition </title>
## <table>
##  (<      [ A ]        [ B )
##  (< (+ C [ A ] ) (+ C [ B ))
## </table>
stmt (ltadd2i () ((< A B)) (< (+ C A) (+ C B)))

## <title> Addition is Monotonic </title>
## <suggest> left('Cancel', '+') </suggest>
stmt (ltadd1 () () (<-> (< A B) (< (+ A C) (+ B C))))

## <title> Addition is Monotonic </title>
## <suggest> left('Cancel', '+') </suggest>
stmt (ltadd2 () () (<-> (< A B) (< (+ C A) (+ C B))))

stmt (gtadd1 () () (<-> (> B A) (> (+ B C) (+ A C))))

stmt (gtadd2 () () (<-> (> B A) (> (+ C B) (+ C A))))

## <title> Add on Both Sides of Inequality </title>
stmt (geadd1 () ()  (<-> (>= A B) (>= (+ A C) (+ B C))))

## <title> Addition is Monotonic </title>
stmt (geadd2 () ()  (<-> (>= A B) (>= (+ C A) (+ C B))))

## <title> Inequality relation for two equal sums </title>
stmt (ltadd12 () () (-> (= (+ A B) (+ C D)) (<-> (< A C) (< D B))))

## <title> ≥ means > OR = </title>
## <suggest> right('Equivalence', '∨') left('Simplify', '≥') </suggest>
stmt (gegeo () () (<-> (>= A B) (\/ (> A B) (= A B))))

## <title> ≤ means < OR = </title>
## <suggest> right('Equivalence', '∨') left('Simplify', '≤') </suggest>
stmt (leleo () () (<-> (<= A B) (\/ (< A B) (= A B))))

## <title> Combine Inequalities </title>
stmt (letradd () () (-> (/\ (<= A B) (<= C D)) (<= (+ A C) (+ B D))))

## <title> Combine Inequalities </title>
stmt (lttradd () () (-> (/\ (< A B) (< C D)) (< (+ A C) (+ B D))))

## <title> Combine Inequalities </title>
stmt (lelttradd () () (-> (/\ (<= A B) (< C D)) (< (+ A C) (+ B D))))

stmt (getradd () () (-> (/\ (>= A B) (>= C D)) (>= (+ A C) (+ B D))))

stmt (gttradd () () (-> (/\ (> A B) (> C D)) (> (+ A C) (+ B D))))

## <title> Combine Inequalities </title>
stmt (gegttradd () () (-> (/\ (>= B A) (> D C)) (> (+ B D) (+ A C))))

## <table>
##  (<=    A ]   ]      [ B ] )
##  (<=      [ C ]      [   [ D)
##  (<= (+ A ] C ] ) (+ [ B [ D))
## </table>
stmt (letraddi () ((<= A B) (<= C D)) (<= (+ A C) (+ B D)))

## <table>
##  (<    A ]   ]      [ B ] )
##  (<      [ C ]      [   [ D)
##  (< (+ A ] C ] ) (+ [ B [ D))
## </table>
stmt (lttraddi () ((< A B) (< C D)) (< (+ A C) (+ B D)))

## <table>
##  (>=    A ]   ]      [ B ] )
##  (>=      [ C ]      [   [ D)
##  (>= (+ A ] C ] ) (+ [ B [ D))
## </table>
stmt (getraddi () ((>= A B) (>= C D)) (>= (+ A C) (+ B D)))

## <table>
##  (>    A ]   ]      [ B ] )
##  (>      [ C ]      [   [ D)
##  (> (+ A ] C ] ) (+ [ B [ D))
## </table>
stmt (gttraddi () ((> A B) (> C D)) (> (+ A C) (+ B D)))

## <title> Addition Over Inequality </title>
## <table>
##  (>    A ]       [ B ] )
##  (> (+ A ] C) (+ [ B ] C))
## </table>
stmt (gtadd1i () ((> A B)) (> (+ A C) (+ B C)))

## <title> Addition Over Inequality </title>
## <table>
##  (>    A ]       [ B ] )
##  (> (+ A ] C) (+ [ B ] C))
## </table>
stmt (gtadd2i () ((> A B)) (> (+ C A) (+ C B)))

## <title> Addition Over Inequality </title>
## <table>
##  (>=    A ]       [ B ] )
##  (>= (+ A ] C) (+ [ B ] C))
## </table>
stmt (geadd1i () ((>= A B)) (>= (+ A C) (+ B C)))

## <title> Addition Over Inequality </title>
## <table>
##  (>=      [ A ]        [ B )
##  (>= (+ C [ A ] ) (+ C [ B ))
## </table>
stmt (geadd2i () ((>= A B)) (>= (+ C A) (+ C B)))

## <title> Converse of ≤ </title>
## <suggest> right('Commute', '≤') left('Commute', '≥') </suggest>
stmt (lecon () () (<-> (<= A B) (>= B A)))

## <title> Converse of ≤ </title>
stmt (leconi () ((<= A B)) (>= B A))

## <title> Converse of ≤ </title>
## <suggest> right('Commute', '≤') left('Commute', '≥') </suggest>
stmt (leconold () () (<-> (<= A B) (-. (< B A))))

## <title> Converse of < </title>
## <suggest> right('Commute', '<') left('Commute', '>') </suggest>
stmt (ltcon () () (<-> (< A B) (> B A)))

## <title> Converse of < </title>
stmt (ltconi () ((< A B)) (> B A))

## <title> Def. Greater Than or Equal to </title>
## <suggest> right('Define', '≤') left('Simplify', '≥') </suggest>
stmt (df-ge () () (<-> (>= A B) (-. (< A B))))

## <title> Def. Greater Than </title>
## <suggest> right('Define', '<') left('Simplify', '>') </suggest>
stmt (df-gt () () (<-> (> A B) (-. (<= A B))))

## <title> Def. Greater Than or Equal </title>
## <suggest> right('Simplify', '<') </suggest>
stmt (notge () () (<-> (-. (>= A B)) (< A B)))

## <title> Def. Greater Than </title>
## <suggest> right('Simplify', ' ≤') </suggest>
stmt (notgt () () (<-> (-. (> A B)) (<= A B)))

## <title> Definition of Less Than </title>
stmt (df-lt () () (<-> (< A B) (/\ (<= A B) (-. (= A B)))))

## <title> Equivalence for < </title> ##
stmt (lteq1 () () (-> (= A C) (<-> (< A B) (< C B))))

## <title> Equivalence for < </title> ##
stmt (lteq2 () () (-> (= B C) (<-> (< A B) (< A C))))

## <title> Equivalence over Inequality </title>
## <table>
##   (=      A ]   ]      [ B ]   )
##   (<-> (< A ] C ] ) (< [ B ] C))
## </table>
stmt (lteq1i () ((= A B)) (<-> (< A C) (< B C)))

## <title> Equivalence over Inequality </title>
## <table>
##   (=        [ A ]      [   [ B ] )
##   (<-> (< C [ A ] ) (< [ C [ B ] ))
## </table>
stmt (lteq2i () ((= A B)) (<-> (< C A) (< C B)))

stmt (lteq1d () (
     (-> ph (= A C)))
     (-> ph (<-> (< A B) (< C B))))

stmt (lteq2d () (
     (-> ph (= B C)))
     (-> ph (<-> (< A B) (< A C))))

## <title> Equivalence over Inequality </title>
## <table>
##  (<=    A ] ]   ] [ C)
##      (= A ] [ B ] ] )
##  (<=      [ [ B ] [ C)
## </table>
stmt (leeq1ii () ((<= A C) (= A B)) (<= B C))

## <title> Equivalence over Inequality </title>
## <table>
##  (<= C   [ A ] ] )
##       (= [ A ] [ B)
##  (<= C   [   [ [ B)
## </table>
stmt (leeq2ii () ((<= C A) (= A B)) (<= C B))

## <title> Equivalence over Inequality </title>
## <table>
##  (<    A ] ]   ] [ C)
##     (= A ] [ B ] ] )
##  (<      [ [ B ] [ C)
## </table>
stmt (lteq1ii () ((< A C) (= A B)) (< B C))

## <title> Equivalence over Inequality </title>
## <table>
##  (< C   [ A ] ] )
##      (= [ A ] [ B)
##  (< C   [   [ [ B)
## </table>
stmt (lteq2ii () ((< C A) (= A B)) (< C B))

## <title> Equivalence for ≤ </title>
stmt (leeq12 () () (-> (/\ (= A B) (= C D)) (<-> (<= A C) (<= B D))))

stmt (leeq12d () (
     (-> ph (= A B))
     (-> ph (= C D)))
     (-> ph (<-> (<= A C) (<= B D))))

## <title> Convert between inequalities </title>
stmt (axlttri2i () ((-. (= A B)) (<= A B)) (< A B))

## <title> Multiplication is Monotonic </title>
## <table>
##  (<    B ] ]     ]      [ C ] ]   )
##  (<      [ [ (0) ]      [   [ [ A )
##  (< (* B ] [  A  ] ) (* [ C ] [ A ))
## </table>
stmt (ltmul2i () ((< B C) (< (0) A)) (< (* B A) (* C A)))

## <title> A number is less, equal, or greater </title>
stmt (inequalities () () (\/ (< A B) (\/ (= A B) (> A B))))

## <title> Multiplication is Monotonic </title>
## <table>
##  (>    B ] ]   ]      [ C ] ]     )
##  (>      [ [ A ]      [   [ [ (0) )
##  (> (+ B ] [ A ] ) (+ [ C ] [  A  ))
## </table>
stmt (gtmul2i () ((> B C) (> A (0)))  (> (* B A) (* C A)))

## <title> Inequality Conversion </title>
stmt (axgrtrii () ((-. (= A B)) (>= A B)) (> A B))

## <title> Transitive Property </title>
## <suggest> right('Simplify', '< <') </suggest>
stmt (lttr () () (-> (/\ (< A B) (< B C)) (< A C)))

## <title> Transitive law </title>
## <suggest> right('Simplify', '<') </suggest>
stmt (lelttr () () (-> (/\ (<= A B) (< B C)) (< A C)))

## <title> Transitive law </title>
## <suggest> right('Simplify', '<') </suggest>
stmt (ltletr () () (-> (/\ (< A B) (<= B C)) (< A C)))

## <title> Transitive Inequality </title>
## <suggest> right('Transitive', '≥') </suggest>
stmt (getr () ()  (-> (/\ (>= A B) (>= B C)) (>= A C)))

## <title> Transitive Inequality </title>
## <suggest> right('Transitive', '>') </suggest>
stmt (gtgetr () () (-> (/\ (> C B) (>= B A)) (> C A)))

## <title> Transitive Inequality </title>
## <suggest> right('Transitive', '>') </suggest>
stmt (gegttr () () (-> (/\ (>= C B) (> B A)) (> C A)))

## <title> Transitive Inequality </title>
## <suggest> right('Transitive', '>') </suggest>
stmt (gttr () ()  (-> (/\ (> A B) (> B C)) (> A C)))

## <title> Transitive Inequality </title>
## <table>
##   (<       [ B ]      [   [ C ] )
##   (-> (< A [ B ] ) (< [ A [ C ] ))
## </table>
stmt (ltTrlt () ((< B C)) (-> (< A B) (< A C)))

## <title> Transitive Inequality </title>
## <table>
##   (<        [ B ]      [   [ C ] )
##   (-> (<= A [ B ] ) (< [ A [ C ] ))
## </table>
stmt (ltTrle () ((< B C)) (-> (<= A B) (< A C)))

## <title> Transitive Inequality </title>
## <table>
##   (<       [ B ]      [   [ C ] )
##   (-> (= A [ B ] ) (< [ A [ C ] ))
## </table>
stmt (ltTreq () ((< B C)) (-> (= A B) (< A C)))

## <title> Transitive Inequality </title>
## <table>
##   (<=      [ B ]       [   [ C ] )
##   (-> (= A [ B ] ) (<= [ A [ C ] ))
## </table>
stmt (leTreq () ((<= B C)) (-> (= A B) (<= A C)))

## <title> Transitive Inequality </title>
## <table>
##   (<=      [ B ]       [   [ C ] )
##   (-> (= A [ B ] ) (<= [ A [ C ] ))
## </table>
stmt (leTrlt () ((<= B C)) (-> (< A B) (< A C)))

## <title> Transitive Inequality </title>
## <table>
##   (<=       [ B ]       [   [ C ] )
##   (-> (<= A [ B ] ) (<= [ A [ C ] ))
## </table>
stmt (leTrle () ((<= B C)) (-> (<= A B) (<= A C)))

## <title> Transitive Inequality </title>
## <table>
##   (-. (>   [ B ]      [   [ C ] ))
##   (-> (> A [ B ] ) (> [ A [ C ] ))
## </table>
stmt (gtTrgt () ((> B C)) (-> (> A B) (> A C)))

## <title> Transitive Inequality </title>
## <table>
##   (>=      [ B ]      [   [ C ] )
##   (-> (> A [ B ] ) (> [ A [ C ] ))
## </table>
stmt (geTrgt () ((>= B C)) (-> (> A B) (> A C)))

## <title> Transitive Inequality </title>
## <table>
##   (>=   [ B ]          [   [ C ] )
##   (-> (= A [ B ] ) (>= [ A [ C ] ))
## </table>
stmt (geTreq () ((>= B C)) (-> (= A B) (>= A C)))

## <title> Transitive Inequality </title>
## <table>
##   (>       [ B ]          [   [ C ] )
##   (-> (= A [ B ] ) (> [ A [ C ] ))
## </table>
stmt (gtTreq () ((> B C)) (-> (= A B) (> A C)))

## <title> Transitive Inequality </title>
## <table>
##   (>        [ B ]       [   [ C ] )
##   (-> (>= A [ B ] )) (> [ A [ C ] ))
## </table>
stmt (gtTrge () ((> B C)) (-> (>= C A) (> B A)))

## <title> Transitive Inequality </title>
## <table>
##   (>=       [ B ]           [   [ C ] )
##   (-> (>= A [ B ] ) (>= [ A [ C ] ))
## </table>
stmt (geTrge () ((>= B C)) (-> (>= A B) (>= A C)))

## <title> Equivalence for >= </title>
stmt (geeq1 () () (-> (= A C) (<-> (>= A B) (>= C B))))

## <title> Equivalence for >= </title>
stmt (geeq2 () () (-> (= B C) (<-> (>= A B) (>= A C))))

## <title> Equivalence over Inequality </title>
## <table>
##   (=       A ]   ]       [ B ]   )
##   (<-> (>= A ] C ] ) (>= [ B ] C))
## </table>
stmt (geeq1i () (
     (= A C))
     (<-> (>= A B) (>= C B)))

## <title> Equivalence over Inequality </title>
## <table>
##   (=         [ A ]       [   [ B ] )
##   (<-> (>= C [ A ] ) (>= [ C [ B ] ))
## </table>
stmt (geeq2i ()
  ((= A B))
  (<-> (>= C A) (>= C B)))

stmt (geeq1d () (
     (-> ph (= A C)))
     (-> ph (<-> (>= A B) (>= C B))))

stmt (geeq2d () (
     (-> ph (= B C)))
     (-> ph (<-> (>= A B) (>= A C))))

stmt (gteq1 () () (-> (= A C) (<-> (> A B) (> C B))))

stmt (gteq2 () () (-> (= B C) (<-> (> A B) (> A C))))

## <title> Equivalence over Inequality </title>
## <table>
##   (=      A ]   ]      [ B ]   )
##   (<-> (> A ] C ] ) (> [ B ] C))
## </table>
stmt (gteq1i ()
  ((= A C))
	(<-> (> A B) (> C B)))

## <title> Equivalence over Inequality </title>
## <table>
##   (=        [ A ]      [   [ B ] )
##   (<-> (> C [ A ] ) (> [ C [ B ] ))
## </table>
stmt (gteq2i ()
  ((= B C))
  (<-> (> A B) (> A C)))

stmt (gteq1d () (
     (-> ph (= A C)))
     (-> ph (<-> (> A B) (> C B))))

stmt (gteq2d () (
     (-> ph (= B C)))
     (-> ph (<-> (> A B) (> A C))))

## <title> Operator Conversion </title>
## <suggest> right('Infer', '≠') </suggest>
stmt (ltneq () () (-> (< A B) (-. (= A B))))

## <title> Inequality Conversion </title>
## <suggest> right('Infer', '≤') </suggest>
stmt (ltle () () (-> (< A B) (<= A B)))

## <title> Inequality Conversion </title>
## <suggest> right('Infer', '≠') </suggest>
stmt (gtneq () () (-> (> A B) (-. (= A B))))

## <title> Inequality Conversion </title>
## <suggest> right('Infer', '≥') </suggest>
stmt (gtge () () (-> (> A B) (>= A B)))

## <title> Equality Conversion </title>
## <suggest> right('Infer', '≤') </suggest>
stmt (eqle() () (-> (= A B) (<= A B)))

## <title> Equality Conversion </title>
## <suggest> right('Infer', '≥') </suggest>
stmt (eqge() () (-> (= A B) (>= A B)))

## <title> Equality Conversion </title>
## <suggest> right('Infer', '¬<') </suggest>
stmt (eqnlt () () (-> (= A B) (-. (< A B))))

## <title> Inequality Conversion </title>
## <suggest> right('Infer', '¬<') </suggest>
stmt (gtnlt () () (-> (> A B) (-. (< A B))))

## <title> Inequality Conversion </title>
## <suggest> right('Infer', '¬≤') </suggest>
stmt (gtnle () () (-> (> A B) (-. (<= A B))))

## <title> Inequality Conversion </title>
## <suggest> right('Infer', '¬>') </suggest>
stmt (ltngt () () (-> (< A B) (-. (> A B))))

## <title> Inequality Conversion </title>
## <suggest> right('Infer', '¬≥') </suggest>
stmt (ltnge () () (-> (< A B) (-. (>= A B))))

## <title> Inequality Conversion </title>
## <suggest> right('Infer', '¬>') </suggest>
stmt (eqngt () () (-> (= A B) (-. (> A B))))

## <title> Equivalence over Inequality </title>
## <summary> Equality inference for less than or equal relation </summary>
## <table>
##   (=       A ]   ]       [ B ]   )
##   (<-> (<= A ] C ] ) (<= [ B ] C))
## </table>
stmt (leeq1i () ((= A B)) (<-> (<= A C) (<= B C)))

## <title> Equivalence over Inequality </title>
## <summary> Equality inference for less than or equal relation </summary>
## <table>
##   (=         [ A ]       [   [ B ] )
##   (<-> (<= C [ A ] ) (<= [ C [ B ] ))
## </table>
stmt (leeq2i () ((= A B)) (<-> (<= C A) (<= C B)))

## <title> Inequality Equivalence </title>
## <summary> Equality deduction for less than or equal relation </summary>
stmt (leeq1d () ((-> ph (= A B))) (-> ph (<-> (<= A C) (<= B C))))

## <title> Inequality Equivalence </title>
## <summary> Equality deduction for less than or equal relation </summary>
## <table>
##   (-> ph (=         [ A ]       [   [ B ] ))
##   (-> ph (<-> (<= C [ A ] ) (<= [ C [ B ] )))
## </table>
stmt (leeq2d () ((-> ph (= A B))) (-> ph (<-> (<= C A) (<= C B))))

## <title> Inequality relation for two equal sums </title>
stmt (leadd12 () () (-> (= (+ A B) (+ C D)) (<-> (<= A C) (<= D B))))

## <title> 1 is more than 0 </title>
stmt (1greater0 () () (> (1) (0)))

## <title> Definition of a Positive Number </title>
## <suggest> left('Simplify', '+') </suggest>
stmt (df-pos () () (<-> (pos A) (> A (0))))

stmt (poseq () () (-> (= A B) (<-> (pos A) (pos B))))

stmt (poseqi () ((= A B)) (<-> (pos A) (pos B)))

stmt (1pos () () (pos (1)))

## <title> Definition of a Negative Number </title>
## <suggest> left('Simplify', '-') </suggest>
stmt (df-zneg () () (<-> (zneg A) (< A (0))))

stmt (znegeq () () (-> (= A B) (<-> (zneg A) (zneg B))))

stmt (znegeqi () ((= A B)) (<-> (zneg A) (zneg B)))
		 
stmt (znegeqd () ((-> ph (= A B))) (-> ph (<-> (zneg A) (zneg B))))

## <title> 0 is not positive </title>
stmt (0NotPos () () (-. (pos (0))))

## <title> 0 is not negative </title>
stmt (0NotNeg () () (-. (zneg (0))))

## <title> 0 is not positive </title>
stmt (0NotPosd () () (-> (= A (0)) (-. (pos A))))

## <title> 0 is not positive </title>
stmt (0NotNegd () () (-> (= A (0)) (-. (zneg A))))

## <title> Multiply Two Positive Numbers </title>
stmt (posproduct1 () () (-> (/\ (pos A) (pos B)) (pos (* A B))))

stmt (neqlt () () (-> (-. (= A B)) (\/ (< A B) (> A B))))

stmt (ltmul0 () () (-> (/\ (< (0) A) (< (0) B)) (< (0) (* A B))))

stmt (gtmul0() () (-> (/\ (> A (0)) (> B (0))) (> (* A B) (0))))

## <title> Multiply Both Sides </title>
## <summary> Multiplication is monotonic in its second argument </summary>
stmt (lemul2 () () (-> (/\ (<= A B) (<= (0) C)) (<= (* C A) (* C B))))

## <title> Addition is Monotonic </title>
## <summary> Addition is strictly monotonic in the first addend </summary>
## <suggest> left('Cancel', '+') </suggest>
## <table>
##   (<-> (<= A B) (<= (+ A <g> C) (+ B <g> C)))
## </table>
stmt (leadd1 () () (<-> (<= A B) (<= (+ A C) (+ B C))))

stmt (lemul4 () () (-> (/\ (<= A B) (<= C D)) (<= (+ (* A D) (* B C)) (+ (* A C) (* B D)))))

## <title> Multiply Nonequal Numbers </title>
stmt (ltmul1 () () (-> (/\ (< A B) (< (0) C)) (< (* A C) (* B C))))

stmt (ltmul4 () () (-> (/\ (< A B) (< C D)) (< (+ (* A D) (* B C)) (+ (* A C) (* B D)))))

stmt (gtmul2 () () (-> (/\ (> A B) (> C (0))) (> (* C A) (* C B))))

stmt (gemul1 () () (-> (/\ (>= B A) (>= C (0))) (>= (* B C) (* A C))))

## <title> Less Than or Equal from Positive Difference </title>
stmt (exlt ((A x)(B x)) () (-> (< A B) (E. x (/\ (< (0) x) (= (+ A x) B)))))

# Copied from mulcan.ghi

stmt (mulcan0 () () (-> (-. (= A (0))) (<-> (= (* B A) (0)) (= B (0)))))

## <title> Cancel Multiplication </title>
stmt (mulcan2 () () (-> (-. (= A (0))) (<-> (= (* A B) (* A C)) (= B C))))

## <title> Cancel Multiplication </title>
## <table>
##   (-. (= A ] (0))) ] ]
##   (= (* B ] <r> A) ] (* [ C <r> A))
##   (=    B ]        ]    [ C)
## </table>
stmt (mulcani () ((-. (= A (0))) (= (* B A) (* C A))) (= B C))

## <title> Cancel Multiplication </title>
## <table>
##   (-. (= A    ] ] (0)))  ]
##   (= (* <r> A [ B ) ] (* <r> A [ C ))
##   (=          [ B   ]          [ C)
## </table>
stmt (mulcan2i () ((-. (= A (0))) (= (* A B) (* A C))) (= B C))

## <title> Zero Product Property </title>
stmt (zeroProductz () () (-> (/\ (-. (= A (0))) (-. (= B (0)))) (-. (= (* A B) (0)))))

## <title> Zero Product Property </title>
stmt (zeroFactors () () (<-> (= (* A B) (0)) (\/ (= A (0)) (= B (0)))))

## <title> Zero Product Property </title>
stmt (nonzeroProduct () () (-> (-. (= A (0))) (<-> (= B (0)) (= (* A B) (0)))))

## <title> Zero Product Property </title>
stmt (nonzeroProduct2 () () (<-> (-. (= (* A B) (0))) (/\ (-. (= A (0))) (-. (= B (0))))))

## <title> Multiply Nonequal Numbers </title>
stmt (neqmul () () (-> (/\ (-. (= A B)) (-. (= C (0)))) (-. (= (* A C) (* B C)))))




# ifn.ghi

## <title> First branch of ternary expression </title>
stmt (ifn1 () () (-> ph (= (ifn ph A B) A)))

## <title> Second branch of ternary expression </title>
stmt (ifn2 () () (-> (-. ph) (= (ifn ph A B) B)))
	
## <title> Equivalence of predicate in ifn </title>
stmt (ifnbi1 () () (-> (<-> ph ps) (= (ifn ph A B) (ifn ps A B))))

stmt (ifnbi1i () (
     (<-> ph ps))
     (= (ifn ph A B) (ifn ps A B)))
		 
stmt (ifnbi1d () (
     (-> ch (<-> ph ps)))
     (-> ch (= (ifn ph A B) (ifn ps A B))))
		 
## <title> Equality of first term for ifn </title>
stmt (ifneq2 () () (-> (= A B) (= (ifn ph A C) (ifn ph B C))))

stmt (ifneq2i () (
     (= A B))
     (= (ifn ph A C) (ifn ph B C)))
		 
stmt (ifneq2d () (
     (-> ps (= A B)))
     (-> ps (= (ifn ph A C) (ifn ph B C))))

## <title> Equality of second term for ifn </title>
stmt (ifneq3 () () (-> (= A B) (= (ifn ph C A) (ifn ph C B))))

stmt (ifneq3i () (
     (= A B))
     (= (ifn ph C A) (ifn ph C B)))

stmt (ifneq3d () (
     (-> ps (= A B)))
     (-> ps (= (ifn ph C A) (ifn ph C B))))

stmt (ifneq13 () () (-> (/\ (<-> ph ps) (= A B)) (= (ifn ph C A) (ifn ps C B))))

## <title> Equivalence for ifn </title>
stmt (ifnbi123 () () (-> (/\ (<-> ph ps) (/\ (= A C) (= B D))) (= (ifn ph A B) (ifn ps C D))))

stmt (ifnbi123d () (
      (-> ph (<-> ps ch))
      (-> ph (= A B))
      (-> ph (= C D)))
      (-> ph (= (ifn ps A C) (ifn ch B D))))


# Copied from negative.ghi



term (nat (-n A))

## <title> Cancel using subtraction </title>
## <suggest> right('Simplify','-') </suggest>
stmt (negcan () () (= (+ A (-n A)) (0)))

stmt (negeq  () () (-> (= A B) (= (-n A) (-n B))))


term (nat (- A B))

## <table>
##  (=     [ A      [ B)
##  (= (-n [ A) (-n [ B))
## </table>
stmt (negeqi() ((= A B)) (= (-n A) (-n B)))

stmt (negeqd () ((-> ph (= A B))) (-> ph (= (-n A) (-n B))))

stmt (negeq2() () (<-> (= A B) (= (-n A) (-n B))))

## <title> Negative can switch sides </title>
## <suggest> right('Equivalence', '-') left('Equivalence', '-') </suggest>
stmt (negeq3 () () (<-> (= A (-n B)) (= (-n A) B)))

## <title> Double Negative </title>
## <suggest> right('Simplify', '-') </suggest>
stmt (doubleneg () () (= (-n (-n A)) A))

## <title> Negative of 0 is 0 </title>
## <suggest> right('Simplify', '0') </suggest>
stmt (neg0 () () (= (-n (0)) (0)))

## <title> Negative 1 is not 0 </title>
stmt (neg1ne0 () () (-. (= (-n (1)) (0))))

## <title> Nonzero negatives are not zero </title>
stmt (negne0 () () (<-> (-. (= A (0))) (-. (= (-n A) (0)))))

## <title> Cancel using subtraction </title>
## <suggest> right('Simplify','-') </suggest>
stmt (negcan2() () (= (+ (-n A) A) (0)))

## <title> Definition of Subtraction </title>
## <suggest> right('Define', '-') left('Simplify', '-') </suggest>
stmt (df-minus () () (= (- A B) (+ A (-n B))))

## <title> Minus Definition Reversed </title>
stmt (df-minusr () () (= (+ A (-n B)) (- A B)))

## <title> Subtract a number from both sides </title>
stmt (minuseq1 () () (-> (= A C) (= (- A B) (- C B))))

## <title> Subtract a number from both sides </title>
## <table>
##  (=    A ]       ]      C ] )
##  (= (- A ] <g> B ] ) (- C ] <g> B))
## </table>
stmt (minuseq1i () ((= A C)) (= (- A B) (- C B)))

## <title> Equivalence for - </title> ##
stmt (minuseq2 () () (-> (= B C) (= (- A B) (- A C))))

stmt (minuseq1d () ((-> ph (= A C))) (-> ph (= (- A B) (- C B))))

stmt (minuseq2i () ((= B C)) (= (- A B) (- A C)))

stmt (minuseq2d () ((-> ph (= B C))) (-> ph (= (- A B) (- A C))))

stmt (minuseq12 () () (-> (/\ (= A B) (= C D)) (= (- A C) (- B D))))

## <title> Equality over Subtraction </title>
stmt (minuseq12d ()
  ((-> ph (= A B))
   (-> ph (= C D)))
  (-> ph (= (- A C) (- B D))))

## <title> Equality over Subtraction </title>
## <table>
##   (=    A ] ]   ]      [ B ] ] )
##   (=      [ [ C ]      [   [ [ D)
##   (= (- A ] [ C ] ) (- [ B ] [ D))
## </table>
stmt (minuseq12i ()
  ((= A B)
   (= C D))
  (= (- A C) (- B D)))

## <title> Cancel using subtraction </title>
## <suggest> right('Simplify','-') </suggest>
stmt (minuscan () () (= (- A A) (0)))

## <title> Addition is the inverse of Subtraction </title>
## <suggest> right('Simplify','-') </suggest>
stmt (minuscan2 () () (= (+ (- A B) B) A))

## <title> Addition is the inverse of Subtraction </title>
## <suggest> right('Simplify','-') </suggest>
## <table>
##   (= (- (+ A <r> B) <r> B) A)
## </table>
stmt (addcanr () () (= (- (+ A B) B) A))

## <title> Negative and Subtraction Cancel </title>
## <suggest> right('Simplify', '-') </suggest>
stmt (minusneg () () (= (- A (-n B)) (+ A B)))

## <title> Negative Multiplication </title>
## <suggest> right('Simplify', '-') </suggest>
stmt (negmul () () (= (* (-n A) B) (-n (* A B))))

## <title> Negative Multiplication </title>
## <suggest> right('Simplify', '-') </suggest>
stmt (negmul2 () () (= (* A (-n B)) (-n (* A B))))

## <title> Multiply by Negative 1 </title>
stmt (mulneg1 () () (= (* (-n (1)) A) (-n A)))

## <title> Multiply Two Negative Numbers </title>
## <suggest> right('Simplify', '-') </suggest>
stmt (doublenegmul () () (= (* (-n A) (-n B)) (* A B)))

## <title> Distribute Multiplication over Subtraction </title>
## <table>
##   (= (* <c> A (- B C)) (- (* <c> A B) (* <c> A C)))
## </table>
## <suggest> right('Distribute', 'R') left('Distribute', '-R') </suggest>
stmt (minusdistr () () (= (* A (- B C)) (- (* A B) (* A C))))

## <title> Distribute Multiplication over Subtraction </title>
## <table>
##   (= (* (- A B) <c> C) (- (* A <c> C) (* B <c> C)))
## </table>
## <suggest> right('Distribute', 'L') left('Distribute', '-L') </suggest>
stmt (minusdistl () () (= (* (- A B) C) (- (* A C) (* B C))))

## <title> Multiply Two Negative Numbers </title>
stmt (negProduct () () (-> (/\ (zneg A) (zneg B)) (pos (* A B))))

## <title> Squares are not negative </title>
stmt (posSquares () () (-> (-. (= A (0))) (pos (* A A))))

## <title> Squares are not negative </title>
stmt (squareNotNeg () () (>= (* A A) (0)))

## <title> Negative numbers are not positive </title>
stmt (negNotPos () () (-> (zneg A) (-. (pos A))))

## <title> Positive numbers are not negative </title>
stmt (posNotNeg () () (-> (pos A) (-. (zneg A))))

stmt (posProduct () () (<-> (pos (* A B)) (\/ (/\ (zneg A) (zneg B)) (/\ (pos A) (pos B)))))

stmt (productPos () () (-> (pos (* A B)) (<-> (pos A) (pos B))))

## <title> Positive Proof by Cases </title>
stmt (posCases () () (-> (/\ (-. (zneg A)) (-. (= A (0)))) (pos A)))

stmt (notPos () () (-> (-. (pos A)) (\/ (zneg A) (= A (0)))))

## <title> Negative of a positive number </title>
stmt (negPositive () () (<-> (pos (-n A)) (zneg A)))

## <title> Negative of Subtraction </title>
## <suggest> left('Simplify', '-') </suggest>
stmt (negminus () () (= (- A B) (-n (- B A))))

## <title> Negative of Subtraction </title>
stmt (negminus2 () () (= (+ (-n A) B) (-n (- A B))))

## <title> Negative of Subtraction </title>
stmt (negminus3 () () (= (- (-n A) B) (-n (+ A B))))

## <title> Negative distributes over addition </title>
stmt (negadd () () (= (- (-n A) B) (-n (+ A B))))

## <title> Subtraction Value from Addition </title>
stmt (minusValue () () (-> (= (+ A B) C) (= A (- C B))))

## <title> Subtract both sides </title>
## <table>
##   (= (+ A <c> B) C)
##   (= A (- C <c> B ) )
## </table>
stmt (minusValuei () ((= (+ A B) C)) (= A (- C B)))

## <title> Subtraction from both sides </title>
## <table>
##   (= (+ A <c>     B ) [ C)
##   (= A (- <c> (-n B )  [ C) )
## </table>
stmt (minusValue2i () ((= (+ A B) C)) (= A (+ (-n B) C)))

## <title> Subtract from 0 </title>
## <suggest> right('Simplify', '-') </suggest>
stmt (0minus () () (= (- (0) A) (-n A)))

## <title> Subtraction Identity </title>
## <suggest> right('Simplify', '0') </suggest>
stmt (minusid () () (= (- A (0)) A))

## <title> Add or subtract on both sides </title>
stmt (gediff () () (<-> (>= A B) (>= (- A B) (0))))

## <title> Add or subtract on both sides </title>
stmt (gtdiff () () (<-> (> A B) (> (- A B) (0))))

## <title> Positive Number Subtraction </title>
stmt (subtractPositive () () (<-> (> B (0)) (< (- A B) A)))

stmt (negle () () (<-> (>= A (0)) (<= (-n A) (0))))

stmt (neglt () () (<-> (< (-n A) (0)) (> A (0))))

stmt (negge () () (<-> (>= (-n A) (0)) (<= A (0))))

stmt (neggt () () (<-> (> (-n A) (0)) (< A (0))))


term (nat (abs A))

## <title> Definition of Absolute Value </title>
## <suggest> right('Define', '|x|') left('Simplify', '|x|') </suggest>
stmt (df-abs () () (= (abs A) (ifn (>= A (0)) A (-n A))))

## <title> Equivalence for abs </title> ##
stmt (abseq () () (-> (= A B) (= (abs A) (abs B))))

stmt (abseqi () (
     (= A B))
     (= (abs A) (abs B)))

stmt (abseqd () (
     (-> ph (= A B)))
     (-> ph (= (abs A) (abs B))))

## <title> Def. Absolute Value for Positive Numbers </title>
stmt (dfabs1 () () (-> (>= A (0)) (= (abs A) A)))

## <title> Def. Absolute Value for Negative Numbers </title>
stmt (dfabs2 () () (-> (< A (0)) (= (abs A) (-n A))))

## <title> The absolute value is not negative </title>
stmt (absNotNeg () () (>= (abs A) (0)))

## <title> The absolute value is idempotent </title>
stmt (absidm () () (= (abs (abs A)) (abs A)))

## <title> The absolute value is positive definite </title>
stmt (absPosDef () () (<-> (= A (0)) (= (abs A) (0))))

## <title> Two numbers have the same absolute value </title>
stmt (absTwoValues () () (<-> (= (abs A) B) (/\ (\/ (= A B) (= (-n A) B)) (>= B (0)))))

stmt (absTwoValues2 () () (\/ (= (abs A) A) (= (abs A) (-n A))))



# Copied from division.ghi



term (nat (/ A B))

stmt (diveq12 () () (-> (/\ (= A B) (= C D)) (= (/ A C) (/ B D))))

stmt (divcan () () (-> (-. (= B (0))) (= (* B (/ A B)) A)))

## <title> Divide a number on both sides of an equation </title>
## <table>
##   (-> (= <g> A <b> B) (= (/ <g> A <r> C) (/ <b> B <r> C)))
## </table>
stmt (diveq1 () () (-> (= A B) (= (/ A C) (/ B C))))

## <title> Divide a number on both sides </title>
## <table>
##  (=    A ]        ]    [ B ] )
##  (= (/ A ] <g> C) ] (/ [ B ] <g> C))
## </table>
stmt (diveq1i ()
  ((= A B))
  (= (/ A C) (/ B C)))
	
## <title> Equality over Division </title>
stmt (diveq1d ()
  ((-> ph (= A B)))
  (-> ph (= (/ A C) (/ B C))))

## <title> Divide a number on both sides of an equation </title>
stmt (diveq2 () () (-> (= A B) (= (/ C A) (/ C B))))

## <title> Divide a number on both sides </title>
## <table>
##  (=          [ A ]   [          [ B )
##  (= (/ <g> C [ A ] ) [ (/ <g> C [ B))
## </table>
stmt (diveq2i ()
  ((= A B))
  (= (/ C A) (/ C B)))
	
## <title> Equality over Division </title>
stmt (diveq2d ()
  ((-> ph (= A B)))
  (-> ph (= (/ C A) (/ C B))))
	
## <title> Equality over Division </title>
## <table>
##   (=    A ] ]   ]      [ B ] ] )
##   (=      [ [ C ]      [   [ [ D)
##   (= (/ A ] [ C ] ) (/ [ B ] [ D))
## </table>
stmt (diveq12i ()
  ((= A B)
   (= C D))
  (= (/ A C) (/ B D)))
	
## <title> Equality over Division </title>
stmt (diveq12d ()
  ((-> ph (= A B))
   (-> ph (= C D)))
  (-> ph (= (/ A C) (/ B D))))

## <title> Cancel with Division </title>
stmt (divcani () ((-. (= A (0)))) (= (* A (/ B A)) B))

## <title> Cancel with Division </title>
stmt (reciprocalcan () () (-> (-. (= A (0))) (= (* A (/ (1) A)) (1))))

## <title> Cancel with Division </title>
stmt (reciprocalcani () ((-. (= A (0)))) (= (* A (/ (1) A)) (1)))

## <title> Cancel With Division </title>
stmt (divcan2 () () (-> (-. (= A (0))) (= (/ (* A B) A) B)))

## <title> Cancel with Division </title>
## <table>
##   (-. (= <r> A (0)))
##   (= (/ (* <r> A B) <r> A) B)
## </table>
stmt (divcan2i () ((-. (= A (0)))) (= (/ (* A B) A) B))

## <title> Cancel with Division </title>
stmt (divcan3 () () (-> (-. (= A (0))) (= (/ (* B A) A) B)))

## <title> Divide by 1 </title>
stmt (divid () () (= (/ A (1)) A))

## <title> Expand Fraction </title>
stmt (expandFrac () () (-> (-. (= B (0))) (= (/ A B) (* A (/ (1) B)))))

## <title> Expand Fraction </title>
stmt (expandFraci () ((-. (= B (0)))) (= (/ A B) (* A (/ (1) B))))

## <title> Cancel using Division </title>
stmt (frac1 () () (-> (-. (= A (0))) (= (/ A A) (1))))

## <title> Cancel using Division </title>
stmt (frac1i () ((-. (= A (0)))) (= (/ A A) (1)))

## <title> Division & Multiplication Ass. </title>
stmt (divmulass () () (-> (-. (= C (0))) (= (* A (/ B C)) (/ (* A B) C))))

## <title> Division & Multiplication Ass. </title>
stmt (divmulassi () ((-. (= C (0)))) (= (* A (/ B C)) (/ (* A B) C)))

## <title> Zero Product Property </title>
## <table>
##   (-. (=    A ] ]    ]   (0)))
##   (-. (=      [ [  B ]   (0)))
##   (-. (= (* A ] [  B ] ) (0)))
## </table>
stmt (zeroProducti () ((-. (= A (0))) (-. (= B (0)))) (-. (= (* A B) (0))))

## <title> Multiply Fractions </title>
stmt (fracmul () () (-> (/\ (-. (= B (0))) (-. (= D (0)))) (= (* (/ A B) (/ C D)) (/ (* A C) (* B D)))))

## <title> Multiply Fractions </title>
stmt (fracmuli () ((-. (= B (0))) (-. (= D (0)))) (= (* (/ A B) (/ C D)) (/ (* A C) (* B D))))

## <title> Fraction with common factor </title>
## <summary> Numerators and Denominators with common factors can be simplified. </summary>
stmt (fracFactors () () (-> (/\ (-. (= B (0))) (-. (= C (0)))) (= (/ (* A C) (* B C)) (/ A B))))

## <title> Fraction with common factor </title>
## <summary> Numerators and Denominators with common factors can be simplified. </summary>
stmt (fracFactorsi () ((-. (= B (0))) (-. (= C (0)))) (= (/ (* A C) (* B C)) (/ A B)))

## <title> Distribute Division over Addition </title>
stmt (divdistr () () (-> (-. (= C (0))) (= (+ (/ A C) (/ B C)) (/ (+ A B) C))))

## <title> Distribute Division over Addition </title>
stmt (divdistri () ((-. (= C (0)))) (= (+ (/ A C) (/ B C)) (/ (+ A B) C)))

## <title> Add Fractions </title>
stmt (addfrac () () (-> (/\ (-. (= B (0))) (-. (= D (0)))) (= (+ (/ A B) (/ C D)) (/ (+ (* A D) (* B C)) (* B D)))))

## <title> Add Fractions </title>
stmt (addfraci () ((-. (= B (0))) (-. (= D (0)))) (= (+ (/ A B) (/ C D)) (/ (+ (* A D) (* B C)) (* B D))))

## <title> Negative Numerator </title>
## <summary> A negative numerator is equivalent to a negative fraction. </summary>
stmt (negNumerator () () (-> (-. (= B (0))) (= (/ (-n A) B) (-n (/ A B)))))

## <title> Negative Numerator </title>
stmt (negNumeratori () ((-. (= B (0)))) (= (/ (-n A) B) (-n (/ A B))))

## <title> Negative Denominator </title>
stmt (negDenominatori () ((-. (= B (0)))) (= (/ A (-n B)) (-n (/ A B))))

stmt (negDenominator () () (-> (-. (= B (0))) (= (-n (/ A B)) (/ A (-n B)))))

## <title> Double Negative Fraction </title>
stmt (doublenegfrac () () (-> (-. (= B (0))) (= (/ (-n A) (-n B)) (/ A B))))

## <title> Double Negative Fraction </title>
stmt (doublenegfraci () ((-. (= B (0)))) (= (/ (-n A) (-n B)) (/ A B)))

## <title> Common Division in Fraction </title>
stmt (fracFactors2 () () (-> (/\ (-. (= B (0))) (-. (= C (0)))) (= (/ (/ A C) (/ B C)) (/ A B))))

## <title> Common Division in Fraction </title>
stmt (fracFactors2i () ((-. (= B (0))) (-. (= C (0)))) (= (/ (/ A C) (/ B C)) (/ A B)))

## <title> Commute Division </title>
stmt (divcom () () (-> (/\ (-. (= B (0))) (-. (= C (0)))) (= (/ (/ A B) C) (/ (/ A C) B))))

## <title> Distribute Division Over Subtraction </title>
stmt (divminusdistr () () (-> (-. (= C (0))) (= (- (/ A C) (/ B C)) (/ (- A B) C))))

## <title> 0 divided by anything is 0 </title>
stmt (0div () () (-> (-. (= A (0))) (= (/ (0) A) (0))))

## <title> Combine Two Divisions </title>
stmt (doublediv () () (-> (/\ (-. (= B (0))) (-. (= C (0)))) (= (/ (/ A B) C) (/ A (* B C)))))

## <title> Combine Two Divisions </title>
stmt (doubledivi () ((-. (= B (0))) (-. (= C (0)))) (= (/ (/ A B) C) (/ A (* B C))))

## <title> A positive number has a positive reciprocal </title>
stmt (posReciprocal () () (-> (> A (0)) (> (/ (1) A) (0))))

stmt (posReciprocal2 () () (-> (-. (= A (0))) (<-> (> A (0)) (> (/ (1) A) (0)))))

## <title> A number is its reciprocal's reciprocal </title>
stmt (doubleReciprocal () () (-> (-. (= A (0))) (= (/ (1) (/ (1) A)) A)))

stmt (divDouble () () (-> (/\ (-. (= B (0))) (-. (= C (0)))) (= (/ A (/ B C)) (/ (* A C) B))))

stmt (divNotZeroi () ((-. (= A (0))) (-. (= B (0)))) (-. (= (/ A B) (0))))

stmt (divNotZero () () (-> (/\ (-. (= A (0))) (-. (= B (0)))) (-. (= (/ A B) (0)))))



# Copied from exponent.ghi

term (nat (exp A B))

## <title> Equivalence for exp </title>
stmt (expeq1 () () (-> (= A B) (= (exp A C) (exp B C))))

## <title> Equivalence for exp </title>
stmt (expeq2 () () (-> (= B C) (= (exp A B) (exp A C))))

## <title> 0th power of a number is 1 </title>
## <suggest> right('Simplify', '1') </suggest>
stmt (exp0 () () (= (exp A (0)) (1)))

## <title> Multiply by the base for the next power </title>
stmt (expplus1 () () (= (exp A (+ B (1))) (* A (exp A B))))

stmt (expeq1i () (
     (= A B))
     (= (exp A C) (exp B C)))

stmt (expeq1d () (
     (-> ph (= A B)))
     (-> ph (= (exp A C) (exp B C))))

stmt (expeq2i () (
     (= A B))
     (= (exp C A) (exp C B)))

stmt (expeq2d () (
     (-> ph (= A B)))
     (-> ph (= (exp C A) (exp C B))))

## <title> Equivalence for exp </title>
stmt (expeq12 () () (-> (/\ (= A B) (= C D)) (/\ (= (exp A C) (exp B C)) (= (exp B C) (exp B D)))))

stmt (expeq12d () (
     (-> ph (= A B))
     (-> ph (= C D)))
     (-> ph (/\ (= (exp A C) (exp B C)) (= (exp B C) (exp B D)))))

## <title> Raise to the power of 1 </title>
## <suggest> right('Simplify', '1') </suggest>
stmt (exp1 () () (= (exp A (1)) A))

## <title> Squared means multiply twice </title>
## <suggest> left('Simplify', '2') right('Equivalence', '2') </suggest>
stmt (exp2 () () (= (exp A (2)) (* A A)))

## <title> Cubed means multiply thrice </title>
## <suggest> left('Simplify', '∙') </suggest>
stmt (exp3 () () (= (exp A (3)) (* (* A A) A)))

## <title> Square an Addition </title>
## <suggest> left('Simplify', '2') right('Equivalence', '+') </suggest>
stmt (sqadd () () (= (exp (+ A B) (2)) (+ (+ (exp A (2)) (* (* (2) A) B)) (exp B (2)))))